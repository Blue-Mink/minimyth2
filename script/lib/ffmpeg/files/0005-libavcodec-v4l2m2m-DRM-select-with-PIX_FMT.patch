From 0aca286d480d5a3d37030008aa27d167ad9941a7 Mon Sep 17 00:00:00 2001
From: Jorge Ramirez-Ortiz <jramirez@baylibre.com>
Date: Fri, 27 Apr 2018 19:07:51 +0200
Subject: [PATCH 05/13] libavcodec: v4l2m2m: DRM: select with PIX_FMT

Signed-off-by: Jorge Ramirez-Ortiz <jramirez@baylibre.com>
---
 libavcodec/v4l2_buffers.c | 77 ++++++++++++++++++++++++++++++++---------------
 libavcodec/v4l2_m2m.h     |  3 ++
 libavcodec/v4l2_m2m_dec.c |  3 ++
 3 files changed, 59 insertions(+), 24 deletions(-)

diff --git a/libavcodec/v4l2_buffers.c b/libavcodec/v4l2_buffers.c
index 3503759..0e4c16a 100644
--- a/libavcodec/v4l2_buffers.c
+++ b/libavcodec/v4l2_buffers.c
@@ -418,19 +418,45 @@ int ff_v4l2_buffer_avframe_to_buf(const AVFrame *frame, V4L2Buffer* out)
 int ff_v4l2_buffer_buf_to_avframe(AVFrame *frame, V4L2Buffer *avbuf)
 {
     V4L2m2mContext *s = buf_to_m2mctx(avbuf);
-    int ret;
+    int i, ret;
 
     av_frame_unref(frame);
 
-    /* 1. get references to the actual data */
-    ret = v4l2_buf_to_bufref_drm(avbuf, &frame->buf[0]);
-    if (ret)
-	    return ret;
-    frame->data[0] = (uint8_t *) v4l2_get_drm_frame(avbuf);
+    if (buf_to_m2mctx(avbuf)->drm) {
 
-    /* 2. get frame information */
-    frame->format = AV_PIX_FMT_DRM_PRIME;
+        /* 1. get references to the actual data */
+        ret = v4l2_buf_to_bufref_drm(avbuf, &frame->buf[0]);
+        if (ret)
+            return ret;
+        frame->data[0] = (uint8_t *) v4l2_get_drm_frame(avbuf);
+        frame->format = AV_PIX_FMT_DRM_PRIME;
+    } else {
+        /* 1. get references to the actual data */
+        for (i = 0; i < avbuf->num_planes; i++) {
+            ret = v4l2_buf_to_bufref(avbuf, i, &frame->buf[i]);
+            if (ret)
+                return ret;
+
+            frame->linesize[i] = avbuf->plane_info[i].bytesperline;
+            frame->data[i] = frame->buf[i]->data;
+        }
+
+        /* 1.1 fixup special cases */
+        switch (avbuf->context->av_pix_fmt) {
+        case AV_PIX_FMT_NV12:
+            if (avbuf->num_planes > 1)
+                break;
+            frame->linesize[1] = avbuf->plane_info[0].bytesperline;
+            frame->data[1] = frame->buf[0]->data + avbuf->plane_info[0].bytesperline *
+                avbuf->context->format.fmt.pix_mp.height;
+            break;
+        default:
+            break;
+        }
+        frame->format = avbuf->context->av_pix_fmt;
+    }
 
+    /* 2. get frame information */
     frame->key_frame = !!(avbuf->buf.flags & V4L2_BUF_FLAG_KEYFRAME);
     frame->color_primaries = v4l2_get_color_primaries(avbuf);
     frame->colorspace = v4l2_get_color_space(avbuf);
@@ -546,29 +572,32 @@ int ff_v4l2_buffer_initialize(V4L2Buffer* avbuf, int index)
 
     avbuf->status = V4L2BUF_AVAILABLE;
 
-    if (V4L2_TYPE_IS_OUTPUT(ctx->type)) {
-	avbuf->drm_frame.objects[0].fd = -1;
-        return 0;
-    }
-
-    ret = v4l2_buffer_export(avbuf);
-    if (ret)
-	    return ret;
-
     if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {
         avbuf->buf.m.planes = avbuf->planes;
         avbuf->buf.length   = avbuf->num_planes;
-
-        /* drm information */
-	avbuf->drm_frame.objects[0].fd = avbuf->buf.m.planes[0].m.fd;
-	avbuf->drm_frame.objects[0].size = avbuf->buf.m.planes[0].length;
     } else {
         avbuf->buf.bytesused = avbuf->planes[0].bytesused;
         avbuf->buf.length    = avbuf->planes[0].length;
+    }
 
-        /* drm information */
-	avbuf->drm_frame.objects[0].fd = avbuf->buf.m.fd;
-	avbuf->drm_frame.objects[0].size = avbuf->buf.length;
+    if (V4L2_TYPE_IS_OUTPUT(ctx->type)) {
+	avbuf->drm_frame.objects[0].fd = -1;
+        return 0;
+    }
+
+    if (buf_to_m2mctx(avbuf)->drm) {
+
+        ret = v4l2_buffer_export(avbuf);
+        if (ret)
+                return ret;
+
+        if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {
+            avbuf->drm_frame.objects[0].fd = avbuf->buf.m.planes[0].m.fd;
+            avbuf->drm_frame.objects[0].size = avbuf->buf.m.planes[0].length;
+        } else {
+            avbuf->drm_frame.objects[0].fd = avbuf->buf.m.fd;
+            avbuf->drm_frame.objects[0].size = avbuf->buf.length;
+        }
     }
 
     return ff_v4l2_buffer_enqueue(avbuf);
diff --git a/libavcodec/v4l2_m2m.h b/libavcodec/v4l2_m2m.h
index 452bf0d..85aacc8 100644
--- a/libavcodec/v4l2_m2m.h
+++ b/libavcodec/v4l2_m2m.h
@@ -59,6 +59,9 @@ typedef struct V4L2m2mContext {
 
     /* Reference to self; only valid while codec is active. */
     AVBufferRef *self_ref;
+
+    /* drm enabled */
+    int drm;
 } V4L2m2mContext;
 
 typedef struct V4L2m2mPriv
diff --git a/libavcodec/v4l2_m2m_dec.c b/libavcodec/v4l2_m2m_dec.c
index 08b4c06..011551b 100644
--- a/libavcodec/v4l2_m2m_dec.c
+++ b/libavcodec/v4l2_m2m_dec.c
@@ -184,6 +184,9 @@ static av_cold int v4l2_decode_init(AVCodecContext *avctx)
     capture->av_codec_id = AV_CODEC_ID_RAWVIDEO;
     capture->av_pix_fmt = avctx->pix_fmt;
 
+    if (avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME)
+        s->drm = 1;
+
     ret = ff_v4l2_m2m_codec_init(avctx);
     if (ret) {
         av_log(avctx, AV_LOG_ERROR, "can't configure decoder\n");
-- 
2.7.1

