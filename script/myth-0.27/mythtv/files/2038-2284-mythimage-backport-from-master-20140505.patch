diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythplugins/configure mythtv-0.27-20140504-ge2acf0d-new/mythplugins/configure
--- mythtv-0.27-20140504-ge2acf0d-old/mythplugins/configure	2014-05-05 12:15:07.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythplugins/configure	2014-05-05 12:22:12.000000000 +0200
@@ -272,7 +272,6 @@
 PLUGIN_LIST="
 archive
 browser
-flix
 gallery
 game
 music
@@ -282,6 +281,11 @@
 zoneminder
 "
 
+DEPRECATED_PLUGIN_LIST="
+flix
+gallery
+"
+
 CONFIG_LIST="
 opengl
 fftw
@@ -298,6 +302,7 @@
 "
 
 enable $PLUGIN_LIST $CONFIG_LIST $DEPEND_LIST
+disable $DEPRECATED_PLUGIN_LIST
 
 prefix="/usr/local"
 libdir_name="lib"
@@ -327,7 +332,7 @@
   --libdir-name=LIBNAME    install/look for libs in PREFIX/LIBNAME [$libdir_name]
   --help                   print this message
   --enable-all             Enable all options
-  --enable-opengl          enable OpenGL (Music and Gallery) [$opengl]
+  --enable-opengl          enable OpenGL (MythGallery) [$opengl]
   --previous               use previous configure parameters if possible
 
 MythArchive related options:
@@ -416,6 +421,8 @@
   eval $(echo "$opt" | sed 's/--/action=/;s/-myth/ option=/;s/-/_/g')
   if is_in $option $PLUGIN_LIST; then
       $action $option
+  elif is_in $option $DEPRECATED_PLUGIN_LIST; then
+      $action $option
   else
       die_unknown $opt
   fi
@@ -431,10 +438,10 @@
   --icc-profile=*) icc=`echo $opt | cut -d '=' -f 2`
   ;;
   --enable-all)
-      enable $PLUGIN_LIST $CONFIG_LIST
+      enable $DEPRECATED_PLUGIN_LIST $PLUGIN_LIST $CONFIG_LIST
   ;;
   --disable-all)
-      disable $PLUGIN_LIST $CONFIG_LIST
+      disable $DEPRECATED_PLUGIN_LIST $PLUGIN_LIST $CONFIG_LIST
   ;;
   --enable-?*|--disable-?*)
   eval $(echo "$opt" | sed 's/--/action=/;s/-/ option=/;s/-/_/g')
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/bindings/perl/MythTV.pm mythtv-0.27-20140504-ge2acf0d-new/mythtv/bindings/perl/MythTV.pm
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/bindings/perl/MythTV.pm	2014-05-04 17:43:45.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/bindings/perl/MythTV.pm	2014-05-05 12:22:13.000000000 +0200
@@ -376,11 +376,11 @@
             or die "Can't set timezone: $!\n\n";
 
     # Check for supported schema version
-        $self->{'schema_version'} = $self->backend_setting('DBSchemaVer');
-        if( $self->{'schema_version'} != $SCHEMA_VERSION ) {
-            die "Database schema $self->{'schema_version'} not supported.\n" .
-                "Bindings support schema version $SCHEMA_VERSION\n";
-        }
+#        $self->{'schema_version'} = $self->backend_setting('DBSchemaVer');
+#        if( $self->{'schema_version'} != $SCHEMA_VERSION ) {
+#            die "Database schema $self->{'schema_version'} not supported.\n" .
+#                "Bindings support schema version $SCHEMA_VERSION\n";
+#        }
 
     # Load the master host and port
         $self->{'master_host'} = $self->backend_setting('MasterServerIP');
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/configure mythtv-0.27-20140504-ge2acf0d-new/mythtv/configure
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/configure	2014-05-04 17:43:43.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/configure	2014-05-05 12:22:12.000000000 +0200
@@ -2645,6 +2645,7 @@
 enable libfftw3
 enable taglib
 enable mythlogserver
+enable exiv2
 
 # mythtv paths
 dvb_path_default="${sysroot}/usr/include"
@@ -5383,6 +5384,9 @@
 enabled lamemp3 && check_lib2 lame/lame.h lame_init -lmp3lame -lm ||
     die "ERROR! You must have the Lame MP3 encoding library installed to compile MythTV."
 
+enabled exiv2 && $(pkg-config --exists exiv2) ||
+    die "ERROR! You must have the Exiv2 image tag reader library installed to compile MythTV."
+    
 # Qt dependency checks
 if test $target_os = mingw32 ; then
     qt_inc="-I`cd $(${qmake} -query QT_INSTALL_HEADERS); pwd`"
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/storagegroup.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/storagegroup.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/storagegroup.cpp	2014-05-05 12:15:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/storagegroup.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -32,6 +32,7 @@
     <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Banners")
     <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Music")
     <<  QT_TRANSLATE_NOOP("(StorageGroups)", "MusicArt")
+    <<  QT_TRANSLATE_NOOP("(StorageGroups)", "Photographs")
     ;
 
 /****************************************************************************/
@@ -203,7 +204,7 @@
 }
 
 QStringList StorageGroup::GetDirFileList(QString dir, QString base,
-                                         bool recursive)
+                                         bool recursive, bool onlyDirs)
 {
     QStringList files;
     QDir d(dir);
@@ -230,21 +231,42 @@
         {
             LOG(VB_FILE, LOG_DEBUG, LOC +
                 QString("GetDirFileList: Dir: %1/%2").arg(base).arg(*p));
-            files << GetDirFileList(dir + "/" + *p, base + *p, true);
+
+            if (onlyDirs)
+                files.append(base + *p);
+
+            files << GetDirFileList(dir + "/" + *p, base + *p, true, onlyDirs);
         }
     }
 
-    QStringList list = d.entryList(QDir::Files|QDir::Readable);
-    for (QStringList::iterator p = list.begin(); p != list.end(); ++p)
+    if (!onlyDirs)
     {
-        LOG(VB_FILE, LOG_DEBUG, LOC +
-            QString("GetDirFileList: File: %1%2").arg(base).arg(*p));
-        if (recursive)
-            files.append(base + *p);
-        else
-            files.append(*p);
+        QStringList list = d.entryList(QDir::Files|QDir::Readable);
+        for (QStringList::iterator p = list.begin(); p != list.end(); ++p)
+        {
+            LOG(VB_FILE, LOG_DEBUG, LOC +
+                QString("GetDirFileList: File: %1%2").arg(base).arg(*p));
+            if (recursive)
+                files.append(base + *p);
+            else
+                files.append(*p);
+        }
     }
+    return files;
+}
 
+QStringList StorageGroup::GetDirList(QString Path, bool recursive)
+{
+    QStringList files;
+    QString tmpDir;
+    QDir d;
+    for (QStringList::Iterator it = m_dirlist.begin(); it != m_dirlist.end(); ++it)
+    {
+        tmpDir = *it + Path;
+        d.setPath(tmpDir);
+        if (d.exists())
+            files << GetDirFileList(tmpDir, Path, recursive, true);
+    }
     return files;
 }
 
@@ -260,7 +282,7 @@
 
         d.setPath(tmpDir);
         if (d.exists())
-            files << GetDirFileList(tmpDir, Path, recursive);
+            files << GetDirFileList(tmpDir, Path, recursive, false);
     }
 
     return files;
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/storagegroup.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/storagegroup.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythbase/storagegroup.h	2014-05-04 17:43:17.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythbase/storagegroup.h	2014-05-05 12:22:13.000000000 +0200
@@ -26,7 +26,8 @@
     QString GetFirstDir(bool appendSlash = false) const;
 
     QStringList GetDirFileList(QString dir, QString base,
-                               bool recursive = false);
+                               bool recursive = false, bool onlyDirs = false);
+    QStringList GetDirList(QString Path, bool recursive = false);
     QStringList GetFileList(QString Path, bool recursive = false);
     QStringList GetFileInfoList(QString Path);
     bool FileExists(QString filename);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/globals.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/globals.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/globals.cpp	2014-05-04 17:43:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/globals.cpp	2014-05-05 12:22:11.000000000 +0200
@@ -39,6 +39,8 @@
 const QString JUMP_VIDEO_GALLERY   = "Video Gallery";
 const QString JUMP_VIDEO_DEFAULT   = "Video Default";
 
+const QString JUMP_GALLERY_DEFAULT = "Gallery Default";
+
 #ifdef Q_OS_MAC
 const QString DEFAULT_VIDEOSTARTUP_DIR = QDir::homePath() + "/Movies";
 #else
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/globals.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/globals.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/globals.h	2014-05-04 17:43:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/globals.h	2014-05-05 12:22:11.000000000 +0200
@@ -29,6 +29,8 @@
 META_PUBLIC extern const QString JUMP_VIDEO_GALLERY;
 META_PUBLIC extern const QString JUMP_VIDEO_DEFAULT;
 
+META_PUBLIC extern const QString JUMP_GALLERY_DEFAULT;
+
 META_PUBLIC extern const QString DEFAULT_VIDEOSTARTUP_DIR;
 
 #endif // GLOBALS_H_
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagemetadata.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagemetadata.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagemetadata.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagemetadata.cpp	2014-05-05 12:22:12.000000000 +0200
@@ -0,0 +1,210 @@
+#include "mythcontext.h"
+
+#include "imagemetadata.h"
+
+
+
+/** \fn     ImageMetadata::ImageMetadata()
+ *  \brief  Constructor
+ *  \return void
+ */
+ImageMetadata::ImageMetadata()
+{
+    m_id = 0;
+    m_fileName = "";
+    m_name = "";
+    m_path = "";
+    m_parentId = 0;
+    m_dirCount = 0;
+    m_fileCount = 0;
+    m_type = 0;
+    m_modTime = 0;
+    m_size = 0;
+    m_extension = "";
+    m_angle = 0;
+    m_orientation = 0;
+    m_date = 0;
+    m_zoom = 100;
+    m_isHidden = false;
+
+    m_selected = false;
+
+    m_thumbPath = "";
+    m_thumbFileNameList = new QList<QString>();
+
+    // Initialize the lists to avoid assertions.
+    for (int i = 0; i < kMaxFolderThumbnails; ++i)
+        m_thumbFileNameList->append(QString(""));
+}
+
+
+
+/** \fn     ImageMetadata::~ImageMetadata()
+ *  \brief  Destructor
+ *  \return void
+ */
+ImageMetadata::~ImageMetadata()
+{
+    if (m_thumbFileNameList)
+        delete m_thumbFileNameList;
+}
+
+
+
+/** \fn     ImageMetadata::SetAngle(int)
+ *  \brief  Sets the angle within the allowed range
+ *  \param  angle The angle that shall be saved
+ *  \return void
+ */
+void ImageMetadata::SetAngle(int angle)
+{
+    m_angle += angle;
+
+    if (m_angle >= 360)
+        m_angle -= 360;
+
+    if (m_angle < 0)
+        m_angle += 360;
+}
+
+
+
+/** \fn     ImageMetadata::SetZoom(int)
+ *  \brief  Sets the zoom within the allowed range
+ *  \param  zoom The zoom value that shall be saved
+ *  \return void
+ */
+void ImageMetadata::SetZoom(int zoom)
+{
+    m_zoom += zoom;
+
+    if (m_zoom > 300)
+        m_zoom = 300;
+
+    if (m_zoom < 0)
+        m_zoom = 0;
+}
+
+
+
+/** \fn     ImageMetadata::GetOrientation()
+ *  \brief  Gets the orientation of the image (rotated, vertically and/or
+ *          horizontally flipped) depending on the old state.
+ *  \return The new orientation
+ */
+int ImageMetadata::GetOrientation()
+{
+    return m_orientation;
+}
+
+
+
+/** \fn     ImageMetadata::SetOrientation(int)
+ *  \brief  Sets the orientation of the image (rotated, vertically and/or
+ *          horizontally flipped) depending on the old state.
+ *  \param  orientation The orientation value that shall be set
+ *  \return void
+ */
+void ImageMetadata::SetOrientation(int orientation, bool replace = false)
+{
+    if (replace)
+    {
+        m_orientation = orientation;
+        return;
+    }
+
+    switch (m_orientation)
+    {
+    case 0: // The image has no orientation saved
+    case 1: // If the image is in its original state
+        if (orientation == kFileRotateCW)
+            m_orientation = 8;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 6;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 2;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 4;
+        break;
+
+    case 2: // The image is horizontally flipped
+        if (orientation == kFileRotateCW)
+            m_orientation = 7;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 5;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 1;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 3;
+        break;
+
+    case 3: // The image is rotated 180°
+        if (orientation == kFileRotateCW)
+            m_orientation = 6;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 8;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 4;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 2;
+        break;
+
+    case 4: // The image is vertically flipped
+        if (orientation == kFileRotateCW)
+            m_orientation = 5;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 7;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 3;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 1;
+        break;
+
+    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
+        if (orientation == kFileRotateCW)
+            m_orientation = 2;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 4;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 8;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 6;
+        break;
+
+    case 6: // The image is rotated 90° CCW
+        if (orientation == kFileRotateCW)
+            m_orientation = 1;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 3;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 7;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 5;
+        break;
+
+    case 7: // The image is transversed  (rotated 90° CW and flipped vertically)
+        if (orientation == kFileRotateCW)
+            m_orientation = 4;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 2;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 6;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 8;
+        break;
+
+    case 8: // The image is rotated 90° CW
+        if (orientation == kFileRotateCW)
+            m_orientation = 3;
+        else if (orientation == kFileRotateCCW)
+            m_orientation = 1;
+        else if (orientation == kFileFlipHorizontal)
+            m_orientation = 5;
+        else if (orientation == kFileFlipVertical)
+            m_orientation = 7;
+        break;
+
+    default:
+        break;
+    }
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagemetadata.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagemetadata.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagemetadata.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagemetadata.h	2014-05-05 12:22:12.000000000 +0200
@@ -0,0 +1,94 @@
+#ifndef IMAGEMETADATA_H
+#define IMAGEMETADATA_H
+
+// Qt headers
+#include <QFileInfo>
+#include <QString>
+#include <QImage>
+#include <QList>
+
+// MythTV headers
+#include "mythmetaexp.h"
+
+
+
+// We need to use other names to avoid
+// getting coflicts with the videolist.h file
+enum ImageTreeNodeType {
+    kUnknown        = 0,
+    kBaseDirectory  = 1,
+    kSubDirectory   = 2,
+    kUpDirectory    = 3,
+    kImageFile      = 4,
+    kVideoFile      = 5
+};
+
+enum ImageFileOrientationState {
+    kFileRotateCW       = 0,
+    kFileRotateCCW      = 1,
+    kFileFlipHorizontal = 2,
+    kFileFlipVertical   = 3,
+    kFileZoomIn         = 4,
+    kFileZoomOut        = 5
+};
+
+enum ImageFileSortOrder {
+    kSortByNameAsc     = 0,
+    kSortByNameDesc    = 1,
+    kSortByModTimeAsc  = 2,
+    kSortByModTimeDesc = 3,
+    kSortByExtAsc      = 4,
+    kSortByExtDesc     = 5,
+    kSortBySizeAsc     = 6,
+    kSortBySizeDesc    = 7,
+    kSortByDateAsc     = 8,
+    kSortByDateDesc    = 9
+};
+
+const static int kMaxFolderThumbnails = 4;
+
+
+class META_PUBLIC ImageMetadata
+{
+public:
+    ImageMetadata();
+    ~ImageMetadata();
+
+    // Database fields
+    int         m_id;
+    QString     m_fileName;
+    QString     m_name;
+    QString     m_path;
+    int         m_parentId;
+    int         m_dirCount;
+    int         m_fileCount;
+    int         m_type;
+    int         m_modTime;
+    int         m_size;
+    QString     m_extension;
+    double      m_date;
+    int         m_isHidden;
+
+    // Internal information
+    bool        m_selected;
+
+    int         GetAngle()  const   { return m_angle; }
+    int         GetZoom()   const   { return m_zoom; }
+    int         GetOrientation();
+    void        SetAngle(int);
+    void        SetZoom(int);
+    void        SetOrientation(int, bool);
+
+    // Internal thumbnail information
+    QString         m_thumbPath;
+    QList<QString> *m_thumbFileNameList;
+
+private:
+    int         m_zoom;
+    int         m_angle;
+    int         m_orientation;
+};
+
+Q_DECLARE_METATYPE(ImageMetadata*)
+
+#endif // IMAGEMETADATA_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescan.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescan.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescan.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescan.cpp	2014-05-05 12:22:12.000000000 +0200
@@ -0,0 +1,84 @@
+// Qt headers
+
+// MythTV headers
+#include "mythcontext.h"
+#include "imagescan.h"
+
+
+
+ImageScan* ImageScan::m_instance = NULL;
+
+ImageScan::ImageScan()
+{
+    m_imageScanThread = new ImageScanThread();
+}
+
+
+
+ImageScan::~ImageScan()
+{
+    if (m_imageScanThread)
+    {
+        delete m_imageScanThread;
+        m_imageScanThread = NULL;
+    }
+}
+
+
+
+ImageScan* ImageScan::getInstance()
+{
+    if (!m_instance)
+        m_instance = new ImageScan();
+
+    return m_instance;
+}
+
+
+
+void ImageScan::StartSync()
+{
+    if (m_imageScanThread && !m_imageScanThread->isRunning())
+    {
+        m_imageScanThread->m_continue = true;
+        m_imageScanThread->start();
+    }
+}
+
+
+
+void ImageScan::StopSync()
+{
+    if (m_imageScanThread && m_imageScanThread->isRunning())
+        m_imageScanThread->m_continue = false;
+}
+
+
+
+bool ImageScan::SyncIsRunning()
+{
+    if (m_imageScanThread)
+        return m_imageScanThread->isRunning();
+
+    return false;
+}
+
+
+
+int ImageScan::GetCurrent()
+{
+    if (m_imageScanThread)
+        return m_imageScanThread->m_progressCount;
+
+    return 0;
+}
+
+
+
+int ImageScan::GetTotal()
+{
+    if (m_imageScanThread)
+        return m_imageScanThread->m_progressTotalCount;
+
+    return 0;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescan.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescan.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescan.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescan.h	2014-05-05 12:22:12.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef IMAGESCAN_H
+#define IMAGESCAN_H
+
+// Qt headers
+
+// MythTV headers
+#include "imagescanthread.h"
+#include "mythmetaexp.h"
+
+
+
+class META_PUBLIC ImageScan
+{
+public:
+    static ImageScan*    getInstance();
+
+    void StartSync();
+    void StopSync();
+    bool SyncIsRunning();
+
+    int  GetCurrent();
+    int  GetTotal();
+
+private:
+    ImageScan();
+    ~ImageScan();
+    static ImageScan    *m_instance;
+
+    ImageScanThread     *m_imageScanThread;
+};
+
+#endif // IMAGESCAN_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescanthread.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescanthread.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescanthread.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescanthread.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,292 @@
+// Qt headers
+
+// MythTV headers
+#include "mythcontext.h"
+#include "storagegroup.h"
+#include "imagescanthread.h"
+#include "imageutils.h"
+
+
+/** \fn     ImageScanThread::ImageScanThread()
+ *  \brief  Constructor
+ *  \return void
+ */
+ImageScanThread::ImageScanThread() : MThread("ImageScanThread")
+{
+    // initialize all required data structures
+    m_dbDirList   = new QMap<QString, ImageMetadata *>;
+    m_dbFileList  = new QMap<QString, ImageMetadata *>;
+    m_continue = false;
+
+    m_progressCount       = 0;
+    m_progressTotalCount  = 0;
+}
+
+
+
+/** \fn     ImageScanThread::~ImageScanThread()
+ *  \brief  Destructor
+ *  \return void
+ */
+ImageScanThread::~ImageScanThread()
+{
+    if (m_dbDirList)
+    {
+        delete m_dbDirList;
+        m_dbDirList = NULL;
+    }
+
+    if (m_dbFileList)
+    {
+        delete m_dbFileList;
+        m_dbFileList = NULL;
+    }
+}
+
+
+
+/** \fn     ImageScanThread::run()
+ *  \brief  Called when the thread is started. Loads all storage groups files
+ *          and directories and also from the database and syncronizes them.
+ *  \return void
+ */
+void ImageScanThread::run()
+{
+    RunProlog();
+
+    if (!m_continue)
+    {
+        LOG(VB_GENERAL, LOG_DEBUG,
+            QString("Image scanning thread not allowed to start."));
+        return;
+    }
+
+    LOG(VB_GENERAL, LOG_DEBUG, QString("Syncronization started"));
+
+    m_progressCount       = 0;
+    m_progressTotalCount  = 0;
+    
+    // Load all available directories and files from the database so that
+    // they can be compared against the ones on the filesystem.
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadDirectoriesFromDB(m_dbDirList);
+    iu->LoadFilesFromDB(m_dbFileList);
+
+    QStringList paths = iu->GetStorageDirs();
+
+    // Get the total list of files and directories that will be synced.
+    // This is only an additional information that the themer can show.
+    for (int i = 0; i < paths.size(); ++i)
+    {
+        QString path = paths.at(i);
+        QDirIterator it(path, QDirIterator::Subdirectories);
+
+        while(it.hasNext())
+        {
+            it.next();
+            ++m_progressTotalCount;
+        }
+    }
+
+    // Now start the actual syncronization
+    for (int i = 0; i < paths.size(); ++i)
+    {
+        QString path = paths.at(i);
+        QString base = path;
+        if (!base.endsWith('/'))
+            base.append('/');
+        SyncFilesFromDir(path, 0, base);
+    }
+
+    // Adding or updating directories have been completed.
+    // The directory list still contains the remaining directories
+    // that are not in the filesystem anymore. Remove them from the database
+    QMap<QString, ImageMetadata *>::iterator i;
+    for (i = m_dbDirList->begin(); i != m_dbDirList->end(); ++i)
+    {
+        iu->RemoveDirectoryFromDB(m_dbDirList->value(i.key()));
+    }
+
+    // Repeat the same for the file list.
+    for (i = m_dbFileList->begin(); i != m_dbFileList->end(); ++i)
+    {
+        iu->RemoveFileFromDB(m_dbFileList->value(i.key()));
+    }
+
+    m_continue = false;
+    m_progressCount       = 0;
+    m_progressTotalCount  = 0;
+
+    RunEpilog();
+}
+
+
+
+/** \fn     ImageScanThread::SyncFilesFromDir(QString &, int)
+ *  \brief  Loads all available files from the path on the
+ *          backend and syncs depending if they are a directory or file
+ *  \param  path The current directory with the files that shall be scanned syncronized
+ *  \param  parentId The id of the parent directory which is required for possible subdirectories
+ *  \param  baseDirectory The current root storage group path, this will be stripped before insertion into the database
+ *  \return void
+ */
+void ImageScanThread::SyncFilesFromDir(QString &path, int parentId,
+                                       const QString &baseDirectory)
+{
+    if (!m_continue)
+    {
+        LOG(VB_FILE, LOG_DEBUG,
+            QString("Syncing from SG dir %1 interrupted").arg(path));
+        return;
+    }
+
+    LOG(VB_FILE, LOG_DEBUG,
+        QString("Syncing from SG dir %1").arg(path));
+
+    QDir dir(path);
+    if (!dir.exists())
+        return;
+
+    // Only get files and dirs, no special and hidden stuff
+    dir.setFilter(QDir::Dirs | QDir::Files |
+                  QDir::NoDotAndDotDot | QDir::NoSymLinks);
+    QFileInfoList list = dir.entryInfoList();
+    if (list.isEmpty())
+        return;
+
+    for (QFileInfoList::iterator it = list.begin(); it != list.end(); ++it)
+    {
+        if (!m_continue)
+        {
+            LOG(VB_FILE, LOG_DEBUG,
+                QString("Syncing from SG dir %1 interrupted").arg(path));
+            return;
+        }
+
+        QFileInfo fileInfo = *it;
+        if (fileInfo.isDir())
+        {
+            // Get the id. This will be new parent id
+            // when we traverse down the current directory.
+            int id = SyncDirectory(fileInfo, parentId, baseDirectory);
+
+            // Get new files within this directory
+            QString fileName = fileInfo.absoluteFilePath();
+            SyncFilesFromDir(fileName, id, baseDirectory);
+        }
+        else
+        {
+            SyncFile(fileInfo, parentId, baseDirectory);
+        }
+
+        // Increase the current progress count in case a
+        // progressbar is used to show the sync progress
+        if (m_progressTotalCount > m_progressCount)
+            ++m_progressCount;
+    }
+}
+
+
+
+/** \fn     ImageScanThread::SyncDirectory(QFileInfo &, int)
+ *  \brief  Syncronizes a directory with the database.
+ *          Either inserts or deletes the information in the database.
+ *  \param  fileInfo The information of the directory
+ *  \param  parentId The parent directory which will be saved with the file
+ *  \param  baseDirectory The current root storage group path, this will be stripped before insertion into the database
+ *  \return void
+ */
+int ImageScanThread::SyncDirectory(QFileInfo &fileInfo, int parentId, const QString &baseDirectory)
+{
+
+    LOG(VB_FILE, LOG_DEBUG, QString("Syncing directory %1")
+        .arg(fileInfo.absoluteFilePath()));
+
+    ImageMetadata *im = new ImageMetadata();
+
+    if (!m_dbDirList->contains(fileInfo.absoluteFilePath()))
+    {
+        // Load all required information of the directory
+        ImageUtils *iu = ImageUtils::getInstance();
+        iu->LoadDirectoryData(fileInfo, im, parentId, baseDirectory);
+
+        // The directory is not in the database list
+        // add it to the database and get the new id. This
+        // will be the new parent id for the subdirectories
+        im->m_id = iu->InsertDirectoryIntoDB(im);
+    }
+    else
+    {
+        // The directory exists in the db list
+        // Get the id which will be the new
+        // parent id for the subdirectories
+        im->m_id = m_dbDirList->value(fileInfo.absoluteFilePath())->m_id;
+
+        // Remove the entry from the dbList
+        // so we don't need to search again
+        m_dbDirList->remove(fileInfo.absoluteFilePath());
+    }
+
+    int id = im->m_id;
+    delete im;
+
+    return id;
+}
+
+
+
+/** \fn     ImageScanThread::SyncFile(QFileInfo &, int)
+ *  \brief  Syncronizes a file with the database. Either inserts,
+ *          updates or deletes the information in the database.
+ *  \param  fileInfo The information of the file
+ *  \param  parentId The parent directory which will be saved with the file
+ *  \return void
+ */
+void ImageScanThread::SyncFile(QFileInfo &fileInfo, int parentId,
+                               const QString &baseDirectory)
+{
+    LOG(VB_FILE, LOG_DEBUG, QString("Syncing file %1")
+        .arg(fileInfo.absoluteFilePath()));
+
+    if (!m_dbFileList->contains(fileInfo.absoluteFilePath()))
+    {
+        ImageMetadata *im = new ImageMetadata();
+
+        // Load all required information of the file
+        ImageUtils *iu = ImageUtils::getInstance();
+        iu->LoadFileData(fileInfo, im, baseDirectory);
+
+        // Only load the file if contains a valid file extension
+        LOG(VB_FILE, LOG_DEBUG, QString("Type of file %1 is %2, extension %3").arg(im->m_fileName).arg(im->m_type).arg(im->m_extension));
+        if (im->m_type != kUnknown)
+        {
+            // Load any required exif information if the file is an image
+            if (im->m_type == kImageFile)
+            {
+                bool ok;
+
+                int exifOrientation = iu->GetExifOrientation(fileInfo.absoluteFilePath(), &ok);
+                if (ok)
+                    im->SetOrientation(exifOrientation, true);
+
+                int exifDate = iu->GetExifDate(fileInfo.absoluteFilePath(), &ok);
+                if (ok)
+                    im->m_date = exifDate;
+            }
+
+            // Load the parent id. This is the id of the file's path
+            im->m_parentId = parentId;
+
+            // The file is not in the database list
+            // add it to the database.
+            im->m_id = iu->InsertFileIntoDB(im);
+        }
+        delete im;
+    }
+    else
+    {
+        // Remove the entry from the dbList
+        // so we don't need to search again
+        m_dbFileList->remove(fileInfo.absoluteFilePath());
+    }
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescanthread.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescanthread.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagescanthread.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagescanthread.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,37 @@
+#ifndef IMAGESCANTHREAD_H
+#define IMAGESCANTHREAD_H
+
+// Qt headers
+#include <QApplication>
+#include <QFileInfo>
+#include <QMap>
+
+// MythTV headers
+#include "mthread.h"
+#include "imagemetadata.h"
+
+class ImageScanThread : public MThread
+{
+public:
+    ImageScanThread();
+    ~ImageScanThread();
+
+    bool m_continue;
+    int  m_progressCount;
+    int  m_progressTotalCount;
+
+protected:
+    void run();
+
+private slots:
+
+private:
+    void SyncFilesFromDir(QString &path, int parentId, const QString &baseDirectory);
+    int  SyncDirectory(QFileInfo &fileInfo, int parentId, const QString &baseDirectory);
+    void SyncFile(QFileInfo &fileInfo, int parentId, const QString &baseDirectory);
+
+    QMap<QString, ImageMetadata *> *m_dbDirList;
+    QMap<QString, ImageMetadata *> *m_dbFileList;
+};
+
+#endif // IMAGESCANTHREAD_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,457 @@
+// Qt headers
+#include <QPainter>
+#include <QFile>
+
+// MythTV headers
+#include "mythcontext.h"
+#include "mythdirs.h"
+#include "mythuihelper.h"
+#include "mythsystemlegacy.h"
+#include "exitcodes.h"
+
+#include "imagemetadata.h"
+#include "imageutils.h"
+#include "imagethumbgenthread.h"
+
+/** \fn     ImageThumbGenThread::ImageThumbGenThread()
+ *  \brief  Constructor
+ *  \return void
+ */
+ImageThumbGenThread::ImageThumbGenThread()
+        :   m_progressCount(0), m_progressTotalCount(0),
+            m_width(0), m_height(0),
+            m_pause(false), m_fileListSize(0)
+{
+    QString sgName = IMAGE_STORAGE_GROUP;
+    m_storageGroup = StorageGroup(sgName, gCoreContext->GetHostName());
+
+    if (!gCoreContext->IsMasterBackend())
+        LOG(VB_GENERAL, LOG_ERR, "ImageThumbGenThread MUST be run on the master backend");
+}
+
+
+
+/** \fn     ImageThumbGenThread::~ImageThumbGenThread()
+ *  \brief  Destructor
+ *  \return void
+ */
+ImageThumbGenThread::~ImageThumbGenThread()
+{
+    cancel();
+    wait();
+}
+
+
+
+/** \fn     ImageThumbGenThread::run()
+ *  \brief  Called when the thread starts. Tries to generate
+ *          thumbnails from the file list until its empty or aborted.
+ *  \return void
+ */
+void ImageThumbGenThread::run()
+{
+    volatile bool exit = false;
+
+    m_mutex.lock();
+    m_fileListSize = m_fileList.size();
+    m_mutex.unlock();
+
+    while (!exit)
+    {
+        ImageMetadata *im = NULL;
+
+        m_mutex.lock();
+        if (!m_fileList.isEmpty())
+            im = m_fileList.takeFirst();
+
+        // Update the progressbar even if the thumbnail will not be created
+        emit UpdateThumbnailProgress(m_fileList.size(), m_fileListSize);
+        m_mutex.unlock();
+
+        if (im)
+        {
+            if (im->m_type == kSubDirectory ||
+                im->m_type == kUpDirectory)
+            {
+                for (int i = 0; i < im->m_thumbFileNameList->size(); ++i)
+                    CreateImageThumbnail(im, i);
+            }
+            else if (im->m_type == kImageFile)
+            {
+                CreateImageThumbnail(im, 0);
+            }
+            else if (im->m_type == kVideoFile)
+            {
+                CreateVideoThumbnail(im);
+            }
+        }
+
+        delete im;
+
+        m_mutex.lock();
+        exit = m_fileList.isEmpty();
+        m_mutex.unlock();
+
+        // Allows the thread to be paused when Pause() was called
+        m_mutex.lock();
+        if (m_pause)
+            m_condition.wait(&m_mutex);
+        m_mutex.unlock();
+    }
+}
+
+
+
+/** \fn     ImageThumbGenThread::CreateImageThumbnail(ImageMetadata *, int)
+ *  \brief  Creates a thumbnail with the correct size and rotation
+ *  \param  im The thumbnail details
+ *  \param  dataid The id of the thumbnail
+ *  \return void
+ */
+void ImageThumbGenThread::CreateImageThumbnail(ImageMetadata *im, int id)
+{
+    if (QFile(im->m_thumbFileNameList->at(id)).exists())
+        return;
+
+    QDir dir;
+    if (!dir.exists(im->m_thumbPath))
+        dir.mkpath(im->m_thumbPath);
+
+    QString imageFileName = m_storageGroup.FindFile(im->m_fileName);
+
+    // If a folder thumbnail shall be created we need to get
+    // the real filename from the thumbnail filename by removing
+    // the configuration directory and the MythImage path
+    if (im->m_type == kSubDirectory ||
+        im->m_type == kUpDirectory)
+    {
+        imageFileName = im->m_thumbFileNameList->at(id);
+        imageFileName = imageFileName.mid(GetConfDir().append("/MythImage/").count());
+    }
+
+    QImage image;
+    if (!image.load(imageFileName))
+        return;
+
+    QMatrix matrix;
+    switch (im->GetOrientation())
+    {
+    case 1: // If the image is in its original state
+        break;
+
+    case 2: // The image is horizontally flipped
+        image = image.mirrored(true, false);
+        break;
+
+    case 3: // The image is rotated 180°
+        matrix.rotate(180);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        break;
+
+    case 4: // The image is vertically flipped
+        image = image.mirrored(false, true);
+        break;
+
+    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
+        matrix.rotate(90);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        image = image.mirrored(true, false);
+        break;
+
+    case 6: // The image is rotated 90° CCW
+        matrix.rotate(270);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        break;
+
+    case 7: // The image is transversed  (rotated 90° CW and flipped vertically)
+        matrix.rotate(90);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        image = image.mirrored(false, true);
+        break;
+
+    case 8: // The image is rotated 90° CW
+        matrix.rotate(90);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        break;
+
+    default:
+        break;
+    }
+
+    Resize(image);
+
+    // save the image in the thumbnail directory
+    if (image.save(im->m_thumbFileNameList->at(id)))
+    {
+        QString msg = "IMAGE_THUMB_CREATED %1";
+        gCoreContext->SendMessage(msg.arg(im->m_id));
+    }
+}
+
+
+
+/** \fn     ImageThumbGenThread::CreateVideoThumbnail(ImageMetadata *)
+ *  \brief  Creates a video preview image with the correct size
+ *  \param  im The thumbnail details
+ *  \return void
+ */
+void ImageThumbGenThread::CreateVideoThumbnail(ImageMetadata *im)
+{
+    if (QFile(im->m_thumbFileNameList->at(0)).exists())
+        return;
+
+    QDir dir;
+    if (!dir.exists(im->m_thumbPath))
+        dir.mkpath(im->m_thumbPath);
+
+    QString videoFileName = m_storageGroup.FindFile(im->m_fileName);
+
+    QString cmd = "mythpreviewgen";
+    QStringList args;
+    args << logPropagateArgs.split(" ", QString::SkipEmptyParts);
+    args << "--infile"  << '"' + videoFileName + '"';
+    args << "--outfile" << '"' + im->m_thumbFileNameList->at(0) + '"';
+
+    MythSystemLegacy ms(cmd, args, kMSRunShell);
+    ms.SetDirectory(im->m_thumbPath);
+    ms.Run();
+
+    // If the process exited successful
+    // then try to load the thumbnail
+    if (ms.Wait() == GENERIC_EXIT_OK)
+    {
+        QImage image;
+        if (!image.load(im->m_thumbFileNameList->at(0)))
+            return;
+
+        Resize(image);
+
+        // save the default image in the thumbnail directory
+        if (image.save(im->m_thumbFileNameList->at(0)))
+        {
+            emit ThumbnailCreated(im, 0);
+            QString msg = "IMAGE_THUMB_CREATED %1";
+            gCoreContext->SendMessage(msg.arg(im->m_id));
+        }
+    }
+}
+
+
+
+/** \fn     ImageThumbGenThread::Resize(QImage)
+ *  \brief  Resizes the thumbnail to prevent black areas 
+ *          around the image when its shown in a widget.
+ *  \param  The image that shall be resized
+ *  \return void
+ */
+void ImageThumbGenThread::Resize(QImage &image)
+{
+    QSize size = QSize(m_width, m_height);
+
+    image = image.scaled(size, Qt::KeepAspectRatio, Qt::SmoothTransformation);
+}
+
+
+
+/** \fn     ImageThumbGenThread::AddToThumbnailList(ImageMetadata *)
+ *  \brief  Adds a file to the thumbnail list
+ *  \param  im The file information
+ *  \return void
+ */
+void ImageThumbGenThread::AddToThumbnailList(ImageMetadata *im)
+{
+    if (!im)
+        return;
+
+    m_mutex.lock();
+    m_fileList.append(im);
+    m_fileListSize = m_fileList.size();
+    m_mutex.unlock();
+}
+
+
+
+/** \fn     ImageThumbGenThread::RecreateThumbnail(ImageMetadata *)
+ *  \brief  Deletes the old thumbnail and creates a new one
+ *  \param  im The thumbnail information
+ *  \return void
+ */
+void ImageThumbGenThread::RecreateThumbnail(ImageMetadata *im)
+{
+    if (!im)
+        return;
+
+    if (QFile::remove(im->m_thumbFileNameList->at(0)))
+    {
+        GetMythUI()->RemoveFromCacheByFile(
+                    im->m_thumbFileNameList->at(0));
+
+        AddToThumbnailList(im);
+    }
+}
+
+
+
+/** \fn     ImageThumbGenThread::cancel()
+ *  \brief  Clears the thumbnail list so that the thread can exit.
+ *  \return void
+ */
+void ImageThumbGenThread::cancel()
+{
+    m_mutex.lock();
+    while (!m_fileList.isEmpty())
+        delete m_fileList.takeFirst();
+    m_fileListSize = 0;
+    m_mutex.unlock();
+
+    emit UpdateThumbnailProgress(0, 0);
+}
+
+
+
+/** \fn     ImageThumbGenThread::Pause()
+ *  \brief  Pauses the thumbnail generation
+ *  \return void
+ */
+void ImageThumbGenThread::Pause()
+{
+    m_pause = true;
+}
+
+
+
+/** \fn     ImageThumbGenThread::Resume()
+ *  \brief  Resumes the thumbnail generation
+ *  \return void
+ */
+void ImageThumbGenThread::Resume()
+{
+    m_condition.wakeAll();
+    m_pause = false;
+}
+
+
+
+/** \fn     ImageThumbGenThread::SetThumbnailSize(int, int)
+ *  \brief  Saves and specifies the size of the thumbnails.
+ *  \return void
+ */
+void ImageThumbGenThread::SetThumbnailSize(int width, int height)
+{
+    if (width > 0)
+        m_width = width;
+
+    if (height > 0)
+        m_height = height;
+}
+
+
+//////////////////////////////////////////////////////////////////////////
+
+
+ImageThumbGen* ImageThumbGen::m_instance = NULL;
+
+ImageThumbGen::ImageThumbGen()
+{
+    m_imageThumbGenThread = new ImageThumbGenThread();
+}
+
+
+
+ImageThumbGen::~ImageThumbGen()
+{
+    delete m_imageThumbGenThread;
+    m_imageThumbGenThread = NULL;
+}
+
+
+
+ImageThumbGen* ImageThumbGen::getInstance()
+{
+    if (!m_instance)
+        m_instance = new ImageThumbGen();
+
+    return m_instance;
+}
+
+
+
+void ImageThumbGen::StartThumbGen()
+{
+    if (m_imageThumbGenThread && !m_imageThumbGenThread->isRunning())
+        m_imageThumbGenThread->start();
+}
+
+
+
+void ImageThumbGen::StopThumbGen()
+{
+    if (m_imageThumbGenThread && m_imageThumbGenThread->isRunning())
+        m_imageThumbGenThread->cancel();
+}
+
+
+
+bool ImageThumbGen::ThumbGenIsRunning()
+{
+    if (m_imageThumbGenThread)
+        return m_imageThumbGenThread->isRunning();
+
+    return false;
+}
+
+
+
+int ImageThumbGen::GetCurrent()
+{
+    if (m_imageThumbGenThread)
+        return m_imageThumbGenThread->m_progressCount;
+
+    return 0;
+}
+
+
+
+int ImageThumbGen::GetTotal()
+{
+    if (m_imageThumbGenThread)
+        return m_imageThumbGenThread->m_progressTotalCount;
+
+    return 0;
+}
+
+
+
+bool ImageThumbGen::AddToThumbnailList(ImageMetadata *im)
+{
+    if (!m_imageThumbGenThread)
+        return false;
+
+    m_imageThumbGenThread->AddToThumbnailList(im);
+
+    return true;
+}
+
+
+
+bool ImageThumbGen::RecreateThumbnail(ImageMetadata *im)
+{
+    if (!m_imageThumbGenThread)
+        return false;
+
+    m_imageThumbGenThread->RecreateThumbnail(im);
+
+    return true;
+}
+
+
+
+bool ImageThumbGen::SetThumbnailSize(int width, int height)
+{
+    if (!m_imageThumbGenThread)
+        return false;
+
+    m_imageThumbGenThread->SetThumbnailSize(width, height);
+
+    return true;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,85 @@
+#ifndef GALLERYTHUMBGENTHREAD_H
+#define GALLERYTHUMBGENTHREAD_H
+
+// Qt headers
+#include <QThread>
+#include <QMutex>
+
+// MythTV headers
+#include "mythuibuttontree.h"
+#include "imagemetadata.h"
+#include "storagegroup.h"
+#include "mythmetaexp.h"
+
+class META_PUBLIC ImageThumbGenThread : public QThread
+{
+    Q_OBJECT
+
+  public:
+    ImageThumbGenThread();
+    ~ImageThumbGenThread();
+
+    void cancel();
+    void Pause();
+    void Resume();
+    void AddToThumbnailList(ImageMetadata *);
+    void RecreateThumbnail(ImageMetadata *);
+    void SetThumbnailSize(int, int);
+
+    int m_progressCount;
+    int m_progressTotalCount;
+
+  signals:
+    void ThumbnailCreated(ImageMetadata *, int);
+    void UpdateThumbnailProgress(int, int);
+
+  protected:
+    void run();
+
+  private:
+    void CreateImageThumbnail(ImageMetadata *, int);
+    void CreateVideoThumbnail(ImageMetadata *);
+
+    void Resize(QImage &);
+    void Rotate(QImage &);
+    void Combine(QImage &, QImage &, QPoint);
+    void DrawBorder(QImage &);
+
+    QList<ImageMetadata *>    m_fileList;
+    QMutex              m_mutex;
+
+    int m_width;
+    int m_height;
+    bool m_pause;
+    int m_fileListSize;
+
+    QWaitCondition      m_condition;
+    StorageGroup        m_storageGroup;
+};
+
+class META_PUBLIC ImageThumbGen
+{
+  public:
+    static ImageThumbGen*    getInstance();
+
+    void StartThumbGen();
+    void StopThumbGen();
+    bool ThumbGenIsRunning();
+
+    bool AddToThumbnailList(ImageMetadata *);
+    bool RecreateThumbnail(ImageMetadata *);
+
+    bool SetThumbnailSize(int width, int height);
+
+    int  GetCurrent();
+    int  GetTotal();
+
+  private:
+    ImageThumbGen();
+    ~ImageThumbGen();
+    static ImageThumbGen    *m_instance;
+
+    ImageThumbGenThread     *m_imageThumbGenThread;
+};
+
+#endif // GALLERYTHUMBGENTHREAD_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imageutils.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imageutils.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imageutils.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imageutils.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,904 @@
+// Qt headers
+
+// MythTV headers
+#include "mythcontext.h"
+#include "mythdirs.h"
+#include "storagegroup.h"
+#include "imageutils.h"
+
+
+// The maximum possible value of the utc time
+#define MAX_UTCTIME 2147483646;
+
+ImageUtils* ImageUtils::m_instance = NULL;
+
+ImageUtils::ImageUtils()
+{
+    m_imageFileExt = QString("jpg,jpeg,png,tif,tiff,bmp,gif").split(",");
+    m_videoFileExt = QString("avi,mpg,mp4,mpeg,mov,wmv,3gp").split(",");
+}
+
+
+
+ImageUtils::~ImageUtils()
+{
+
+}
+
+
+
+ImageUtils* ImageUtils::getInstance()
+{
+    if (!m_instance)
+        m_instance = new ImageUtils();
+
+    return m_instance;
+}
+
+
+
+/** \fn     ImageUtils::LoadDirectoryFromDB(QMap<QString, ImageMetadata *>*)
+ *  \brief  Loads all directory information from the database
+ *  \param  dbList The list where the results are stored
+ *  \return void
+ */
+void ImageUtils::LoadDirectoriesFromDB(QMap<QString, ImageMetadata *>* dbList)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("SELECT "
+                        "dir_id, filename, name, path, parent_id, "
+                        "dir_count, file_count, "
+                        "hidden "
+                        "FROM gallery_directories"));
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    if (query.size() > 0)
+    {
+        while (query.next())
+        {
+            ImageMetadata *im = new ImageMetadata();
+            LoadDirectoryValues(query, im);
+            dbList->insert(im->m_fileName, im);
+        }
+    }
+}
+
+
+
+/** \fn     ImageUtils::LoadFilesFromDB(QMap<QString, ImageMetadata *>*)
+ *  \brief  Loads all file information from the database
+ *  \param  dbList The list where the results are stored
+ *  \return void
+ */
+void ImageUtils::LoadFilesFromDB(QMap<QString, ImageMetadata *>* dbList)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("SELECT "
+                        "file_id, CONCAT_WS('/', path, filename), name, path, "
+                        "dir_id, type, modtime, size, extension, "
+                        "angle, date, zoom, "
+                        "hidden, orientation "
+                        "FROM gallery_files"));
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    if (query.size() > 0)
+    {
+        while (query.next())
+        {
+            ImageMetadata *im = new ImageMetadata();
+            LoadFileValues(query, im);
+            dbList->insert(im->m_fileName, im);
+        }
+    }
+}
+
+
+
+/** \fn     ImageUtils::LoadFileFromDB(ImageMetadata *, int)
+ *  \brief  Load the file information from the database given by the id
+ *  \param  im The image metadata which holds the information
+ *  \return void
+ */
+void ImageUtils::LoadFileFromDB(ImageMetadata * im, int id)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("SELECT "
+                        "file_id, CONCAT_WS('/', path, filename), name, path, dir_id, "
+                        "type, modtime, size, extension, "
+                        "angle, date, zoom, "
+                        "hidden, orientation "
+                        "FROM gallery_files "
+                        "WHERE file_id = :FILE_ID;"));
+    query.bindValue(":FILE_ID", id);
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    if (query.size() > 0)
+    {
+        while (query.next())
+        {
+            LoadFileValues(query, im);
+        }
+    }
+}
+
+
+
+/** \fn     ImageUtils::InsertDirectoryIntoDB(ImageMetadata *)
+ *  \brief  Saves information about a given directory in the database
+ *  \param  dm Information of the directory
+ *  \return void
+ */
+int ImageUtils::InsertDirectoryIntoDB(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("INSERT INTO gallery_directories ("
+                        "filename, name, path, parent_id, "
+                        "dir_count, file_count, "
+                        "hidden "
+                        ") VALUES ("
+                        ":FILENAME, :NAME, :PATH, :PARENT_ID, "
+                        ":DIRCOUNT, :FILECOUNT, "
+                        ":HIDDEN);"));
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":PARENT_ID",   im->m_parentId);
+    query.bindValue(":DIRCOUNT" ,   im->m_dirCount);
+    query.bindValue(":FILECOUNT",   im->m_fileCount);
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+
+    if (!query.exec())
+        MythDB::DBError("Error inserting, query: ", query);
+
+    return query.lastInsertId().toInt();
+}
+
+
+
+/** \fn     ImageUtils::InsertFileIntoDB(ImageMetadata *)
+ *  \brief  Saves information about a given file in the database
+ *  \param  dm Information of the file
+ *  \return void
+ */
+int ImageUtils::InsertFileIntoDB(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("INSERT INTO gallery_files ("
+                        "filename, name, path, dir_id, "
+                        "type, modtime, size, extension, "
+                        "angle, date, zoom, "
+                        "hidden, orientation "
+                        ") VALUES ("
+                        ":FILENAME, :NAME, :PATH, :DIR_ID, "
+                        ":TYPE, :MODTIME, :SIZE, :EXTENSION, "
+                        ":ANGLE, :DATE, :ZOOM, "
+                        ":HIDDEN, :ORIENT)"));
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":DIR_ID",      im->m_parentId);
+    query.bindValue(":TYPE",        im->m_type);
+    query.bindValue(":MODTIME",     im->m_modTime);
+    query.bindValue(":SIZE",        im->m_size);
+    query.bindValue(":EXTENSION",   im->m_extension);
+    query.bindValue(":ANGLE",       im->GetAngle());
+    query.bindValue(":DATE",        im->m_date);
+    query.bindValue(":ZOOM",        im->GetZoom());
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+    query.bindValue(":ORIENT",      im->GetOrientation());
+
+    if (!query.exec())
+        MythDB::DBError("Error inserting, query: ", query);
+
+    return query.lastInsertId().toInt();
+}
+
+
+
+/** \fn     ImageUtils::UpdateDirectoryInDB(ImageMetadata *)
+ *  \brief  Updates the information about a given directory in the database
+ *  \param  dm Information of the directory
+ *  \return void
+ */
+bool ImageUtils::UpdateDirectoryInDB(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("UPDATE gallery_directories SET "
+                        "filename =     :FILENAME, "
+                        "name =         :NAME, "
+                        "path =         :PATH, "
+                        "parent_id =    :PARENT_ID, "
+                        "dir_count =    :DIR_COUNT, "
+                        "file_count =   :FILE_COUNT, "
+                        "hidden =       :HIDDEN "
+                        "WHERE dir_id = :ID;"));
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":PARENT_ID",   im->m_parentId);
+    query.bindValue(":DIR_COUNT",   im->m_dirCount);
+    query.bindValue(":FILE_COUNT",  im->m_fileCount);
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+    query.bindValue(":ID",          im->m_id);
+
+    return query.exec();
+}
+
+
+
+/** \fn     ImageUtils::UpdateFileInDB(ImageMetadata *)
+ *  \brief  Updates the information about a given file in the database
+ *  \param  dm Information of the file
+ *  \return void
+ */
+bool ImageUtils::UpdateFileInDB(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("UPDATE gallery_files SET "
+                        "filename       = :FILENAME, "
+                        "name           = :NAME, "
+                        "path           = :PATH, "
+                        "dir_id         = :DIR_ID, "
+                        "type           = :TYPE, "
+                        "modtime        = :MODTIME, "
+                        "size           = :SIZE, "
+                        "extension      = :EXTENSION, "
+                        "angle          = :ANGLE, "
+                        "date           = :DATE, "
+                        "zoom           = :ZOOM, "
+                        "hidden         = :HIDDEN, "
+                        "orientation    = :ORIENT "
+                        "WHERE file_id  = :ID;"));
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":DIR_ID",      im->m_parentId);
+    query.bindValue(":TYPE",        im->m_type);
+    query.bindValue(":MODTIME",     im->m_modTime);
+    query.bindValue(":SIZE",        im->m_size);
+    query.bindValue(":EXTENSION",   im->m_extension);
+    query.bindValue(":ANGLE",       im->GetAngle());
+    query.bindValue(":DATE",        im->m_date);
+    query.bindValue(":ZOOM",        im->GetZoom());
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+    query.bindValue(":ORIENT",      im->GetOrientation());
+    query.bindValue(":ID",          im->m_id);
+
+    return query.exec();
+}
+
+
+
+/** \fn     ImageUtils::RemoveFromDB(ImageMetadata *im)
+ *  \brief  Deletes either a directory or file from the database
+ *  \param  im Information of the given item
+ *  \return void
+ */
+bool ImageUtils::RemoveFromDB(ImageMetadata *im)
+{
+    if (!im)
+        return false;
+
+    if (im->m_type == kSubDirectory || im->m_type == kUpDirectory)
+        return RemoveDirectoryFromDB(im);
+
+    if (im->m_type == kImageFile || im->m_type == kVideoFile)
+        return RemoveFileFromDB(im);
+
+    return false;
+}
+
+
+
+/** \fn     ImageUtils::RemoveDirectoryFromDB(ImageMetadata *)
+ *  \brief  Deletes the information about a given directory in the database
+ *  \param  im Information of the directory
+ *  \return void
+ */
+bool ImageUtils::RemoveDirectoryFromDB(ImageMetadata *im)
+{
+    if (!im)
+        return false;
+
+    return RemoveDirectoryFromDB(im->m_id);
+}
+
+
+
+bool ImageUtils::RemoveDirectoryFromDB(int id)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("DELETE from gallery_directories "
+                        "WHERE dir_id = :ID;"));
+    query.bindValue(":ID", id);
+
+    return query.exec();
+}
+
+
+
+/** \fn     ImageUtils::RemoveFileFromDB(ImageMetadata *)
+ *  \brief  Deletes the information about a given file in the database
+ *  \param  im Information of the directory
+ *  \return void
+ */
+bool ImageUtils::RemoveFileFromDB(ImageMetadata *im)
+{
+    if (!im)
+        return false;
+
+    return RemoveFileFromDB(im->m_id);
+}
+
+
+
+bool ImageUtils::RemoveFileFromDB(int id)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(
+                QString("DELETE from gallery_files "
+                        "WHERE file_id = :ID;"));
+    query.bindValue(":ID", id);
+
+    return query.exec();
+}
+
+
+
+/** \fn     ImageUtils::LoadDirectoryValues(MSqlQuery &, ImageMetadata *)
+ *  \brief  Loads the directory information from the database into the dataMap
+ *  \param  query Information from the database
+ *  \param  dm Holds the loaded information
+ *  \return void
+ */
+void ImageUtils::LoadDirectoryValues(MSqlQuery &query, ImageMetadata *dm)
+{
+    dm->m_id            = query.value(0).toInt();
+    dm->m_fileName      = query.value(1).toString();
+    dm->m_name          = query.value(2).toString();
+    dm->m_path          = query.value(3).toString();
+    dm->m_parentId      = query.value(4).toInt();
+    dm->m_dirCount      = query.value(5).toInt();
+    dm->m_fileCount     = query.value(6).toInt();
+    dm->m_isHidden      = query.value(7).toInt();
+
+    // preset all directories as subfolders
+    dm->m_type          = kSubDirectory;
+
+    LoadDirectoryThumbnailValues(dm);
+}
+
+
+
+/** \fn     ImageUtils::LoadFileValues(MSqlQuery &, ImageMetadata *)
+ *  \brief  Loads the file information from the database into the dataMap
+ *  \param  query Information from the database
+ *  \param  dm Holds the loaded information
+ *  \return void
+ */
+void ImageUtils::LoadFileValues(MSqlQuery &query, ImageMetadata *dm)
+{
+    dm->m_id            = query.value(0).toInt();
+    dm->m_fileName      = query.value(1).toString();
+    dm->m_name          = query.value(2).toString();
+    dm->m_path          = query.value(3).toString();
+    dm->m_parentId      = query.value(4).toInt();
+    dm->m_type          = query.value(5).toInt();
+    dm->m_modTime       = query.value(6).toInt();
+    dm->m_size          = query.value(7).toInt();
+    dm->m_extension     = query.value(8).toString();
+    dm->SetAngle(         query.value(9).toInt());
+    dm->m_date          = query.value(10).toInt();
+    dm->SetZoom(          query.value(11).toInt());
+    dm->m_isHidden      = query.value(12).toInt();
+    dm->SetOrientation(   query.value(13).toInt(), true);
+
+    LoadFileThumbnailValues(dm);
+}
+
+
+
+/** \fn     ImageUtils::GetStorageDirs()
+ *  \brief  Gets the available storage groups
+ *  \return List of all available storage groups
+ */
+QStringList ImageUtils::GetStorageDirs()
+{
+    QStringList sgDirList;
+
+    QString sgName = IMAGE_STORAGE_GROUP;
+
+    if (!sgName.isEmpty())
+    {
+        QString host = gCoreContext->GetHostName();
+
+        // Search for the specified dirs in the defined storage group.
+        // If there is no such storage group then don't use the fallback
+        // and don't get the default storage group name of "/mnt/store".
+        // The list will be empty. The user has to check the settings.
+        StorageGroup sg;
+        sg.Init(sgName, host, false);
+        sgDirList = sg.GetDirList();
+    }
+
+    return sgDirList;
+}
+
+
+
+/** \fn     ImageUtils::LoadDirectoryData(QFileInfo &, DataMap *, int)
+ *  \brief  Loads the information from the fileInfo into the dataMap object
+ *  \param  fileInfo Holds the information about the file
+ *  \param  data Holds the loaded information about a file
+ *  \param  parentId The parent directory
+ *  \return void
+ */
+void ImageUtils::LoadDirectoryData(QFileInfo &fileInfo,
+                                   ImageMetadata *data,
+                                   int parentId,
+                                   const QString &baseDirectory)
+{
+    QDir baseDir(baseDirectory);
+    data->m_parentId    = parentId;
+    data->m_fileName    = baseDir.relativeFilePath(fileInfo.absoluteFilePath());
+    data->m_name        = fileInfo.fileName();
+    data->m_path        = baseDir.relativeFilePath(fileInfo.absoluteFilePath());
+    data->m_isHidden    = fileInfo.isHidden();
+
+    QDir dir(data->m_fileName);
+    data->m_dirCount = dir.entryList(QDir::Dirs |
+                                     QDir::NoSymLinks |
+                                     QDir::NoDotAndDotDot |
+                                     QDir::Readable).count();
+
+    data->m_fileCount = dir.entryList(QDir::Files |
+                                      QDir::NoSymLinks |
+                                      QDir::NoDotAndDotDot |
+                                      QDir::Readable).count();
+}
+
+
+
+/** \fn     ImageUtils::LoadFileData(QFileInfo &, DataMap *)
+ *  \brief  Loads the information from the fileInfo into the dataMap object
+ *  \param  fileInfo Holds the information about the file
+ *  \param  data Holds the loaded information about a file
+ *  \return void
+ */
+void ImageUtils::LoadFileData(QFileInfo &fileInfo,
+                              ImageMetadata *data,
+                              const QString &baseDirectory)
+{
+    QDir baseDir(baseDirectory);
+    data->m_fileName    = fileInfo.fileName();
+    data->m_name        = fileInfo.fileName();
+    data->m_path        = baseDir.relativeFilePath(fileInfo.absolutePath());
+    if (data->m_path.isNull()) // Hack because relativeFilePath will return a null instead of empty string
+        data->m_path = "";
+    data->m_modTime     = fileInfo.lastModified().toTime_t();
+    data->m_size        = fileInfo.size();
+    data->m_isHidden    = fileInfo.isHidden();
+    data->m_extension   = fileInfo.completeSuffix().toLower();
+
+    // Set defaults, the data will be loaded later
+    data->SetAngle(0);
+    data->m_date = MAX_UTCTIME;
+
+    if (m_imageFileExt.contains(data->m_extension))
+    {
+        data->m_type = kImageFile;
+    }
+    else if (m_videoFileExt.contains(data->m_extension))
+    {
+        data->m_type = kVideoFile;
+    }
+    else
+    {
+        data->m_type = kUnknown;
+    }
+}
+
+
+
+/** \fn     ImageUtils::GetExifOrientation(const QString &fileName, bool *ok)
+ *  \brief  Reads and returns the orientation value
+ *  \param  fileName The filename that holds the exif data
+ *  \param  ok Will be set to true if the reading was ok, otherwise false
+ *  \return The orientation value
+ */
+int ImageUtils::GetExifOrientation(const QString &fileName, bool *ok)
+{
+    QString tag = "Exif.Image.Orientation";
+    QString value = GetExifValue(fileName, tag, ok);
+
+    // The orientation of the image. Only return the value if its valid
+    // See http://jpegclub.org/exif_orientation.html for details
+    bool valid;
+    int orientation = QString(value).toInt(&valid);
+    return (valid) ? orientation : 1;
+}
+
+
+
+/** \fn     ImageUtils::SetExifOrientation(const QString &, const long , bool *)
+ *  \brief  Saves the given value in the orientation exif tag
+ *  \param  fileName The filename that holds the exif data
+ *  \param  orientation The value that shall be saved in the exif data
+ *  \param  ok Will be set to true if the update was ok, otherwise false
+ *  \return void
+ */
+void ImageUtils::SetExifOrientation(const QString &fileName,
+                                    const int orientation, bool *ok)
+{
+    // the orientation of the image.
+    // See http://jpegclub.org/exif_orientation.html for details
+    if (orientation >= 1 && orientation <= 8)
+    {
+        QString tag = "Exif.Image.Orientation";
+        SetExifValue(fileName, tag, QString::number(orientation), ok);
+    }
+}
+
+
+
+/** \fn     ImageUtils::GetExifDate(const QString &, bool *)
+ *  \brief  Reads and returns the exif date
+ *  \param  fileName The filename that holds the exif data
+ *  \param  ok Will be set to true if the reading was ok, otherwise false
+ *  \return The date in utc time
+ */
+long ImageUtils::GetExifDate(const QString &fileName, bool *ok)
+{
+    long utcTime = MAX_UTCTIME;
+
+    QString tag = "Exif.Image.DateTime";
+    QString value = GetExifValue(fileName, tag, ok);
+
+    // convert the string into the UTC time. We need to split
+    // the exif time format, which is this: "2006:07:21 18:54:58"
+    if (!value.isEmpty())
+    {
+        bool ok;
+        QDateTime dateTime =
+                QDateTime(QDate(value.mid(0,4).toInt(&ok, 10),
+                                value.mid(5,2).toInt(&ok, 10),
+                                value.mid(8,2).toInt(&ok, 10)),
+                          QTime(value.mid(11,2).toInt(&ok, 10),
+                                value.mid(14,2).toInt(&ok, 10),
+                                value.mid(17,2).toInt(&ok, 10), 0));
+
+        // convert it to the utc time so
+        // we can easily compare it later.
+        utcTime = dateTime.toTime_t();
+    }
+
+    return utcTime;
+}
+
+
+
+/** \fn     ImageUtils::SetExifDate(const QString &, const long , bool *)
+ *  \brief  Saves the given date in the date exif tag
+ *  \param  fileName The filename that holds the exif data
+ *  \param  date The date that shall be saved in the exif data
+ *  \param  ok Will be set to true if the update was ok, otherwise false
+ *  \return void
+ */
+void ImageUtils::SetExifDate(const QString &fileName,
+                             const long date, bool *ok)
+{
+    QString value;
+
+    // Convert the date number into the UTC time and then
+    // into the string with the format "2006:07:21 18:54:58".
+    QDateTime dateTime;
+    dateTime.setTime_t(date);
+    value = dateTime.toString("yyyy:MM:dd hh:mm:ss");
+
+    if (!value.isEmpty())
+    {
+        QString tag = "Exif.Image.DateTime";
+        SetExifValue(fileName, tag, value, ok);
+    }
+}
+
+
+
+/** \fn     ImageUtils::GetAllExifValues(const QString &)
+ *  \brief  Reads and returns all non empty tags from the given file
+ *  \param  fileName The filename that holds the exif data
+ *  \return The list of exif tag names and values
+ */
+QList<QStringList> ImageUtils::GetAllExifValues(const QString &fileName)
+{
+    // default value, an empty list means no
+    // exif tags were found or an error occured
+    QList<QStringList> valueList;
+
+    try
+    {
+        Exiv2::Image::AutoPtr image =
+                Exiv2::ImageFactory::open(fileName.toLocal8Bit().constData());
+
+        if (image.get())
+        {
+            image->readMetadata();
+            Exiv2::ExifData &exifData = image->exifData();
+            if (!exifData.empty())
+            {
+                LOG(VB_FILE, LOG_DEBUG,
+                    QString("Found %1 tag(s) for file %2")
+                    .arg(exifData.count())
+                    .arg(fileName));
+
+                Exiv2::ExifData::const_iterator end = exifData.end();
+                Exiv2::ExifData::const_iterator i = exifData.begin();
+                for (; i != end; ++i)
+                {
+                    QString value = QString::fromStdString(i->value().toString());
+
+                    // Do not add empty tags to the list
+                    if (!value.isEmpty())
+                    {
+                        QStringList values;
+
+                        // These three are the same as i->key()
+                        values.append(QString::fromStdString(i->familyName()));
+                        values.append(QString::fromStdString(i->groupName()));
+                        values.append(QString::fromStdString(i->tagName()));
+                        values.append(QString::fromStdString(i->key()));
+                        values.append(QString::fromStdString(i->tagLabel()));
+                        values.append(QString::fromStdString(i->value().toString()));
+
+                        // Add the exif information to the list
+                        valueList.append(values);
+                    }
+                }
+            }
+            else
+            {
+                LOG(VB_FILE, LOG_DEBUG,
+                    QString("Exiv2 error: No header, file %1")
+                    .arg(fileName));
+            }
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("Exiv2 error: Could not open file, file %1")
+                .arg(fileName));
+        }
+    }
+    catch (Exiv2::Error& e)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Exiv2 exception %1, file %2")
+            .arg(e.what()).arg(fileName));
+    }
+
+    return valueList;
+}
+
+
+
+/** \fn     ImageUtils::GetExifValue(const QString &, const QString &, bool *)
+ *  \brief  Reads and returns the value of an exif tag in a file
+ *  \param  fileName The filename that holds the exif data
+ *  \param  exifTag The key that shall be updated
+ *  \param  ok Will be set to true if the reading was ok, otherwise false
+ *  \return The value of the exif tag or an empty string
+ */
+QString ImageUtils::GetExifValue(const QString &fileName,
+                                 const QString &exifTag,
+                                 bool *ok)
+{
+    // Assume the exif reading fails
+    *ok = false;
+
+    // default value
+    QString value("");
+
+    try
+    {
+        Exiv2::Image::AutoPtr image =
+                Exiv2::ImageFactory::open(fileName.toLocal8Bit().constData());
+
+        if (image.get())
+        {
+            image->readMetadata();
+            Exiv2::ExifData &exifData = image->exifData();
+            if (!exifData.empty())
+            {
+                Exiv2::Exifdatum &datum =
+                        exifData[exifTag.toLocal8Bit().constData()];
+
+                value = QString::fromStdString(datum.toString());
+                if (!value.isEmpty())
+                {
+                    *ok = true;
+                }
+                else
+                {
+                    LOG(VB_FILE, LOG_DEBUG,
+                        QString("Exiv2 error: No tag found, file %1, tag %2")
+                        .arg(fileName).arg(exifTag));
+                }
+            }
+            else
+            {
+                LOG(VB_FILE, LOG_DEBUG,
+                    QString("Exiv2 error: No header, file %1, tag %2")
+                    .arg(fileName).arg(exifTag));
+            }
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("Exiv2 error: Could not open file, file %1, tag %2")
+                .arg(fileName).arg(exifTag));
+        }
+    }
+    catch (Exiv2::Error& e)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Exiv2 exception %1, file %2, tag %3")
+            .arg(e.what()).arg(fileName).arg(exifTag));
+    }
+
+    return value;
+}
+
+
+
+/** \fn     ImageUtils::SetExifValue(const QString &, const QString &, const QString &, bool *)
+ *  \brief  Updates the exif tag in a file with the given value
+ *  \param  fileName The filename that holds the exif data
+ *  \param  exifTag The key that shall be updated
+ *  \param  value The new value of the exif tag
+ *  \param  ok Will be set to true if the update was ok, otherwise false
+ *  \return True if the exif key exists, otherwise false
+ */
+void ImageUtils::SetExifValue(const QString &fileName,
+                              const QString &exifTag,
+                              const QString &value,
+                              bool *ok)
+{
+    // Assume the exif writing fails
+    *ok = false;
+
+    try
+    {
+        Exiv2::Image::AutoPtr image =
+                Exiv2::ImageFactory::open(fileName.toLocal8Bit().constData());
+
+        if (image.get())
+        {
+            Exiv2::ExifData exifData;
+            Exiv2::Exifdatum &datum = exifData[exifTag.toLocal8Bit().constData()];
+            datum.setValue(value.toLocal8Bit().constData());
+
+            image->setExifData(exifData);
+            image->writeMetadata();
+
+            *ok = true;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("Exiv2 error: Could not open file, file %1, tag %2")
+                .arg(fileName).arg(exifTag));
+        }
+    }
+    catch (Exiv2::Error& e)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Exiv2 exception %1, file %2, tag %3, value %4")
+            .arg(e.what()).arg(fileName).arg(exifTag).arg(value));
+    }
+}
+
+
+
+/** \fn     ImageUtils::HasExifKey(Exiv2::ExifData, const QString &)
+ *  \brief  Checks if the exif data of the file contains the given key
+ *  \param  exifData The entire exif data
+ *  \param  exifTag The key that shall be checked
+ *  \return True if the exif key exists, otherwise false
+ */
+bool ImageUtils::HasExifKey(Exiv2::ExifData exifData,
+                            const QString &exifTag)
+{
+    Exiv2::ExifKey key(exifTag.toLocal8Bit().constData());
+    Exiv2::ExifData::iterator it = exifData.findKey(key);
+
+    // If the iterator has is the end of the
+    // list then the key has not been found
+    return !(it == exifData.end());
+}
+
+/**
+ *  \brief  Gets four images from the directory from the
+ *          database which will be used as a folder thumbnail
+ *  \param  im Holds the loaded information
+ *  \return void
+ */
+void ImageUtils::LoadDirectoryThumbnailValues(ImageMetadata *im)
+{
+    // Try to get four new thumbnail filenames
+    // from the available images in this folder
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT CONCAT_WS('/', path, filename), path FROM gallery_files "
+                          "WHERE path = :PATH "
+                          "AND type = '4' "
+                          "AND hidden = '0' LIMIT :LIMIT");
+    query.bindValue(":PATH", im->m_path);
+    query.bindValue(":LIMIT", kMaxFolderThumbnails);
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    int i = 0;
+    while (query.next())
+    {
+        QString thumbFileName = QString("%1%2")
+                .arg(GetConfDir().append("/tmp/MythImage/"))
+                .arg(query.value(0).toString());
+
+        if (i >= im->m_thumbFileNameList->size())
+            break;
+
+        im->m_thumbFileNameList->replace(i, thumbFileName);
+        im->m_thumbPath = query.value(1).toString();
+        ++i;
+    }
+
+    // Set the path to the thumbnail files. As a default this will be
+    // the path ".mythtv/MythGallery" in the users home directory
+    im->m_thumbPath.prepend(GetConfDir().append("/tmp/MythImage/"));
+}
+
+
+
+/**
+ *  \brief  Sets the thumbnail information for a file
+ *  \param  im Holds the loaded information
+ *  \return void
+ */
+void ImageUtils::LoadFileThumbnailValues(ImageMetadata *im)
+{
+    // Set the path to the thumbnail files. As a default this will be
+    // the path ".mythtv/MythGallery" in the users home directory
+    im->m_thumbPath = im->m_path;
+    im->m_thumbPath.prepend(GetConfDir().append("/tmp/MythImage/"));
+
+    // Create the full path and filename to the thumbnail image
+    QString thumbFileName = QString("%1%2")
+                                .arg(GetConfDir().append("/tmp/MythImage/"))
+                                .arg(im->m_fileName);
+
+    // If the file is a video then append a png, otherwise the preview
+    // image would not be readable due to the video file extension
+    if (im->m_type == kVideoFile)
+        thumbFileName.append(".png");
+
+    im->m_thumbFileNameList->replace(0, thumbFileName);
+}
+
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imageutils.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imageutils.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/imageutils.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/imageutils.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,72 @@
+#ifndef IMAGEUTILS_H
+#define IMAGEUTILS_H
+
+// Qt headers
+#include <QDirIterator>
+
+// Other headers
+// Note: Older versions of Exiv2 don't have the exiv2.hpp include
+// file.  Using image.hpp instead seems to work.
+//#include <exiv2/exiv2.hpp>
+#include <exiv2/image.hpp>
+
+// MythTV headers
+#include "mythdbcon.h"
+#include "imagemetadata.h"
+#include "mythmetaexp.h"
+
+#define IMAGE_STORAGE_GROUP "Photographs";
+
+class META_PUBLIC ImageUtils
+{
+public:
+    static ImageUtils* getInstance();
+
+    void LoadDirectoriesFromDB(QMap<QString, ImageMetadata *>*);
+    void LoadFilesFromDB(QMap<QString, ImageMetadata *>*);
+    void LoadFileFromDB(ImageMetadata * im, int id);
+
+    int  InsertDirectoryIntoDB(ImageMetadata *);
+    int  InsertFileIntoDB(ImageMetadata *);
+
+    bool UpdateDirectoryInDB(ImageMetadata *);
+    bool UpdateFileInDB(ImageMetadata *);
+
+    bool RemoveFromDB(ImageMetadata *);
+    bool RemoveDirectoryFromDB(ImageMetadata *);
+    bool RemoveDirectoryFromDB(int);
+    bool RemoveFileFromDB(ImageMetadata *);
+    bool RemoveFileFromDB(int);
+
+    void LoadDirectoryData(QFileInfo &, ImageMetadata *, int, const QString &);
+    void LoadFileData(QFileInfo &, ImageMetadata *, const QString &);
+
+    QStringList  GetStorageDirs();
+
+    long                GetExifDate(const QString &, bool *);
+    int                 GetExifOrientation(const QString &, bool *);
+    QString             GetExifValue(const QString &, const QString &, bool *);
+    QList<QStringList>  GetAllExifValues(const QString &fileName);
+
+    void    SetExifDate(const QString &, const long, bool *);
+    void    SetExifOrientation(const QString &, const int, bool *);
+    void    SetExifValue(const QString &, const QString &, const QString &, bool *);
+
+private:
+    ImageUtils();
+    ~ImageUtils();
+    static ImageUtils   *m_instance;
+
+    QStringList          m_imageFileExt;
+    QStringList          m_videoFileExt;
+
+    void LoadDirectoryValues(MSqlQuery &, ImageMetadata *);
+    void LoadFileValues(MSqlQuery &, ImageMetadata *);
+
+    void LoadDirectoryThumbnailValues(ImageMetadata *);
+    void LoadFileThumbnailValues(ImageMetadata *);
+
+    bool HasExifKey(Exiv2::ExifData, const QString &);
+};
+
+#endif // IMAGEUTILS_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/libmythmetadata.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/libmythmetadata.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythmetadata/libmythmetadata.pro	2014-05-05 12:15:11.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythmetadata/libmythmetadata.pro	2014-05-05 12:22:13.000000000 +0200
@@ -25,6 +25,8 @@
 HEADERS += musicmetadata.h musicutils.h metaio.h metaiotaglib.h
 HEADERS += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 HEADERS += metaiowavpack.h metaioid3.h metaiooggvorbis.h musicfilescanner.h
+HEADERS += imagemetadata.h imageutils.h imagescan.h imagescanthread.h
+HEADERS += imagethumbgenthread.h
 
 SOURCES += cleanup.cpp  dbaccess.cpp  dirscan.cpp  globals.cpp
 SOURCES += parentalcontrols.cpp  videoscan.cpp  videoutils.cpp
@@ -35,6 +37,8 @@
 SOURCES += musicmetadata.cpp musicutils.cpp metaio.cpp metaiotaglib.cpp
 SOURCES += metaioflacvorbis.cpp metaioavfcomment.cpp metaiomp4.cpp
 SOURCES += metaiowavpack.cpp metaioid3.cpp metaiooggvorbis.cpp musicfilescanner.cpp
+SOURCES += imagemetadata.cpp imageutils.cpp imagescan.cpp imagescanthread.cpp
+SOURCES += imagethumbgenthread.cpp
 
 INCLUDEPATH += ../libmythbase ../libmythtv
 INCLUDEPATH += ../.. ../ ./ ../libmythupnp ../libmythui
@@ -86,6 +90,8 @@
 inc.files += metaio.h metaiotaglib.h
 inc.files += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 inc.files += metaiowavpack.h metaioid3.h metaiooggvorbis.h musicfilescanner.h
+inc.files += imagemetadata.h imageutils.h imagescan.h imagescanthread.h
+inc.files += imagethumbgenthread.h
 
 INSTALLS += inc
 
@@ -99,4 +105,4 @@
 
 include ( ../libs-targetfix.pro )
 
-LIBS += $$EXTRA_LIBS $$LATE_LIBS
+LIBS += $$EXTRA_LIBS $$LATE_LIBS -lexiv2
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h	2014-05-05 12:22:11.000000000 +0200
@@ -0,0 +1,73 @@
+#ifndef IMAGEMETADATAINFO_H
+#define IMAGEMETADATAINFO_H
+
+#include <QString>
+
+#include "serviceexp.h"
+#include "datacontracthelper.h"
+
+
+
+namespace DTC
+{
+
+class SERVICE_PUBLIC ImageMetadataInfo : public QObject
+{
+    Q_OBJECT
+    Q_CLASSINFO( "version"    , "1.00" )
+
+    Q_PROPERTY( int             Number      READ Number         WRITE setNumber     )
+    Q_PROPERTY( QString         Family      READ Family         WRITE setFamily     )
+    Q_PROPERTY( QString         Group       READ Group          WRITE setGroup      )
+    Q_PROPERTY( QString         Tag         READ Tag            WRITE setTag        )
+    Q_PROPERTY( QString         Key         READ Key            WRITE setKey        )
+    Q_PROPERTY( QString         Label       READ Label          WRITE setLabel      )
+    Q_PROPERTY( QString         Value       READ Value          WRITE setValue      )
+
+    PROPERTYIMP    ( int        , Number       )
+    PROPERTYIMP    ( QString    , Family       )
+    PROPERTYIMP    ( QString    , Group        )
+    PROPERTYIMP    ( QString    , Tag          )
+    PROPERTYIMP    ( QString    , Key          )
+    PROPERTYIMP    ( QString    , Label        )
+    PROPERTYIMP    ( QString    , Value        )
+
+    public:
+
+        static void InitializeCustomTypes()
+        {
+            qRegisterMetaType< ImageMetadataInfo  >();
+            qRegisterMetaType< ImageMetadataInfo* >();
+        }
+
+    public:
+
+        ImageMetadataInfo(QObject *parent = 0)
+                        : QObject         ( parent ),
+                          m_Number        ( 0      )
+        {
+        }
+
+        ImageMetadataInfo( const ImageMetadataInfo &src )
+        {
+            Copy( src );
+        }
+
+        void Copy( const ImageMetadataInfo &src )
+        {
+            m_Number    = src.m_Number;
+            m_Family    = src.m_Family;
+            m_Group     = src.m_Group;
+            m_Tag       = src.m_Tag;
+            m_Key       = src.m_Key;
+            m_Label     = src.m_Label;
+            m_Value     = src.m_Value;
+        }
+};
+
+} // namespace DTC
+
+Q_DECLARE_METATYPE( DTC::ImageMetadataInfo  )
+Q_DECLARE_METATYPE( DTC::ImageMetadataInfo* )
+
+#endif // IMAGEMETADATAINFO_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfoList.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfoList.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfoList.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfoList.h	2014-05-05 12:22:11.000000000 +0200
@@ -0,0 +1,91 @@
+#ifndef IMAGEMETADATAINFOLIST_H
+#define IMAGEMETADATAINFOLIST_H
+
+#include <QVariantList>
+
+#include "serviceexp.h"
+#include "datacontracthelper.h"
+#include "imageMetadataInfo.h"
+
+
+
+namespace DTC
+{
+
+class SERVICE_PUBLIC ImageMetadataInfoList : public QObject
+{
+    Q_OBJECT
+    Q_CLASSINFO( "version", "1.0" )
+
+    // Q_CLASSINFO Used to augment Metadata for properties.
+    // See datacontracthelper.h for details
+
+    Q_CLASSINFO( "ImageMetadataInfos", "type=DTC::ImageMetadataInfo")
+
+    Q_PROPERTY( int          Count              READ Count              WRITE setCount          )
+    Q_PROPERTY( QString      File               READ File               WRITE setFile           )
+    Q_PROPERTY( QString      Path               READ Path               WRITE setPath           )
+    Q_PROPERTY( int          Size               READ Size               WRITE setSize           )
+    Q_PROPERTY( QString      Extension          READ Extension          WRITE setExtension      )
+    Q_PROPERTY( QVariantList ImageMetadataInfos READ ImageMetadataInfos DESIGNABLE true )
+
+    PROPERTYIMP       ( int         , Count           )
+    PROPERTYIMP       ( QString     , File            )
+    PROPERTYIMP       ( QString     , Path            )
+    PROPERTYIMP       ( int         , Size            )
+    PROPERTYIMP       ( QString     , Extension       )
+    PROPERTYIMP_RO_REF( QVariantList, ImageMetadataInfos )
+
+    public:
+
+        static void InitializeCustomTypes()
+        {
+            qRegisterMetaType< ImageMetadataInfoList  >();
+            qRegisterMetaType< ImageMetadataInfoList* >();
+
+            ImageMetadataInfo::InitializeCustomTypes();
+        }
+
+    public:
+
+        ImageMetadataInfoList(QObject *parent = 0)
+            : QObject( parent ),
+              m_Count         ( 0      ),
+              m_Size          ( 0      )
+        {
+        }
+
+        ImageMetadataInfoList( const ImageMetadataInfoList &src )
+        {
+            Copy( src );
+        }
+
+        void Copy( const ImageMetadataInfoList &src )
+        {
+            m_Count         = src.m_Count;
+            m_File          = src.m_File;
+            m_Path          = src.m_Path;
+            m_Size          = src.m_Size;
+            m_Extension     = src.m_Extension;
+
+            CopyListContents< ImageMetadataInfo >( this, m_ImageMetadataInfos, src.m_ImageMetadataInfos );
+        }
+
+        ImageMetadataInfo *AddNewImageMetadataInfo()
+        {
+            // We must make sure the object added to the
+            // QVariantList has a parent of 'this'
+            ImageMetadataInfo *pObject = new ImageMetadataInfo( this );
+            m_ImageMetadataInfos.append( QVariant::fromValue<QObject *>( pObject ));
+
+            return pObject;
+        }
+
+};
+
+} // namespace DTC
+
+Q_DECLARE_METATYPE( DTC::ImageMetadataInfoList  )
+Q_DECLARE_METATYPE( DTC::ImageMetadataInfoList* )
+
+#endif // IMAGEMETADATAINFOLIST_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageSyncInfo.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageSyncInfo.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageSyncInfo.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageSyncInfo.h	2014-05-05 12:22:11.000000000 +0200
@@ -0,0 +1,63 @@
+#ifndef IMAGESYNCINFO_H
+#define IMAGESYNCINFO_H
+
+#include <QString>
+
+#include "serviceexp.h"
+#include "datacontracthelper.h"
+
+
+
+namespace DTC
+{
+
+class SERVICE_PUBLIC ImageSyncInfo : public QObject
+{
+    Q_OBJECT
+    Q_CLASSINFO( "version"    , "1.00" )
+
+    Q_PROPERTY( bool            Running     READ Running        WRITE setRunning    )
+    Q_PROPERTY( int             Current     READ Current        WRITE setCurrent    )
+    Q_PROPERTY( int             Total       READ Total          WRITE setTotal      )
+
+    PROPERTYIMP    ( bool       , Running      )
+    PROPERTYIMP    ( int        , Current      )
+    PROPERTYIMP    ( int        , Total        )
+
+    public:
+
+        static void InitializeCustomTypes()
+        {
+            qRegisterMetaType< ImageSyncInfo  >();
+            qRegisterMetaType< ImageSyncInfo* >();
+        }
+
+    public:
+
+        ImageSyncInfo(QObject *parent = 0)
+                        : QObject         ( parent ),
+                          m_Running       ( false  ),
+                          m_Current       ( 0 ),
+                          m_Total         ( 0 )
+        {
+        }
+
+        ImageSyncInfo( const ImageSyncInfo &src )
+        {
+            Copy( src );
+        }
+
+        void Copy( const ImageSyncInfo &src )
+        {
+            m_Running       = src.m_Running;
+            m_Current       = src.m_Current;
+            m_Total         = src.m_Total;
+        }
+};
+
+} // namespace DTC
+
+Q_DECLARE_METATYPE( DTC::ImageSyncInfo  )
+Q_DECLARE_METATYPE( DTC::ImageSyncInfo* )
+
+#endif // IMAGESYNCINFO_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/libmythservicecontracts.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/libmythservicecontracts.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/libmythservicecontracts.pro	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/libmythservicecontracts.pro	2014-05-05 12:22:11.000000000 +0200
@@ -21,6 +21,7 @@
 HEADERS += services/channelServices.h services/videoServices.h
 HEADERS += services/captureServices.h
 HEADERS += services/frontendServices.h
+HEADERS += services/imageServices.h
 
 HEADERS += datacontracts/connectionInfo.h        datacontracts/databaseInfo.h
 HEADERS += datacontracts/programAndChannel.h     datacontracts/programGuide.h
@@ -43,6 +44,8 @@
 HEADERS += datacontracts/titleInfo.h             datacontracts/titleInfoList.h
 HEADERS += datacontracts/labelValue.h
 HEADERS += datacontracts/logMessage.h            datacontracts/logMessageList.h
+HEADERS += datacontracts/imageMetadataInfoList.h datacontracts/imageMetadataInfo.h
+HEADERS += datacontracts/imageSyncInfo.h
 
 SOURCES += service.cpp
 
@@ -64,6 +67,7 @@
 incServices.files += services/channelServices.h services/videoServices.h
 incServices.files += services/captureServices.h
 incServices.files += services/frontendServices.h
+incServices.files += services/imageServices.h
 
 incDatacontracts.path = $${PREFIX}/include/mythtv/libmythservicecontracts/datacontracts/
 incDatacontracts.files  = datacontracts/connectionInfo.h      datacontracts/databaseInfo.h
@@ -84,6 +88,8 @@
 incDatacontracts.files += datacontracts/titleInfo.h           datacontracts/titleInfoList.h
 incDatacontracts.files += datacontracts/labelValue.h
 incDatacontracts.files += datacontracts/logMessage.h          datacontracts/logMessageList.h
+incDatacontracts.files += datacontracts/imageMetadataInfoList.h datacontracts/imageMetadataInfo.h
+incDatacontracts.files += datacontracts/imageSyncInfo.h
 
 INSTALLS += inc incServices incDatacontracts
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/services/contentServices.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/services/contentServices.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/services/contentServices.h	2014-05-04 17:43:16.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/services/contentServices.h	2014-05-05 12:22:13.000000000 +0200
@@ -39,8 +39,10 @@
 class SERVICE_PUBLIC ContentServices : public Service  //, public QScriptable ???
 {
     Q_OBJECT
-    Q_CLASSINFO( "version"    , "1.33" );
+    Q_CLASSINFO( "version"    , "1.34" );
     Q_CLASSINFO( "DownloadFile_Method",            "POST" )
+    Q_CLASSINFO( "DeleteFile_Method",              "POST" )
+    Q_CLASSINFO( "RenameFile_Method",              "POST" )
 
     public:
 
@@ -64,6 +66,8 @@
 
         virtual QStringList         GetFileList         ( const QString   &StorageGroup ) = 0;
 
+        virtual QStringList         GetDirList          ( const QString   &StorageGroup ) = 0;
+
         virtual QFileInfo           GetRecordingArtwork ( const QString   &Type,
                                                           const QString   &Inetref,
                                                           int Season, int Width,
@@ -102,6 +106,13 @@
         virtual bool                DownloadFile        ( const QString   &URL,
                                                           const QString   &StorageGroup ) = 0;
 
+        virtual bool                DeleteFile          ( const QString   &StorageGroup,
+                                                          const QString   &FileName ) = 0;
+
+        virtual bool                RenameFile          ( const QString   &StorageGroup,
+                                                          const QString   &FileName,
+                                                          const QString   &NewName ) = 0;
+
         virtual DTC::LiveStreamInfo     *AddLiveStream          ( const QString   &StorageGroup,
                                                                   const QString   &FileName,
                                                                   const QString   &HostName,
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/services/imageServices.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/services/imageServices.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythservicecontracts/services/imageServices.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythservicecontracts/services/imageServices.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,68 @@
+#ifndef IMAGESERVICES_H_
+#define IMAGESERVICES_H_
+
+#include <QFileInfo>
+#include <QStringList>
+
+#include "service.h"
+#include "datacontracts/imageMetadataInfoList.h"
+#include "datacontracts/imageSyncInfo.h"
+
+
+
+class SERVICE_PUBLIC ImageServices : public Service
+{
+    Q_OBJECT
+    Q_CLASSINFO( "version"    , "1.0" )
+    Q_CLASSINFO( "SetImageInfo_Method",         "POST" )
+    Q_CLASSINFO( "StartSync_Method",            "POST" )
+    Q_CLASSINFO( "StopSync_Method",             "POST" )
+
+    public:
+
+        // Must call InitializeCustomTypes for each unique
+        // Custom Type used in public slots below.
+        ImageServices( QObject *parent = 0 ) : Service( parent )
+        {
+            // Must call InitializeCustomTypes for each
+            // unique Custom Type used in public slots below.
+            DTC::ImageMetadataInfoList::InitializeCustomTypes();
+            DTC::ImageSyncInfo::InitializeCustomTypes();
+        }
+
+    public slots:
+
+        virtual bool                        SetImageInfo                ( int   Id,
+                                                                          const QString &Tag,
+                                                                          const QString &Value ) = 0;
+
+        virtual bool                        SetImageInfoByFileName      ( const QString &FileName,
+                                                                          const QString &Tag,
+                                                                          const QString &Value ) = 0;
+
+        virtual QString                     GetImageInfo                ( int   Id,
+                                                                          const QString &Tag ) = 0;
+
+        virtual QString                     GetImageInfoByFileName      ( const QString &FileName,
+                                                                          const QString &Tag ) = 0;
+
+        virtual DTC::ImageMetadataInfoList* GetImageInfoList            ( int   Id ) = 0;
+
+        virtual DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName ) = 0;
+
+        virtual bool                        RemoveImageFromDB  ( int   Id ) = 0;
+        virtual bool                        RemoveImage        ( int   Id ) = 0;
+
+        virtual bool                        StartSync          ( void ) = 0;
+        virtual bool                        StopSync           ( void ) = 0;
+        virtual DTC::ImageSyncInfo*         GetSyncStatus      ( void ) = 0;
+
+        virtual bool                        StartThumbnailGeneration ( void ) = 0;
+        virtual bool                        StopThumbnailGeneration  ( void ) = 0;
+        virtual bool                        CreateThumbnail    ( int   Id ) = 0;
+        virtual bool                        RecreateThumbnail  ( int   Id ) = 0;
+        virtual bool                        SetThumbnailSize   ( int   Width,
+                                                                 int   Height) = 0;
+};
+
+#endif
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.cpp	2014-05-05 12:15:13.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.cpp	2014-05-05 12:22:11.000000000 +0200
@@ -41,6 +41,7 @@
     m_gradAlpha = 255;
     m_gradDirection = FillTopToBottom;
 
+    m_isOriented = false;
     m_isReflected = false;
     m_isYUV = false;
 
@@ -112,6 +113,65 @@
     Assign(pix.toImage());
 }
 
+/**
+ * Changes the orientation angle of the image according to
+ * the exif rotation values. The image will be rotated accordingly.
+ * @brief MythImage::Orientation
+ * @param orientation
+ */
+void MythImage::Orientation(int orientation)
+{
+    if (m_isOriented)
+        return;
+
+    QMatrix matrix;
+    switch (orientation)
+    {
+    case 1: // If the image is in its original state
+        break;
+
+    case 2: // The image is horizontally flipped
+        Assign(mirrored(true, false));
+        break;
+
+    case 3: // The image is rotated 180°
+        matrix.rotate(180);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        break;
+
+    case 4: // The image is vertically flipped
+        Assign(mirrored(false, true));
+        break;
+
+    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
+        matrix.rotate(90);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        Assign(mirrored(true, false));
+        break;
+
+    case 6: // The image is rotated 90° CCW
+        matrix.rotate(270);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        break;
+
+    case 7: // The image is transversed  (rotated 90° CW and flipped vertically)
+        matrix.rotate(90);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        Assign(mirrored(false, true));
+        break;
+
+    case 8: // The image is rotated 90° CW
+        matrix.rotate(90);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        break;
+
+    default:
+        break;
+    }
+
+    m_isOriented = true;
+}
+
 void MythImage::Resize(const QSize &newSize, bool preserveAspect)
 {
     if ((size() == newSize) && !isNull())
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythimage.h	2014-05-05 12:15:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythimage.h	2014-05-05 12:22:11.000000000 +0200
@@ -45,6 +45,7 @@
 
     bool IsGradient() const { return m_isGradient; }
     bool IsReflected() const { return m_isReflected; }
+    bool IsOriented() const { return m_isOriented; }
 
     void SetToYUV(void) { m_isYUV = true; }
     void ConvertToYUV(void);
@@ -55,6 +56,7 @@
     bool Load(MythImageReader *reader);
     bool Load(const QString &filename);
 
+    void Orientation(int orientation);
     void Resize(const QSize &newSize, bool preserveAspect = false);
     void Reflect(ReflectAxis axis, int shear, int scale, int length,
                  int spacing = 0);
@@ -79,6 +81,7 @@
     QString GetFileName(void) const { return m_FileName; }
 
     void setIsReflected(bool reflected) { m_isReflected = reflected; }
+    void setIsOriented(bool oriented) { m_isOriented = oriented; }
 
     void SetIsInCache(bool bCached);
 
@@ -103,6 +106,7 @@
     int m_gradAlpha;
     FillDirection m_gradDirection;
 
+    bool m_isOriented;
     bool m_isReflected;
     bool m_isYUV;
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.cpp	2014-05-05 12:15:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -66,11 +66,13 @@
     isGreyscale = false;
     isReflected = false;
     isMasked = false;
+    isOriented = false;
     reflectAxis = ReflectVertical;
     reflectScale = 100;
     reflectLength = 100;
     reflectShear = 0;
-    reflectSpacing = 0,
+    reflectSpacing = 0;
+    orientation = 1;
     isThemeImage = false;
     maskImage = NULL;
 }
@@ -87,12 +89,14 @@
     isGreyscale = other.isGreyscale;
     isReflected = other.isReflected;
     isMasked = other.isMasked;
+    isOriented = other.isOriented;
 
     reflectAxis = other.reflectAxis;
     reflectScale = other.reflectScale;
     reflectLength = other.reflectLength;
     reflectShear = other.reflectShear;
     reflectSpacing = other.reflectSpacing;
+    orientation = other.orientation;
 
     isThemeImage = other.isThemeImage;
 
@@ -188,6 +192,12 @@
         if (imProps.isGreyscale)
             s_Attrib += "greyscale";
 
+        if (imProps.isOriented)
+        {
+            s_Attrib += "orientation";
+            s_Attrib += QString("%1").arg(imProps.orientation);
+        }
+
         int w = -1;
         int h = -1;
         if (!imProps.forceSize.isNull())
@@ -269,6 +279,9 @@
             if (imProps.isReflected)
                 image->setIsReflected(true);
 
+            if (imProps.isOriented)
+                image->setIsOriented(true);
+
             bFoundInCache = true;
         }
         else
@@ -353,6 +366,9 @@
             if (imProps.isGreyscale)
                 image->ToGreyscale();
 
+            if (imProps.isOriented)
+                image->Orientation(imProps.orientation);
+
             if (!imageReader)
                 GetMythUI()->CacheImage(cacheKey, image);
         }
@@ -786,6 +802,11 @@
     Clear();
     m_Delay = -1;
 
+    if (m_imageProperties.isOriented && !img->IsOriented() &&
+        (m_imageProperties.orientation >= 1 &&
+         m_imageProperties.orientation <= 8))
+        img->Orientation(m_imageProperties.orientation);
+
     if (m_imageProperties.forceSize.isNull())
         SetSize(img->size());
 
@@ -849,6 +870,11 @@
         if (m_imageProperties.isGreyscale && !im->isGrayscale())
             im->ToGreyscale();
 
+        if (m_imageProperties.isOriented && !im->IsOriented() &&
+            (m_imageProperties.orientation >= 1 &&
+             m_imageProperties.orientation <= 8))
+            im->Orientation(m_imageProperties.orientation);
+
         m_ImagesLock.lock();
         m_Images[m_Images.size()] = im;
         m_ImagesLock.unlock();
@@ -917,6 +943,15 @@
 }
 
 /**
+ *  \brief Saves the exif orientation value of the first image in the widget
+ */
+void MythUIImage::SetOrientation(int orientation)
+{
+    m_imageProperties.isOriented = true;
+    m_imageProperties.orientation = orientation;
+}
+
+/**
  *  \brief Set the size of the widget
  */
 void MythUIImage::SetSize(int width, int height)
@@ -1401,7 +1436,19 @@
 
         MythImage *newMaskImage = GetPainter()->GetFormatImage();
         if (newMaskImage->Load(maskfile))
+        {
+            float wmult; // Width multipler
+            float hmult; // Height multipler
+            GetMythUI()->GetScreenSettings(wmult, hmult);
+            if (wmult != 1.0f || hmult != 1.0f)
+            {
+                int width = newMaskImage->size().width() * wmult;
+                int height = newMaskImage->size().height() * hmult;
+                newMaskImage->Resize(QSize(width, height));
+            }
+
             m_imageProperties.SetMaskImage(newMaskImage);
+        }
         else
             m_imageProperties.SetMaskImage(NULL);
         newMaskImage->DecrRef();
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/libs/libmythui/mythuiimage.h	2014-05-05 12:15:12.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/libs/libmythui/mythuiimage.h	2014-05-05 12:22:11.000000000 +0200
@@ -56,6 +56,7 @@
     bool isGreyscale;
     bool isReflected;
     bool isMasked;
+    bool isOriented;
 
     ReflectAxis reflectAxis;
     int reflectScale;
@@ -65,6 +66,8 @@
 
     bool isThemeImage;
 
+    int orientation;
+
   private:
     void Init(void);
     void Copy(const ImageProperties &other);
@@ -121,6 +124,8 @@
 
     virtual void LoadNow(void);
 
+    void SetOrientation(int orientation);
+
   protected:
     virtual void DrawSelf(MythPainter *p, int xoffset, int yoffset,
                           int alphaMod, QRect clipRect);
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mediaserver.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mediaserver.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mediaserver.cpp	2014-05-04 17:43:46.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mediaserver.cpp	2014-05-05 12:22:11.000000000 +0200
@@ -27,6 +27,7 @@
 #include "serviceHosts/channelServiceHost.h"
 #include "serviceHosts/videoServiceHost.h"
 #include "serviceHosts/captureServiceHost.h"
+#include "serviceHosts/imageServiceHost.h"
 
 #ifdef USING_LIBDNS_SD
 #include "bonjourregister.h"
@@ -122,6 +123,7 @@
     m_pHttpServer->RegisterExtension( new ChannelServiceHost( m_sSharePath ));
     m_pHttpServer->RegisterExtension( new VideoServiceHost  ( m_sSharePath ));
     m_pHttpServer->RegisterExtension( new CaptureServiceHost( m_sSharePath ));
+    m_pHttpServer->RegisterExtension( new ImageServiceHost  ( m_sSharePath ));
 
     QString sIP = g_pConfig->GetValue( "BackendServerIP"  , ""   );
     if (sIP.isEmpty())
@@ -158,6 +160,8 @@
          pEngine->scriptValueFromQMetaObject< ScriptableVideo   >() );
      pEngine->globalObject().setProperty("Capture"  ,
          pEngine->scriptValueFromQMetaObject< ScriptableCapture   >() );
+     pEngine->globalObject().setProperty("Image"  ,
+         pEngine->scriptValueFromQMetaObject< Image             >() );
 
     // ------------------------------------------------------------------
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mythbackend.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mythbackend.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/mythbackend.pro	2014-05-04 17:43:46.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/mythbackend.pro	2014-05-05 12:22:11.000000000 +0200
@@ -32,10 +32,12 @@
 HEADERS += serviceHosts/contentServiceHost.h serviceHosts/dvrServiceHost.h
 HEADERS += serviceHosts/channelServiceHost.h serviceHosts/videoServiceHost.h
 HEADERS += serviceHosts/captureServiceHost.h
+HEADERS += serviceHosts/imageServiceHost.h
 
 HEADERS += services/myth.h services/guide.h services/content.h services/dvr.h
 HEADERS += services/serviceUtil.h services/channel.h services/video.h
 HEADERS += services/capture.h
+HEADERS += services/image.h
 
 SOURCES += autoexpire.cpp encoderlink.cpp filetransfer.cpp httpstatus.cpp
 SOURCES += main.cpp mainserver.cpp playbacksock.cpp scheduler.cpp server.cpp
@@ -47,6 +49,7 @@
 SOURCES += services/myth.cpp services/guide.cpp services/content.cpp 
 SOURCES += services/dvr.cpp services/channel.cpp services/video.cpp
 SOURCES += services/serviceUtil.cpp services/capture.cpp
+SOURCES += services/image.cpp
 
 using_oss:DEFINES += USING_OSS
 
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/serviceHosts/imageServiceHost.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/serviceHosts/imageServiceHost.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/serviceHosts/imageServiceHost.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/serviceHosts/imageServiceHost.h	2014-05-05 12:22:11.000000000 +0200
@@ -0,0 +1,49 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: contentServiceHost.h
+// Created     : Jul. 27, 2012
+//
+// Purpose - Content Service Host
+//
+// Copyright (c) 2012 Robert Siebert <trebor_s@web.de>
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef IMAGESERVICEHOST_H_
+#define IMAGESERVICEHOST_H_
+
+#include "servicehost.h"
+#include "services/image.h"
+
+
+
+class ImageServiceHost : public ServiceHost
+{
+    public:
+
+        ImageServiceHost( const QString &sSharePath )
+             : ServiceHost( Image::staticMetaObject,
+                            "Image",
+                            "/Image",
+                            sSharePath )
+        {
+        }
+
+        virtual ~ImageServiceHost()
+        {
+        }
+};
+
+#endif
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/content.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/content.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/content.cpp	2014-05-05 12:15:17.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/content.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -206,6 +206,26 @@
 //
 /////////////////////////////////////////////////////////////////////////////
 
+QStringList Content::GetDirList( const QString &sStorageGroup )
+{
+
+    if (sStorageGroup.isEmpty())
+    {
+        QString sMsg( "GetDirList - StorageGroup missing.");
+        LOG(VB_UPNP, LOG_ERR, sMsg);
+
+        throw sMsg;
+    }
+
+    StorageGroup sgroup(sStorageGroup);
+
+    return sgroup.GetDirList("", true);
+}
+
+/////////////////////////////////////////////////////////////////////////////
+//
+/////////////////////////////////////////////////////////////////////////////
+
 QStringList Content::GetFileList( const QString &sStorageGroup )
 {
 
@@ -787,6 +807,90 @@
     return false;
 }
 
+/** \fn     Content::DeleteImage( const QString &sStorageGroup,
+ *                                const QString &sFileName )
+ *  \brief  Permanently deletes the given file from the disk.
+ *  \param  sStorageGroup The storage group name where the image is located
+ *  \param  sFileName The filename including the path that shall be deleted
+ *  \return bool True if deletion was successful, otherwise false
+ */
+bool Content::DeleteFile( const QString &sStorageGroup,
+                          const QString &sFileName )
+{
+    // Get the fileinfo object
+    QFileInfo fileInfo = GetFile(sStorageGroup, sFileName);
+
+    // Check if the file exists. Only then we can actually delete it.
+    if (!fileInfo.isFile() && !QFile::exists( fileInfo.absoluteFilePath()))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "DeleteFile - File does not exist.");
+        return false;
+    }
+    return QFile::remove( fileInfo.absoluteFilePath() );
+}
+
+/** \fn     Content::RenameFile(const QString &sStorageGroup,
+ *                              const QString &sFileName,
+ *                              const QString &sNewFile)
+ *  \brief  Renames the file to the new name.
+ *  \param  sStorageGroup The storage group name where the image is located
+ *  \param  sFileName The filename including the path that shall be renamed
+ *  \param  sNewName  The new name of the file (only the name, no path)
+ *  \return bool True if renaming was successful, otherwise false
+ */
+bool Content::RenameFile( const QString &sStorageGroup,
+                          const QString &sFileName,
+                          const QString &sNewName)
+{
+    QFileInfo fi = QFileInfo();
+    fi = GetFile(sStorageGroup, sFileName);
+
+    // Check if the file exists and is writable.
+    // Only then we can actually delete it.
+    if (!fi.isFile() && !QFile::exists(fi.absoluteFilePath()))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RenameFile - File does not exist.");
+        return false;
+    }
+
+    // Check if the new filename has no path stuff specified
+    if (sNewName.contains("/") || sNewName.contains("\\"))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RenameFile - New file must not contain a path.");
+        return false;
+    }
+    
+    // The newly renamed file must be in the same path as the original one.
+    // So we need to check if a file of the new name exists and would be 
+    // overwritten by the new filename. To to this get the path from the 
+    // original file and append the new file name, Then check 
+    // if it exists in the given storage group
+    
+    // Get the everthing until the last directory separator
+    QString path = sFileName.left(sFileName.lastIndexOf("/"));
+    // Append the new file name to the path
+    QString newFileName = path.append("/").append(sNewName);
+    
+    QFileInfo nfi = QFileInfo();
+    nfi = GetFile(sStorageGroup, newFileName);
+    
+    // Check if the target file is already present.
+    // If is there then abort, overwriting is not supported
+    if (nfi.isFile() || QFile::exists(nfi.absoluteFilePath()))
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("RenameFile - New file %1 would overwrite "
+                    "existing one, not renaming.").arg(sFileName));
+        return false;
+    }
+
+    // All checks have been passed, rename the file
+    QFile file; 
+    file.setFileName(fi.fileName());
+    QDir::setCurrent(fi.absolutePath());
+    return file.rename(sNewName);
+}
+
 /////////////////////////////////////////////////////////////////////////////
 //
 /////////////////////////////////////////////////////////////////////////////
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/content.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/content.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/content.h	2014-05-04 17:43:46.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/content.h	2014-05-05 12:22:13.000000000 +0200
@@ -49,6 +49,8 @@
 
         QStringList         GetFileList         ( const QString   &StorageGroup );
 
+        QStringList         GetDirList          ( const QString   &StorageGroup );
+
         QFileInfo           GetRecordingArtwork ( const QString   &Type,
                                                   const QString   &Inetref,
                                                   int Season, int Width,
@@ -85,6 +87,13 @@
         bool                DownloadFile        ( const QString   &URL,
                                                   const QString   &StorageGroup );
 
+        bool                DeleteFile          ( const QString   &StorageGroup,
+                                                  const QString   &FileName );
+
+        bool                RenameFile          ( const QString   &StorageGroup,
+                                                  const QString   &FileName,
+                                                  const QString   &NewName );
+
         // HTTP Live Streaming
         DTC::LiveStreamInfo     *AddLiveStream          ( const QString   &StorageGroup,
                                                           const QString   &FileName,
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/image.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/image.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/image.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/image.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,459 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: image.cpp
+// Created     : Jul. 27, 2012
+//
+// Copyright (c) 2012 Robert Siebert  <trebor_s@web.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#include <QFile>
+
+#include "mythcorecontext.h"
+#include "storagegroup.h"
+
+#include "imagescan.h"
+#include "imagethumbgenthread.h"
+#include "imageutils.h"
+#include "image.h"
+
+
+
+/** \fn     Image::SetImageInfo( int id,
+                                 const QString &tag,
+                                 const QString &value )
+ *  \brief  Saves the given value into the exif tag of the filename.
+ *  \param  id The database id of the file
+ *  \param  tag The tag that shall be overwritten
+ *  \param  value The new value
+ *  \return bool True when saving was successful, otherwise false
+ */
+bool Image::SetImageInfo( int id, const QString &tag,
+                          const QString &value )
+{
+    ImageMetadata *im = new ImageMetadata();
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadFileFromDB(im, id);
+
+    if (im->m_fileName.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "SetImageInfo - File not found in DB.");
+        delete im;
+        return false;
+    }
+
+    // We got the file name from the ID, so use this method
+    // which does the same but just on a filename basis.
+    bool ok;
+    ok = SetImageInfoByFileName( im->m_fileName, tag, value );
+
+    delete im;
+    return ok;
+ }
+
+
+
+/** \fn     Image::SetImageInfoByFileName( const QString &fileName,
+                                           const QString &tag,
+                                           const QString &value )
+ *  \brief  Saves the given value into the exif tag of the filename.
+ *  \param  fileName The full filename
+ *  \param  tag The tag that shall be overwritten
+ *  \param  value The new value
+ *  \return bool True when saving was successful, otherwise false
+ */
+bool Image::SetImageInfoByFileName( const QString &fileName,
+                                    const QString &tag,
+                                    const QString &value )
+{
+    if (!QFile::exists( fileName ))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - File does not exist.");
+        return false;
+    }
+
+    if (tag.isEmpty() || value.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - Exif tag name or value is missing.");
+        return false;
+    }
+
+    bool ok;
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->SetExifValue(fileName, tag, value, &ok);
+
+    return ok;
+}
+
+
+
+/** \fn     Image::GetImageInfo( int id, const QString &tag )
+ *  \brief  Returns the value of the specified exif tag from the image
+            file. If the filename or exif tag do not
+            exist or the tag has no contents, an empty value is returned.
+ *  \param  id The database id of the file
+ *  \param  tag The exif tag
+ *  \return QString The exif tag value if successful, otherwise empty
+ */
+QString Image::GetImageInfo( int id, const QString &tag )
+{
+    ImageMetadata *im = new ImageMetadata();
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadFileFromDB(im, id);
+
+    if (im->m_fileName.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfo - File not found in DB.");
+        delete im;
+        return QString();
+    }
+
+    // We got the file name from the ID, so use this method
+    // which does the same but just on a filename basis.
+    QString value = GetImageInfoByFileName( im->m_fileName, tag );
+
+    delete im;
+    return value;
+}
+
+
+
+/** \fn     Image::GetImageInfoByFileName( const QString &fileName,
+                                           const QString &tag )
+ *  \brief  Returns the value of the specified exif tag from the image
+            file. If the filename or exif tag do not
+            exist or the tag has no contents, an empty value is returned.
+ *  \param  fileName The full filename
+ *  \param  tag The exif tag
+ *  \return QString The exif tag value if successful, otherwise empty
+ */
+QString Image::GetImageInfoByFileName( const QString &fileName, const QString &tag )
+{
+    if (!QFile::exists( fileName ))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - File does not exist.");
+        return QString();
+    }
+
+    if (tag.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Exif tag name is missing.");
+        return QString();
+    }
+
+    bool ok;
+    ImageUtils *iu = ImageUtils::getInstance();
+    QString value = iu->GetExifValue(fileName, tag, &ok);
+
+    if (!ok)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Could not read exif tag");
+        return QString();
+    }
+
+    return value;
+}
+
+
+
+/** \fn     Image::GetImageInfoList(int id)
+ *  \brief  Returns all values from all available exif tags
+ *  \param  id The database id of the file
+ *  \return DTC::ImageMetadataInfoList The list with all exif values
+ */
+DTC::ImageMetadataInfoList* Image::GetImageInfoList( int id )
+{
+    ImageMetadata *im = new ImageMetadata();
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadFileFromDB(im, id);
+
+    if (im->m_fileName.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoList - File not found in DB");
+        delete im;
+        return NULL;
+    }
+
+    // We got the file name from the ID, so use this method
+    // which does the same but just on a filename basis.
+    DTC::ImageMetadataInfoList *imInfoList;
+    imInfoList = GetImageInfoListByFileName(im->m_fileName);
+
+    delete im;
+    return imInfoList;
+}
+
+
+
+/** \fn     Image::GetImageInfoListByFileName(QString &fileName)
+ *  \brief  Returns all values from all available exif tags
+ *  \param  fileName The name of the file
+ *  \return DTC::ImageMetadataInfoList The list with all exif values
+ */
+DTC::ImageMetadataInfoList* Image::GetImageInfoListByFileName( const QString &fileName )
+{
+    if (!QFile::exists(fileName))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoListByFileName - File does not exist.");
+        return NULL;
+    }
+
+    // Read all available exif tag
+    // values from the given image file
+    ImageUtils *iu = ImageUtils::getInstance();
+    QList<QStringList> valueList = iu->GetAllExifValues(fileName);
+
+    if (valueList.size() == 0)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoListByFileName - Could not read exif tags");
+        return NULL;
+    }
+
+    // This holds the xml data structure from
+    // the returned stringlist with the exif data
+    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
+
+    // Set the general information of the image
+    QFileInfo fi(fileName);
+    imInfoList->setCount(valueList.size());
+    imInfoList->setFile(fi.fileName());
+    imInfoList->setPath(fi.path());
+    imInfoList->setSize(fi.size());
+    imInfoList->setExtension(fi.suffix());
+
+    // The returned stringlist contents are
+    // <familyname>, <groupname>, <tagname>, <taglabel>, <value>
+    // Go through all list items and build the response. Create
+    // a new tag and add the tagnames below it. Each tagname
+    // has these children: family, group, name, label, value.
+    for (int i = 0; i < valueList.size(); ++i)
+    {
+        QStringList values = valueList.at(i);
+
+        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
+
+        imInfo->setNumber(  i);
+        imInfo->setFamily(  values.at(0));
+        imInfo->setGroup(   values.at(1));
+        imInfo->setTag(     values.at(2));
+        imInfo->setKey(     values.at(3));
+        imInfo->setLabel(   values.at(4));
+        imInfo->setValue(   values.at(5));
+    }
+
+    return imInfoList;
+}
+
+
+
+/** \fn     Image::RemoveImageFromDB(int id)
+ *  \brief  Returns all values from all available exif tags
+ *  \param  id The database id of the file
+ *  \return bool True if successful, otherwise false
+ */
+bool Image::RemoveImageFromDB( int id )
+{
+    ImageUtils *iu = ImageUtils::getInstance();
+    return iu->RemoveFileFromDB(id);
+}
+
+
+
+/** \fn     Image::RemoveImage(int id)
+ *  \brief  Returns all values from all available exif tags
+ *  \param  id The database id of the file
+ *  \return bool True if successful, otherwise false
+ */
+bool Image::RemoveImage( int id )
+{
+    ImageMetadata *im = new ImageMetadata();
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadFileFromDB(im, id);
+
+    if (im->m_fileName.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RemoveImage - File not found");
+        delete im;
+        return false;
+    }
+
+    if (!QFile::exists( im->m_fileName ))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RemoveImage - File does not exist.");
+        delete im;
+        return false;
+    }
+
+    if (!QFile::remove( im->m_fileName ))
+    {
+        LOG(VB_GENERAL, LOG_ERR, "RemoveImage - Could not delete file.");
+        delete im;
+        return false;
+    }
+
+    delete im;
+
+    // Remove the database entry if the file has been deleted.
+    return RemoveImageFromDB(id);
+}
+
+
+
+/** \fn     Image::StartSync(void)
+ *  \brief  Starts the synchronization of the images with the database
+ *  \return bool True if the sync has started, otherwise false
+ */
+bool Image::StartSync( void )
+{
+    // Check that the required image tables exist to avoid
+    // syncing against non existent tables in the database.
+    if (gCoreContext->GetNumSetting("DBSchemaVer") < 1317)
+    {
+        LOG(VB_GENERAL, LOG_INFO,
+            "Sync cannot start, the required database tables are missing."
+            "Please upgrade your database schema to at least 1318.");
+        return false;
+    }
+
+    ImageScan *is = ImageScan::getInstance();
+    if (!is->SyncIsRunning())
+        is->StartSync();
+
+    return is->SyncIsRunning();
+}
+
+
+
+/** \fn     Image::StopSync(void)
+ *  \brief  Stops the image synchronization if its running
+ *  \return bool True if the sync has stopped, otherwise false
+ */
+bool Image::StopSync( void )
+{
+    ImageScan *is = ImageScan::getInstance();
+    if (is->SyncIsRunning())
+        is->StopSync();
+
+    return is->SyncIsRunning();
+}
+
+
+
+/** \fn     Image::GetSyncStatus(void)
+ *  \brief  Returns a list with information if the synchronization is
+            currently running, the already synchronized images and
+            the total amount of images that shall be synchronized.
+ *  \return DTC::ImageSyncInfo The status information
+ */
+DTC::ImageSyncInfo* Image::GetSyncStatus( void )
+{
+    DTC::ImageSyncInfo *syncInfo = new DTC::ImageSyncInfo();
+
+    ImageScan *is = ImageScan::getInstance();
+
+    LOG(VB_GENERAL, LOG_DEBUG,
+        QString("Image: Sync status is running: %1, current: %2, total: %3")
+        .arg(is->SyncIsRunning())
+        .arg(is->GetCurrent())
+        .arg(is->GetTotal()));
+
+    syncInfo->setRunning(is->SyncIsRunning());
+    syncInfo->setCurrent(is->GetCurrent());
+    syncInfo->setTotal(is->GetTotal());
+
+    return syncInfo;
+}
+
+/**
+ *  \brief  Starts thumbnail generation thread for images
+ *  \return bool True if the generation thread has started, otherwise false
+ */
+bool Image::StartThumbnailGeneration(void )
+{
+    // Check that the required image tables exist to avoid
+    // syncing against non existent tables in the database.
+    if (gCoreContext->GetNumSetting("DBSchemaVer") < 1317)
+    {
+        LOG(VB_GENERAL, LOG_INFO,
+            "Thumbnail generation cannot start, the required database tables "
+            "are missing. "
+            "Please upgrade your database schema to at least 1318.");
+        return false;
+    }
+
+    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
+    if (!thumbGen->ThumbGenIsRunning())
+        thumbGen->StartThumbGen();
+
+    return thumbGen->ThumbGenIsRunning();
+}
+
+
+/**
+ *  \brief  Stops the thumbnail generation if it's running
+ *  \return bool True if the generation has stopped, otherwise false
+ */
+bool Image::StopThumbnailGeneration(void )
+{
+    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
+    if (thumbGen->ThumbGenIsRunning())
+        thumbGen->StopThumbGen();
+
+    return !thumbGen->ThumbGenIsRunning();
+}
+
+bool Image::CreateThumbnail(int id)
+{
+    ImageMetadata *im = new ImageMetadata();
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadFileFromDB(im, id);
+
+    if (im->m_fileName.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "QueueCreateThumbnail - File not found");
+        delete im;
+        return false;
+    }
+
+    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
+    return thumbGen->AddToThumbnailList(im);
+}
+
+bool Image::RecreateThumbnail(int id)
+{
+    ImageMetadata *im = new ImageMetadata();
+    ImageUtils *iu = ImageUtils::getInstance();
+    iu->LoadFileFromDB(im, id);
+
+    if (im->m_fileName.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "QueueCreateThumbnail - File not found");
+        delete im;
+        return false;
+    }
+
+    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
+    return thumbGen->RecreateThumbnail(im);
+}
+
+bool Image::SetThumbnailSize(int Width, int Height)
+{
+    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
+    return thumbGen->SetThumbnailSize(Width, Height);
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/image.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/image.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythbackend/services/image.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythbackend/services/image.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,73 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: image.h
+// Created     : Jul. 27, 2012
+//
+// Copyright (c) 2012 Robert Siebert <trebor_s@web.de>
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef IMAGE_H
+#define IMAGE_H
+
+#include <QScriptEngine>
+#include "services/imageServices.h"
+
+
+
+class Image : public ImageServices
+{
+    Q_OBJECT
+
+public:
+    Q_INVOKABLE Image( QObject *parent = 0 ) {}
+
+public:
+    bool                        SetImageInfo                ( int   Id,
+                                                              const QString &Tag,
+                                                              const QString &Value );
+
+    bool                        SetImageInfoByFileName      ( const QString &FileName,
+                                                              const QString &Tag,
+                                                              const QString &Value );
+
+    QString                     GetImageInfo                ( int   Id,
+                                                              const QString &Tag );
+
+    QString                     GetImageInfoByFileName      ( const QString &FileName,
+                                                              const QString &Tag );
+
+    DTC::ImageMetadataInfoList* GetImageInfoList            ( int   Id );
+
+    DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName );
+
+    bool                        RemoveImageFromDB  ( int   Id );
+    bool                        RemoveImage        ( int   Id );
+
+    bool                        StartSync          ( void );
+    bool                        StopSync           ( void );
+    DTC::ImageSyncInfo*         GetSyncStatus      ( void );
+
+    bool                        StartThumbnailGeneration ( void );
+    bool                        StopThumbnailGeneration  ( void );
+    bool                        CreateThumbnail    ( int   Id );
+    bool                        RecreateThumbnail  ( int   Id );
+    bool                        SetThumbnailSize   ( int   Width,
+                                                     int   Height);
+};
+
+Q_SCRIPT_DECLARE_QMETAOBJECT( Image, QObject*)
+
+#endif
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/example.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/example.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/example.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/example.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,169 @@
+#include "mythmainwindow.h"
+#include "mythscreenstack.h"
+#include "mythscreentype.h"
+#include "mythuiimage.h"
+#include "mythuitext.h"
+
+// .h
+class AirPlayPictureScreen : public MythScreenType
+{
+  public:
+    AirPlayPictureScreen(MythScreenStack *parent);
+   ~AirPlayPictureScreen();
+
+   // These two methods are declared by MythScreenType and their signatures
+   // should not be changed
+    virtual bool Create(void);
+    virtual void Init(void);
+
+    void UpdatePicture(const QString &imageFilename,
+                       const QString &imageDescription);
+
+  private:
+    QString     m_imageFilename;
+    QString     m_imageDescription;
+    MythUIImage *m_airplayImage;
+    MythUIText  *m_airplayText;
+};
+
+///////////////////////////////////////////////////
+// .cpp
+
+AirPlayPictureScreen::AirPlayPictureScreen(MythScreenStack *parent)
+              :MythScreenType(parent, "airplaypicture"),
+              m_imageFilename(""), m_imageDescription(""),
+              m_airplayImage(NULL), m_airplayText(NULL)
+{
+}
+
+bool AirPlayPictureScreen::Create(void)
+{
+    bool foundtheme = false;
+
+    // Load the theme for this screen
+    // The xml file containing the screen definition is airplay-ui.xml in this
+    // example, the name of the screen in the xml is airplaypicture. This
+    // should make sense when you look at the xml below
+    foundtheme = LoadWindowFromXML("airplay-ui.xml", "airplaypicture", this);
+
+    if (!foundtheme) // If we cannot load the theme for any reason ...
+        return false;
+
+    // The xml should contain an <imagetype> named 'picture', if it doesn't
+    // then we cannot display the image and may as well abort
+    m_airplayImage = dynamic_cast<MythUIImage*>
+                                            (GetChild("picture"));
+    if (!m_airplayImage)
+        return false;
+
+    // As an illustration let's say the picture includes a description/title or some other metadata
+    // Let's also say that display of this metadata is entirely optional, so we won't fail if the theme
+    // doesn't include 'description'
+    m_airplayText = dynamic_cast<MythUIText*>
+                                            (GetChild("description"));
+
+    return true;
+}
+
+void AirPlayPictureScreen::Init(void)
+{
+    if (m_airplayImage)
+    {
+        if (!m_imageFilename.isEmpty())
+        {
+            m_airplayImage->SetFilename(m_imageFilename); // Absolute path, http or SG url
+            m_airplayImage->Load(); // By default the image is loaded in a background thread, use LoadNow() to load in foreground
+        }
+        else
+        {
+            // Will default to displaying whatever placeholder image is defined
+            // in the xml by the themer, means we can show _something_ rather than
+            // a big empty hole. Generally you always want to call Reset() in
+            // these circumstances
+            m_airplayImage->Reset();
+        }
+    }
+
+    if (m_airplayText)
+    {
+        if (!m_imageDescription.isEmpty())
+        {
+            m_airplayText->SetText(m_imageDescription);
+        }
+        else
+        {
+            // Same as above, calling Reset() allows for a sane, themer defined
+            //default to be displayed
+            m_airplayText->Reset();
+        }
+    }
+}
+
+// If want to update the displayed image or text without closing this screen
+// and creating a new one then it might look something like this
+void AirPlayPictureScreen::UpdatePicture(const QString &imageFilename,
+                                         const QString &imageDescription)
+{
+    m_imageFilename = imageFilename;
+    m_imageDescription = imageDescription;
+
+    Init();
+}
+
+////////////////////////////////////////
+
+// Your AirPlay picture event handler, after writing image to disc
+void SomeClass::AirPlayPictureEventHandler(blah ...)
+{
+    QString filename = "/path/to/image";
+    QString description = "Description of image, from metadata?";
+
+    // .... //
+
+    MythScreenStack *screenStack = GetMythMainWindow()->GetStack("popup stack");
+    AirPlayPictureScreen *picScreen = new AirPlayPictureScreen();
+
+    if (picScreen->Create()) // Reads screen definition from xml, and constructs screen
+    {
+        picScreen->UpdatePicture(filename, description);
+        screenStack->AddScreen(picScreen);
+    }
+    else
+    {
+        // If we can't create the screen then we can't display it, so delete
+        // and abort
+        delete picScreen;
+        return;
+    }
+}
+
+////////////////////////////////////////
+// airplay-ui.xml
+// See http://www.mythtv.org/wiki/MythUI_Theme_Development for more, this is a
+// bare minimum example, the wiki explains everything in detail
+
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE mythuitheme SYSTEM "http://www.mythtv.org/schema/mythuitheme.dtd">
+<mythuitheme>
+
+    <window name="airplaypicture">
+        <!-- No <area> tags for window implies fullscreen -->
+
+        <!-- Required -->
+        <imagetype name="picture">
+            <area>0,0,100%,100%</area> <!-- Same size as screen, i.e. fullscreen -->
+        </imagetype>
+
+        <!-- Optional -->
+        <textarea name="description">
+            <area>50,50,300,200</area> <!-- x,y,w,h - Origin at top left -->
+            <font>basesmall</font> <!-- See base.xml for the theme -->
+            <align>hcenter,vcenter</align> <!-- Centre text in available space -->
+            <multiline>yes</multiline> <!-- Allow wrapping -->
+        </textarea>
+
+    </window>
+
+</mythuitheme>
+
+
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryconfig.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryconfig.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryconfig.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryconfig.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,274 @@
+
+#include "galleryconfig.h"
+
+// Qt headers
+
+// MythTV headers
+#include "mythcontext.h"
+#include "mythmainwindow.h"
+#include "mythuitextedit.h"
+#include "mythuicheckbox.h"
+#include "mythuibutton.h"
+#include "mythuibuttonlist.h"
+#include "mythuispinbox.h"
+#include "mythdialogbox.h"
+#include "mythscreentype.h"
+
+#include "gallerydatabasehelper.h"
+#include "gallerytypedefs.h"
+
+
+
+/** \fn     GalleryConfig::GalleryConfig(MythScreenStack *, const char *)
+ *  \brief  Constructor
+ *  \param  parent The screen parent
+ *  \param  name The name of the screen
+ *  \return void
+ */
+GalleryConfig::GalleryConfig(MythScreenStack *parent, const char *name)
+    : MythScreenType(parent, name),
+      m_sortOrder(NULL),
+      m_slideShowTime(NULL),
+      m_transitionType(NULL),
+      m_transitionTime(NULL),
+      m_showHiddenFiles(NULL),
+      m_saveButton(NULL),
+      m_cancelButton(NULL),
+      m_clearDbButton(NULL)
+{
+    // preset or load all variables
+    m_sortOrder = 0;
+}
+
+
+
+/** \fn     GalleryConfig::~GalleryConfig()
+ *  \brief  Destructor
+ *  \return void
+ */
+GalleryConfig::~GalleryConfig()
+{
+
+}
+
+
+
+/** \fn     GalleryConfig::Create()
+ *  \brief  Initialises and shows the graphical elements
+ *  \return void
+ */
+bool GalleryConfig::Create()
+{
+    // Load the theme for this screen
+    if (!LoadWindowFromXML("image-ui.xml", "galleryconfig", this))
+        return false;
+
+    bool err = false;
+    UIUtilE::Assign(this, m_sortOrder, "sortorder", &err);
+    UIUtilE::Assign(this, m_slideShowTime, "slideshowtime", &err);
+    UIUtilE::Assign(this, m_transitionType, "transitiontype", &err);
+    UIUtilE::Assign(this, m_transitionTime, "transitiontime", &err);
+    UIUtilE::Assign(this, m_showHiddenFiles, "showhiddenfiles", &err);
+
+    UIUtilE::Assign(this, m_saveButton, "save", &err);
+    UIUtilE::Assign(this, m_cancelButton, "cancel", &err);
+    UIUtilW::Assign(this, m_clearDbButton, "cleardatabase", &err);
+
+    // check if all widgets are present
+    if (err)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Theme is missing critical theme elements.");
+        return false;
+    }
+
+    // Load the values from the database
+    Load();
+
+    // connect the widgets to their methods
+    connect(m_saveButton, SIGNAL(Clicked()), this, SLOT(Save()));
+    connect(m_cancelButton, SIGNAL(Clicked()), this, SLOT(Exit()));
+
+    if (m_clearDbButton)
+        connect(m_clearDbButton, SIGNAL(Clicked()), this, SLOT(ConfirmClearDatabase()));
+
+    BuildFocusList();
+
+    SetFocusWidget(m_sortOrder);
+
+    return true;
+}
+
+
+
+/** \fn     GalleryConfig::keyPressEvent(QKeyEvent *)
+ *  \brief  Translates the keypresses and keys bound to the
+ *          plugin to specific actions within the plugin
+ *  \param  event The pressed key
+ *  \return bool True if the key was used, otherwise false
+ */
+bool GalleryConfig::keyPressEvent(QKeyEvent *event)
+{
+    if (GetFocusWidget()->keyPressEvent(event))
+        return true;
+
+    bool handled = false;
+
+    if (!handled && MythScreenType::keyPressEvent(event))
+        handled = true;
+
+    return handled;
+}
+
+
+
+/** \fn     GalleryView::customEvent(QEvent *)
+ *  \brief  Translates the keypresses to specific actions within the plugin
+ *  \param  event The custom event
+ *  \return void
+ */
+void GalleryConfig::customEvent(QEvent *event)
+{
+    if (event->type() == DialogCompletionEvent::kEventType)
+    {
+        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
+
+        QString resultid  = dce->GetId();
+        int     buttonnum = dce->GetResult();
+
+        // Confirm current file deletion
+        if (resultid == "confirmdelete")
+        {
+            switch (buttonnum)
+            {
+            case 0 :
+                break;
+            case 1 :
+                ClearDatabase();
+                break;
+            }
+        }
+    }
+}
+
+
+
+/** \fn     GalleryConfig::Load()
+ *  \brief  Load the values from the database and adds them to the widgets
+ *  \return void
+ */
+void GalleryConfig::Load()
+{
+    new MythUIButtonListItem(m_sortOrder, tr("Name (A-Z alpha)"),
+                             qVariantFromValue(QString::number(kSortByNameAsc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Reverse Name (Z-A alpha)"),
+                             qVariantFromValue(QString::number(kSortByNameDesc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Mod Time (oldest first)"),
+                             qVariantFromValue(QString::number(kSortByModTimeAsc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Reverse Mod Time (newest first)"),
+                             qVariantFromValue(QString::number(kSortByModTimeDesc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Extension (A-Z alpha)"),
+                             qVariantFromValue(QString::number(kSortByExtAsc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Reverse Extension (Z-A alpha)"),
+                             qVariantFromValue(QString::number(kSortByExtDesc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Filesize (smallest first)"),
+                             qVariantFromValue(QString::number(kSortBySizeAsc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Reverse Filesize (largest first)"),
+                             qVariantFromValue(QString::number(kSortBySizeDesc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Date (oldest first)"),
+                             qVariantFromValue(QString::number(kSortByDateAsc)));
+    new MythUIButtonListItem(m_sortOrder, tr("Reverse Date (neweset first)"),
+                             qVariantFromValue(QString::number(kSortByDateDesc)));
+    m_sortOrder->SetValueByData(gCoreContext->GetNumSetting("GallerySortOrder", kSortByDateAsc));
+
+    m_slideShowTime->SetRange(0, 30000, 500);
+    m_slideShowTime->SetValue(gCoreContext->GetSetting("GallerySlideShowTime", "3000"));
+
+    new MythUIButtonListItem(m_transitionType, tr("None"), qVariantFromValue(0));
+    new MythUIButtonListItem(m_transitionType, tr("Fade"), qVariantFromValue(1));
+    m_transitionType->SetValueByData(gCoreContext->GetNumSetting("GalleryTransitionType", kFade));
+
+    m_transitionTime->SetRange(0, 5000, 100);
+    m_transitionTime->SetValue(gCoreContext->GetSetting("GalleryTransitionTime", "1000"));
+
+    int setting = gCoreContext->GetNumSetting("GalleryShowHiddenFiles", 0);
+    if (setting == 1)
+        m_showHiddenFiles->SetCheckState(MythUIStateType::Full);
+}
+
+
+
+/** \fn     GalleryConfig::Save()
+ *  \brief  Saves the values from the widgets into the database
+ *  \return void
+ */
+void GalleryConfig::Save()
+{
+    gCoreContext->SaveSetting("GallerySortOrder",
+                              m_sortOrder->GetDataValue().toString());
+    gCoreContext->SaveSetting("GallerySlideShowTime",
+                              m_slideShowTime->GetValue());
+    gCoreContext->SaveSetting("GalleryTransitionType",
+                              m_transitionType->GetDataValue().toString());
+    gCoreContext->SaveSetting("GalleryTransitionTime",
+                              m_transitionTime->GetValue());
+
+    int checkstate = (m_showHiddenFiles->GetCheckState() == MythUIStateType::Full) ? 1 : 0;
+    gCoreContext->SaveSetting("GalleryShowHiddenFiles", checkstate);
+
+    // tell the main view to reload the images
+    // because the storage group dir might have changed
+    emit configSaved();
+
+    Close();
+}
+
+
+
+/** \fn     GalleryConfig::Exit()
+ *  \brief  Exits the configuration screen
+ *  \return void
+ */
+void GalleryConfig::Exit()
+{
+    Close();
+}
+
+
+
+/** \fn     GalleryConfig::ConfirmClearDatabase()
+ *  \brief  Asks the user to confirm the removal of
+ *          all image related contents from the database
+ *  \return void
+ */
+void GalleryConfig::ConfirmClearDatabase()
+{
+    QString msg = QString("Do you want to clear all database contents?");
+    MythScreenStack         *m_popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythConfirmationDialog  *m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
+
+    if (m_confirmPopup->Create())
+    {
+        m_confirmPopup->SetReturnEvent(this, "confirmdelete");
+        m_popupStack->AddScreen(m_confirmPopup);
+    }
+    else
+        delete m_confirmPopup;
+}
+
+
+
+/** \fn     GalleryConfig::ClearDatabase()
+ *  \brief  Clears all image related contents from the database
+ *  \return void
+ */
+void GalleryConfig::ClearDatabase()
+{
+    GalleryDatabaseHelper *m_dbHelper = new GalleryDatabaseHelper();
+    m_dbHelper->ClearDatabase();
+    delete m_dbHelper;
+
+    // tell the main view to reload the images
+    // because the storage group dir might have changed
+    emit configSaved();
+    Close();
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryconfig.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryconfig.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryconfig.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,44 @@
+#ifndef GALLERYCONFIG_H
+#define GALLERYCONFIG_H
+
+// Qt headers
+
+// MythTV headers
+#include "mythscreentype.h"
+
+
+
+class GalleryConfig : public MythScreenType
+{
+    Q_OBJECT
+public:
+    GalleryConfig(MythScreenStack *parent, const char *name);
+    ~GalleryConfig();
+
+    bool Create();
+    bool keyPressEvent(QKeyEvent *);
+    void customEvent(QEvent*);
+
+signals:
+    void configSaved();
+
+private:
+    MythUIButtonList   *m_sortOrder;
+    MythUISpinBox      *m_slideShowTime;
+    MythUIButtonList   *m_transitionType;
+    MythUISpinBox      *m_transitionTime;
+    MythUICheckBox     *m_showHiddenFiles;
+
+    MythUIButton       *m_saveButton;
+    MythUIButton       *m_cancelButton;
+    MythUIButton       *m_clearDbButton;
+
+private slots:
+    void Save();
+    void Exit();
+    void Load();
+    void ConfirmClearDatabase();
+    void ClearDatabase();
+};
+
+#endif // GALLERYCONFIG_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,618 @@
+// Qt headers
+
+// MythTV headers
+#include "mythcontext.h"
+#include "mythdirs.h"
+
+#include "gallerydatabasehelper.h"
+
+
+
+GalleryDatabaseHelper::GalleryDatabaseHelper()
+{
+
+}
+
+
+
+GalleryDatabaseHelper::~GalleryDatabaseHelper()
+{
+
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadParentDirectory(QList<ImageMetadata *>* , int)
+ *  \brief  Loads the information from the database for a given directory
+ *  \param  dbList The list where the results are stored
+ *  \param  parentId The id of the given directory
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadParentDirectory(QList<ImageMetadata *>* dbList, int parentId)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT "
+                  "dir_id, filename, name, path, parent_id, "
+                  "dir_count, file_count, "
+                  "hidden "
+                  "FROM gallery_directories "
+                  "WHERE dir_id = :PARENTID;");
+    query.bindValue(":PARENTID", parentId);
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    while (query.next())
+    {
+        ImageMetadata *im = new ImageMetadata();
+        LoadDirectoryValues(query, im);
+
+        // Overwrite the folder type
+        im->m_type = kUpDirectory;
+        dbList->append(im);
+    }
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadDirectories(QMap<QString, ImageMetadata *>*)
+ *  \brief  Loads all directory information from the database
+ *  \param  dbList The list where the results are stored
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadDirectories(QMap<QString, ImageMetadata *>* dbList)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT "
+                   "dir_id, filename, name, path, parent_id, "
+                   "dir_count, file_count, hidden "
+                   "FROM gallery_directories");
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    while (query.next())
+    {
+        ImageMetadata *im = new ImageMetadata();
+        LoadDirectoryValues(query, im);
+        dbList->insert(im->m_fileName, im);
+    }
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadDirectories(QList<ImageMetadata *>* , int)
+ *  \brief  Loads all subdirectory information from the database for a given directory
+ *  \param  dbList The list where the results are stored
+ *  \param  parentId The id of the given directory
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadDirectories(QList<ImageMetadata *>* dbList, int parentId)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT "
+                        "dir_id, filename, name, path, parent_id, "
+                        "dir_count, file_count, "
+                        "hidden "
+                        "FROM gallery_directories "
+                        "WHERE (parent_id = :PARENTID) "
+                        "AND (hidden = '0' OR hidden = :HIDDEN) "
+                        "ORDER BY name ASC;");
+    query.bindValue(":PARENTID", parentId);
+    query.bindValue(":HIDDEN", gCoreContext->GetNumSetting("GalleryShowHiddenFiles"));
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    while (query.next())
+    {
+        ImageMetadata *im = new ImageMetadata();
+        LoadDirectoryValues(query, im);
+        dbList->append(im);
+    }
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadFiles(QMap<QString, ImageMetadata *>*)
+ *  \brief  Loads all file information from the database
+ *  \param  dbList The list where the results are stored
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadFiles(QMap<QString, ImageMetadata *>* dbList)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT "
+                    "file_id, CONCAT_WS('/', path, filename), name, path, dir_id, "
+                    "type, modtime, size, extension, "
+                    "angle, date, zoom, hidden, orientation "
+                    "FROM gallery_files");
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    while (query.next())
+    {
+        ImageMetadata *im = new ImageMetadata();
+        LoadFileValues(query, im);
+        dbList->insert(im->m_fileName, im);
+    }
+}
+
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadFiles(QList<ImageMetadata *>* , int)
+ *  \brief  Loads all file information from the database for a given directory
+ *  \param  dbList The list where the results are stored
+ *  \param  parentId The id of the given directory
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadFiles(QList<ImageMetadata *>* dbList, int parentId)
+{
+    dbList->clear();
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT "
+                    "file_id, CONCAT_WS('/', path, filename), name, path, dir_id, "
+                    "type, modtime, size, extension, "
+                    "angle, date, zoom, hidden, orientation "
+                    "FROM gallery_files "
+                    "WHERE (dir_id = :PARENTID) "
+                    "AND (hidden = '0' OR hidden = :HIDDEN) "
+                    "ORDER BY :ORDERBY");
+    query.bindValue(":PARENTID", parentId);
+    query.bindValue(":HIDDEN", gCoreContext->GetNumSetting("GalleryShowHiddenFiles"));
+    query.bindValue(":ORDERBY", GetSortOrder());
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    while (query.next())
+    {
+        ImageMetadata *im = new ImageMetadata();
+        LoadFileValues(query, im);
+        dbList->append(im);
+    }
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::InsertDirectory(ImageMetadata *)
+ *  \brief  Saves information about a given directory in the database
+ *  \param  im Information of the directory
+ *  \return void
+ */
+int GalleryDatabaseHelper::InsertDirectory(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("INSERT INTO gallery_directories ("
+                        "filename, name, path, parent_id, "
+                        "dir_count, file_count, "
+                        "hidden "
+                        ") VALUES ("
+                        ":FILENAME, :NAME, :PATH, :PARENT_ID, "
+                        ":DIRCOUNT, :FILECOUNT, "
+                        ":HIDDEN)");
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":PARENT_ID",   im->m_parentId);
+    query.bindValue(":DIRCOUNT" ,   im->m_dirCount);
+    query.bindValue(":FILECOUNT",   im->m_fileCount);
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+
+    if (!query.exec())
+        MythDB::DBError("Error inserting, query: ", query);
+
+    return query.lastInsertId().toInt();
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::InsertFile(ImageMetadata *)
+ *  \brief  Saves information about a given file in the database
+ *  \param  im Information of the file
+ *  \return void
+ */
+int GalleryDatabaseHelper::InsertFile(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("INSERT INTO gallery_files ("
+                    "filename, name, path, dir_id, "
+                    "type, modtime, size, extension, "
+                    "angle, date, zoom, "
+                    "hidden, orientation "
+                    ") VALUES ("
+                    ":FILENAME, :NAME, :PATH, :DIR_ID, "
+                    ":TYPE, :MODTIME, :SIZE, :EXTENSION, "
+                    ":ANGLE, :DATE, :ZOOM, "
+                    ":HIDDEN, :ORIENT)");
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":DIR_ID",      im->m_parentId);
+    query.bindValue(":TYPE",        im->m_type);
+    query.bindValue(":MODTIME",     im->m_modTime);
+    query.bindValue(":SIZE",        im->m_size);
+    query.bindValue(":EXTENSION",   im->m_extension);
+    query.bindValue(":ANGLE",       im->GetAngle());
+    query.bindValue(":DATE",        im->m_date);
+    query.bindValue(":ZOOM",        im->GetZoom());
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+    query.bindValue(":ORIENT",      im->GetOrientation());
+
+    if (!query.exec())
+        MythDB::DBError("Error inserting, query: ", query);
+
+    return query.lastInsertId().toInt();
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::UpdateDirectory(ImageMetadata *)
+ *  \brief  Updates the information about a given directory in the database
+ *  \param  im Information of the directory
+ *  \return void
+ */
+void GalleryDatabaseHelper::UpdateDirectory(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("UPDATE gallery_directories SET "
+                    "filename =     :FILENAME, "
+                    "name =         :NAME, "
+                    "path =         :PATH, "
+                    "parent_id =    :PARENT_ID, "
+                    "dir_count =    :DIR_COUNT, "
+                    "file_count =   :FILE_COUNT, "
+                    "hidden =       :HIDDEN "
+                    "WHERE dir_id = :ID;");
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":PARENT_ID",   im->m_parentId);
+    query.bindValue(":DIR_COUNT",   im->m_dirCount);
+    query.bindValue(":FILE_COUNT",  im->m_fileCount);
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+    query.bindValue(":ID",          im->m_id);
+
+    if (!query.exec())
+        MythDB::DBError("Error updating, query: ", query);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::UpdateFile(ImageMetadata *)
+ *  \brief  Updates the information about a given file in the database
+ *  \param  im Information of the file
+ *  \return void
+ */
+void GalleryDatabaseHelper::UpdateFile(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("UPDATE gallery_files SET "
+                    "filename       = :FILENAME, "
+                    "name           = :NAME, "
+                    "path           = :PATH, "
+                    "dir_id         = :DIR_ID, "
+                    "type           = :TYPE, "
+                    "modtime        = :MODTIME, "
+                    "size           = :SIZE, "
+                    "extension      = :EXTENSION, "
+                    "angle          = :ANGLE, "
+                    "date           = :DATE, "
+                    "zoom           = :ZOOM, "
+                    "hidden         = :HIDDEN, "
+                    "orientation    = :ORIENT "
+                    "WHERE file_id  = :ID;");
+    query.bindValue(":FILENAME",    im->m_fileName);
+    query.bindValue(":NAME",        im->m_name);
+    query.bindValue(":PATH",        im->m_path);
+    query.bindValue(":DIR_ID",      im->m_parentId);
+    query.bindValue(":TYPE",        im->m_type);
+    query.bindValue(":MODTIME",     im->m_modTime);
+    query.bindValue(":SIZE",        im->m_size);
+    query.bindValue(":EXTENSION",   im->m_extension);
+    query.bindValue(":ANGLE",       im->GetAngle());
+    query.bindValue(":DATE",        im->m_date);
+    query.bindValue(":ZOOM",        im->GetZoom());
+    query.bindValue(":HIDDEN",      im->m_isHidden);
+    query.bindValue(":ORIENT",      im->GetOrientation());
+    query.bindValue(":ID",          im->m_id);
+
+    if (!query.exec())
+        MythDB::DBError("Error updating, query: ", query);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::RemoveDirectory(ImageMetadata *)
+ *  \brief  Deletes the information about a given directory in the database
+ *  \param  im Information of the directory
+ *  \return void
+ */
+void GalleryDatabaseHelper::RemoveDirectory(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("DELETE from gallery_directories WHERE dir_id = :ID;");
+    query.bindValue(":ID", im->m_id);
+
+    if (!query.exec())
+        MythDB::DBError("Error removing, query: ", query);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::RemoveFile(ImageMetadata *)
+ *  \brief  Deletes the information about a given file in the database
+ *  \param  im Information of the directory
+ *  \return void
+ */
+void GalleryDatabaseHelper::RemoveFile(ImageMetadata *im)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("DELETE from gallery_files WHERE file_id = :ID;");
+    query.bindValue(":ID", im->m_id);
+
+    if (!query.exec())
+        MythDB::DBError("Error removing, query: ", query);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::InsertData(ImageMetadata *)
+ *  \brief  Inserts either a new directory or file in the database
+ *  \param  im Information of the given item
+ *  \return void
+ */
+void GalleryDatabaseHelper::InsertData(ImageMetadata *im)
+{
+    if (!im)
+        return;
+
+    if (im->m_type == kSubDirectory || im->m_type == kUpDirectory)
+        InsertDirectory(im);
+
+    if (im->m_type == kImageFile || im->m_type == kVideoFile)
+        InsertFile(im);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::UpdateData(ImageMetadata *)
+ *  \brief  Updates either a directory or a file in the database
+ *  \param  im Information of the given item
+ *  \return void
+ */
+void GalleryDatabaseHelper::UpdateData(ImageMetadata *im)
+{
+    if (!im)
+        return;
+
+    if (im->m_type == kSubDirectory || im->m_type == kUpDirectory)
+        UpdateDirectory(im);
+
+    if (im->m_type == kImageFile || im->m_type == kVideoFile)
+        UpdateFile(im);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::RemoveData(ImageMetadata *)
+ *  \brief  Deletes either a directory or file from the database
+ *  \param  im Information of the given item
+ *  \return void
+ */
+void GalleryDatabaseHelper::RemoveData(ImageMetadata *im)
+{
+    if (!im)
+        return;
+
+    if (im->m_type == kSubDirectory || im->m_type == kUpDirectory)
+        RemoveDirectory(im);
+
+    if (im->m_type == kImageFile || im->m_type == kVideoFile)
+        RemoveFile(im);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadDirectoryValues(MSqlQuery &, ImageMetadata *)
+ *  \brief  Loads the directory information from the database
+ *  \param  query Information from the database
+ *  \param  im Holds the loaded information
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadDirectoryValues(MSqlQuery &query, ImageMetadata *im)
+{
+    im->m_id            = query.value(0).toInt();
+    im->m_fileName      = query.value(1).toString();
+    im->m_name          = query.value(2).toString();
+    im->m_path          = query.value(3).toString();
+    im->m_parentId      = query.value(4).toInt();
+    im->m_dirCount      = query.value(5).toInt();
+    im->m_fileCount     = query.value(6).toInt();
+    im->m_isHidden      = query.value(7).toInt();
+
+    // preset all directories as subfolders
+    im->m_type          = kSubDirectory;
+
+    LoadDirectoryThumbnailValues(im);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadFileValues(MSqlQuery &, ImageMetadata *)
+ *  \brief  Loads the file information from the database
+ *  \param  query Information from the database
+ *  \param  im Holds the loaded information
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadFileValues(MSqlQuery &query, ImageMetadata *im)
+{
+    im->m_id            = query.value(0).toInt();
+    im->m_fileName      = query.value(1).toString();
+    im->m_name          = query.value(2).toString();
+    im->m_path          = query.value(3).toString();
+    im->m_parentId      = query.value(4).toInt();
+    im->m_type          = query.value(5).toInt();
+    im->m_modTime       = query.value(6).toInt();
+    im->m_size          = query.value(7).toInt();
+    im->m_extension     = query.value(8).toString();
+    im->SetAngle(         query.value(9).toInt());
+    im->m_date          = query.value(10).toInt();
+    im->SetZoom(          query.value(11).toInt());
+    im->m_isHidden      = query.value(12).toInt();
+    im->SetOrientation(   query.value(13).toInt(), true);
+
+    LoadFileThumbnailValues(im);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadDirectoryThumbnailValues(ImageMetadata *)
+ *  \brief  Gets four images from the directory from the
+ *          database which will be used as a folder thumbnail
+ *  \param  im Holds the loaded information
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadDirectoryThumbnailValues(ImageMetadata *im)
+{
+    // Try to get four new thumbnail filenames
+    // from the available images in this folder
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT CONCAT_WS('/', path, filename) FROM gallery_files "
+                          "WHERE path = :PATH "
+                          "AND type = '4' "
+                          "AND hidden = '0' LIMIT :LIMIT");
+    query.bindValue(":PATH", im->m_path);
+    query.bindValue(":LIMIT", kMaxFolderThumbnails);
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    int i = 0;
+    while (query.next())
+    {
+        QString thumbFileName = QString("%1%2")
+                .arg("/MythImage/")
+                .arg(query.value(0).toString());
+
+        thumbFileName = gCoreContext->GenMythURL(gCoreContext->GetSetting("MasterServerIP"),
+                                                 gCoreContext->GetNumSetting("MasterServerPort"),
+                                                 thumbFileName, "Temp");
+
+        if (i >= im->m_thumbFileNameList->size())
+            break;
+
+        im->m_thumbFileNameList->replace(i, thumbFileName);
+        ++i;
+    }
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::LoadFileThumbnailValues(ImageMetadata *)
+ *  \brief  Sets the thumbnail information for a file
+ *  \param  im Holds the loaded information
+ *  \return void
+ */
+void GalleryDatabaseHelper::LoadFileThumbnailValues(ImageMetadata *im)
+{
+
+
+    // Create the relative path and filename to the thumbnail image
+    QString thumbFileName = QString("%1%2")
+            .arg("/MythImage/")
+            .arg(im->m_fileName);
+
+    // If the file is a video then append a png, otherwise the preview
+    // image would not be readable due to the video file extension
+    if (im->m_type == kVideoFile)
+        thumbFileName.append(".png");
+
+    thumbFileName = gCoreContext->GenMythURL(gCoreContext->GetSetting("MasterServerIP"),
+                                             gCoreContext->GetNumSetting("MasterServerPort"),
+                                             thumbFileName, "Temp");
+
+    im->m_thumbFileNameList->replace(0, thumbFileName);
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::GetSortOrder()
+ *  \brief  Prepares the SQL query according to the sorting
+ *          rules specified by the user in the settings.
+ *  \return void
+ */
+QString GalleryDatabaseHelper::GetSortOrder()
+{
+    // prepare the sorting statement
+    QString sort;
+    switch (gCoreContext->GetNumSetting("GallerySortOrder"))
+    {
+    case kSortByNameAsc:
+        sort.append("name ASC ");
+        break;
+    case kSortByNameDesc:
+        sort.append("name DESC ");
+        break;
+    case kSortByModTimeAsc:
+        sort.append("modtime ASC, name ASC ");
+        break;
+    case kSortByModTimeDesc:
+        sort.append("modtime DESC, name ASC ");
+        break;
+    case kSortByExtAsc:
+        sort.append("extension ASC, name ASC ");
+        break;
+    case kSortByExtDesc:
+        sort.append("extension DESC, name ASC ");
+        break;
+    case kSortBySizeAsc:
+        sort.append("size ASC, name ASC ");
+        break;
+    case kSortBySizeDesc:
+        sort.append("size DESC, name ASC ");
+        break;
+    case kSortByDateAsc:
+        sort.append("date ASC, name ASC ");
+        break;
+    case kSortByDateDesc:
+        sort.append("date DESC, name ASC ");
+        break;
+    default:
+        sort.append("name ASC ");
+        break;
+    }
+
+    return sort;
+}
+
+
+
+/** \fn     GalleryDatabaseHelper::ClearDatabase()
+ *  \brief  Removes all contents from the gallery_directories and gallery_files tables.
+ *  \return void
+ */
+void GalleryDatabaseHelper::ClearDatabase()
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("TRUNCATE gallery_directories;"));
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+
+    query.prepare(QString("TRUNCATE gallery_files;"));
+
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,48 @@
+#ifndef GALLERYDATABASEHELPER_H
+#define GALLERYDATABASEHELPER_H
+
+// Qt headers
+
+// MythTV headers
+#include "mythdbcon.h"
+#include "imagemetadata.h"
+
+#include "gallerytypedefs.h"
+
+
+// TODO: Merge this into libmythmetadata/imageutils.h and remove
+class GalleryDatabaseHelper
+{
+public:
+    GalleryDatabaseHelper();
+    ~GalleryDatabaseHelper();
+
+    void LoadParentDirectory(QList<ImageMetadata *>*, int);
+    void LoadDirectories(QMap<QString, ImageMetadata *>*);
+    void LoadDirectories(QList<ImageMetadata *>*, int);
+    void LoadFiles(QMap<QString, ImageMetadata *>*);
+    void LoadFiles(QList<ImageMetadata *>*, int);
+    void RemoveDirectory(ImageMetadata *);
+    void RemoveFile(ImageMetadata *);
+    int InsertDirectory(ImageMetadata *);
+    int InsertFile(ImageMetadata *);
+    void UpdateDirectory(ImageMetadata *);
+    void UpdateFile(ImageMetadata *);
+
+    void InsertData(ImageMetadata *);
+    void UpdateData(ImageMetadata *);
+    void RemoveData(ImageMetadata *);
+
+    void ClearDatabase();
+
+private:
+    void LoadDirectoryValues(MSqlQuery &, ImageMetadata *);
+    void LoadFileValues(MSqlQuery &, ImageMetadata *);
+
+    void LoadDirectoryThumbnailValues(ImageMetadata *);
+    void LoadFileThumbnailValues(ImageMetadata *);
+
+    QString GetSortOrder();
+};
+
+#endif // GALLERYDATABASEHELPER_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryfilehelper.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryfilehelper.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryfilehelper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryfilehelper.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,391 @@
+
+#include "galleryfilehelper.h"
+
+// Qt headers
+#include <QNetworkAccessManager>
+#include <QXmlStreamReader>
+#include <QNetworkReply>
+#include <QEventLoop>
+
+// MythTV headers
+#include "mythcontext.h"
+#include "storagegroup.h"
+#include "remoteutil.h"
+
+#include "gallerytypedefs.h"
+
+
+
+/** \fn     GalleryFileHelper::GalleryFileHelper()
+ *  \brief  Constructor
+ *  \return void
+ */
+GalleryFileHelper::GalleryFileHelper()
+{
+    m_backendHost   = gCoreContext->GetSetting("MasterServerIP","localhost");
+    m_backendPort   = gCoreContext->GetNumSetting("BackendStatusPort", 6544);
+
+    m_manager = new QNetworkAccessManager();
+}
+
+
+
+/** \fn     GalleryFileHelper::~GalleryFileHelper()
+ *  \brief  Destructor
+ *  \return void
+ */
+GalleryFileHelper::~GalleryFileHelper()
+{
+    delete m_manager;
+    m_manager = NULL;
+}
+
+
+
+/** \fn     GalleryFileHelper::StartSyncImages()
+ *  \brief  Starts the image syncronization from the backend
+ *  \return void
+ */
+void GalleryFileHelper::StartSyncImages()
+{
+    QUrl url(QString("http://%1:%2/Image/StartSync")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+
+
+/** \fn     GalleryFileHelper::StopSyncImages()
+ *  \brief  Stops the image syncronization from the backend
+ *  \return void
+ */
+void GalleryFileHelper::StopSyncImages()
+{
+    QUrl url(QString("http://%1:%2/Image/StopSync")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+/** \fn     GalleryFileHelper::GetSyncStatus()
+ *  \brief  Reads the current image syncronization status
+ *  \return Struct with bool running, int current image, int total images
+ */
+GallerySyncStatus GalleryFileHelper::GetSyncStatus()
+{
+    QUrl url(QString("http://%1:%2/Image/GetSyncStatus")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    GallerySyncStatus status;
+    status.running = false;
+    status.current = 0;
+    status.total = 0;
+
+    QByteArray ba = SendRequest(url, QNetworkAccessManager::GetOperation);
+    if (ba.count() > 0)
+    {
+        bool ok;
+        QXmlStreamReader xml(ba);
+        while (!xml.atEnd())
+        {
+            xml.readNext();
+            if (xml.isStartElement())
+            {
+                if (xml.name() == "Running")
+                {
+                    QString value = xml.readElementText();
+                    if (value.compare("true") == 0)
+                        status.running = true;
+                }
+                else if (xml.name() == "Current")
+                    status.current = xml.readElementText().toInt(&ok);
+                else if (xml.name() == "Total")
+                    status.total = xml.readElementText().toInt(&ok);
+            }
+        }
+    }
+
+    return status;
+}
+
+
+
+/**
+ *  \brief  Starts the thumbnail generation thread on the backend
+ *  \return void
+ */
+void GalleryFileHelper::StartThumbGen()
+{
+    QUrl url(QString("http://%1:%2/Image/StartThumbnailGeneration")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+
+
+/**
+ *  \brief  Stops the thumbnail generation thread on the backend
+ *  \return void
+ */
+void GalleryFileHelper::StopThumbGen()
+{
+    QUrl url(QString("http://%1:%2/Image/StopThumbnailGeneration")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+
+void GalleryFileHelper::AddToThumbnailList(ImageMetadata* im)
+{
+    if (!im)
+        return;
+
+    int id = im->m_id;
+    QUrl url(QString("http://%1:%2/Image/CreateThumbnail?Id=%3")
+             .arg(m_backendHost)
+             .arg(m_backendPort)
+             .arg(id));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+
+void GalleryFileHelper::RecreateThumbnail(ImageMetadata* im)
+{
+    if (!im)
+        return;
+
+    int id = im->m_id;
+    QUrl url(QString("http://%1:%2/Image/RecreateThumbnail?Id=%3")
+             .arg(m_backendHost)
+             .arg(m_backendPort)
+             .arg(id));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+
+void GalleryFileHelper::SetThumbnailSize(int width, int height)
+{
+    QUrl url(QString("http://%1:%2/Image/SetThumbnailSize?Width=%3&Height=%4")
+             .arg(m_backendHost)
+             .arg(m_backendPort)
+             .arg(width)
+             .arg(height));
+
+    SendRequest(url, QNetworkAccessManager::PostOperation);
+}
+
+
+/** \fn     GalleryFileHelper::RenameFile(const int &, const QString &)
+ *  \brief  Renames the file via the service api
+ *  \param  im The image metadata object that contains all required information
+ *  \param  name The new name of the file (only the filename, no path)
+ *  \return True if removal was successful, otherwise false
+ */
+bool GalleryFileHelper::RenameFile(ImageMetadata *im, const QString &name)
+{
+    bool ok = false;
+
+    QUrl url(QString("http://%1:%2/Content/RenameFile")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    url.addQueryItem("FileName", im->m_fileName);
+    url.addQueryItem("NewName", name);
+
+    QByteArray ba = SendRequest(url, QNetworkAccessManager::PostOperation);
+
+    if (ba.count() > 0)
+    {
+        QXmlStreamReader xml(ba);
+        while (!xml.atEnd())
+        {
+            xml.readNext();
+            if (xml.isStartElement() && xml.name() == "bool")
+            {
+                ok = xml.readElementText().compare("true") == 0;
+
+                LOG(VB_GENERAL, LOG_DEBUG,
+                    QString("RenameFile - Status: %1").arg(ok));
+
+                // The returned data from the service api has only one
+                // value, so we stop when we have hit the first bool string
+                break;
+            }
+        }
+    }
+
+    return ok;
+}
+
+
+
+/** \fn     GalleryFileHelper::RemoveFile(ImageMetadata *)
+ *  \brief  Deletes the file via the service api
+ *  \param  im The image metadata object that contains all required information
+ *  \return True if removal was successful, otherwise false
+ */
+bool GalleryFileHelper::RemoveFile(ImageMetadata *im)
+{
+    bool ok = false;
+
+    QUrl url(QString("http://%1:%2/Content/DeleteFile")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    url.addQueryItem("FileName", im->m_fileName);
+
+    QByteArray ba = SendRequest(url, QNetworkAccessManager::PostOperation);
+
+    if (ba.count() > 0)
+    {
+        QXmlStreamReader xml(ba);
+        while (!xml.atEnd())
+        {
+            xml.readNext();
+            if (xml.isStartElement() && xml.name() == "bool")
+            {
+                ok = xml.readElementText().compare("true") == 0;
+
+                LOG(VB_GENERAL, LOG_DEBUG,
+                    QString("RemoveFile - Status: %1").arg(ok));
+
+                // The returned data from the service api has only one
+                // value, so we stop when we have hit the first bool string
+                break;
+            }
+        }
+    }
+
+    return ok;
+}
+
+
+
+/** \fn     GalleryFileHelper::SetImageOrientation(ImageMetadata *)
+ *  \brief  Saves the given value in the orientation exif tag
+ *  \param  im The image metadata object that contains all required information
+ *  \return True if saving the orientation was successful, otherwise false
+ */
+bool GalleryFileHelper::SetImageOrientation(ImageMetadata *im)
+{
+    // the orientation of the image.
+    // See http://jpegclub.org/exif_orientation.html for details
+    if (im->GetOrientation() < 1 || im->GetOrientation() > 8)
+        return false;
+
+    bool ok = false;
+
+    QUrl url(QString("http://%1:%2/Image/SetImageInfo")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    url.addQueryItem("Id", QString::number(im->m_id));
+    url.addQueryItem("Tag", "Exif.Image.Orientation");
+    url.addQueryItem("Value", QString::number(im->GetOrientation()));
+
+    QByteArray ba = SendRequest(url, QNetworkAccessManager::PostOperation);
+    if (ba.count() > 0)
+    {
+        QXmlStreamReader xml(ba);
+        while (!xml.atEnd())
+        {
+            xml.readNext();
+            if (xml.isStartElement() && xml.name() == "bool")
+            {
+                ok = xml.readElementText().compare("true") == 0;
+
+                LOG(VB_GENERAL, LOG_DEBUG,
+                    QString("SetExifOrientation - Status: %1").arg(ok));
+
+                // The returned data from the service api has only one
+                // value, so we stop when we have hit the first bool string
+                break;
+            }
+        }
+    }
+
+    return ok;
+}
+
+
+
+/** \fn     GalleryFileHelper::GetExifValues(ImageMetadata *)
+ *  \brief  Returns the XML data that contains all available exif header
+            tags and values from the image specified by the id.
+ *  \param  im The image metadata object that contains all required information
+ *  \return The returned XML data
+ */
+QByteArray GalleryFileHelper::GetExifValues(ImageMetadata *im)
+{
+    QUrl url(QString("http://%1:%2/Image/GetImageInfoList")
+             .arg(m_backendHost)
+             .arg(m_backendPort));
+
+    url.addQueryItem("Id", QString::number(im->m_id));
+
+    return SendRequest(url, QNetworkAccessManager::GetOperation);
+}
+
+
+
+/** \fn     GalleryFileHelper::SendRequest(QUrl &url, QNetworkAccessManager::Operation type)
+ *  \brief  Calls the url with the given data either via
+            a GET or POST and returns the retrieved data
+ *  \param  url The url with all parameters that shall be called
+ *  \param  type The type of the call, can be either GET or POST
+ *  \return The returned XML data
+ */
+QByteArray GalleryFileHelper::SendRequest(QUrl &url,
+                                          QNetworkAccessManager::Operation type)
+{
+    QByteArray ba;
+    QNetworkReply *reply = NULL;
+    QNetworkRequest request(url);
+
+    if (type == QNetworkAccessManager::GetOperation)
+    {
+        reply = m_manager->get(request);
+    }
+    else if (type == QNetworkAccessManager::PostOperation)
+    {
+        request.setHeader(QNetworkRequest::ContentTypeHeader,
+                          "application/x-www-form-urlencoded");
+        reply = m_manager->post(request, QByteArray());
+    }
+
+    // Create a local event loop that blocks further processing
+    // until the finished signal is emitted from the network manager
+    QEventLoop loop;
+    QObject::connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
+    loop.exec();
+
+    // The network manager is done, continue
+    if (reply)
+    {
+        if (reply->error() == QNetworkReply::NoError)
+        {
+            LOG(VB_GENERAL, LOG_DEBUG,
+                QString("GalleryFileHelper SendRequest ok"));
+            ba = reply->readAll();
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_DEBUG,
+                QString("GalleryFileHelper SendRequest error: %1")
+                .arg(reply->errorString()));
+        }
+        reply->deleteLater();
+    }
+
+    return ba;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryfilehelper.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryfilehelper.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryfilehelper.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryfilehelper.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,53 @@
+#ifndef GALLERYFILEHELPER_H
+#define GALLERYFILEHELPER_H
+
+// Qt headers
+#include <QNetworkAccessManager>
+#include <QNetworkProxy>
+#include <QDirIterator>
+#include <QMap>
+#include <QList>
+#include <QUrl>
+
+// MythImage headers
+#include "imagemetadata.h"
+
+
+
+struct GallerySyncStatus {
+    bool running;
+    int  current;
+    int  total;
+};
+
+
+
+class GalleryFileHelper
+{
+public:
+    GalleryFileHelper();
+    ~GalleryFileHelper();
+
+    void        StartSyncImages();
+    void        StopSyncImages();
+    void        StartThumbGen();
+    void        StopThumbGen();
+    void        AddToThumbnailList(ImageMetadata *);
+    void        RecreateThumbnail(ImageMetadata *);
+    void        SetThumbnailSize(int width, int height);
+    bool        RemoveFile(ImageMetadata *);
+    bool        RenameFile(ImageMetadata *, const QString &);
+    bool        SetImageOrientation(ImageMetadata *);
+
+    GallerySyncStatus   GetSyncStatus();
+    QByteArray          GetExifValues(ImageMetadata *);
+
+private:
+    QByteArray  SendRequest(QUrl &, QNetworkAccessManager::Operation);
+
+    int                         m_backendPort;
+    QString                     m_backendHost;
+    QNetworkAccessManager      *m_manager;
+};
+
+#endif // GALLERYFILEHELPER_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerytypedefs.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerytypedefs.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerytypedefs.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerytypedefs.h	2014-05-05 12:22:12.000000000 +0200
@@ -0,0 +1,37 @@
+#ifndef TYPEDEFS_H
+#define TYPEDEFS_H
+
+
+
+enum ImageLoadStatusType {
+    kStatusOk           = 0,
+    kStatusNoFiles      = 1,
+    kStatusNoBaseDir    = 2
+};
+
+
+enum ImageNodeState {
+    kNodeStateSelect    = 0,
+    kNodeStateDeselect  = 1,
+    kNodeStateInvert    = 2,
+    kNodeStateVisible   = 3,
+    kNodeStateInvisible = 4
+};
+
+
+enum ImageSlideShowType {
+    kNoSlideShow            = 0,
+    kNormalSlideShow        = 1,
+    kRandomSlideShow        = 2,
+    kNormalRecSlideShow     = 3,
+    kRandomRecSlideShow     = 4
+};
+
+
+enum ImageTransitionType {
+    kNoTransition = 0,
+    kFade = 1
+};
+
+
+#endif // TYPEDEFS_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryview.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryview.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryview.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryview.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,1450 @@
+
+#include "galleryview.h"
+
+// Qt headers
+
+// MythTV headers
+#include "mythcontext.h"
+
+#include "galleryconfig.h"
+#include "gallerytypedefs.h"
+#include "imagescan.h"
+
+
+
+/** \fn     GalleryView::GalleryView(MythScreenStack *, const char *)
+ *  \brief  Constructor
+ *  \param  parent The screen parent
+ *  \param  name The name of the screen
+ *  \return void
+ */
+GalleryView::GalleryView(MythScreenStack *parent, const char *name)
+    : MythScreenType(parent, name),
+      m_menuPopup(NULL),
+      m_confirmPopup(NULL),
+      m_inputPopup(NULL),
+      m_imageList(NULL),
+      m_captionText(NULL),
+      m_crumbsText(NULL),
+      m_positionText(NULL),
+      m_imageText(NULL),
+      m_selectedImage(NULL),
+      m_syncProgressText(NULL),
+      m_thumbProgressText(NULL)
+{
+    gCoreContext->addListener(this);
+
+    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
+    m_mainStack = GetMythMainWindow()->GetMainStack();
+
+    // interface between the frontend and the data
+    m_galleryViewHelper = new GalleryViewHelper(this);
+
+    // Fetches the syncronization status in the
+    // background and updates a theme widget
+    m_syncStatusThread = new GallerySyncStatusThread();
+
+    connect(m_syncStatusThread,  SIGNAL(UpdateSyncProgress(int, int)),
+            this,   SLOT(UpdateSyncProgress(int, int)));
+
+    connect(m_syncStatusThread,  SIGNAL(finished()),
+            this,   SLOT(ResetSyncProgress()));
+
+    // Start the sync status thread so that an already 
+    // running  background sync can be seen
+    m_syncStatusThread->start();
+}
+
+
+
+/** \fn     GalleryView::~GalleryView()
+ *  \brief  Destructor
+ *  \return void
+ */
+GalleryView::~GalleryView()
+{
+    gCoreContext->removeListener(this);
+
+    if (m_syncStatusThread)
+    {
+        m_syncStatusThread->quit();
+        m_syncStatusThread->wait();
+        delete m_syncStatusThread;
+        m_syncStatusThread = NULL;
+    }
+
+    if (m_galleryViewHelper)
+    {
+        delete m_galleryViewHelper;
+        m_galleryViewHelper = NULL;
+    }
+}
+
+
+
+/** \fn     GalleryView::Create()
+ *  \brief  Initialises and shows the graphical elements
+ *  \return True if successful, otherwise false
+ */
+bool GalleryView::Create()
+{
+    if (!LoadWindowFromXML("image-ui.xml", "gallery", this))
+        return false;
+
+    bool err = false;
+    UIUtilE::Assign(this, m_imageList,     "images", &err);
+    UIUtilW::Assign(this, m_captionText,   "title");
+    UIUtilW::Assign(this, m_imageText,     "noimages");
+    UIUtilW::Assign(this, m_selectedImage, "selectedimage");
+    UIUtilW::Assign(this, m_positionText,  "position");
+    UIUtilW::Assign(this, m_crumbsText,    "breadcrumbs");
+
+    UIUtilW::Assign(this, m_syncProgressText, "syncprogresstext");
+    UIUtilW::Assign(this, m_thumbProgressText, "thumbprogresstext");
+
+    if (err)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Cannot load screen 'gallery'");
+        return false;
+    }
+
+    // set the size of the preview images (usually the thumbnails)
+    m_galleryViewHelper->SetPreviewImageSize(m_imageList);
+
+    if (m_syncProgressText)
+        m_syncProgressText->SetVisible(false);
+
+    if (m_thumbProgressText)
+        m_thumbProgressText->SetVisible(false);
+
+    BuildFocusList();
+    SetFocusWidget(m_imageList);
+
+    // connect the widgets with their slot methods
+    connect(m_imageList, SIGNAL(itemClicked(MythUIButtonListItem *)),
+            SLOT(ItemSelected(MythUIButtonListItem *)));
+    connect(m_imageList, SIGNAL(itemSelected(MythUIButtonListItem *)),
+            SLOT(UpdateImageItem(MythUIButtonListItem *)));
+
+    return true;
+}
+
+
+
+/** \fn     GalleryView::keyPressEvent(QKeyEvent *)
+ *  \brief  Translates the keypresses and keys bound to the
+ *          plugin to specific actions within the plugin
+ *  \param  event The pressed key
+ *  \return True if key was used, otherwise false
+ */
+bool GalleryView::keyPressEvent(QKeyEvent *event)
+{
+    if (GetFocusWidget()->keyPressEvent(event))
+        return true;
+
+    bool handled = false;
+    QStringList actions;
+    handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
+
+    for (int i = 0; i < actions.size() && !handled; i++)
+    {
+        QString action = actions[i];
+        handled = true;
+
+        if (action == "MENU")
+            MenuMain();
+        else if (action == "INFO")
+            MenuInformation();
+        else if (action == "ROTRIGHT")
+            FileRotateCW();
+        else if (action == "ROTLEFT")
+            FileRotateCCW();
+        else if (action == "FLIPHORIZONTAL")
+            FileFlipHorizontal();
+        else if (action == "FLIPVERTICAL")
+            FileFlipVertical();
+        else if (action == "ZOOMIN")
+            FileZoomIn();
+        else if (action == "ZOOMOUT")
+            FileZoomOut();
+        else if (action == "SLIDESHOW")
+            ShowFiles();
+        else if (action == "RANDOMSHOW")
+            ShowRandomFiles();
+        else if (action == "MARK")
+        {
+            ImageMetadata *im = GetImageMetadataFromSelectedButton();
+            if (im)
+            {
+                if (im->m_selected)
+                    FileSelectOne();
+                else
+                    FileDeselectOne();
+            }
+        }
+        else if (action == "ESCAPE")
+        {
+            // If the jumppoint is not active and the first node is of
+            // the type kUpFolder then allow going up one directory
+            if (!GetMythMainWindow()->IsExitingToMain())
+            {
+                ImageMetadata *data = m_galleryViewHelper->GetImageMetadataFromNode(0);
+                if (data && data->m_type == kUpDirectory)
+                    handled = DirSelectUp();
+                else
+                    handled = false;
+            }
+            else
+                handled = false;
+        }
+        else
+            handled = false;
+    }
+
+    if (!handled && MythScreenType::keyPressEvent(event))
+        handled = true;
+
+    return handled;
+}
+
+
+
+/** \fn     GalleryView::customEvent(QEvent *)
+ *  \brief  Translates the keypresses to specific actions within the plugin
+ *  \param  event The custom event
+ *  \return void
+ */
+void GalleryView::customEvent(QEvent *event)
+{
+    if ((MythEvent::Type)(event->type()) == MythEvent::MythEventMessage)
+    {
+        MythEvent *me = (MythEvent *)event;
+        QString message = me->Message();
+
+        if (message.startsWith("IMAGE_THUMB_CREATED"))
+        {
+            QStringList tokens = message.simplified().split(" ");
+            int fileid = 0;
+            if (tokens.size() >= 2)
+            {
+                fileid = tokens[1].toUInt();
+
+                // FIXME: This sucks, must be a better way to do this
+                //
+                // get through the entire list of image items and find
+                // the fileid that matches the created thumbnail filename
+                for (int i = 0; i < m_imageList->GetCount(); i++)
+                {
+                    MythUIButtonListItem *item = m_imageList->GetItemAt(i);
+                    if (!item)
+                        continue;
+
+                    ImageMetadata *im = GetImageMetadataFromButton(item);
+                    if (!im)
+                        continue;
+
+                    if (im->m_id == fileid)
+                    {
+                        UpdateThumbnail(item, true);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+    else if (event->type() == DialogCompletionEvent::kEventType)
+    {
+        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
+
+        QString resultid  = dce->GetId();
+        int     buttonnum = dce->GetResult();
+
+        // Confirm current file deletion
+        if (resultid == "confirmdelete")
+        {
+            switch (buttonnum)
+            {
+            case 0 :
+                break;
+            case 1 :
+                FileDelete();
+                break;
+            }
+        }
+
+        // Confirm all selected file deletion
+        if (resultid == "confirmdeleteselected")
+        {
+            switch (buttonnum)
+            {
+            case 0 :
+                break;
+            case 1 :
+                FileDeleteSelected();
+                break;
+            }
+        }
+
+        // Synchronize the database
+        if (resultid == "confirmstartsync")
+        {
+            switch (buttonnum)
+            {
+            case 0 :
+                break;
+            case 1 :
+                // Start the sync, the API call will
+                // check if a sync is running already
+                m_galleryViewHelper->m_fileHelper->StartSyncImages();
+
+                if (!m_syncStatusThread->isRunning())
+                    m_syncStatusThread->start();
+
+                break;
+            }
+        }
+
+        // Stop the database sync
+        if (resultid == "confirmstopsync")
+        {
+            switch (buttonnum)
+            {
+            case 0 :
+                break;
+            case 1 :
+                if (m_syncStatusThread->isRunning())
+                    m_syncStatusThread->quit();
+
+                m_galleryViewHelper->m_fileHelper->StopSyncImages();
+                break;
+            }
+        }
+
+        if (resultid == "filerename")
+        {
+            QString newName = dce->GetResultText();
+            FileRename(newName);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryView::ResetImageItems()
+ *  \brief  Resets the image related widgets by clearing all
+            visible items and removing any shown text.
+ *  \return void
+ */
+void GalleryView::ResetImageItems()
+{
+    m_imageList->Reset();
+
+    if (m_positionText)
+        m_positionText->Reset();
+
+    if (m_captionText)
+        m_captionText->Reset();
+
+    if (m_crumbsText)
+        m_crumbsText->Reset();
+}
+
+
+
+/** \fn     GalleryView::LoadData()
+ *  \brief  Loads the available data from the database.
+            If there is no data available the user needs to rescan.
+ *  \return void
+ */
+void GalleryView::LoadData()
+{
+    ResetImageItems();
+
+    m_imageText->SetText("Loading available images...");
+    m_imageText->SetVisible(true);
+    m_imageList->SetVisible(false);
+
+    // loads the data from the database at the specified path
+    int status = m_galleryViewHelper->LoadData();
+
+    switch (status)
+    {
+    case kStatusNoBaseDir:
+        m_imageText->SetText("No image storage group has been defined.\n"
+                             "Please check the stoage group settings\n"
+                             "and the directory permissions.");
+        break;
+    case kStatusNoFiles:
+        m_imageText->SetText("No images in the database found.\n"
+                             "You need to scan for new images.");
+        break;
+    case kStatusOk:
+        m_imageText->SetText("");
+        m_imageText->SetVisible(false);
+        m_imageList->SetVisible(true);
+
+        // set the first node as the selected node
+        m_galleryViewHelper->m_currentNode->setSelectedChild(m_galleryViewHelper->m_currentNode->getChildAt(0));
+
+        // loads the data from the MythGenericTree into the image list
+        UpdateImageList();
+        break;
+    }
+}
+
+
+
+/** \fn     GalleryView::UpdateImageList()
+ *  \brief  Updates the visible items
+ *  \return void
+ */
+void GalleryView::UpdateImageList()
+{
+    m_imageList->Reset();
+
+    // get all children from the the selected node
+    MythGenericTree *selectedNode = m_galleryViewHelper->m_currentNode->getSelectedChild();
+    QList<MythGenericTree *> *childs = m_galleryViewHelper->m_currentNode->getAllChildren();
+
+    // go through the entire list and update
+    QList<MythGenericTree *>::const_iterator it;
+    for (it = childs->begin(); it != childs->end(); ++it)
+    {
+        if (*it != NULL)
+        {
+            MythUIButtonListItem *item = new MythUIButtonListItem(
+                    m_imageList, QString(), 0,
+                    true, MythUIButtonListItem::NotChecked);
+            item->SetData(qVariantFromValue(*it));
+
+            // assign and display all information about
+            // the current item, like title and subdirectory count
+            UpdateImageItem(item);
+
+            // set the currently active node as selected in the image list
+            if (*it == selectedNode)
+                m_imageList->SetItemCurrent(item);
+        }
+    }
+
+    // when the UpdateImageItem method is called the current node will also
+    // be set to the current image item. After updating all items in the
+    // image list we need to set the current node back to the on it was before
+    m_galleryViewHelper->m_currentNode->setSelectedChild(selectedNode);
+
+    // Updates all other widgets on the screen that show
+    // information about the selected MythUIButtonListItem
+    UpdateText(m_imageList->GetItemCurrent());
+}
+
+
+
+/** \fn     GalleryView::UpdateImageItem(MythUIButtonListItem *)
+ *  \brief  Updates the visible representation of a MythUIButtonListItem
+ *  \param  item The item that shall be updated
+ *  \return void
+ */
+void GalleryView::UpdateImageItem(MythUIButtonListItem *item)
+{
+    if (!item)
+        return;
+
+    MythGenericTree *node = item->GetData().value<MythGenericTree *>();
+    if (!node)
+        return;
+
+    // update the position in the node list
+    m_galleryViewHelper->m_currentNode->setSelectedChild(node);
+
+    ImageMetadata *im = qVariantValue<ImageMetadata *>(node->GetData());
+    if (!im)
+        return;
+
+    // Depending what the themer has done, display a small
+    // icon that shows if the current item is a file or a folder
+    // Also show an additional background image if required. This is
+    // primarily useful when the item is a folder and a folder background
+    // image shall be shown behind the small preview thumbnail images
+    switch (im->m_type)
+    {
+    case kSubDirectory:
+
+        item->SetText(QString::number(im->m_dirCount), "childcount");
+
+        if (im->m_fileCount > 0)
+            item->SetText(QString("%1/%2")
+                          .arg(im->m_dirCount)
+                          .arg(im->m_fileCount), "childcount");
+
+        item->DisplayState("subfolder", "nodetype");
+        break;
+
+    case kUpDirectory:
+        item->DisplayState("upfolder", "nodetype");
+        break;
+
+    case kImageFile:
+        item->DisplayState("image", "nodetype");
+        break;
+
+    case kVideoFile:
+        item->DisplayState("video", "nodetype");
+        break;
+
+    default:
+        break;
+    }
+
+    // set the image as hidden or visible
+    QString state = (im->m_isHidden) ? "hidden" : "visible";
+    item->DisplayState(state, "nodevisibility");
+
+    item->SetText(im->m_name, "title");
+    item->SetText(im->m_name);
+
+    // set the image as selected
+    item->setChecked(MythUIButtonListItem::NotChecked);
+    item->DisplayState("off", "nodecheck");
+    if (im->m_selected)
+    {
+        item->setChecked(MythUIButtonListItem::FullChecked);
+        item->DisplayState("full", "nodecheck");
+    }
+
+    // update the other widgets in the screen
+    if (item == m_imageList->GetItemCurrent())
+        UpdateText(item);
+
+    // set the thumbnail image
+    UpdateThumbnail(item);
+}
+
+
+
+/** \fn     GalleryView::UpdateThumbnail(MythUIButtonListItem *)
+ *  \brief  Updates the thumbnail image of the given item
+ *  \param  item The item that shall be updated
+ *  \return void
+ */
+void GalleryView::UpdateThumbnail(MythUIButtonListItem *item, bool forceReload)
+{
+    if (!item)
+        return;
+
+    ImageMetadata *im = GetImageMetadataFromButton(item);
+    if (!im)
+        return;
+
+    if (im->m_type == kUpDirectory || im->m_type == kSubDirectory)
+    {
+        for (int i = 0; i < im->m_thumbFileNameList->size(); ++i)
+        {
+            item->SetImage(im->m_thumbFileNameList->at(i),
+                           QString("thumbimage%1").arg(i+1), forceReload);
+        }
+    }
+    else
+    {
+        item->SetImage(im->m_thumbFileNameList->at(0), "", forceReload);
+    }
+}
+
+
+
+/** \fn     GalleryView::UpdateThumbnail(ImageMetadata *, int)
+ *  \brief  Updates the thumbnail image of an image or
+ *          folder which contains the given image metadata
+ *  \param  item The item that shall be updated
+ *  \param  id The thumbnail id that shall be used,
+ *          there are 4 ids when the item is a folder
+ *  \return void
+ */
+void GalleryView::UpdateThumbnail(ImageMetadata *thumbImageMetadata, int id)
+{
+    // get through the entire list of image items and find
+    // the filename that matches the created thumbnail filename
+    for (int i = 0; i < m_imageList->GetCount(); i++)
+    {
+        MythUIButtonListItem *item = m_imageList->GetItemAt(i);
+        if (!item)
+            continue;
+
+        ImageMetadata *im = GetImageMetadataFromButton(item);
+        if (!im)
+            continue;
+
+        // Set the thumbnail image if the thumbnail
+        // image names at the given index are the same
+        if (thumbImageMetadata->m_thumbFileNameList->at(id).compare(
+                    im->m_thumbFileNameList->at(id)) == 0)
+        {
+            // Set the images for the four thumbnail image widgets in case
+            // the node is a folder. Otherwise set the buttonimage widget.
+            if (im->m_type == kUpDirectory ||
+                im->m_type == kSubDirectory)
+            {
+                item->SetImage(thumbImageMetadata->m_thumbFileNameList->at(id),
+                               QString("thumbimage%1").arg(id+1), true);
+            }
+            else
+            {
+                item->SetImage(thumbImageMetadata->m_thumbFileNameList->at(0), "", true);
+            }
+            break;
+        }
+    }
+}
+
+
+
+/** \fn     GalleryView::ResetThumbnailProgress()
+ *  \brief  Resets the status of the progress text
+ *  \return void
+ */
+void GalleryView::ResetThumbnailProgress()
+{
+    if (m_thumbProgressText)
+        m_thumbProgressText->SetVisible(false);
+}
+
+
+
+/** \fn     GalleryView::ResetSyncProgress()
+ *  \brief  Resets the status of the progress text
+ *  \return void
+ */
+void GalleryView::ResetSyncProgress()
+{
+    if (m_syncProgressText)
+        m_syncProgressText->SetVisible(false);
+
+    LoadData();
+}
+
+
+
+/** \fn     GalleryView::UpdateThumbnailProgress(int, int)
+ *  \brief  Updates the dialog that shows the thumbnail creation progress
+ *  \param  remaining The number of thumbnail still to be created
+ *  \param  total The overall number of thumbnail that will be created
+ *  \return void
+ */
+void GalleryView::UpdateThumbnailProgress(int remaining, int total)
+{
+    int current = total - remaining;
+
+    if (m_thumbProgressText)
+    {
+        m_thumbProgressText->SetVisible(true);
+        m_thumbProgressText->SetText(QString("%1 %2 %3")
+                                     .arg(current)
+                                     .arg(tr("of"))
+                                     .arg(total));
+    }
+}
+
+
+
+/** \fn     GalleryView::UpdateSyncProgress(int, int)
+ *  \brief  Updates the widget that shows the sync progress
+ *  \param  remaining The number of images still to be synced
+ *  \param  total The overall number of images that will be synced
+ *  \return void
+ */
+void GalleryView::UpdateSyncProgress(int current, int total)
+{
+    if (m_syncProgressText)
+    {
+        m_syncProgressText->SetVisible(true);
+        m_syncProgressText->SetText(QString("%1 %2 %3")
+                                     .arg(current)
+                                     .arg(tr("of"))
+                                     .arg(total));
+    }
+}
+
+
+
+/** \fn     GalleryView::UpdateText(MythUIButtonListItem *)
+ *  \brief  Updates all other widgets on the screen that show
+ *          information about the selected MythUIButtonListItem.
+ *  \param  item The item that shall be updated
+ *  \return void.
+ */
+void GalleryView::UpdateText(MythUIButtonListItem *item)
+{
+    ImageMetadata *im = GetImageMetadataFromButton(item);
+    if (im)
+    {
+        // show the name of the image
+        if (m_captionText)
+            m_captionText->SetText(im->m_name);
+
+        // show the position of the image
+        if (m_positionText)
+            m_positionText->SetText(QString("%1 of %2")
+                                    .arg(m_imageList->GetCurrentPos()+1)
+                                    .arg(m_imageList->GetCount()));
+
+        // show the path of the image
+        if (m_crumbsText)
+            m_crumbsText->SetText(im->m_path);
+    }
+}
+
+
+
+/** \fn     GalleryView::ConfirmStartSync()
+ *  \brief  Shows a confirmation dialog so the user can confirm his request
+ *  \return void
+ */
+void GalleryView::ConfirmStartSync()
+{
+    QString msg = QString("Do you really want to synchronize?\n"
+                          "This could take some time.");
+    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
+
+    if (m_confirmPopup->Create())
+    {
+        m_confirmPopup->SetReturnEvent(this, "confirmstartsync");
+        m_popupStack->AddScreen(m_confirmPopup);
+    }
+    else
+        delete m_confirmPopup;
+}
+
+
+
+/** \fn     GalleryView::ConfirmStopSync()
+ *  \brief  Shows a confirmation dialog so the user can confirm his request
+ *  \return void
+ */
+void GalleryView::ConfirmStopSync()
+{
+    QString msg = QString("The syncronization of the images with the database "
+                          "is still running. Do you want to stop it or let it "
+                          "run in the background until its complete?");
+    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
+    if (m_confirmPopup->Create())
+    {
+        m_confirmPopup->SetReturnEvent(this, "confirmstopsync");
+        m_popupStack->AddScreen(m_confirmPopup);
+    }
+    else
+        delete m_confirmPopup;
+}
+
+
+
+/** \fn     GalleryView::MenuInformation()
+ *  \brief  Shows the menu when the INFO key was pressed
+ *  \return void
+ */
+void GalleryView::MenuInformation()
+{
+    QString label = tr("Image Information");
+    MythMenu *menu = new MythMenu(label, this, "infomenu");
+
+    // only show the slideshow options and details menu when
+    // the item is a video or image file
+    ImageMetadata *im = GetImageMetadataFromSelectedButton();
+    if (im)
+    {
+        if (im->m_type == kImageFile ||
+            im->m_type == kVideoFile)
+        {
+            menu->AddItem(tr("Normal SlideShow"), SLOT(ShowFiles()));
+            menu->AddItem(tr("Random Slideshow"), SLOT(ShowRandomFiles()));
+        }
+
+        if (im->m_type == kImageFile)
+            menu->AddItem(tr("Show Details"), SLOT(FileDetails()));
+    }
+
+    m_menuPopup = new MythDialogBox(menu, m_popupStack, "menuPopup");
+    if (!m_menuPopup->Create())
+    {
+        delete m_menuPopup;
+        m_menuPopup = NULL;
+        return;
+    }
+
+    m_popupStack->AddScreen(m_menuPopup);
+}
+
+
+
+/** \fn     GalleryView::MenuMain()
+ *  \brief  Shows the main menu when the MENU button was pressed
+ *  \return void
+ */
+void GalleryView::MenuMain()
+{
+    // Create the main menu that
+    // will contain the submenus above
+    MythMenu *menu = new MythMenu(tr("Image Options"), this, "mainmenu");
+
+    // Depending on the status of the sync show either the
+    // start sync or stop sync. The user can decide if he
+    // wants to stop the sync before leaving the main screen.
+    if (!m_syncStatusThread->isSyncRunning())
+        menu->AddItem(tr("Start Syncronization"), SLOT(ConfirmStartSync()));
+    else
+        menu->AddItem(tr("Stop Syncronization"), SLOT(ConfirmStopSync()));
+
+    // Add the available submenus to the main menu. The methods will
+    // check if the requirements for showing the menu item is fulfilled
+    MenuMetadata(menu);
+    MenuSelection(menu);
+    MenuFile(menu);
+
+    menu->AddItem(tr("Settings"), SLOT(MenuSettings()));
+
+    m_menuPopup = new MythDialogBox(menu, m_popupStack, "menuPopup");
+    if (!m_menuPopup->Create())
+    {
+        delete m_menuPopup;
+        m_menuPopup = NULL;
+        return;
+    }
+
+    m_popupStack->AddScreen(m_menuPopup);
+}
+
+
+
+/** \fn     GalleryView::MenuMetadata(MythMenu *)
+ *  \brief  Adds a new metadata menu entry into the main menu
+ *  \param  mainMenu Parent that will hold the menu entry
+ *  \return void
+ */
+void GalleryView::MenuMetadata(MythMenu *mainMenu)
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedButton();
+    if (im)
+    {
+        // only show the metadata menu
+        // if the current item is an image
+        if (im->m_type == kImageFile)
+        {
+            MythMenu *menu = new MythMenu(tr("Metadata Options"),
+                                          this, "metadatamenu");
+
+            menu->AddItem(tr("Rotate CW"), SLOT(FileRotateCW()));
+            menu->AddItem(tr("Rotate CCW"), SLOT(FileRotateCCW()));
+            menu->AddItem(tr("Flip Horizontal"), SLOT(FileFlipHorizontal()));
+            menu->AddItem(tr("Flip Vertical"), SLOT(FileFlipVertical()));
+            // menu->AddItem(tr("Zoom In"), SLOT(FileZoomIn()));
+            // menu->AddItem(tr("Zoom Out"), SLOT(FileZoomOut()));
+
+            mainMenu->AddItem(tr("Meta Data Menu"), NULL, menu);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryView::MenuFile(MythMenu *)
+ *  \brief  Adds a new file menu entry into the main menu
+ *  \param  mainMenu Parent that will hold the menu entry
+ *  \return void
+ */
+void GalleryView::MenuFile(MythMenu *mainMenu)
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedButton();
+    if (im)
+    {
+        // There are no options available for up folders
+        // They are just there to navigate one level up
+        if (im->m_type == kUpDirectory)
+            return;
+
+        QString type = "Directory";
+        if (im->m_type == kImageFile ||
+            im->m_type == kVideoFile)
+            type = "File";
+
+        MythMenu *menu = new MythMenu(tr("%1 Options").arg(type),
+                                      this, "fileactionmenu");
+
+        // Allow renaming and deletion only for files
+        if (im->m_type == kImageFile ||
+            im->m_type == kVideoFile)
+        {
+            menu->AddItem(tr("Delete File"),
+                          SLOT(ConfirmFileDelete()));
+            menu->AddItem(tr("Delete Selected Files"),
+                          SLOT(ConfirmFileDeleteSelected()));
+            menu->AddItem(tr("Rename File"),
+                          SLOT(FileRenameInput()));
+        }
+
+        if (im->m_isHidden)
+            menu->AddItem(tr("Unhide %1").arg(type), SLOT(FileUnhide()));
+        else
+            menu->AddItem(tr("Hide %1").arg(type), SLOT(FileHide()));
+
+        mainMenu->AddItem(tr("File Menu"), NULL, menu);
+    }
+}
+
+
+
+/** \fn     GalleryView::MenuSelection(MythMenu *)
+ *  \brief  Adds a new selection menu entry into the main menu
+ *  \param  mainMenu Parent that will hold the menu entry
+ *  \return void
+ */
+void GalleryView::MenuSelection(MythMenu *mainMenu)
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedButton();
+    if (im)
+    {
+        // Selection / deselection is only
+        // available for images or videos
+        if (im->m_type == kImageFile ||
+            im->m_type == kVideoFile)
+        {
+            MythMenu *menu = new MythMenu(tr("Selection Options"),
+                                          this, "selectionmenu");
+
+            if (!im->m_selected)
+                menu->AddItem(tr("Select File"),
+                              SLOT(FileSelectOne()));
+            else
+                menu->AddItem(tr("Deselect File"),
+                              SLOT(FileDeselectOne()));
+
+            menu->AddItem(tr("Select All Files"), SLOT(FileSelectAll()));
+            menu->AddItem(tr("Deselect All Files"), SLOT(FileDeselectAll()));
+            menu->AddItem(tr("Invert Selection"), SLOT(FileInvertAll()));
+
+            mainMenu->AddItem(tr("Selection Menu"), NULL, menu);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryView::MenuSettings(MythMenu *)
+ *  \brief  Adds a new settings menu entry into the main menu
+ *  \param  mainMenu Parent that will hold the menu entry
+ *  \return void
+ */
+void GalleryView::MenuSettings()
+{
+    GalleryConfig *config = new GalleryConfig(m_mainStack, "galleryconfig");
+    connect(config, SIGNAL(configSaved()), this, SLOT(LoadData()));
+
+    if (config->Create())
+    {
+        m_mainStack->AddScreen(config);
+    }
+    else
+        delete config;
+}
+
+
+
+/** \fn     GalleryView::ItemSelected(MythUIButtonListItem *)
+ *  \brief  A new MythUIButtonListItem has been selected
+ *  \param  item The given button item that has been selected
+ *  \return void
+ */
+void GalleryView::ItemSelected(MythUIButtonListItem *item)
+{
+    if (!item)
+        return;
+
+    ImageMetadata *dm = GetImageMetadataFromButton(item);
+    if (!dm)
+        return;
+
+    switch (dm->m_type)
+    {
+    case kSubDirectory:
+        DirSelectDown();
+        break;
+    case kUpDirectory:
+        DirSelectUp();
+        break;
+    case kImageFile:
+        ShowFile();
+        break;
+    case kVideoFile:
+        ShowFile();
+        break;
+    default:
+        break;
+    };
+}
+
+
+
+/** \fn     GalleryView::ShowFiles()
+ *  \brief  Starts a slideshow with the images in normal order
+ *  \return void
+ */
+void GalleryView::ShowFiles()
+{
+    GalleryWidget *widget = ShowFile();
+
+    if (widget)
+        widget->StartNormalSlideShow();
+}
+
+
+
+/** \fn     GalleryView::ShowRandomFiles()
+ *  \brief  Starts a slide show with the images in random order
+ *  \return void
+ */
+void GalleryView::ShowRandomFiles()
+{
+    GalleryWidget *widget = ShowFile();
+
+    if (widget)
+        widget->StartRandomSlideShow();
+}
+
+
+
+/** \fn     GalleryView::ShowFile()
+ *  \brief  Creates the window that will show the images and slideshows
+ *  \return The created window or NULL
+ */
+GalleryWidget* GalleryView::ShowFile()
+{
+    GalleryWidget *widget = new GalleryWidget(m_mainStack, "gallerywidget", m_galleryViewHelper);
+    if (widget->Create())
+    {
+        ResetThumbnailProgress();
+        m_mainStack->AddScreen(widget);
+        widget->LoadFile();
+    }
+    else
+    {
+        delete widget;
+        widget = NULL;
+    }
+
+    return widget;
+}
+
+
+
+/** \fn     GalleryView::DirSelectUp()
+ *  \brief  Goes up one directory level
+ *  \return void
+ */
+bool GalleryView::DirSelectUp()
+{
+    // Set the first node (upfolder) active
+    m_galleryViewHelper->m_currentNode->setSelectedChild(m_galleryViewHelper->m_currentNode->getChildAt(0));
+
+    // Get the data and with it the kUpFolder directory node
+    int id = m_galleryViewHelper->GetImageMetadataFromSelectedNode()->m_id;
+
+    m_galleryViewHelper->LoadTreeData();
+    ResetThumbnailProgress();
+    UpdateImageList();
+
+    // Go through the entire list of image items and find
+    // the directory id that matches the saved directory id
+    for (int i = 0; i < m_imageList->GetCount(); i++)
+    {
+        MythUIButtonListItem *item = m_imageList->GetItemAt(i);
+        if (!item)
+            continue;
+
+        ImageMetadata *data = GetImageMetadataFromButton(item);
+        if (!data)
+            continue;
+
+        if (data->m_id == id)
+        {
+            m_imageList->SetItemCurrent(item);
+            break;
+        }
+    }
+
+    return true;
+}
+
+
+
+/** \fn     GalleryView::DirSelectDown()
+ *  \brief  Goes one directory level down
+ *  \return void
+ */
+void GalleryView::DirSelectDown()
+{
+    m_galleryViewHelper->LoadTreeData();
+    m_galleryViewHelper->m_currentNode->setSelectedChild(m_galleryViewHelper->m_currentNode->getChildAt(0));
+
+    ResetThumbnailProgress();
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileSelectOne()
+ *  \brief  Marks a single file as selected
+ *  \return void
+ */
+void GalleryView::FileSelectOne()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetNodeSelectionState(kNodeStateSelect, false);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileDeselectOne()
+ *  \brief  Marks a single file as not selected
+ *  \return void
+ */
+void GalleryView::FileDeselectOne()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetNodeSelectionState(kNodeStateDeselect, false);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileSelectAll()
+ *  \brief  Marks all files as selected
+ *  \return void
+ */
+void GalleryView::FileSelectAll()
+{
+    m_galleryViewHelper->SetNodeSelectionState(kNodeStateSelect, true);
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileDeselectAll()
+ *  \brief  Marks all files as not selected
+ *  \return void
+ */
+void GalleryView::FileDeselectAll()
+{
+    m_galleryViewHelper->SetNodeSelectionState(kNodeStateDeselect, true);
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileInvertAll()
+ *  \brief  Inverts the current selection for all files
+ *  \return void
+ */
+void GalleryView::FileInvertAll()
+{
+    m_galleryViewHelper->SetNodeSelectionState(kNodeStateInvert, true);
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileRotateCW()
+ *  \brief  Rotates the selected file 90 clockwise.
+ *          The thumbnail will also be updated.
+ *  \return void
+ */
+void GalleryView::FileRotateCW()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetFileOrientation(kFileRotateCW);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileRotateCCW()
+ *  \brief  Rotates the selected file 90 counter clockwise.
+ *          The thumbnail will also be updated.
+ *  \return void
+ */
+void GalleryView::FileRotateCCW()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetFileOrientation(kFileRotateCCW);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileFlipHorizontal()
+ *  \brief  Flips the file horizontally.
+ *          The thumbnail will also be updated.
+ *  \return void
+ */
+void GalleryView::FileFlipHorizontal()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetFileOrientation(kFileFlipHorizontal);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileFlipVertical()
+ *  \brief  Flips the file vertically.
+ *          The thumbnail will also be updated.
+ *  \return void
+ */
+void GalleryView::FileFlipVertical()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetFileOrientation(kFileFlipVertical);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileZoomIn()
+ *  \brief  Zooms into the file. The thumbnail will also be updated.
+ *  \return void
+ */
+void GalleryView::FileZoomIn()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetFileZoom(kFileZoomIn);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileZoomOut()
+ *  \brief  Zooms out of the file. The thumbnail will also be updated.
+ *  \return void
+ */
+void GalleryView::FileZoomOut()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return;
+
+    m_galleryViewHelper->SetFileZoom(kFileZoomOut);
+    UpdateImageItem(item);
+}
+
+
+
+/** \fn     GalleryView::FileHide()
+ *  \brief  Marks the file as hidden and hides it from the visible image list
+ *  \return void
+ */
+void GalleryView::FileHide()
+{
+    m_galleryViewHelper->SetNodeVisibilityState(kNodeStateInvisible);
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileHide()
+ *  \brief  Marks the file as visible and unhides it from the visible image list
+ *  \return void
+ */
+void GalleryView::FileUnhide()
+{
+    m_galleryViewHelper->SetNodeVisibilityState(kNodeStateVisible);
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::ConfirmFileDelete()
+ *  \brief  Shows a confirmation dialog before
+ *          the user can delete a single file
+ *  \return void
+ */
+void GalleryView::ConfirmFileDelete()
+{
+    // Create a confirmation dialog to confirm the file deletion
+    // of the currently selected image. This is only a safety precausion.
+    ImageMetadata *data = GetImageMetadataFromSelectedButton();
+    if (!data)
+        return;
+
+    QString msg = QString("Do you want to delete '\n%1'").arg(data->m_name);
+    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
+
+    if (m_confirmPopup->Create())
+    {
+        m_confirmPopup->SetReturnEvent(this, "confirmdelete");
+        m_popupStack->AddScreen(m_confirmPopup);
+    }
+    else
+        delete m_confirmPopup;
+}
+
+
+
+/** \fn     GalleryView::ConfirmFileDeleteSelected()
+ *  \brief  Shows a confirmation dialog before the
+ *          user can delete all selected files
+ *  \return void
+ */
+void GalleryView::ConfirmFileDeleteSelected()
+{
+    QString msg = QString("Do you want to delete all selected files");
+    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
+
+    if (m_confirmPopup->Create())
+    {
+        m_confirmPopup->SetReturnEvent(this, "confirmdeleteselected");
+        m_popupStack->AddScreen(m_confirmPopup);
+    }
+    else
+        delete m_confirmPopup;
+}
+
+
+
+/** \fn     GalleryView::FileDelete()
+ *  \brief  Deletes a single file
+ *  \return void
+ */
+void GalleryView::FileDelete()
+{
+    m_galleryViewHelper->DeleteCurrentNode();
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileDeleteSelected()
+ *  \brief  Deletes all selected files
+ *  \return void
+ */
+void GalleryView::FileDeleteSelected()
+{
+    m_galleryViewHelper->DeleteSelectedNodes();
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileRenameInput()
+ *  \brief  Shows a popup where the user can enter a new filename
+ *  \return void
+ */
+void GalleryView::FileRenameInput()
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedButton();
+    if (im)
+    {
+        QString msg = QString("Enter a new name for '%1'.").arg(im->m_name);
+        m_inputPopup = new MythTextInputDialog(m_popupStack, msg,
+                                               FilterNone, false, im->m_name );
+
+        if (m_inputPopup->Create())
+        {
+            m_inputPopup->SetReturnEvent(this, "filerename");
+            m_popupStack->AddScreen(m_inputPopup);
+        }
+        else
+            delete m_inputPopup;
+    }
+}
+
+
+
+/** \fn     GalleryView::FileRename(QString &)
+ *  \brief  Renames the current filename to the new filename
+            if the new filename does not exist already.
+ *  \param  New name of the file with the full path
+ *  \return void
+ */
+void GalleryView::FileRename(QString &newName)
+{
+    m_galleryViewHelper->RenameCurrentNode(newName);
+    UpdateImageList();
+}
+
+
+
+/** \fn     GalleryView::FileDetails()
+ *  \brief  Shows details about the single file
+ *  \return void
+ */
+void GalleryView::FileDetails()
+{
+    GalleryWidget *widget = ShowFile();
+
+    if (widget)
+        widget->ShowFileDetails();
+}
+
+
+
+/** \fn     GalleryView::GetImageMetadataFromSelectedButton()
+ *  \brief  Returns the data of the currently selected image list item
+ *  \return ImageMetadata
+ */
+ImageMetadata *GalleryView::GetImageMetadataFromSelectedButton()
+{
+    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
+    if (!item)
+        return NULL;
+
+    MythGenericTree *node = item->GetData().value<MythGenericTree *>();
+    if (!node)
+        return NULL;
+
+    ImageMetadata *data = qVariantValue<ImageMetadata *>(node->GetData());
+    if (!data)
+        return NULL;
+
+    return data;
+}
+
+
+
+/** \fn     GalleryView::GetImageMetadataFromButton(MythUIButtonListItem *)
+ *  \brief  Returns the data of the given image list item
+ *  \param  item The given image list item
+ *  \return ImageMetadata
+ */
+ImageMetadata *GalleryView::GetImageMetadataFromButton(MythUIButtonListItem *item)
+{
+    if (!item)
+        return NULL;
+
+    MythGenericTree *node = item->GetData().value<MythGenericTree *>();
+    if (!node)
+        return NULL;
+
+    ImageMetadata *data = qVariantValue<ImageMetadata *>(node->GetData());
+    if (!data)
+        return NULL;
+
+    return data;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryview.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryview.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryview.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryview.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,116 @@
+#ifndef GALLERYVIEW_H
+#define GALLERYVIEW_H
+
+// Qt headers
+#include <QStringList>
+
+// MythTV headers
+#include "mythscreentype.h"
+#include "mythuitext.h"
+#include "mythuibuttonlist.h"
+#include "mythuiimage.h"
+#include "mythdialogbox.h"
+#include "mythprogressdialog.h"
+#include "mythuitextedit.h"
+#include "imagemetadata.h"
+
+#include "galleryviewhelper.h"
+#include "gallerywidget.h"
+
+
+
+class GalleryView : public MythScreenType
+{
+    Q_OBJECT
+
+public:
+    GalleryView(MythScreenStack *parent, const char *name);
+    ~GalleryView();
+    bool Create();
+
+    GalleryViewHelper     *m_galleryViewHelper;
+
+public slots:
+    void LoadData();
+    void UpdateThumbnail(ImageMetadata *, int);
+    void ResetThumbnailProgress();
+    void UpdateThumbnailProgress(int, int);
+
+    void ResetSyncProgress();
+    void UpdateSyncProgress(int, int);
+
+private:
+    bool keyPressEvent(QKeyEvent *);
+    void customEvent(QEvent*);
+    void UpdateImageList();
+    void ResetImageItems();
+
+private slots:
+    void ItemSelected(MythUIButtonListItem *);
+    void UpdateImageItem(MythUIButtonListItem *);
+    void UpdateText(MythUIButtonListItem *);
+    void UpdateThumbnail(MythUIButtonListItem *, bool forceReload = false);
+
+    void MenuMain();
+    void MenuInformation();
+    void MenuMetadata(MythMenu *);
+    void MenuSelection(MythMenu *);
+    void MenuFile(MythMenu *);
+    void MenuSettings();
+
+    void ShowFiles();
+    void ShowRandomFiles();
+    GalleryWidget* ShowFile();
+
+    bool DirSelectUp();
+    void DirSelectDown();
+
+    void FileDetails();
+    void FileRotateCW();
+    void FileRotateCCW();
+    void FileFlipHorizontal();
+    void FileFlipVertical();
+    void FileZoomIn();
+    void FileZoomOut();
+    void FileSelectOne();
+    void FileDeselectOne();
+    void FileSelectAll();
+    void FileDeselectAll();
+    void FileInvertAll();
+    void FileHide();
+    void FileUnhide();
+    void FileDelete();
+    void FileDeleteSelected();
+    void FileRenameInput();
+    void FileRename(QString &);
+
+    void ConfirmStartSync();
+    void ConfirmStopSync();
+    void ConfirmFileDelete();
+    void ConfirmFileDeleteSelected();
+
+private:
+    ImageMetadata         *GetImageMetadataFromSelectedButton();
+    ImageMetadata         *GetImageMetadataFromButton(MythUIButtonListItem *item);
+
+    GallerySyncStatusThread     *m_syncStatusThread;
+
+    // used to show the menus and other popups
+    MythDialogBox           *m_menuPopup;
+    MythConfirmationDialog  *m_confirmPopup;
+    MythTextInputDialog     *m_inputPopup;
+    MythScreenStack         *m_popupStack;
+    MythScreenStack         *m_mainStack;
+
+    MythUIButtonList   *m_imageList;
+    MythUIText         *m_captionText;
+    MythUIText         *m_crumbsText;
+    MythUIText         *m_positionText;
+    MythUIText         *m_imageText;
+    MythUIImage        *m_selectedImage;
+
+    MythUIText         *m_syncProgressText;
+    MythUIText         *m_thumbProgressText;
+};
+
+#endif // GALLERYVIEW_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryviewhelper.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryviewhelper.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryviewhelper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryviewhelper.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,579 @@
+
+#include "galleryviewhelper.h"
+
+// Qt headers
+#include <QFile>
+
+// MythTV headers
+#include "mythcontext.h"
+#include "storagegroup.h"
+#include "imageutils.h"
+
+/** \fn     GalleryViewHelper::GalleryViewHelper(MythScreenType *)
+ *  \brief  Constructor
+ *  \param  parent The screen parent
+ */
+GalleryViewHelper::GalleryViewHelper(MythScreenType *parent)
+{
+    m_parent = parent;
+
+    m_sgName    = IMAGE_STORAGE_GROUP;
+    m_sgDirList = StorageGroup::getGroupDirs(m_sgName, "");
+
+    m_dbHelper = new GalleryDatabaseHelper();
+    m_fileHelper  = new GalleryFileHelper();
+
+    // these are the node trees that hold the data and
+    // are used for navigating and finding files
+    m_currentNode = new MythGenericTree("", kBaseDirectory, false);
+
+    m_allNodesVisible = false;
+}
+
+
+
+/** \fn     GalleryViewHelper::~GalleryViewHelper()
+ *  \brief  Destructor
+ */
+GalleryViewHelper::~GalleryViewHelper()
+{
+    if (m_dbHelper)
+    {
+        delete m_dbHelper;
+        m_dbHelper = NULL;
+    }
+
+    if (m_currentNode)
+    {
+        delete m_currentNode;
+        m_currentNode = NULL;
+    }
+
+    if (m_fileHelper)
+    {
+        // FIXME Triggers segfault
+        // m_fileHelper->StopThumbGen();
+        delete m_fileHelper;
+        m_fileHelper = NULL;
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::LoadData()
+ *  \brief  Checks the prerequisites are fulfilled
+ *          before the data can be loaded
+ *  \return void
+ */
+int GalleryViewHelper::LoadData()
+{
+    // clear all previously loaded data
+    m_currentNode->deleteAllChildren();
+
+    // get the base directories and check if they are valid
+    if (m_sgDirList.isEmpty())
+        return kStatusNoBaseDir;
+
+    // Fill the MythGenericTree with the data of the first level
+    // This method will be called recursively to further fill the tree
+    LoadTreeData();
+
+    // check if there is any data in the database
+    if (m_currentNode->childCount() == 0)
+        return kStatusNoFiles;
+
+    return kStatusOk;
+}
+
+
+/** \fn     GalleryViewHelper::LoadTreeData()
+ *  \brief  Load all available data from the database and populates the tree.
+ *  \return void
+ */
+void GalleryViewHelper::LoadTreeData()
+{
+    QList<ImageMetadata *> *dirList = new QList<ImageMetadata *>;
+    QList<ImageMetadata *> *fileList = new QList<ImageMetadata *>;
+
+    // Stop generating thumbnails
+    // when a new directory is loaded
+    m_fileHelper->StopThumbGen();
+
+    // The parent id is the database index of the
+    // directories which subdirectories and files shall be loaded
+    int id = 0;
+
+    // Get the selected node. If there is no data available then the
+    // plugin has been started for the first time, a synchronization
+    // request was made or the settings have changed. In this case
+    // use default parent id of the storage group directories.
+    ImageMetadata *im = GetImageMetadataFromSelectedNode();
+    if (im)
+    {
+        if (im->m_type == kUpDirectory)
+            id = im->m_parentId;
+
+        if (im->m_type == kSubDirectory)
+            id = im->m_id;
+    }
+
+    // The data from the selected node has used.
+    // Clear the list so that it can be populated with new data.
+    m_currentNode->deleteAllChildren();
+
+    // If the parent is a root directory
+    // then add a additional directory at the beginning of the list that
+    // is of the type kUpDirectory so that the user can navigate one level up.
+    if (id > 0)
+    {
+        m_dbHelper->LoadParentDirectory(dirList, id);
+        LoadTreeNodeData(dirList, m_currentNode);
+    }
+
+    m_dbHelper->LoadDirectories(dirList, id);
+    LoadTreeNodeData(dirList, m_currentNode);
+
+    // Load all files with the specified sorting criterias
+    m_dbHelper->LoadFiles(fileList, id);
+    LoadTreeNodeData(fileList, m_currentNode);
+
+    // Start generating thumbnails if required
+    m_fileHelper->StartThumbGen();
+
+    // clean up
+    delete dirList;
+    delete fileList;
+}
+
+
+
+/** \fn     GalleryViewHelper::LoadNodeTreeData(QList<ImageMetadata *> *, MythGenericTree *)
+ *  \brief  Creates a new generic tree with the information from the database
+ *  \param  list The list with the database file information
+ *  \param  tree The tree that will be populated and shown
+ *  \return void
+ */
+void GalleryViewHelper::LoadTreeNodeData(QList<ImageMetadata *> *list,
+                                       MythGenericTree *tree)
+{
+    // Add all items in the list to the tree
+    for (int i = 0; i < list->size(); ++i)
+    {
+        ImageMetadata *im = list->at(i);
+        if (im)
+        {
+            m_fileHelper->AddToThumbnailList(im);
+
+            // Create a new tree node that will hold the data
+            MythGenericTree *treeItem =
+                    new MythGenericTree(im->m_fileName,
+                                        im->m_type, true);
+
+            treeItem->SetData(qVariantFromValue<ImageMetadata *> (im));
+            tree->addNode(treeItem);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::RenameCurrentNode(QString &)
+ *  \brief  Renames the file that belongs to the node and updates the database
+ *  \param  New name of the file with the full path
+ *  \return void
+ */
+void GalleryViewHelper::RenameCurrentNode(QString &newName)
+{
+    bool fileExist = false;
+
+    // Check if the file with the new name already exists in the current directory
+    QList<MythGenericTree *> *nodeTree = m_currentNode->getAllChildren();
+    for (int i = 0; i < nodeTree->size(); i++)
+    {
+        ImageMetadata *im = qVariantValue<ImageMetadata *>(nodeTree->at(i)->GetData());
+        if (im)
+        {
+            if (im->m_name.compare(newName) == 0)
+            {
+                fileExist = true;
+                break;
+            }
+        }
+    }
+
+    // The file with the given new name does not yet exist.
+    // Continue with the renaming of the file
+    if (!fileExist)
+    {
+        ImageMetadata *im = GetImageMetadataFromSelectedNode();
+        if (!im)
+            return;
+
+        if (m_fileHelper->RenameFile(im, newName))
+        {
+            // replace the original filename with the
+            // new one in the pull path + filename variable
+            QString newFileName = im->m_fileName.replace(im->m_name, newName);
+
+            im->m_fileName = newFileName;
+            im->m_name = newName;
+
+            m_dbHelper->UpdateData(im);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::DeleteCurrentNode()
+ *  \brief  Deletes the current node from the generic tree
+ *  \return void
+ */
+void GalleryViewHelper::DeleteCurrentNode()
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedNode();
+    if (!im)
+        return;
+
+    // Delete the file and remove the database entry
+    if (m_fileHelper->RemoveFile(im))
+    {
+        // Remove the entry from the node list
+        m_currentNode->deleteNode(m_currentNode->getSelectedChild());
+
+        // Only remove the first thumbnail when it is an image or video.
+        // If its a folder, it will use thumbnails from other images
+        if (im->m_type == kImageFile || im->m_type == kVideoFile)
+            QFile::remove(im->m_thumbFileNameList->at(0));
+
+        m_dbHelper->RemoveFile(im);
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::DeleteSelectedNodes()
+ *  \brief  Deletes multiple selected nodes from the generic tree
+ *  \return void
+ */
+void GalleryViewHelper::DeleteSelectedNodes()
+{
+    QList<MythGenericTree *> *nodeTree = m_currentNode->getAllChildren();
+    for (int i = 0; i < nodeTree->size(); i++)
+    {
+        ImageMetadata *im = qVariantValue<ImageMetadata *>(nodeTree->at(i)->GetData());
+        if (im && im->m_selected)
+        {
+            // Delete the file and remove the
+            // database entry only if it was successful
+            if (m_fileHelper->RemoveFile(im))
+            {
+                // Only remove the first thumbnail when it is an image or video.
+                // If its a folder, it will use thumbnails from other images
+                if (im->m_type == kImageFile || im->m_type == kVideoFile)
+                    QFile::remove(im->m_thumbFileNameList->at(0));
+
+                m_dbHelper->RemoveFile(im);
+
+                // Remove the entry from the node list
+                m_currentNode->deleteNode(nodeTree->at(i));
+            }
+        }
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::SetNodeSelectionState(int, bool)
+ *  \brief  Sets either one or all nodes to the
+            nodeState that the user has specified
+ *  \param  nodeState Can be either selected or unselected
+ *  \param  allNodes Set the selection state for all nodes or not
+ *  \return void
+ */
+void GalleryViewHelper::SetNodeSelectionState(int nodeState, bool allNodes)
+{
+    if (!m_currentNode)
+        return;
+
+    if (!allNodes)
+    {
+        SetNodeSelectionState(m_currentNode->getSelectedChild(), nodeState);
+    }
+    else
+    {
+        QList<MythGenericTree *> *nodeTree = m_currentNode->getAllChildren();
+        for (int i = 0; i < nodeTree->size(); i++)
+            SetNodeSelectionState(nodeTree->at(i), nodeState);
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::SetNodeSelectionState(MythGenericTree *, int)
+ *  \brief  Sets the given node to the given nodeState
+ *  \param  node The single node that shall be changed
+ *  \param  nodeState Can be either selected or unselected
+ *  \return void
+ */
+void GalleryViewHelper::SetNodeSelectionState(MythGenericTree *node,
+                                            int nodeState)
+{
+    // set the given node as selected / unselected
+    if (node)
+    {
+        ImageMetadata *im = qVariantValue<ImageMetadata *>(node->GetData());
+
+        // Allow a selection / deselection only for images
+        if (im &&
+            im->m_type == kImageFile)
+        {
+            if (nodeState == kNodeStateSelect)
+                im->m_selected = true;
+
+            if (nodeState == kNodeStateDeselect)
+                im->m_selected = false;
+
+            if (nodeState == kNodeStateInvert)
+                im->m_selected = !im->m_selected;
+        }
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::SetNodeVisibilityState(int)
+ *  \brief  Sets the selected not either to the
+            nodeState that the user has specified
+ *  \param  nodeState Can be either visible or invisible
+ *  \return void
+ */
+void GalleryViewHelper::SetNodeVisibilityState(int nodeState)
+{
+    // set the given node as visible / invisible
+    ImageMetadata *im = GetImageMetadataFromSelectedNode();
+    if (im)
+    {
+        if (nodeState == kNodeStateVisible)
+            im->m_isHidden = false;
+
+        if (nodeState == kNodeStateInvisible)
+            im->m_isHidden = true;
+
+        m_dbHelper->UpdateData(im);
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::SetFileOrientation(int)
+ *  \brief  Saves the orientation information of the selected node
+ *  \param  fileOrientation The orientation value 1-8
+ *  \return void
+ */
+void GalleryViewHelper::SetFileOrientation(int fileOrientation)
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedNode();
+    if (!im)
+        return;
+
+    int oldFileOrientation = im->GetOrientation();
+
+    // Update the orientation, the new value will
+    // be calculated with this method. This new
+    // value will then be saved in the exif header tag.
+    im->SetOrientation(fileOrientation, false);
+
+    // Update the exif tag, if that fails we can restore the original
+    // orientation so that the database and image file are not out of sync
+    if (m_fileHelper->SetImageOrientation(im))
+    {
+        m_dbHelper->UpdateData(im);
+        m_fileHelper->RecreateThumbnail(im);
+        m_fileHelper->StartThumbGen();
+    }
+    else
+    {
+        im->SetOrientation(oldFileOrientation, false);
+
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Could not write the angle %1 into the file %2. "
+                    "The database value has not been updated.")
+            .arg(im->GetAngle()).arg(im->m_fileName));
+    }
+}
+
+
+
+/** \fn     GalleryViewHelper::SetFileZoom(int)
+ *  \brief  Saves the zoom information of the selected node
+ *  \param  zoom The zoom value in percent
+ *  \return void
+ */
+void GalleryViewHelper::SetFileZoom(int zoom)
+{
+    ImageMetadata *im = GetImageMetadataFromSelectedNode();
+    if (!im)
+        return;
+
+    if (zoom == kFileZoomIn)
+        im->SetZoom(20);
+
+    if (zoom == kFileZoomOut)
+        im->SetZoom(-20);
+
+    m_dbHelper->UpdateData(im);
+}
+
+
+
+/** \fn     GalleryViewHelper::GetImageMetadataFromSelectedNode()
+ *  \brief  Returns the data selected node
+ *  \return ImageMetadata
+ */
+ImageMetadata *GalleryViewHelper::GetImageMetadataFromSelectedNode()
+{
+    if (!m_currentNode)
+        return NULL;
+
+    MythGenericTree *node = m_currentNode->getSelectedChild();
+    if (!node)
+        return NULL;
+
+    ImageMetadata *im = qVariantValue<ImageMetadata *>(node->GetData());
+    if (!im)
+        return NULL;
+
+    return im;
+}
+
+
+
+/** \fn     GalleryViewHelper::GetImageMetadataFromNode(MythGenericTree *)
+ *  \brief  Returns the data of the given node
+ *  \param  node The specified node that shall be used
+ *  \return ImageMetadata
+ */
+ImageMetadata *GalleryViewHelper::GetImageMetadataFromNode(MythGenericTree *node)
+{
+    if (!node)
+        return NULL;
+
+    ImageMetadata *im = qVariantValue<ImageMetadata *>(node->GetData());
+    if (!im)
+        return NULL;
+
+    return im;
+}
+
+
+
+/** \fn     GalleryViewHelper::GetImageMetadataFromNode(int)
+ *  \brief  Returns the data of the given node id
+ *  \param  id The specified node id that shall be used
+ *  \return ImageMetadata
+ */
+ImageMetadata *GalleryViewHelper::GetImageMetadataFromNode(int i)
+{
+    if (!m_currentNode)
+        return NULL;
+
+    MythGenericTree *node = m_currentNode->getChildAt(i);
+    if (!node)
+        return NULL;
+
+    ImageMetadata *im = qVariantValue<ImageMetadata *>(node->GetData());
+    if (!im)
+        return NULL;
+
+    return im;
+}
+
+
+
+/** \fn     GalleryViewHelper::SetPreviewImageSize(MythUIButtonList *)
+ *  \brief  Gets and saves the size of the shown image previews which
+ *          will be used to create thumbnails of the given dimensions.
+ *  \param  imageList The widget where the themer has specified the images sizes
+ *  \return void
+ */
+void GalleryViewHelper::SetPreviewImageSize(MythUIButtonList *imageList)
+{
+    float width  = (float)imageList->ItemWidth();
+    float height = (float)imageList->ItemHeight();
+
+    m_fileHelper->SetThumbnailSize((int)width, (int)height);
+}
+
+
+
+/** \fn     GallerySyncStatusThread::GallerySyncStatusThread()
+ *  \brief  Constructor
+ *  \return void
+ */
+GallerySyncStatusThread::GallerySyncStatusThread()
+{
+
+}
+
+/**
+ * @brief GallerySyncStatusThread::isSyncRunning
+ * @return void
+ */
+bool GallerySyncStatusThread::isSyncRunning()
+{
+    GalleryFileHelper *fh = new GalleryFileHelper();
+    GallerySyncStatus status = fh->GetSyncStatus();
+
+    LOG(VB_GENERAL, LOG_DEBUG,
+        QString("GallerySyncStatusThread: Sync status is running: %1").arg(status.running));
+
+    delete fh;
+
+    return status.running;
+}
+
+/** \fn     GallerySyncStatusThread::run()
+ *  \brief  Called when the thread is started. Calls the service
+            api to start the syncing and checks the status every 2s.
+ *  \return void
+ */
+void GallerySyncStatusThread::run()
+{
+    volatile bool exit = false;
+    GalleryFileHelper *fh = new GalleryFileHelper();
+
+    // Internal counter that tracks how many
+    // times we have been in the while loop
+    int loopCounter = 0;
+
+    while (!exit)
+    {
+        GallerySyncStatus status = fh->GetSyncStatus();
+
+        LOG(VB_GENERAL, LOG_DEBUG,
+            QString("GallerySyncStatusThread: Sync status is running: %1, Syncing image '%2' of '%3'")
+            .arg(status.running).arg(status.current).arg(status.total));
+
+        // Only update the progress text
+        // if the sync is still running
+        if (status.running)
+            emit UpdateSyncProgress(status.current, status.total);
+
+        // Try at least one time to get the sync
+        // status before checking for the exit condition
+        if (loopCounter >= 1)
+        {
+            if (status.running == false)
+                exit = true;
+        }
+
+        // Wait some time before trying to get and update the status
+        // This also avoids too many calls to the service api.
+        usleep(1000000);
+
+        ++loopCounter;
+    }
+
+    delete fh;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryviewhelper.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryviewhelper.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/galleryviewhelper.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/galleryviewhelper.h	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,76 @@
+#ifndef GALLERYVIEWHELPER_H
+#define GALLERYVIEWHELPER_H
+
+// Qt headers
+#include <QString>
+#include <QList>
+#include <QMap>
+#include <QThread>
+
+// MythTV headers
+#include "mythgenerictree.h"
+#include "imagemetadata.h"
+
+#include "galleryfilehelper.h"
+#include "gallerydatabasehelper.h"
+
+
+class GalleryViewHelper : public QObject
+{
+    Q_OBJECT
+
+public:
+    GalleryViewHelper(MythScreenType *);
+    ~GalleryViewHelper();
+
+    MythGenericTree         *m_currentNode;
+
+    QStringList m_sgDirList;
+    QString     m_sgName;
+
+    int     LoadData();
+    void    LoadTreeData();
+    void    LoadTreeNodeData(QList<ImageMetadata *>*, MythGenericTree*);
+    void    UpdateAllData();
+    void    RenameCurrentNode(QString &);
+    void    DeleteCurrentNode();
+    void    DeleteSelectedNodes();
+    void    SetNodeSelectionState(int, bool);
+    void    SetNodeVisibilityState(int);
+    void    SetFileOrientation(int);
+    void    SetFileZoom(int);
+    void    SetPreviewImageSize(MythUIButtonList *);
+
+    ImageMetadata*  GetImageMetadataFromSelectedNode();
+    ImageMetadata*  GetImageMetadataFromNode(MythGenericTree *);
+    ImageMetadata*  GetImageMetadataFromNode(int);
+
+    GalleryFileHelper       *m_fileHelper;
+
+private:
+    void    SetNodeSelectionState(MythGenericTree *, int);
+
+    MythScreenType          *m_parent;
+    GalleryDatabaseHelper   *m_dbHelper;
+
+    bool    m_allNodesVisible;
+};
+
+
+
+class GallerySyncStatusThread : public QThread
+{
+    Q_OBJECT
+
+public:
+    GallerySyncStatusThread();
+    bool isSyncRunning();
+
+protected:
+    void run();
+
+signals:
+    void UpdateSyncProgress(int, int);
+};
+
+#endif // GALLERYVIEWHANDLER_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerywidget.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerywidget.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerywidget.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerywidget.cpp	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,862 @@
+
+#include "gallerywidget.h"
+
+// Qt headers
+#include <QByteArray>
+#include <QXmlStreamReader>
+
+// MythTV headers
+#include "mythcontext.h"
+#include "mythmainwindow.h"
+
+ImageLoadingThread::ImageLoadingThread() :
+    m_image(NULL),
+    m_imageData(NULL),
+    m_url()
+{
+
+}
+
+void ImageLoadingThread::setImage(MythUIImage *image,
+                                  ImageMetadata *imageData,
+                                  QString &url)
+{
+    m_image = image;
+    m_imageData = imageData;
+    m_url = url;
+}
+
+void ImageLoadingThread::run()
+{
+    if (m_image && m_imageData)
+    {
+        m_image->SetFilename(m_url);
+        m_image->SetOrientation(m_imageData->GetOrientation());
+        m_image->SetZoom(m_imageData->GetZoom() / 100);
+        m_image->Load(false);
+    }
+}
+
+
+
+
+/** \fn     GalleryWidget::GalleryWidget(MythScreenStack *,
+ *                       const char *, GalleryViewHelper *
+ *  \brief  Constructor
+ *  \param  parent The screen parent
+ *  \param  name The name of the screen
+ *  \param  ivh Main helper class of the image plugin
+ *  \return void
+ */
+GalleryWidget::GalleryWidget(MythScreenStack *parent,
+                         const char *name,
+                         GalleryViewHelper *ivh) : MythScreenType(parent, name),
+    m_menuPopup(NULL),
+    m_image1(NULL),
+    m_image2(NULL),
+    m_status(NULL),
+    m_infoList(NULL),
+    m_fileList(NULL),
+    m_fileDataList(NULL)
+{
+    m_gvh = ivh;
+    m_fh = new GalleryFileHelper();
+
+    m_ilt = new ImageLoadingThread();
+    connect(m_ilt, SIGNAL(finished()),
+            this, SLOT(HandleImageTransition()));
+
+    m_backendHost = gCoreContext->GetSetting("BackendServerIP","localhost");
+    m_backendPort = gCoreContext->GetSetting("BackendServerPort", "6543");
+
+    m_slideShowType = kNoSlideShow;
+    m_slideShowTime = gCoreContext->GetNumSetting("GallerySlideShowTime", 3000);
+    m_transitionType = gCoreContext->GetNumSetting("GalleryTransitionType", kFade);
+
+    // calculate the alphachange from the specified transition time.
+    // an alphachange of 1 would take approx. 3,64s because the alpha value is
+    // changed 70 times per second. 3,64 * 70 = 255 (max alpha).
+    // example: 2 = abs(36400 / 15000) with transition time of 1500
+    m_transitionTime = abs(((255 / 70) * 10000) /
+                           (gCoreContext->GetNumSetting("GalleryTransitionTime", 1000) * 10));
+
+    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
+
+    // Save the selected image in the gallery view
+    // so that the initially selected image can be
+    // restored when the GalleryWidget is detroyed.
+    m_selectedNode = m_gvh->m_currentNode->getSelectedChild();
+
+    // this timer is used for the slideshow
+    m_timer = new QTimer();
+    m_timer->setSingleShot(true);
+    m_timer->setInterval(m_slideShowTime);
+
+    m_infoVisible = false;
+    m_index = 0;
+}
+
+
+
+/** \fn     GalleryWidget::~GalleryWidget()
+ *  \brief  Destructor
+ */
+GalleryWidget::~GalleryWidget()
+{
+    if (m_timer)
+        m_timer->stop();
+
+    delete m_timer;
+    m_timer = NULL;
+
+    delete m_fileList;
+    m_fileList = NULL;
+
+    delete m_fileDataList;
+    m_fileDataList = NULL;
+
+    delete m_fh;
+    m_fh = NULL;
+
+    if (m_ilt)
+        m_ilt->wait();
+
+    delete m_ilt;
+    m_ilt = NULL;
+
+    // Set the selected image in the gallery view to the saved one
+    // so that the initially selected image is the correct one again.
+    m_gvh->m_currentNode->setSelectedChild(m_selectedNode);
+}
+
+
+
+/** \fn     GalleryWidget::Create()
+ *  \brief  Initialises and shows the graphical elements
+ *  \return True if successful otherwise false
+ */
+bool GalleryWidget::Create()
+{
+    if (!LoadWindowFromXML("image-ui.xml", "slideshow", this))
+        return false;
+
+    bool err = false;
+
+    // Widget for showing the images
+    UIUtilE::Assign(this, m_image1, "first_image", &err);
+    UIUtilE::Assign(this, m_image2, "second_image", &err);
+    UIUtilW::Assign(this, m_status, "status");
+
+    // Widgets to show the details to an image
+    UIUtilE::Assign(this, m_infoList, "infolist", &err);
+
+    if (err)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Cannot load screen 'slideshow'");
+        return false;
+    }
+
+    HideFileDetails();
+    BuildFocusList();
+    SetFocusWidget(m_image1);
+
+    m_fileDataList = new QList<ImageMetadata *>();
+    m_fileDataList->append(new ImageMetadata());
+    m_fileDataList->append(new ImageMetadata());
+
+    m_fileList = new QList<MythUIImage *>();
+    m_fileList->append(m_image1);
+    m_fileList->append(m_image2);
+
+    return true;
+}
+
+
+
+/** \fn     GalleryWidget::keyPressEvent(QKeyEvent *)
+ *  \brief  Translates the keypresses and keys bound to the
+ *          plugin to specific actions within the plugin
+ *  \param  event The pressed key
+ *  \return True if key was used, otherwise false
+ */
+bool GalleryWidget::keyPressEvent(QKeyEvent *event)
+{
+    if (GetFocusWidget()->keyPressEvent(event))
+        return true;
+
+    bool handled = false;
+    QStringList actions;
+    handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
+
+    for (int i = 0; i < actions.size() && !handled; i++)
+    {
+        QString action = actions[i];
+        handled = true;
+
+        if (action == "LEFT")
+            ShowPrevFile();
+        else if (action == "RIGHT")
+            ShowNextFile();
+        else if (action == "INFO")
+            ShowFileDetails();
+        else if (action == "MENU")
+            MenuMain();
+        else if (action == "PLAY")
+        {
+            // If no slideshow is active and the user presses the play
+            // button then start a normal slideshow. But if a slideshow
+            // is already running then start or pause it.
+            if (m_slideShowType == kNoSlideShow)
+                StartNormalSlideShow();
+            else
+            {
+                if (m_timer->isActive())
+                    PauseSlideShow();
+                else
+                    ResumeSlideShow();
+            }
+        }
+        else if (action == "PAUSE")
+            PauseSlideShow();
+        else if (action == "STOP")
+            StopSlideShow();
+        else if (action == "ROTRIGHT")
+        {
+            m_gvh->SetFileOrientation(kFileRotateCW);
+            LoadFile();
+        }
+        else if (action == "ROTLEFT")
+        {
+            m_gvh->SetFileOrientation(kFileRotateCCW);
+            LoadFile();
+        }
+        else if (action == "FLIPHORIZONTAL")
+        {
+            m_gvh->SetFileOrientation(kFileFlipHorizontal);
+            LoadFile();
+        }
+        else if (action == "FLIPVERTICAL")
+        {
+            m_gvh->SetFileOrientation(kFileFlipVertical);
+            LoadFile();
+        }
+        else if (action == "ZOOMIN")
+        {
+            m_gvh->SetFileZoom(kFileZoomIn);
+            LoadFile();
+        }
+        else if (action == "ZOOMOUT")
+        {
+            m_gvh->SetFileZoom(kFileZoomOut);
+            LoadFile();
+        }
+        else if (action == "ESCAPE")
+        {
+            if (m_infoVisible)
+                HideFileDetails();
+            else
+                handled = false;
+        }
+    }
+
+    if (!handled && MythScreenType::keyPressEvent(event))
+        handled = true;
+
+    return handled;
+}
+
+
+
+/** \fn     GalleryWidget::customEvent(QEvent *event)
+ *  \brief  Translates the keypresses to
+ *          specific actions within the plugin
+ *  \param  event The custom event
+ */
+void GalleryWidget::customEvent(QEvent *event)
+{
+    if (event->type() == DialogCompletionEvent::kEventType)
+    {
+        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
+
+        QString resultid  = dce->GetId();
+        int     buttonnum = dce->GetResult();
+
+        if (resultid == "metadatamenu")
+        {
+            switch (buttonnum)
+            {
+            case 0 :
+                m_gvh->SetFileOrientation(kFileRotateCW);
+                LoadFile();
+                break;
+            case 1 :
+                m_gvh->SetFileOrientation(kFileRotateCCW);
+                LoadFile();
+                break;
+            case 2 :
+                m_gvh->SetFileOrientation(kFileFlipHorizontal);
+                LoadFile();
+                break;
+            case 3 :
+                m_gvh->SetFileOrientation(kFileFlipVertical);
+                LoadFile();
+                break;
+            case 4 :
+                m_gvh->SetFileZoom(kFileZoomIn);
+                LoadFile();
+                break;
+            case 5 :
+                m_gvh->SetFileZoom(kFileZoomOut);
+                LoadFile();
+                break;
+            }
+        }
+
+        m_menuPopup = NULL;
+    }
+}
+
+
+
+/** \fn     GalleryView::MenuMain()
+ *  \brief  Shows a dialog popup with the main menu
+ *  \return void
+ */
+void GalleryWidget::MenuMain()
+{
+    // Create the main menu that will contain the submenus above
+    MythMenu *menu = new MythMenu(tr("Image Information"), this, "mainmenu");
+
+    // If no slideshow type was given show the item to start it
+    // otherwise show the items to stop or resume a slideshow.
+    if (m_slideShowType == kNoSlideShow)
+    {
+        menu->AddItem(tr("Start Normal SlideShow"),
+                      SLOT(StartNormalSlideShow()));
+        menu->AddItem(tr("Start Random SlideShow"),
+                      SLOT(StartRandomSlideShow()));
+    }
+    else
+    {
+        if (m_timer->isActive())
+            menu->AddItem(tr("Pause SlideShow"), SLOT(PauseSlideShow()));
+        else
+        {
+            if (m_slideShowType == kNormalSlideShow)
+                menu->AddItem(tr("Resume SlideShow"),
+                              SLOT(StartNormalSlideShow()));
+
+            if (m_slideShowType == kRandomSlideShow)
+                menu->AddItem(tr("Resume SlideShow"),
+                              SLOT(StartRandomSlideShow()));
+        }
+    }
+
+    MenuMetadata(menu);
+    menu->AddItem(tr("Show Details"),   SLOT(FileDetails()));
+
+    m_menuPopup = new MythDialogBox(menu, m_popupStack, "menuPopup");
+    if (!m_menuPopup->Create())
+    {
+        delete m_menuPopup;
+        m_menuPopup = NULL;
+        return;
+    }
+
+    m_popupStack->AddScreen(m_menuPopup);
+}
+
+
+
+/** \fn     GalleryWidget::MenuMetadata(MythMenu *)
+ *  \brief  Adds a new metadata menu entry into the main menu
+ *  \param  mainMenu Parent that will hold the menu entry
+ *  \return void
+ */
+void GalleryWidget::MenuMetadata(MythMenu *mainMenu)
+{
+    MythMenu *menu = new MythMenu(tr("Metadata Options"),
+                                  this, "metadatamenu");
+
+    menu->AddItem(tr("Rotate CW"));
+    menu->AddItem(tr("Rotate CCW"));
+    menu->AddItem(tr("Flip Horizontal"));
+    menu->AddItem(tr("Flip Vertical"));
+
+    if (m_fileDataList->at(m_index))
+    {
+        if (m_fileDataList->at(m_index)->GetZoom() < 300)
+            menu->AddItem(tr("Zoom In"));
+
+        if (m_fileDataList->at(m_index)->GetZoom() > 0)
+            menu->AddItem(tr("Zoom Out"));
+    }
+
+    mainMenu->AddItem(tr("Meta Data Menu"), NULL, menu);
+}
+
+
+
+/** \fn     GalleryWidget::HideFileDetails()
+ *  \brief  Hides the details of the current file
+ *  \return void
+ */
+void GalleryWidget::HideFileDetails()
+{
+    m_infoList->SetVisible(false);
+    m_infoVisible = false;
+    SetFocusWidget(m_image1);
+}
+
+
+
+/** \fn     GalleryWidget::ShowFileDetails()
+ *  \brief  Shows the available details of the current image file.
+            The details will only be shown if the file is an image.
+ *  \return void
+ */
+void GalleryWidget::ShowFileDetails()
+{
+    ImageMetadata *im = m_fileDataList->at(m_index);
+    if (!im)
+        return;
+
+    if (im->m_type != kImageFile)
+    {
+        delete im;
+        return;
+    }
+
+    // First remove all entries
+    m_infoList->Reset();
+
+    // This map holds all the exif tag values
+    QMap<QString, QString> infoList;
+
+    // Get all the available exif header information from the file
+    // and create a data structure that can be displayed nicely
+    QByteArray ba = m_fh->GetExifValues(im);
+    if (ba.count() > 0)
+    {
+        bool readTagValues = false;
+        QString key, value;
+
+        QXmlStreamReader xml(ba);
+        while (!xml.atEnd())
+        {
+            xml.readNext();
+
+            // Read the general information
+            if (xml.isStartElement() &&
+                    (xml.name() == "Count"  ||
+                     xml.name() == "File"   ||
+                     xml.name() == "Path"   ||
+                     xml.name() == "Size"   ||
+                     xml.name() == "Extension"))
+                infoList.insert(xml.name().toString(), xml.readElementText());
+
+            if (xml.isStartElement() && xml.name() == "ImageMetadataInfo")
+                readTagValues = true;
+
+            if (readTagValues)
+            {
+                if (xml.isStartElement() && xml.name() == "Label")
+                    key = xml.readElementText();
+
+                if (xml.isStartElement() && xml.name() == "Value")
+                    value = xml.readElementText();
+            }
+
+            if (xml.isEndElement() && xml.name() == "ImageMetadataInfo")
+            {
+                readTagValues = false;
+                infoList.insert(key, value);
+            }
+        }
+    }
+
+    // Now go through the info list and create a map for the mythui buttonlist
+    QMap<QString, QString>::const_iterator i = infoList.constBegin();
+    while (i != infoList.constEnd())
+    {
+        MythUIButtonListItem *item = new MythUIButtonListItem(m_infoList, "");
+        InfoMap infoMap;
+        infoMap.insert("name", i.key());
+
+        QString value = tr("Not defined");
+        if (!i.value().isEmpty())
+            value = i.value();
+
+        infoMap.insert("value", value);
+
+        item->SetTextFromMap(infoMap);
+
+        ++i;
+    }
+
+    m_infoList->SetVisible(true);
+
+    // All widgets are visible, remember this
+    m_infoVisible = true;
+    SetFocusWidget(m_infoList);
+
+    delete im;
+}
+
+
+
+/** \fn     GalleryWidget::LoadFile()
+ *  \brief  Stops any slideshow and loads the file
+ *          from disk or memory in the background.
+ *  \return void
+ */
+void GalleryWidget::LoadFile()
+{
+    // Pause the slideshow so that the timer can't fire
+    // until the image loading thread has finished
+    PauseSlideShow();
+
+    // Switch the index
+    m_index = (m_index == 0) ? 1 : 0;
+
+    // Load the new data into the new index, this will be
+    // the new image which will be shown in the foreground
+    m_fileDataList->replace(m_index, m_gvh->GetImageMetadataFromSelectedNode());
+
+    if (m_fileDataList->at(m_index))
+    {
+        // Show an information that
+        // the image is being loaded
+        if (m_status)
+            m_status->SetVisible(true);
+
+        m_fileList->at(m_index)->SetAlpha(0);
+
+        // Get the full path and name of the image
+        // or if its a video the first preview image
+        QString fileName = m_fileDataList->at(m_index)->m_fileName;
+        if (m_fileDataList->at(m_index)->m_type == kVideoFile)
+            fileName = m_fileDataList->at(m_index)->m_thumbFileNameList->at(0);
+
+        QString url = CreateImageUrl(fileName);
+
+        // This thread will loads the image so the UI is not blocked.
+        m_ilt->setImage(m_fileList->at(m_index),
+                        m_fileDataList->at(m_index), url);
+        m_ilt->start();
+    }
+}
+
+
+
+/** \fn     GalleryWidget::CreateImageUrl(QString &fileName)
+ *  \brief
+ *  \return QString
+ */
+QString GalleryWidget::CreateImageUrl(QString &fileName)
+{
+    QString url = gCoreContext->GenMythURL(gCoreContext->GetSetting("MasterServerIP"),
+                                           gCoreContext->GetNumSetting("MasterServerPort"),
+                                           fileName,
+                                           m_gvh->m_sgName);
+
+    LOG(VB_GENERAL, LOG_INFO, QString("Loading image from url '%1'").arg(url));
+
+    return url;
+}
+
+
+
+/** \fn     GalleryWidget::HandleImageTransition()
+ *  \brief  Handles any specified effects between two
+ *          images when the file loading was completed
+ *  \return void
+ */
+void GalleryWidget::HandleImageTransition()
+{
+    // If the image loading is done then resume the slideshow which was
+    // only paused to not to interfere with the loading process.
+    ResumeSlideShow();
+
+    // Also update the file details information in case its visible.
+    if (m_infoVisible)
+        ShowFileDetails();
+
+    // Hide the status information
+    // that can be displayed in the themes
+    if (m_status)
+        m_status->SetVisible(false);
+
+    switch (m_transitionType)
+    {
+    case kFade:
+        HandleFadeTransition();
+        break;
+
+    default:
+        HandleNoTransition();
+        break;
+    }
+}
+
+
+
+/** \fn     GalleryWidget::HandleFadeTransition()
+ *  \brief  Handles the fading between two images
+ *  \return void
+ */
+void GalleryWidget::HandleFadeTransition()
+{
+    int index = (m_index == 0) ? 1 : 0;
+
+    // Fade out the old image if its loaded. This will not be done when
+    // called for the first time because there is no object at this index
+    if (m_fileDataList->at(index))
+        m_fileList->at(index)->AdjustAlpha(1, (m_transitionTime * -1), 0, 255);
+
+    // Fade in the new image and if the next
+    // file is a video then start playing it
+    if (m_fileDataList->at(m_index))
+    {
+        m_fileList->at(m_index)->AdjustAlpha(1, m_transitionTime, 0, 255);
+        if (m_fileDataList->at(m_index)->m_type == kVideoFile)
+        {
+            if (m_fileDataList->at(index))
+                m_fileList->at(index)->SetAlpha(0);
+
+            PauseSlideShow();
+            GetMythMainWindow()->HandleMedia("Internal",
+                                             m_fileDataList->at(m_index)->m_fileName);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryWidget::HandleNoTransition()
+ *  \brief  Just like the HandleFadeTransition() method but without any effects.
+ *  \return void
+ */
+void GalleryWidget::HandleNoTransition()
+{
+    int index = (m_index == 0) ? 1 : 0;
+
+    // Hide the old image if its loaded. This will not be done when
+    // called for the first time because there is no object at this index
+    if (m_fileDataList->at(index))
+        m_fileList->at(index)->SetAlpha(0);
+
+    // Immediately show the new image and if the next
+    // file is a video then start playing it
+    if (m_fileDataList->at(m_index))
+    {
+        m_fileList->at(m_index)->SetAlpha(255);
+        if (m_fileDataList->at(m_index)->m_type == kVideoFile)
+        {
+            PauseSlideShow();
+            GetMythMainWindow()->HandleMedia("Internal",
+                                             m_fileDataList->at(m_index)->m_fileName);
+        }
+    }
+}
+
+
+
+/** \fn     GalleryWidget::ShowPrevFile()
+ *  \brief  Loads the previous image file if possible
+ *  \return void
+ */
+void GalleryWidget::ShowPrevFile()
+{
+    MythGenericTree *node = m_gvh->m_currentNode->getSelectedChild()->prevSibling(1);
+    ImageMetadata *im = m_gvh->GetImageMetadataFromNode(node);
+
+    // If a data object exists then a node must also exist
+    if (im && (im->m_type == kImageFile ||
+                 im->m_type == kVideoFile))
+    {
+        m_gvh->m_currentNode->setSelectedChild(node);
+        LoadFile();
+    }
+    else
+    {
+        QString msg = "You have reached the beginning of the gallery.";
+        ShowInformation(msg);
+    }
+}
+
+
+
+/** \fn     GalleryWidget::ShowNextFile()
+ *  \brief  Loads the next image file if possible
+ *  \return void
+ */
+void GalleryWidget::ShowNextFile()
+{
+    PauseSlideShow();
+
+    MythGenericTree *node = m_gvh->m_currentNode->getSelectedChild()->nextSibling(1);
+    ImageMetadata *im = m_gvh->GetImageMetadataFromNode(node);
+
+    // If a data object exists then a node must also exist
+    if (im && (im->m_type == kImageFile ||
+                 im->m_type == kVideoFile))
+    {
+        m_gvh->m_currentNode->setSelectedChild(node);
+        LoadFile();
+    }
+    else
+    {
+        QString msg = "You have reached the end of the gallery.";
+        ShowInformation(msg);
+    }
+}
+
+
+
+/** \fn     GalleryWidget::ShowRandomFile()
+ *  \brief  Loads a random image
+ *  \return void
+ */
+void GalleryWidget::ShowRandomFile()
+{
+    volatile bool exit = false;
+
+    int size = m_gvh->m_currentNode->getSelectedChild()->siblingCount();
+    int counter = 0;
+    int position = 0;
+
+    MythGenericTree *node = NULL;
+    ImageMetadata *im = NULL;
+
+    PauseSlideShow();
+
+    // Get a random node from the list. If its not an image or
+    // video continue and try to get a new one until its an image
+    // or all siblings have been checked.
+    if (size > 0)
+    {
+        while (!exit)
+        {
+            position = (qrand() % size);
+            counter++;
+
+            node = m_gvh->m_currentNode->getChildAt(position);
+            im = m_gvh->GetImageMetadataFromNode(node);
+
+            if ((im && (im->m_type == kImageFile ||
+                          im->m_type == kVideoFile)) || counter == size)
+                exit = true;
+        }
+
+        // If we have data then is is already an image or
+        // video. This has been checked in the while loop
+        if (im)
+        {
+            m_gvh->m_currentNode->setSelectedChild(node);
+            LoadFile();
+        }
+    }
+    else
+    {
+        QString msg = "There are no images in the current directory.";
+        ShowInformation(msg);
+    }
+}
+
+
+
+/** \fn     GalleryWidget::ShowInformation(QString &msg)
+ *  \brief  Shows a message to the user
+ *  \param  msg The message that shall be shown
+ *  \return void
+ */
+void GalleryWidget::ShowInformation(QString &msg)
+{
+    MythConfirmationDialog *okPopup =
+            new MythConfirmationDialog(m_popupStack, msg, false);
+
+    if (okPopup->Create())
+        m_popupStack->AddScreen(okPopup);
+    else
+        delete okPopup;
+}
+
+
+
+/** \fn     GalleryWidget::StartNormalSlideShow()
+ *  \brief  Starts a slideshow where the images are shown in normal order
+ *  \return void
+ */
+void GalleryWidget::StartNormalSlideShow()
+{
+    if (!m_timer)
+        return;
+
+    StopSlideShow();
+    m_slideShowType = kNormalSlideShow;
+    connect(m_timer, SIGNAL(timeout()), this, SLOT(ShowNextFile()));
+    ResumeSlideShow();
+}
+
+
+
+/** \fn     GalleryWidget::StartRandomSlideShow()
+ *  \brief  Starts a slideshow where the images are shown randomly
+ *  \return void
+ */
+void GalleryWidget::StartRandomSlideShow()
+{
+    if (!m_timer)
+        return;
+
+    StopSlideShow();
+    m_slideShowType = kRandomSlideShow;
+    connect(m_timer, SIGNAL(timeout()), this, SLOT(ShowRandomFile()));
+    ResumeSlideShow();
+}
+
+
+
+/** \fn     GalleryWidget::ResumeSlideShow()
+ *  \brief  Resumes a paused slideshow
+ *  \return void
+ */
+void GalleryWidget::ResumeSlideShow()
+{
+    if (!m_timer)
+        return;
+
+    m_timer->start();
+}
+
+
+
+/** \fn     GalleryWidget::PauseSlideShow()
+ *  \brief  Pauses an active slideshow
+ *  \return void
+ */
+void GalleryWidget::PauseSlideShow()
+{
+    if (!m_timer)
+        return;
+
+    m_timer->stop();
+}
+
+
+
+/** \fn     GalleryWidget::StopSlideShow()
+ *  \brief  Stops an active slideshow
+ *  \return void
+ */
+void GalleryWidget::StopSlideShow()
+{
+    if (!m_timer)
+        return;
+
+    m_timer->stop();
+    m_timer->disconnect();
+
+    m_slideShowType = kNoSlideShow;
+}
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerywidget.h mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerywidget.h
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/gallerywidget.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/gallerywidget.h	2014-05-05 12:22:12.000000000 +0200
@@ -0,0 +1,102 @@
+#ifndef GALLERYWIDGET_H
+#define GALLERYWIDGET_H
+
+// Qt headers
+#include <QTimer>
+
+// MythTV headers
+#include "mythscreentype.h"
+#include "mythdialogbox.h"
+#include "imagemetadata.h"
+
+#include "galleryviewhelper.h"
+#include "galleryfilehelper.h"
+
+
+
+class ImageLoadingThread : public QThread
+{
+public:
+    ImageLoadingThread();
+    void setImage(MythUIImage *image,
+                  ImageMetadata *imageData,
+                  QString &url);
+    void run();
+
+private:
+    MythUIImage     *m_image;
+    ImageMetadata   *m_imageData;
+    QString          m_url;
+};
+
+
+
+class GalleryWidget : public MythScreenType
+{
+    Q_OBJECT
+public:
+    GalleryWidget(MythScreenStack *parent,
+                const char *name,
+                GalleryViewHelper*);
+    ~GalleryWidget();
+
+    bool Create();
+    bool keyPressEvent(QKeyEvent *);
+    void customEvent(QEvent *);
+    void LoadFile();
+    void ShowFileDetails();
+
+public slots:
+    void StartNormalSlideShow();
+    void StartRandomSlideShow();
+
+private:
+    void HandleFadeTransition();
+    void HandleNoTransition();
+    void ShowInformation(QString &);
+    void HideFileDetails();
+
+    QString CreateImageUrl(QString &);
+
+private slots:
+    void MenuMain();
+    void MenuMetadata(MythMenu *);
+    void ShowPrevFile();
+    void ShowNextFile();
+    void ShowRandomFile();
+    void HandleImageTransition();
+
+    void StopSlideShow();
+    void PauseSlideShow();
+    void ResumeSlideShow();
+
+private:
+    MythDialogBox      *m_menuPopup;
+    MythScreenStack    *m_popupStack;
+    MythUIImage        *m_image1;
+    MythUIImage        *m_image2;
+    MythUIText         *m_status;
+
+    MythUIButtonList       *m_infoList;
+    QList<MythUIImage *>   *m_fileList;
+    QList<ImageMetadata *>       *m_fileDataList;
+
+    GalleryFileHelper  *m_fh;
+    GalleryViewHelper  *m_gvh;
+    MythGenericTree    *m_selectedNode;
+    ImageLoadingThread *m_ilt;
+
+    int                 m_index;
+    int                 m_slideShowType;
+    int                 m_slideShowTime;
+    int                 m_transitionTime;
+    int                 m_transitionType;
+    QTimer             *m_timer;
+
+    QString             m_backendHost;
+    QString             m_backendPort;
+
+    bool                m_infoVisible;
+};
+
+#endif // GALLERYWIDGET_H
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/main.cpp mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/main.cpp
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/main.cpp	2014-05-05 12:15:10.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/main.cpp	2014-05-05 12:22:11.000000000 +0200
@@ -91,6 +91,9 @@
 #include "videometadatasettings.h"
 #include "videolist.h"
 
+// Gallery
+#include "galleryview.h"
+
 // DVD
 #include "DVD/dvdringbuffer.h"
 
@@ -681,6 +684,21 @@
 static void jumpScreenVideoGallery() { RunVideoScreen(VideoDialog::DLG_GALLERY, true); }
 static void jumpScreenVideoDefault() { RunVideoScreen(VideoDialog::DLG_DEFAULT, true); }
 
+static void RunGallery()
+{
+    MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
+    GalleryView *galleryView = new GalleryView(mainStack, "galleryview");
+    if (galleryView->Create())
+    {
+        mainStack->AddScreen(galleryView);
+        galleryView->LoadData();
+    }
+    else
+    {
+        delete galleryView;
+    }
+}
+
 static void playDisc()
 {
     //
@@ -1350,6 +1368,11 @@
      REG_JUMPEX(QT_TRANSLATE_NOOP("MythControls", "Reset All Keys"),
          QT_TRANSLATE_NOOP("MythControls", "Reset all keys to defaults"),
          "", resetAllKeys, false);
+
+     // Gallery
+
+     REG_JUMP(JUMP_GALLERY_DEFAULT, QT_TRANSLATE_NOOP("MythControls",
+         "The Gallery Default View"), "", RunGallery);
 }
 
 static void ReloadJumpPoints(void)
@@ -1381,6 +1404,36 @@
          "Go to the first video"), "Home");
      REG_KEY("Video","END", QT_TRANSLATE_NOOP("MythControls",
          "Go to the last video"), "End");
+
+     // Gallery keybindings
+     REG_KEY("Images", "PLAY", QT_TRANSLATE_NOOP("MythControls",
+         "Start Slideshow"), "P");
+     REG_KEY("Images", "PAUSE", QT_TRANSLATE_NOOP("MythControls",
+         "Pause Slideshow"), "Ctrl+P");
+     REG_KEY("Images", "STOP", QT_TRANSLATE_NOOP("MythControls",
+         "Stop Slideshow"), "Alt+P");
+     REG_KEY("Images", "HOME", QT_TRANSLATE_NOOP("MythControls",
+         "Go to the first image in thumbnail view"), "Home");
+     REG_KEY("Images", "END", QT_TRANSLATE_NOOP("MythControls",
+         "Go to the last image in thumbnail view"), "End");
+     REG_KEY("Images", "SLIDESHOW", QT_TRANSLATE_NOOP("MythControls",
+         "Start Slideshow in thumbnail view"), "S");
+     REG_KEY("Images", "RANDOMSHOW", QT_TRANSLATE_NOOP("MythControls",
+         "Start Random Slideshow in thumbnail view"), "R");
+     REG_KEY("Images", "ROTRIGHT", QT_TRANSLATE_NOOP("MythControls",
+         "Rotate image right 90 degrees"), "],3");
+     REG_KEY("Images", "ROTLEFT", QT_TRANSLATE_NOOP("MythControls",
+         "Rotate image left 90 degrees"), "[,1");
+     REG_KEY("Images", "ZOOMOUT", QT_TRANSLATE_NOOP("MythControls",
+         "Zoom image out"), "7");
+     REG_KEY("Images", "ZOOMIN", QT_TRANSLATE_NOOP("MythControls",
+         "Zoom image in"), "9");
+     REG_KEY("Images", "FLIPHORIZONTAL", QT_TRANSLATE_NOOP("MythControls",
+         "Flip image horizontally"), "");
+     REG_KEY("Images", "FLIPVERTICAL", QT_TRANSLATE_NOOP("MythControls",
+         "Flip image vertically"), "");
+     REG_KEY("Images", "MARK", QT_TRANSLATE_NOOP("MythControls",
+         "Mark image"), "T");
 }
 
 static void ReloadKeys(void)
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/mythfrontend.pro mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/mythfrontend.pro
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/programs/mythfrontend/mythfrontend.pro	2014-05-04 17:43:45.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/programs/mythfrontend/mythfrontend.pro	2014-05-05 12:22:13.000000000 +0200
@@ -47,6 +47,10 @@
 HEADERS += videoplayersettings.h        videodlg.h
 HEADERS += videoglobalsettings.h        upnpscanner.h
 HEADERS += commandlineparser.h          idlescreen.h
+HEADERS += galleryview.h                galleryviewhelper.h
+HEADERS += galleryconfig.h              galleryfilehelper.h
+HEADERS += gallerydatabasehelper.h      gallerywidget.h
+HEADERS += gallerytypedefs.h
 
 SOURCES += main.cpp playbackbox.cpp viewscheduled.cpp audiogeneralsettings.cpp
 SOURCES += globalsettings.cpp manualschedule.cpp programrecpriority.cpp
@@ -68,6 +72,9 @@
 SOURCES += videoplayersettings.cpp      videodlg.cpp
 SOURCES += videoglobalsettings.cpp      upnpscanner.cpp
 SOURCES += commandlineparser.cpp        idlescreen.cpp
+SOURCES += galleryview.cpp              gallerywidget.cpp
+SOURCES += galleryviewhelper.cpp        galleryconfig.cpp
+SOURCES += gallerydatabasehelper.cpp    galleryfilehelper.cpp
 
 HEADERS += serviceHosts/frontendServiceHost.h
 HEADERS += services/frontend.h
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/DVR/util_menu.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/DVR/util_menu.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/DVR/util_menu.xml	2014-05-04 17:43:21.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/DVR/util_menu.xml	2014-05-05 12:22:13.000000000 +0200
@@ -35,6 +35,13 @@
     </button>
 
     <button>
+        <type>IMAGES</type>
+        <text>New Image Gallery</text>
+        <description>Look at Pictures</description>
+        <action>JUMP Gallery Default</action>
+    </button>
+
+    <button>
         <type>GAME</type>
         <text>Games</text>
         <action>PLUGIN mythgame</action>
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/classic/mainmenu.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/classic/mainmenu.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/classic/mainmenu.xml	2014-05-05 12:15:06.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/classic/mainmenu.xml	2014-05-05 12:22:12.000000000 +0200
@@ -47,6 +47,13 @@
     </button>
 
     <button>
+        <type>IMAGES</type>
+        <text>New Image Gallery</text>
+        <description>Look at Pictures</description>
+        <action>JUMP Gallery Default</action>
+    </button>
+
+    <button>
         <type>GAME</type>
         <text>Games</text>
         <action>PLUGIN mythgame</action>
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/default-wide/image-ui.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/default-wide/image-ui.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/default-wide/image-ui.xml	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/default-wide/image-ui.xml	2014-05-05 12:22:13.000000000 +0200
@@ -0,0 +1,600 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!DOCTYPE mythuitheme SYSTEM "http://www.mythtv.org/schema/mythuitheme.dtd">
+<mythuitheme>
+
+    <window name="gallery">
+
+        <!-- The heading (name) of the screen -->
+        <textarea name="heading" from="basetextarea">
+            <position>0,0</position>
+            <textarea name="text">
+            <value>Image Gallery</value>
+            </textarea>
+        </textarea>
+
+        <!-- the shape where the imagelist is displayed -->
+        <shape name="gallerybackground">
+            <area>25,60,1230,633</area>
+            <type>roundbox</type>
+            <fill color="#000000" alpha="130" />
+            <line color="#AAAAAA" alpha="150" width="1" />
+            <cornerradius>2</cornerradius>
+        </shape>
+
+        <!-- shows the name of the folder or image -->
+        <textarea name="title" from="basetextarea">
+            <area>45,80,900,30</area>
+            <cutdown>yes</cutdown>
+            <font>title</font>
+            <align>left,vcenter</align>
+        </textarea>
+
+        <!-- optional - shows current position in grid eg '1 of 123' -->
+        <textarea name="position" from="basetextarea">
+            <area>1055,80,180,30</area>
+            <align>right,vcenter</align>
+        </textarea>
+
+        <!-- shows path to current image -->
+        <textarea name="breadcrumbs" from="basetextarea">
+            <area>45,120,900,20</area>
+            <font>text_very_small</font>
+            <cutdown>yes</cutdown>
+        </textarea>
+
+        <textarea name="thumbprogresstext" from="basetextarea">
+            <area>950,85,100,20</area>
+            <align>right,vcenter</align>
+        </textarea>
+
+        <!-- the list that shows the images in the screen -->
+        <buttonlist name="images">
+            <area>45,155,1170,535</area>
+            <buttonarea>0,0,1190,535</buttonarea>
+            <wrapstyle>flowing</wrapstyle>
+            <layout>grid</layout>
+            <spacing>7</spacing>
+            <statetype name="buttonitem">
+
+                <state name="active">
+                    <area>0,0,164,124</area>
+
+                    <!-- This is the dark background behind each image -->
+                    <shape name="buttonimage_background_shape">
+                        <area>0,0,164,124</area>
+                        <type>box</type>
+                        <line color="#000000" alpha="0" width="1" />
+                        <fill color="#000000" alpha="130" />
+                    </shape>
+
+                    <!-- Show an additional background image if required. This is
+                    primarily useful when the item is a folder and a folder background
+                    image shall be shown behind the small preview thumbnail images -->
+                    <statetype name="buttonbackground">
+                        <position>0,0</position>
+                        <state name="subfolder">
+                            <imagetype name="icon">
+                                <area>2,2,160,120</area>
+                                <filename>gallery-folder-reg.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="upfolder">
+                            <imagetype name="icon">
+                                <area>2,2,160,120</area>
+                                <filename>gallery-folder-reg.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="image">
+                        </state>
+                        <state name="video">
+                        </state>
+                    </statetype>
+
+                    <!-- this shows the actual image -->
+                    <imagetype name="buttonimage">
+                        <area>2,2,160,120</area>
+                        <preserveaspect>yes</preserveaspect>
+                    </imagetype>
+
+                    <imagetype name="thumbimage1">
+                        <area>2,2,80,60</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+                    <imagetype name="thumbimage2">
+                        <area>82,2,80,60</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+                    <imagetype name="thumbimage3">
+                        <area>82,62,80,60</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+                    <imagetype name="thumbimage4">
+                        <area>2,62,80,60</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+
+                    <!-- This is the border around the image. Its placed here
+                         draw over the edges of the image -->
+                    <shape name="buttonimage_border_shape">
+                        <area>0,0,164,124</area>
+                        <type>box</type>
+                        <fill color="#000000" alpha="0" />
+                        <line color="#AAAAAA" alpha="150" width="1" />
+                    </shape>
+
+                    <!-- shows that the image was marked/selected and
+                        might be manipulated with other images -->
+                    <statetype name="buttoncheck">
+                        <position>2,2</position>
+                        <state type="full">
+                            <shape name="marked_background">
+                                <area>0,0,33,33</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />
+                            </shape>
+                            <imagetype name="marked">
+                                <filename>gallery-mark.png</filename>
+                            </imagetype>
+                        </state>
+                    </statetype>
+
+                    <!-- Shows an indication if a file or folder is hidden
+                         or not. It will be marked and darkened -->
+                    <statetype name="buttonstate">
+                        <position>0,0</position>
+                        <state name="hidden">
+                            <shape name="hidden_background_shape">
+                                <area>1,1,162,122</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="210" />
+                            </shape>
+                        </state>
+                        <state name="visible">
+                        </state>
+                    </statetype>
+
+                    <!-- show additional information about the selected item.
+                         Shows a small folder or video icon -->
+                    <statetype name="buttontype">
+                        <position>0,0</position>
+                        <state name="subfolder">
+                            <shape name="buttonimage_shape">
+                                <area>1,93,162,30</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />
+                            </shape>
+                            <imagetype name="icon">
+                                <area>7,97,24,24</area>
+                                <filename>gallery-folder-sel.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="upfolder">
+                            <shape name="buttonimage_shape">
+                                <area>1,93,162,30</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />
+                            </shape>
+                            <imagetype name="icon">
+                                <area>7,97,24,24</area>
+                                <filename>gallery-folder-sel.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="video">
+                            <shape name="buttonimage_shape">
+                                <area>120,80,43,43</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />
+                            </shape>
+                            <imagetype name="icon">
+                                <area>122,83,37,37</area>
+                                <filename>gallery-moviethumb.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="image">
+                        </state>
+                    </statetype>
+
+                    <!-- show how many images / directories are in this directory -->
+                    <textarea name="childcount" from="basetextarea">
+                        <area>37,95,90,30</area>
+                        <font>text_small</font>
+                        <align>left,vcenter</align>
+                    </textarea>
+                </state>
+
+                <state name="selectedactive">
+                    <area>-38,-28,240,180</area>
+
+                    <shape name="buttonimage_background_shape">
+                        <area>0,0,240,180</area>
+                        <type>box</type>
+                        <line color="#000000" alpha="0" width="1" />
+                        <fill color="#000000" alpha="130" />
+                    </shape>
+-
+                    <statetype name="buttonbackground">
+                        <position>0,0</position>
+                        <state name="subfolder">
+                            <imagetype name="icon">
+                                <area>2,2,235,176</area>
+                                <filename>gallery-folder-sel.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="upfolder">
+                            <imagetype name="icon">
+                                <area>2,2,235,176</area>
+                                <filename>gallery-folder-sel.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="image">
+                        </state>
+                        <state name="video">
+                        </state>
+                    </statetype>
+
+                    <imagetype name="buttonimage">
+                        <area>2,2,235,176</area>
+                        <preserveaspect>yes</preserveaspect>
+                    </imagetype>
+
+                    <imagetype name="thumbimage1">
+                        <area>2,2,117,88</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+                    <imagetype name="thumbimage2">
+                        <area>119,2,117,88</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+                    <imagetype name="thumbimage3">
+                        <area>119,90,117,88</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+                    <imagetype name="thumbimage4">
+                        <area>2,90,117,88</area>
+                        <preserveaspect>false</preserveaspect>
+                    </imagetype>
+
+                    <shape name="buttonimage_border_shape">
+                        <area>0,0,240,180</area>
+                        <type>box</type>
+                        <fill color="#000000" alpha="0" />
+                        <line color="#AAAAAA" alpha="150" width="2" />
+                    </shape>
+
+                    <statetype name="buttoncheck">
+                        <position>2,2</position>
+                        <state type="full">
+                            <shape name="marked_background">
+                                <area>0,0,33,33</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="210" />
+                            </shape>
+                            <imagetype name="marked">
+                                <filename>gallery-mark.png</filename>
+                            </imagetype>
+                        </state>
+                    </statetype>
+
+                    <statetype name="buttonstate">
+                        <position>0,0</position>
+                        <state name="hidden">
+                            <shape name="hidden_background_shape">
+                                <area>1,1,162,122</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="210" />
+                            </shape>
+                        </state>
+                        <state name="visible">
+                        </state>
+                    </statetype>
+
+                    <statetype name="buttontype">
+                        <position>0,0</position>
+                        <state name="subfolder">
+                            <shape name="buttonimage_shape">
+                                <area>1,139,238,40</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />
+                            </shape>
+                            <imagetype name="icon">
+                                <area>9,144,32,32</area>
+                                <filename>gallery-folder-sel.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="upfolder">
+                            <shape name="buttonimage_shape">
+                                <area>1,139,238,40</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />
+                            </shape>
+                            <imagetype name="icon">
+                                <area>9,144,32,32</area>
+                                <filename>gallery-folder-sel.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="video">
+                            <shape name="buttonimage_shape">
+                                <area>181,121,58,58</area>
+                                <type>box</type>
+                                <line color="#000000" alpha="0" width="1" />
+                                <fill color="#000000" alpha="130" />v
+                            </shape>
+                            <imagetype name="icon">
+                                <area>183,124,52,52</area>
+                                <filename>gallery-moviethumb.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="image">
+                        </state>
+                    </statetype>
+
+                    <textarea name="childcount" from="basetextarea">
+                        <area>49,145,90,30</area>
+                        <font>text_small</font>
+                        <align>left,vcenter</align>
+                    </textarea>
+
+                </state>
+            </statetype>
+
+            <!-- Show the arrow image that indicates that there are
+                more menu entries above the first visible menu -->
+            <statetype name="upscrollarrow">
+                <position>1135,-20</position>
+                <state type="off">
+                    <imagetype name="upon">
+                        <filename>lb-uparrow-reg.png</filename>
+                    </imagetype>
+                </state>
+                <state type="full">
+                    <imagetype name="upoff">
+                        <filename>lb-uparrow-sel.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+
+            <!-- Show the arrow image that indicates that there are
+                more menu entries below the last visible menu -->
+            <statetype name="downscrollarrow">
+                <position>1160,-20</position>
+                <state type="off">
+                    <imagetype name="dnon">
+                        <filename>lb-dnarrow-reg.png</filename>
+                    </imagetype>
+                </state>
+                <state type="full">
+                    <imagetype name="dnoff">
+                        <filename>lb-dnarrow-sel.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+
+        </buttonlist>
+
+        <!-- shows a message when no images are available
+             in the current directory -->
+         <textarea name="noimages" from="basetextarea">
+             <area>225,60,830,633</area>
+             <align>allcenter</align>
+         </textarea>
+
+    </window>
+
+
+
+
+
+
+    <!-- Configuration dialog. This is currently
+         used by the MythImage plugin only -->
+    <window name="galleryconfig">
+
+        <!-- The heading (name) of the screen -->
+        <textarea name="heading" from="basetextarea">
+            <position>0,0</position>
+            <textarea name="text">
+            <value>Gallery Settings</value>
+            </textarea>
+        </textarea>
+
+        <!-- the shape where the imagelist is displayed -->
+        <shape name="galleryconfig_background">
+            <area>160,170,960,460</area>
+            <type>roundbox</type>
+            <fill color="#000000" alpha="130" />
+            <line color="#AAAAAA" alpha="150" width="1" />
+            <cornerradius>2</cornerradius>
+        </shape>
+
+        <textarea name="sortorder_label" from="basetextarea">
+            <area>180,190,540,40</area>
+            <align>right,vcenter</align>
+            <value>Sorting order of the shown images:</value>
+        </textarea>
+        <textarea name="slideshowtime_label" from="sortorder_label">
+            <position>180,290</position>
+            <value>Time to display each image during a slideshow (ms):</value>
+        </textarea>
+        <textarea name="transitiontype_label" from="sortorder_label">
+            <position>180,340</position>
+            <value>Type of transition between two images:</value>
+        </textarea>
+        <textarea name="transitiontime_label" from="sortorder_label">
+            <position>180,390</position>
+            <value>Duration of an image transition (ms):</value>
+        </textarea>
+        <textarea name="showhiddenfiles_label" from="sortorder_label">
+            <position>180,440</position>
+            <value>Show files that are marked as hidden:</value>
+        </textarea>
+        <textarea name="cleardatabase_label" from="sortorder_label">
+            <position>180,490</position>
+            <value>Clear database contents (Resync required):</value>
+        </textarea>
+
+        <buttonlist name="sortorder" from="basewideselector">
+            <position>730,240</position>
+        </buttonlist>
+        <spinbox name="slideshowtime" from="basespinbox">
+            <position>730,290</position>
+        </spinbox>
+        <buttonlist name="transitiontype" from="baseselector">
+            <position>730,340</position>
+        </buttonlist>
+        <spinbox name="transitiontime" from="basespinbox">
+            <position>730,390</position>
+        </spinbox>
+        <checkbox name="showhiddenfiles" from="basecheckbox">
+            <position>730,445</position>
+        </checkbox>
+        <button name="cleardatabase" from="basebutton">
+            <area>730,495,40,40</area>
+            <statetype name="buttonstate">
+                <state name="active">
+                    <area>0,0,40,40</area>
+                </state>
+                <state name="selected">
+                    <area>0,0,40,40</area>
+                </state>
+                <state name="disabled">
+                    <area>0,0,40,40</area>
+                </state>
+                <state name="pushed">
+                    <area>0,0,40,40</area>
+                </state>
+            </statetype>
+        </button>
+
+        <shape name="description_separator">
+            <area>180,550,920,1</area>
+            <type>box</type>
+            <line color="#AAAAAA" alpha="150" width="1" />
+        </shape>
+
+        <button name="save" from="basebutton">
+            <position>450,570</position>
+            <value>Save</value>
+        </button>
+        <button name="cancel" from="basebutton">
+            <position>680,570</position>
+            <value>Cancel</value>
+        </button>
+
+    </window>
+
+
+
+
+
+
+    <!-- Slideshow window which shows the a single image only or a slideshow.
+         This is currently used by the MythImage plugin only -->
+    <window name="slideshow">
+
+        <!-- the background behind the images (black) -->
+        <shape name="background_shape">
+            <area>0,0,1280,720</area>
+            <fill color="#000000" alpha="255" />
+            <line color="#000000" alpha="255" />
+            <type>roundbox</type>
+            <cornerradius>2</cornerradius>
+        </shape>
+
+        <!-- this is the image that shown in the foreground.
+             when fading is enabled this image is faded out. -->
+        <imagetype name="first_image">
+            <area>-2,-2,1284,724</area>
+            <preserveaspect>yes</preserveaspect>
+        </imagetype>
+
+        <!-- this is the image that shown in the background
+             when fading is enabled this image is faded in. -->
+        <imagetype name="second_image">
+            <area>-2,-2,1284,724</area>
+            <preserveaspect>yes</preserveaspect>
+        </imagetype>
+
+        <!-- shows some information if required -->
+        <textarea name="status" from="basetextarea">
+            <area>500,-4,280,30</area>
+            <shape name="background">
+                <area>0,0,280,40</area>
+                <fill color="#000000" alpha="255" />
+                <line color="#000000" alpha="255" />
+                <type>roundbox</type>
+                <cornerradius>2</cornerradius>
+            </shape>
+            <textarea name="status_text" from="basetextarea">
+                <area>0,0,280,40</area>
+                <align>allcenter</align>
+                <value>Image Loading...</value>
+            </textarea>
+        </textarea>
+
+
+        <!-- This list shows all the file information -->
+        <buttonlist name="infolist">
+            <area>315,180,650,348</area>
+            <layout>vertical</layout>
+            <spacing>5</spacing>
+            <wrapstyle>selection</wrapstyle>
+            <buttonarea>0,0,100%,97%</buttonarea>
+            <statetype name="buttonitem">
+                <state name="active">
+                    <shape name="buttonbackground">
+                        <area>0,0,650,40</area>
+                        <fill style="gradient">
+                            <gradient start="#505050" end="#000000" alpha="200" direction="vertical"  />
+                        </fill>
+                    </shape>
+                    <textarea name="name" from="basetextarea">
+                        <area>8,5,250,30</area>
+                    </textarea>
+                    <textarea name="value" from="basetextarea">
+                        <area>270,5,370,30</area>
+                    </textarea>
+                </state>
+                <state name="inactive" from="active"/>
+                <state name="selectedactive" from="active">
+                    <shape name="buttonbackground">
+                        <area>0,0,650,40</area>
+                        <fill style="gradient">
+                            <gradient start="#52CA38" end="#349838" alpha="255" />
+                        </fill>
+                    </shape>
+                </state>
+                <state name="selectedinactive" from="active">
+                    <shape name="buttonbackground">
+                        <area>0,0,650,40</area>
+                        <fill style="gradient">
+                            <gradient start="#52CA38" end="#349838" alpha="100" />
+                        </fill>
+                    </shape>
+                </state>
+            </statetype>
+        </buttonlist>
+
+    </window>
+
+</mythuitheme>
+
+
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/defaultmenu/library.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/defaultmenu/library.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/defaultmenu/library.xml	2014-05-04 17:43:20.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/defaultmenu/library.xml	2014-05-05 12:22:12.000000000 +0200
@@ -64,6 +64,13 @@
     </button>
 
     <button>
+        <type>IMAGES</type>
+        <text>New Image Gallery</text>
+        <description>Look at Pictures</description>
+        <action>JUMP Gallery Default</action>
+    </button>
+    
+    <button>
         <type>GAME</type>
         <text>Play Games</text>
         <description>Play video games</description>
diff -Naur mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/mediacentermenu/plugin_menu.xml mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/mediacentermenu/plugin_menu.xml
--- mythtv-0.27-20140504-ge2acf0d-old/mythtv/themes/mediacentermenu/plugin_menu.xml	2014-05-04 17:43:18.000000000 +0200
+++ mythtv-0.27-20140504-ge2acf0d-new/mythtv/themes/mediacentermenu/plugin_menu.xml	2014-05-05 12:22:13.000000000 +0200
@@ -10,6 +10,13 @@
     </button>
 
     <button>
+        <type>IMAGES</type>
+        <text>New Image Gallery</text>
+        <description>Look at Pictures</description>
+        <action>JUMP Gallery Default</action>
+    </button>
+
+    <button>
         <type>GAME</type>
         <text>Play Games</text>
         <description>Play video games</description>
