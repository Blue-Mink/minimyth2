From dcb7fbbd151f0d6b215ffbd3525b522889023bbd Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Wed, 21 May 2014 00:24:04 +1000
Subject: [PATCH 01/17] Re-enable old FFmpeg's VDPAU API for non-nvidia
 drivers

This is a partial reverse of a5b996c06dd73b378b39bbc772183c4abf53e4d7.
The new FFmpeg hwaccel API causes issues with non-nvidia drivers, causing either crashes (nouveau drivers) or playback issues (AMD).
So only use hwaccel with NVIDIA native drivers.
As of today (2014-05-20) The Ondine_clip.mpg doesn't play with any non nvidia drivers anyway (ref #11377)

This is a very direty solution, I don't like it but I couldn't find a universal solution working on all platforms at once.
Hopefully, hwaccel in FFmpeg 2.x works better
---
 mythtv/libs/libmythtv/avformatdecoder.cpp    |   86 +++++++++++++++++++++++---
 mythtv/libs/libmythtv/mythcodecid.h          |   28 ++++-----
 mythtv/libs/libmythtv/videoout_nullvdpau.cpp |    7 ++-
 mythtv/libs/libmythtv/videoout_vdpau.cpp     |   13 +++-
 mythtv/libs/libmythtv/videoout_vdpau.h       |    1 +
 mythtv/libs/libmythui/mythrender_vdpau.cpp   |   25 ++++++--
 mythtv/libs/libmythui/mythrender_vdpau.h     |    1 +
 7 files changed, 132 insertions(+), 29 deletions(-)

diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index 222552a..5497504 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -157,10 +157,12 @@ static float get_aspect(H264Parser &p)
 
 int  get_avf_buffer(struct AVCodecContext *c, AVFrame *pic);
 void release_avf_buffer(struct AVCodecContext *c, AVFrame *pic);
+#ifdef USING_VDPAU
 int  get_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic);
 void release_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic);
 void render_slice_vdpau(struct AVCodecContext *s, const AVFrame *src,
                         int offset[4], int y, int type, int height);
+#endif
 int  get_avf_buffer_dxva2(struct AVCodecContext *c, AVFrame *pic);
 int  get_avf_buffer_vaapi(struct AVCodecContext *c, AVFrame *pic);
 
@@ -222,6 +224,22 @@ static int has_codec_parameters(AVStream *st)
     return 1;
 }
 
+#ifdef USING_VDPAU
+static AVCodec *find_vdpau_decoder(AVCodec *c, enum CodecID id)
+{
+    AVCodec *codec = c;
+    while (codec)
+    {
+        if (codec->id == id && CODEC_IS_VDPAU(codec))
+            return codec;
+
+        codec = codec->next;
+    }
+
+    return c;
+}
+#endif
+
 static bool force_sw_decode(AVCodecContext *avctx)
 {
     switch (avctx->codec_id)
@@ -1402,11 +1420,36 @@ float AvFormatDecoder::normalized_fps(AVStream *stream, AVCodecContext *enc)
     return fps;
 }
 
+#ifdef USING_VDPAU
+static bool IS_VDPAU_PIX_FMT(enum PixelFormat fmt)
+{
+    return
+        fmt == PIX_FMT_VDPAU_H264  ||
+        fmt == PIX_FMT_VDPAU_MPEG1 ||
+        fmt == PIX_FMT_VDPAU_MPEG2 ||
+        fmt == PIX_FMT_VDPAU_MPEG4 ||
+        fmt == PIX_FMT_VDPAU_WMV3  ||
+        fmt == PIX_FMT_VDPAU_VC1;
+}
+
 static enum PixelFormat get_format_vdpau(struct AVCodecContext *avctx,
                                          const enum PixelFormat *fmt)
 {
+    int i = 0;
+
+    for(i=0; fmt[i]!=PIX_FMT_NONE; i++)
+        if (IS_VDPAU_PIX_FMT(fmt[i]))
+            break;
+
+    return fmt[i];
+}
+
+static enum PixelFormat get_format_vdpau_hwaccel(struct AVCodecContext *avctx,
+                                                 const enum PixelFormat *fmt)
+{
     return AV_PIX_FMT_VDPAU;
 }
+#endif
 
 // Declared seperately to allow attribute
 static enum PixelFormat get_format_dxva2(struct AVCodecContext *,
@@ -1486,11 +1529,21 @@ void AvFormatDecoder::InitVideoCodec(AVStream *stream, AVCodecContext *enc,
 
     AVCodec *codec = avcodec_find_decoder(enc->codec_id);
 
+#ifdef USING_VDPAU
+    // When using non-nvidia vdpau driver, use older FFmpeg API
+    // which requires to use an explicit vdpau capable codec
+    if (codec_is_vdpau(video_codec_id) && !CODEC_IS_VDPAU(codec) &&
+        !VideoOutputVDPAU::IsNVIDIA())
+    {
+        codec = find_vdpau_decoder(codec, enc->codec_id);
+    }
+#endif
+
     if (selectedStream)
     {
         directrendering = true;
         if (!gCoreContext->GetNumSetting("DecodeExtraAudio", 0) &&
-            !CODEC_IS_HWACCEL(codec, enc))
+            !(CODEC_IS_HWACCEL(codec, enc) || codec_is_vdpau(video_codec_id)))
         {
             SetLowBuffers(false);
         }
@@ -1501,15 +1554,27 @@ void AvFormatDecoder::InitVideoCodec(AVStream *stream, AVCodecContext *enc,
     if (metatag && metatag->value && QString("180") == metatag->value)
         video_inverted = true;
 
+#ifdef USING_VDPAU
     if (codec_is_vdpau(video_codec_id))
     {
         enc->get_buffer      = get_avf_buffer_vdpau;
-        enc->get_format      = get_format_vdpau;
+        if (CODEC_IS_VDPAU(codec))
+        {
+            // Legacy FFmpeg VDPAU API
+            enc->get_format      = get_format_vdpau;
+        }
+        else
+        {
+            // FFmpeg hwaccel API
+            enc->get_format      = get_format_vdpau_hwaccel;
+        }
         enc->release_buffer  = release_avf_buffer_vdpau;
         enc->draw_horiz_band = render_slice_vdpau;
         enc->slice_flags     = SLICE_FLAG_CODED_ORDER | SLICE_FLAG_ALLOW_FIELD;
     }
-    else if (CODEC_IS_DXVA2(codec, enc))
+    else
+#endif
+        if (CODEC_IS_DXVA2(codec, enc))
     {
         enc->get_buffer      = get_avf_buffer_dxva2;
         enc->get_format      = get_format_dxva2;
@@ -2326,6 +2391,7 @@ int AvFormatDecoder::ScanStreams(bool novideo)
 
                 if (vdpau_mcid >= video_codec_id)
                 {
+                    enc->codec_id = (CodecID) myth2av_codecid(vdpau_mcid);
                     video_codec_id = vdpau_mcid;
                 }
 #endif // USING_VDPAU
@@ -2415,6 +2481,14 @@ int AvFormatDecoder::ScanStreams(bool novideo)
                 QString("Using %1 for video decoding")
                 .arg(GetCodecDecoderName()));
 
+#ifdef USING_VDPAU
+            if (codec_is_vdpau(video_codec_id) && !CODEC_IS_VDPAU(codec) &&
+                !VideoOutputVDPAU::IsNVIDIA())
+            {
+                codec = find_vdpau_decoder(codec, enc->codec_id);
+            }
+#endif
+
             if (!enc->codec)
             {
                 QMutexLocker locker(avcodeclock);
@@ -2769,6 +2843,7 @@ void release_avf_buffer(struct AVCodecContext *c, AVFrame *pic)
         pic->data[i] = NULL;
 }
 
+#ifdef USING_VDPAU
 int get_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic)
 {
     AvFormatDecoder *nd = (AvFormatDecoder *)(c->opaque);
@@ -2786,7 +2861,6 @@ int get_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic)
 
     frame->pix_fmt = c->pix_fmt;
 
-#ifdef USING_VDPAU
     struct vdpau_render_state *render = (struct vdpau_render_state *)frame->buf;
     render->state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
     pic->data[3] = (uint8_t*)(uintptr_t)render->surface;
@@ -2795,7 +2869,6 @@ int get_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic)
     {
         c->hwaccel_context = nd->GetPlayer()->GetDecoderContext(NULL, dummy[0]);
     }
-#endif
 
     pic->reordered_opaque = c->reordered_opaque;
 
@@ -2806,10 +2879,8 @@ void release_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic)
 {
     assert(pic->type == FF_BUFFER_TYPE_USER);
 
-#ifdef USING_VDPAU
     struct vdpau_render_state *render = (struct vdpau_render_state *)pic->data[0];
     render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
-#endif
 
     AvFormatDecoder *nd = (AvFormatDecoder *)(c->opaque);
     if (nd && nd->GetPlayer())
@@ -2843,6 +2914,7 @@ void render_slice_vdpau(struct AVCodecContext *s, const AVFrame *src,
             "render_slice_vdpau called with bad avctx or src");
     }
 }
+#endif // USING_VDPAU
 
 int get_avf_buffer_dxva2(struct AVCodecContext *c, AVFrame *pic)
 {
diff --git a/mythtv/libs/libmythtv/mythcodecid.h b/mythtv/libs/libmythtv/mythcodecid.h
index 0f28bfd..b464133 100644
--- a/mythtv/libs/libmythtv/mythcodecid.h
+++ b/mythtv/libs/libmythtv/mythcodecid.h
@@ -72,21 +72,21 @@ typedef enum
 // MythCodecID convenience functions
 #define codec_is_std(id)      (id < kCodec_NORMAL_END)
 #define codec_is_std_mpeg(id) (id == kCodec_MPEG1 || id == kCodec_MPEG2)
-#define codec_is_vdpau(id)    (id > kCodec_VDPAU_BEGIN) &&\
-                              (id < kCodec_VDPAU_END)
-#define codec_is_vdpau_hw(id) (codec_is_vdpau(id) &&\
-                              (id != kCodec_H263_VDPAU) &&\
-                              (id != kCodec_VP8_VDPAU))
-#define codec_is_vaapi(id)    (id > kCodec_VAAPI_BEGIN) &&\
-                              (id < kCodec_VAAPI_END)
-#define codec_is_vaapi_hw(id) (codec_is_vaapi(id) &&\
-                              (id != kCodec_VP8_VAAPI))
-#define codec_is_dxva2(id)    (id > kCodec_DXVA2_BEGIN) &&\
-                              (id < kCodec_DXVA2_END)
+#define codec_is_vdpau(id)    ((id > kCodec_VDPAU_BEGIN) &&     \
+                               (id < kCodec_VDPAU_END))
+#define codec_is_vdpau_hw(id) ((codec_is_vdpau(id) &&           \
+                                (id != kCodec_H263_VDPAU) &&    \
+                                (id != kCodec_VP8_VDPAU)))
+#define codec_is_vaapi(id)    ((id > kCodec_VAAPI_BEGIN) &&     \
+                               (id < kCodec_VAAPI_END))
+#define codec_is_vaapi_hw(id) (codec_is_vaapi(id) &&            \
+                               (id != kCodec_VP8_VAAPI))
+#define codec_is_dxva2(id)    ((id > kCodec_DXVA2_BEGIN) &&     \
+                               (id < kCodec_DXVA2_END))
 #define codec_is_dxva2_hw(id) (codec_is_dxva2(id) &&\
-                             ((id == kCodec_H264_DXVA2)  ||\
-                              (id == kCodec_MPEG2_DXVA2) ||\
-                              (id == kCodec_VC1_DXVA2)))
+                               ((id == kCodec_H264_DXVA2)  ||   \
+                                (id == kCodec_MPEG2_DXVA2) ||   \
+                                (id == kCodec_VC1_DXVA2)))
 
 QString get_encoding_type(MythCodecID codecid);
 QString get_decoder_name(MythCodecID codec_id);
diff --git a/mythtv/libs/libmythtv/videoout_nullvdpau.cpp b/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
index 39eb195..eb189d3 100644
--- a/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
+++ b/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
@@ -286,7 +286,9 @@ void VideoOutputNullVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int
         uint max_refs = MIN_REFERENCE_FRAMES;
         if (video_codec_id == kCodec_H264_VDPAU)
         {
-            max_refs = m_context.info.h264.num_ref_frames;
+            max_refs = m_render->gVDPAUNVIDIA ?
+                m_context.info.h264.num_ref_frames :
+                render->info.h264.num_ref_frames;
             if (max_refs < 1 || max_refs > MAX_REFERENCE_FRAMES)
             {
                 uint32_t round_width  = (frame->width + 15) & ~15;
@@ -387,7 +389,8 @@ void VideoOutputNullVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int
         return;
     }
 
-    m_render->Decode(m_decoder, render, &m_context);
+    m_render->Decode(m_decoder, render,
+                     m_render->gVDPAUNVIDIA ? &m_context : NULL);
 }
 
 void VideoOutputNullVDPAU::ClearAfterSeek(void)
diff --git a/mythtv/libs/libmythtv/videoout_vdpau.cpp b/mythtv/libs/libmythtv/videoout_vdpau.cpp
index 7df0945..77d99d4 100644
--- a/mythtv/libs/libmythtv/videoout_vdpau.cpp
+++ b/mythtv/libs/libmythtv/videoout_vdpau.cpp
@@ -603,7 +603,9 @@ void VideoOutputVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int h)
         uint max_refs = MIN_REFERENCE_FRAMES;
         if (video_codec_id == kCodec_H264_VDPAU)
         {
-            max_refs = m_context.info.h264.num_ref_frames;
+            max_refs = IsNVIDIA() ?
+                m_context.info.h264.num_ref_frames :
+                render->info.h264.num_ref_frames;
             if (max_refs < 1 || max_refs > MAX_REFERENCE_FRAMES)
             {
                 uint32_t round_width  = (frame->width + 15) & ~15;
@@ -698,7 +700,7 @@ void VideoOutputVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int h)
         return;
     }
 
-    m_render->Decode(m_decoder, render, &m_context);
+    m_render->Decode(m_decoder, render, IsNVIDIA() ? &m_context : NULL);
 }
 
 void VideoOutputVDPAU::Show(FrameScanType scan)
@@ -958,6 +960,13 @@ MythCodecID VideoOutputVDPAU::GetBestSupportedCodec(
     return test_cid;
 }
 
+bool VideoOutputVDPAU::IsNVIDIA(void)
+{
+        // this forces the check of VDPAU capabilities
+    (void)MythRenderVDPAU::IsMPEG4Available();
+    return MythRenderVDPAU::gVDPAUNVIDIA;
+}
+
 void VideoOutputVDPAU::UpdateReferenceFrames(VideoFrame *frame)
 {
     while (m_reference_frames.size() > (NUM_REFERENCE_FRAMES - 1))
diff --git a/mythtv/libs/libmythtv/videoout_vdpau.h b/mythtv/libs/libmythtv/videoout_vdpau.h
index cead864..c756aef 100644
--- a/mythtv/libs/libmythtv/videoout_vdpau.h
+++ b/mythtv/libs/libmythtv/videoout_vdpau.h
@@ -62,6 +62,7 @@ class VideoOutputVDPAU : public VideoOutput
                                              const QString &decoder,
                                              uint stream_type,
                                              bool no_acceleration);
+    static bool IsNVIDIA(void);
     virtual bool IsPIPSupported(void) const { return true;  }
     virtual bool IsPBPSupported(void) const { return false; }
     virtual bool NeedExtraAudioDecode(void) const
diff --git a/mythtv/libs/libmythui/mythrender_vdpau.cpp b/mythtv/libs/libmythui/mythrender_vdpau.cpp
index 6c4d1b7..b72fbec 100644
--- a/mythtv/libs/libmythui/mythrender_vdpau.cpp
+++ b/mythtv/libs/libmythui/mythrender_vdpau.cpp
@@ -275,6 +275,7 @@ static void vdpau_preemption_callback(VdpDevice device, void *myth_render)
 bool MythRenderVDPAU::gVDPAUSupportChecked = false;
 bool MythRenderVDPAU::gVDPAUMPEG4Accel     = false;
 uint MythRenderVDPAU::gVDPAUBestScaling    = 0;
+bool MythRenderVDPAU::gVDPAUNVIDIA         = false;
 
 MythRenderVDPAU::MythRenderVDPAU()
   : MythRender(kRenderVDPAU), m_preempted(false), m_recreating(false),
@@ -1530,10 +1531,22 @@ void MythRenderVDPAU::Decode(uint id, struct vdpau_render_state *render,
     }
 
     INIT_ST
-    vdp_st = vdp_decoder_render(m_decoders[id].m_id, render->surface,
-                               (VdpPictureInfo const *)&(context->info),
-                                context->bitstream_buffers_used,
-                                context->bitstream_buffers);
+
+    if (context)
+    {
+        vdp_st = vdp_decoder_render(m_decoders[id].m_id, render->surface,
+                                    (VdpPictureInfo const *)&(context->info),
+                                    context->bitstream_buffers_used,
+                                    context->bitstream_buffers);
+    }
+    else
+    {
+        vdp_st = vdp_decoder_render(m_decoders[id].m_id, render->surface,
+                                    (VdpPictureInfo const *)&(render->info),
+                                    render->bitstream_buffers_used,
+                                    render->bitstream_buffers);
+    }
+
     CHECK_ST
 }
 
@@ -1729,6 +1742,10 @@ bool MythRenderVDPAU::CheckHardwareSupport(void)
         {
             const char * info;
             vdp_get_information_string(&info);
+            QString vendor(info);
+
+            gVDPAUNVIDIA = vendor.contains("nvidia", Qt::CaseInsensitive);
+
             LOG(VB_GENERAL, LOG_INFO, LOC +
                 QString("Information %2").arg(info));
         }
diff --git a/mythtv/libs/libmythui/mythrender_vdpau.h b/mythtv/libs/libmythui/mythrender_vdpau.h
index 7b924f4..d933292 100644
--- a/mythtv/libs/libmythui/mythrender_vdpau.h
+++ b/mythtv/libs/libmythui/mythrender_vdpau.h
@@ -61,6 +61,7 @@ class MUI_PUBLIC MythRenderVDPAU : public MythRender
     static bool gVDPAUSupportChecked;
     static uint gVDPAUBestScaling;
     static bool gVDPAUMPEG4Accel;
+    static bool gVDPAUNVIDIA;
     static bool IsMPEG4Available(void);
     static bool H264DecoderSizeSupported(uint width, uint height);
     bool        CreateDummy(void);
-- 
1.7.10.2

