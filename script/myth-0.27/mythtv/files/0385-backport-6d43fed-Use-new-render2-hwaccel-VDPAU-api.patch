From 6d43fed59abe3f86127cf5ed64b36bdfff4b00d2 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Thu, 5 Jun 2014 12:07:39 +1000
Subject: [PATCH 2/3] Use new render2/hwaccel VDPAU api

Hopefully, no more changes in the VDPAU Ffmpeg API (3rd in 12 months).
Fully remove the original VDPAU api, as it causes memory corruption from time to time. Hwaccel is the way forward anyway.

Tested with nvidia (both nouveau and proprietary) and AMD cards.
---
 mythtv/libs/libmythtv/avformatdecoder.cpp    |  106 ++++++--------------------
 mythtv/libs/libmythtv/videoout_nullvdpau.cpp |   40 ++--------
 mythtv/libs/libmythtv/videoout_nullvdpau.h   |    4 -
 mythtv/libs/libmythtv/videoout_vdpau.cpp     |   39 ++--------
 mythtv/libs/libmythtv/videoout_vdpau.h       |    4 -
 mythtv/libs/libmythui/mythrender_vdpau.cpp   |   24 +++---
 mythtv/libs/libmythui/mythrender_vdpau.h     |    3 +-
 7 files changed, 48 insertions(+), 172 deletions(-)

diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index c7f6a94..b71eaab 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -160,13 +160,15 @@ void release_avf_buffer(struct AVCodecContext *c, AVFrame *pic);
 #ifdef USING_VDPAU
 int  get_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic);
 void release_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic);
-void render_slice_vdpau(struct AVCodecContext *s, const AVFrame *src,
-                        int offset[4], int y, int type, int height);
+int render_wrapper_vdpau(struct AVCodecContext *s, AVFrame *src,
+                         const VdpPictureInfo *info,
+                         uint32_t count,
+                         const VdpBitstreamBuffer *buffers);
 #endif
 int  get_avf_buffer_dxva2(struct AVCodecContext *c, AVFrame *pic);
 int  get_avf_buffer_vaapi(struct AVCodecContext *c, AVFrame *pic);
 
-static int determinable_frame_size(AVCodecContext *avctx)
+static int determinable_frame_size(struct AVCodecContext *avctx)
 {
     if (/*avctx->codec_id == AV_CODEC_ID_AAC ||*/
         avctx->codec_id == AV_CODEC_ID_MP1 ||
@@ -224,22 +226,6 @@ static int has_codec_parameters(AVStream *st)
     return 1;
 }
 
-#ifdef USING_VDPAU
-static AVCodec *find_vdpau_decoder(AVCodec *c, enum AVCodecID id)
-{
-    AVCodec *codec = c;
-    while (codec)
-    {
-        if (codec->id == id && CODEC_IS_VDPAU(codec))
-            return codec;
-
-        codec = codec->next;
-    }
-
-    return c;
-}
-#endif
-
 static bool force_sw_decode(AVCodecContext *avctx)
 {
     switch (avctx->codec_id)
@@ -1420,32 +1406,9 @@ float AvFormatDecoder::normalized_fps(AVStream *stream, AVCodecContext *enc)
 }
 
 #ifdef USING_VDPAU
-static bool IS_VDPAU_PIX_FMT(enum PixelFormat fmt)
-{
-    return
-        fmt == PIX_FMT_VDPAU_H264  ||
-        fmt == PIX_FMT_VDPAU_MPEG1 ||
-        fmt == PIX_FMT_VDPAU_MPEG2 ||
-        fmt == PIX_FMT_VDPAU_MPEG4 ||
-        fmt == PIX_FMT_VDPAU_WMV3  ||
-        fmt == PIX_FMT_VDPAU_VC1;
-}
-
 static enum PixelFormat get_format_vdpau(struct AVCodecContext *avctx,
                                          const enum PixelFormat *fmt)
 {
-    int i = 0;
-
-    for(i=0; fmt[i]!=PIX_FMT_NONE; i++)
-        if (IS_VDPAU_PIX_FMT(fmt[i]))
-            break;
-
-    return fmt[i];
-}
-
-static enum PixelFormat get_format_vdpau_hwaccel(struct AVCodecContext *avctx,
-                                                 const enum PixelFormat *fmt)
-{
     return AV_PIX_FMT_VDPAU;
 }
 #endif
@@ -1528,16 +1491,6 @@ void AvFormatDecoder::InitVideoCodec(AVStream *stream, AVCodecContext *enc,
 
     AVCodec *codec = avcodec_find_decoder(enc->codec_id);
 
-#ifdef USING_VDPAU
-    // When using non-nvidia vdpau driver, use older FFmpeg API
-    // which requires to use an explicit vdpau capable codec
-    if (codec_is_vdpau(video_codec_id) && !CODEC_IS_VDPAU(codec) &&
-        !VideoOutputVDPAU::IsNVIDIA())
-    {
-        codec = find_vdpau_decoder(codec, enc->codec_id);
-    }
-#endif
-
     if (selectedStream)
     {
         directrendering = true;
@@ -1557,18 +1510,8 @@ void AvFormatDecoder::InitVideoCodec(AVStream *stream, AVCodecContext *enc,
     if (codec_is_vdpau(video_codec_id))
     {
         enc->get_buffer      = get_avf_buffer_vdpau;
-        if (CODEC_IS_VDPAU(codec))
-        {
-            // Legacy FFmpeg VDPAU API
-            enc->get_format      = get_format_vdpau;
-        }
-        else
-        {
-            // FFmpeg hwaccel API
-            enc->get_format      = get_format_vdpau_hwaccel;
-        }
+        enc->get_format      = get_format_vdpau;
         enc->release_buffer  = release_avf_buffer_vdpau;
-        enc->draw_horiz_band = render_slice_vdpau;
         enc->slice_flags     = SLICE_FLAG_CODED_ORDER | SLICE_FLAG_ALLOW_FIELD;
     }
     else
@@ -2474,14 +2417,6 @@ int AvFormatDecoder::ScanStreams(bool novideo)
                 QString("Using %1 for video decoding")
                 .arg(GetCodecDecoderName()));
 
-#ifdef USING_VDPAU
-            if (codec_is_vdpau(video_codec_id) && !CODEC_IS_VDPAU(codec) &&
-                !VideoOutputVDPAU::IsNVIDIA())
-            {
-                codec = find_vdpau_decoder(codec, enc->codec_id);
-            }
-#endif
-
             if (!enc->codec)
             {
                 QMutexLocker locker(avcodeclock);
@@ -2861,6 +2796,7 @@ int get_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic)
     if (nd->GetPlayer())
     {
         c->hwaccel_context = nd->GetPlayer()->GetDecoderContext(NULL, dummy[0]);
+        ((AVVDPAUContext*)(c->hwaccel_context))->render2 = render_wrapper_vdpau;
     }
 
     pic->reordered_opaque = c->reordered_opaque;
@@ -2883,29 +2819,37 @@ void release_avf_buffer_vdpau(struct AVCodecContext *c, AVFrame *pic)
         pic->data[i] = NULL;
 }
 
-void render_slice_vdpau(struct AVCodecContext *s, const AVFrame *src,
-                        int offset[4], int y, int type, int height)
+int render_wrapper_vdpau(struct AVCodecContext *s, AVFrame *src,
+                         const VdpPictureInfo *info,
+                         uint32_t count,
+                         const VdpBitstreamBuffer *buffers)
 {
     if (!src)
-        return;
-
-    (void)offset;
-    (void)type;
+        return -1;
 
     if (s && src && s->opaque && src->opaque)
     {
         AvFormatDecoder *nd = (AvFormatDecoder *)(s->opaque);
+        VideoFrame *frame = (VideoFrame *)src->opaque;
+        struct vdpau_render_state data;
 
-        int width = s->width;
+        data.surface = (VdpVideoSurface)(uintptr_t)src->data[3];
+        data.bitstream_buffers_used = count;
+        data.bitstream_buffers = (VdpBitstreamBuffer*)buffers;
 
-        VideoFrame *frame = (VideoFrame *)src->opaque;
-        nd->GetPlayer()->DrawSlice(frame, 0, y, width, height);
+        // Store information we will require in DrawSlice()
+        frame->priv[0] = (unsigned char*)&data;
+        frame->priv[1] = (unsigned char*)info;
+
+        nd->GetPlayer()->DrawSlice(frame, 0, 0, 0, 0);
     }
     else
     {
         LOG(VB_GENERAL, LOG_ERR, LOC +
-            "render_slice_vdpau called with bad avctx or src");
+            "render_wrapper_vdpau called with bad avctx or src");
     }
+
+    return 0;
 }
 #endif // USING_VDPAU
 
diff --git a/mythtv/libs/libmythtv/videoout_nullvdpau.cpp b/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
index eb189d3..bcee8a4 100644
--- a/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
+++ b/mythtv/libs/libmythtv/videoout_nullvdpau.cpp
@@ -29,7 +29,7 @@ VideoOutputNullVDPAU::VideoOutputNullVDPAU()
     m_checked_surface_ownership(false), m_shadowBuffers(NULL),
     m_surfaceSize(QSize(0,0))
 {
-    m_context.bitstream_buffers_allocated = 0;
+    memset(&m_context, 0, sizeof(AVVDPAUContext));
 }
 
 VideoOutputNullVDPAU::~VideoOutputNullVDPAU()
@@ -74,13 +74,6 @@ bool VideoOutputNullVDPAU::InitRender(void)
 {
     QMutexLocker locker(&m_lock);
 
-    if (m_context.bitstream_buffers_allocated)
-    {
-        av_freep(&m_context.bitstream_buffers);
-    }
-    memset(&m_context, 0, sizeof(AVVDPAUContext));
-    m_context.render = Render;
-
     m_render = new MythRenderVDPAU();
     if (m_render->CreateDecodeOnly())
         return true;
@@ -98,12 +91,6 @@ void VideoOutputNullVDPAU::DeleteRender(void)
         m_render->DecrRef();
     }
 
-    if (m_context.bitstream_buffers_allocated)
-    {
-        av_freep(&m_context.bitstream_buffers);
-        m_context.bitstream_buffers_allocated = 0;
-    }
-
     m_decoder = 0;
     m_render  = NULL;
     m_pix_fmt = -1;
@@ -266,13 +253,9 @@ void VideoOutputNullVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int
     if (!m_checked_surface_ownership)
         ClaimVideoSurfaces();
 
-    struct vdpau_render_state *render = (struct vdpau_render_state *)frame->buf;
-    if (!render)
-    {
-        LOG(VB_GENERAL, LOG_ERR, LOC + "No video surface to decode to.");
-        errorState = kError_Unknown;
-        return;
-    }
+    struct vdpau_render_state *render =
+        (struct vdpau_render_state *)frame->priv[0];
+    const VdpPictureInfo *info = (const VdpPictureInfo *)frame->priv[1];
 
     if (frame->pix_fmt != m_pix_fmt)
     {
@@ -286,9 +269,7 @@ void VideoOutputNullVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int
         uint max_refs = MIN_REFERENCE_FRAMES;
         if (video_codec_id == kCodec_H264_VDPAU)
         {
-            max_refs = m_render->gVDPAUNVIDIA ?
-                m_context.info.h264.num_ref_frames :
-                render->info.h264.num_ref_frames;
+            max_refs = ((VdpPictureInfoH264*)info)->num_ref_frames;
             if (max_refs < 1 || max_refs > MAX_REFERENCE_FRAMES)
             {
                 uint32_t round_width  = (frame->width + 15) & ~15;
@@ -389,8 +370,7 @@ void VideoOutputNullVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int
         return;
     }
 
-    m_render->Decode(m_decoder, render,
-                     m_render->gVDPAUNVIDIA ? &m_context : NULL);
+    m_render->Decode(m_decoder, render, info);
 }
 
 void VideoOutputNullVDPAU::ClearAfterSeek(void)
@@ -636,11 +616,3 @@ void* VideoOutputNullVDPAU::GetDecoderContext(unsigned char* buf, uint8_t*& id)
 {
     return &m_context;
 }
-
-VdpStatus VideoOutputNullVDPAU::Render(VdpDecoder decoder, VdpVideoSurface target,
-                                       VdpPictureInfo const *picture_info,
-                                       uint32_t bitstream_buffer_count,
-                                       VdpBitstreamBuffer const *bitstream_buffers)
-{
-    return VDP_STATUS_OK;
-}
diff --git a/mythtv/libs/libmythtv/videoout_nullvdpau.h b/mythtv/libs/libmythtv/videoout_nullvdpau.h
index e128846..4eb3759 100644
--- a/mythtv/libs/libmythtv/videoout_nullvdpau.h
+++ b/mythtv/libs/libmythtv/videoout_nullvdpau.h
@@ -71,10 +71,6 @@ class VideoOutputNullVDPAU : public VideoOutput
                                     const QString &name) { return false; }
     virtual MythPainter *GetOSDPainter(void) { return NULL; }
     virtual void DrawSlice(VideoFrame *frame, int x, int y, int w, int h);
-    static VdpStatus Render(VdpDecoder decoder, VdpVideoSurface target,
-                            VdpPictureInfo const *picture_info,
-                            uint32_t bitstream_buffer_count,
-                            VdpBitstreamBuffer const *bitstream_buffers);
 
     virtual VideoFrame *GetLastDecodedFrame(void);
     virtual VideoFrame *GetLastShownFrame(void);
diff --git a/mythtv/libs/libmythtv/videoout_vdpau.cpp b/mythtv/libs/libmythtv/videoout_vdpau.cpp
index 957f3f5..0759c6f 100644
--- a/mythtv/libs/libmythtv/videoout_vdpau.cpp
+++ b/mythtv/libs/libmythtv/videoout_vdpau.cpp
@@ -67,7 +67,7 @@ VideoOutputVDPAU::VideoOutputVDPAU()
 {
     if (gCoreContext->GetNumSetting("UseVideoModes", 0))
         display_res = DisplayRes::GetDisplayRes(true);
-    m_context.bitstream_buffers_allocated = 0;
+    memset(&m_context, 0, sizeof(AVVDPAUContext));
 }
 
 VideoOutputVDPAU::~VideoOutputVDPAU()
@@ -132,13 +132,6 @@ bool VideoOutputVDPAU::InitRender(void)
 
     const QSize size = window.GetDisplayVisibleRect().size();
 
-    if (m_context.bitstream_buffers_allocated)
-    {
-        av_freep(&m_context.bitstream_buffers);
-    }
-    memset(&m_context, 0, sizeof(AVVDPAUContext));
-    m_context.render = Render;
-
     m_render = new MythRenderVDPAU();
     if (m_render->Create(size, m_win))
     {
@@ -176,12 +169,6 @@ void VideoOutputVDPAU::DeleteRender(void)
         m_render = NULL;
     }
 
-    if (m_context.bitstream_buffers_allocated)
-    {
-        av_freep(&m_context.bitstream_buffers);
-        m_context.bitstream_buffers_allocated = 0;
-    }
-
     m_checked_output_surfaces = false;
     m_osd_painter = NULL;
     m_decoder = 0;
@@ -583,13 +570,9 @@ void VideoOutputVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int h)
     if (!m_checked_surface_ownership)
         ClaimVideoSurfaces();
 
-    struct vdpau_render_state *render = (struct vdpau_render_state *)frame->buf;
-    if (!render)
-    {
-        LOG(VB_GENERAL, LOG_ERR, LOC + "No video surface to decode to.");
-        errorState = kError_Unknown;
-        return;
-    }
+    struct vdpau_render_state *render =
+        (struct vdpau_render_state *)frame->priv[0];
+    const VdpPictureInfo *info = (const VdpPictureInfo *)frame->priv[1];
 
     if (frame->pix_fmt != m_pix_fmt)
     {
@@ -603,9 +586,7 @@ void VideoOutputVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int h)
         uint max_refs = MIN_REFERENCE_FRAMES;
         if (video_codec_id == kCodec_H264_VDPAU)
         {
-            max_refs = IsNVIDIA() ?
-                m_context.info.h264.num_ref_frames :
-                render->info.h264.num_ref_frames;
+            max_refs = ((VdpPictureInfoH264*)info)->num_ref_frames;
             if (max_refs < 1 || max_refs > MAX_REFERENCE_FRAMES)
             {
                 uint32_t round_width  = (frame->width + 15) & ~15;
@@ -700,7 +681,7 @@ void VideoOutputVDPAU::DrawSlice(VideoFrame *frame, int x, int y, int w, int h)
         return;
     }
 
-    m_render->Decode(m_decoder, render, IsNVIDIA() ? &m_context : NULL);
+    m_render->Decode(m_decoder, render, info);
 }
 
 void VideoOutputVDPAU::Show(FrameScanType scan)
@@ -1360,11 +1341,3 @@ void* VideoOutputVDPAU::GetDecoderContext(unsigned char* buf, uint8_t*& id)
 {
     return &m_context;
 }
-
-VdpStatus VideoOutputVDPAU::Render(VdpDecoder decoder, VdpVideoSurface target,
-                         VdpPictureInfo const *picture_info,
-                         uint32_t bitstream_buffer_count,
-                         VdpBitstreamBuffer const *bitstream_buffers)
-{
-    return VDP_STATUS_OK;
-}
diff --git a/mythtv/libs/libmythtv/videoout_vdpau.h b/mythtv/libs/libmythtv/videoout_vdpau.h
index c756aef..0e8fe33 100644
--- a/mythtv/libs/libmythtv/videoout_vdpau.h
+++ b/mythtv/libs/libmythtv/videoout_vdpau.h
@@ -35,10 +35,6 @@ class VideoOutputVDPAU : public VideoOutput
                       FrameScanType scan);
     void PrepareFrame(VideoFrame*, FrameScanType, OSD *osd);
     void DrawSlice(VideoFrame*, int x, int y, int w, int h);
-    static VdpStatus Render(VdpDecoder decoder, VdpVideoSurface target,
-                            VdpPictureInfo const *picture_info,
-                            uint32_t bitstream_buffer_count,
-                            VdpBitstreamBuffer const *bitstream_buffers);
     void Show(FrameScanType);
     void ClearAfterSeek(void);
     bool InputChanged(const QSize &video_dim_buf,
diff --git a/mythtv/libs/libmythui/mythrender_vdpau.cpp b/mythtv/libs/libmythui/mythrender_vdpau.cpp
index 4a39df3..c021e3b 100644
--- a/mythtv/libs/libmythui/mythrender_vdpau.cpp
+++ b/mythtv/libs/libmythui/mythrender_vdpau.cpp
@@ -1530,8 +1530,13 @@ void MythRenderVDPAU::ChangeVideoSurfaceOwner(uint id)
     m_videoSurfaces[id].m_owner = QThread::currentThread();
 }
 
+void MythRenderVDPAU::Decode(uint id, struct vdpau_render_state *render)
+{
+    Decode(id, render, (VdpPictureInfo const *)&render->info);
+}
+
 void MythRenderVDPAU::Decode(uint id, struct vdpau_render_state *render,
-                             AVVDPAUContext *context)
+                             const VdpPictureInfo *info)
 {
     CHECK_VIDEO_SURFACES()
 
@@ -1544,20 +1549,9 @@ void MythRenderVDPAU::Decode(uint id, struct vdpau_render_state *render,
 
     INIT_ST
 
-    if (context)
-    {
-        vdp_st = vdp_decoder_render(m_decoders[id].m_id, render->surface,
-                                    (VdpPictureInfo const *)&(context->info),
-                                    context->bitstream_buffers_used,
-                                    context->bitstream_buffers);
-    }
-    else
-    {
-        vdp_st = vdp_decoder_render(m_decoders[id].m_id, render->surface,
-                                    (VdpPictureInfo const *)&(render->info),
-                                    render->bitstream_buffers_used,
-                                    render->bitstream_buffers);
-    }
+    vdp_st = vdp_decoder_render(m_decoders[id].m_id, render->surface, info,
+                                render->bitstream_buffers_used,
+                                render->bitstream_buffers);
 
     CHECK_ST
 }
diff --git a/mythtv/libs/libmythui/mythrender_vdpau.h b/mythtv/libs/libmythui/mythrender_vdpau.h
index 6e0ed41..59620a0 100644
--- a/mythtv/libs/libmythui/mythrender_vdpau.h
+++ b/mythtv/libs/libmythui/mythrender_vdpau.h
@@ -136,8 +136,9 @@ class MUI_PUBLIC MythRenderVDPAU : public MythRender
     void  ClearVideoSurface(uint id);
     void  ChangeVideoSurfaceOwner(uint id);
 
+    void  Decode(uint id, struct vdpau_render_state *render);
     void  Decode(uint id, struct vdpau_render_state *render,
-                 AVVDPAUContext *context);
+                 const VdpPictureInfo *info);
     void  SetVideoFlip(void) { m_flipFrames = true; }
 
   private:
-- 
1.7.10.2

