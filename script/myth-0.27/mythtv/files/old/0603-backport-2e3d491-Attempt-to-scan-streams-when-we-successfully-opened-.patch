From 2e3d491c59c267539f82d49fc43a75831656abbb Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Thu, 10 Apr 2014 22:28:22 +0700
Subject: [PATCH] Attempt to scan streams when we successfully opened a file.

This is to prevent false positive that would cause early exit but cause a context re-initialisation later.
---
 mythtv/libs/libmythtv/avformatdecoder.cpp |  107 ++++++++++++++++++++++++++---
 1 file changed, 96 insertions(+), 11 deletions(-)

diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index 642c837..f1e3f15 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -164,6 +164,64 @@ void render_slice_vdpau(struct AVCodecContext *s, const AVFrame *src,
 int  get_avf_buffer_dxva2(struct AVCodecContext *c, AVFrame *pic);
 int  get_avf_buffer_vaapi(struct AVCodecContext *c, AVFrame *pic);
 
+static int determinable_frame_size(AVCodecContext *avctx)
+{
+    if (/*avctx->codec_id == AV_CODEC_ID_AAC ||*/
+        avctx->codec_id == AV_CODEC_ID_MP1 ||
+        avctx->codec_id == AV_CODEC_ID_MP2 ||
+        avctx->codec_id == AV_CODEC_ID_MP3/* ||
+        avctx->codec_id == AV_CODEC_ID_CELT*/)
+        return 1;
+    return 0;
+}
+
+static int has_codec_parameters(AVStream *st)
+{
+    AVCodecContext *avctx = st->codec;
+
+#define FAIL(errmsg) do {                                     \
+    LOG(VB_PLAYBACK, LOG_DEBUG, LOC + errmsg);                \
+    return 0;                                                 \
+} while (0)
+
+    switch (avctx->codec_type)
+    {
+        case AVMEDIA_TYPE_AUDIO:
+            if (!avctx->frame_size && determinable_frame_size(avctx))
+                FAIL("unspecified frame size");
+            if (avctx->sample_fmt == AV_SAMPLE_FMT_NONE)
+                FAIL("unspecified sample format");
+            if (!avctx->sample_rate)
+                FAIL("unspecified sample rate");
+            if (!avctx->channels)
+                FAIL("unspecified number of channels");
+            if (!st->nb_decoded_frames && avctx->codec_id == AV_CODEC_ID_DTS)
+                FAIL("no decodable DTS frames");
+            break;
+        case AVMEDIA_TYPE_VIDEO:
+            if (!avctx->width)
+                FAIL("unspecified size");
+            if (avctx->pix_fmt == AV_PIX_FMT_NONE)
+                FAIL("unspecified pixel format");
+            if (st->codec->codec_id == AV_CODEC_ID_RV30 || st->codec->codec_id == AV_CODEC_ID_RV40)
+                if (!st->sample_aspect_ratio.num && !st->codec->sample_aspect_ratio.num && !st->codec_info_nb_frames)
+                    FAIL("no frame in rv30/40 and no sar");
+            break;
+        case AVMEDIA_TYPE_SUBTITLE:
+            if (avctx->codec_id == AV_CODEC_ID_HDMV_PGS_SUBTITLE && !avctx->width)
+                FAIL("unspecified size");
+            break;
+        case AVMEDIA_TYPE_DATA:
+            if(avctx->codec_id == AV_CODEC_ID_NONE) return 1;
+        default:
+            break;
+    }
+
+    if (avctx->codec_id == AV_CODEC_ID_NONE)
+        FAIL("unknown codec");
+    return 1;
+}
+
 static AVCodec *find_vdpau_decoder(AVCodec *c, enum CodecID id)
 {
     AVCodec *codec = c;
@@ -981,12 +1039,13 @@ int AvFormatDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
         }
     }
 
-    int err;
+    int err = 0;
     bool found = false;
+    bool scanned = false;
 
     if (livetv)
     {
-        // We try to open the file for up to 1.5 second using only only buffer in memory
+        // We try to open the file for up to 1.5 second using only buffer in memory
         MythTimer timer; timer.start();
 
         avfRingBuffer->SetInInit(true);
@@ -1008,13 +1067,35 @@ int AvFormatDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
                 usleep(50 * 1000);  // wait 50ms
                 continue;
             }
+
+            // Test if we can find all streams details in what has been found so far
+            if (FindStreamInfo() < 0)
+            {
+                avformat_close_input(&ic);
+                usleep(50 * 1000);  // wait 50ms
+                continue;
+            }
+
             found = true;
+
+            for (uint i = 0; i < ic->nb_streams; i++)
+            {
+                if (!has_codec_parameters(ic->streams[i]))
+                {
+                    avformat_close_input(&ic);
+                    found = false;
+                    usleep(50 * 1000);  // wait 50ms
+                    break;
+                }
+            }
         }
 
         if (!found)
         {
             avfRingBuffer->SetInInit(false);
         }
+
+        scanned = found;
     }
 
     // If we haven't been opened to open the file so far, revert to old method
@@ -1053,18 +1134,22 @@ int AvFormatDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
     {
         LOG(VB_GENERAL, LOG_ERR, LOC +
             QString("avformat err(%1) on avformat_open_input call.").arg(err));
+        ic = NULL;
         return -1;
     }
 
-    int ret = FindStreamInfo();
-    avfRingBuffer->SetInInit(false);
-    if (ret < 0)
+    if (!scanned)
     {
-        LOG(VB_GENERAL, LOG_ERR, LOC + "Could not find codec parameters. " +
-                QString("file was \"%1\".").arg(filename));
-        avformat_close_input(&ic);
-        ic = NULL;
-        return -1;
+        int ret = FindStreamInfo();
+        avfRingBuffer->SetInInit(false);
+        if (ret < 0)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC + "Could not find codec parameters. " +
+                    QString("file was \"%1\".").arg(filename));
+            avformat_close_input(&ic);
+            ic = NULL;
+            return -1;
+        }
     }
     ic->streams_changed = HandleStreamChange;
     if (ringBuffer->IsDVD())
@@ -1084,7 +1169,7 @@ int AvFormatDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
     }
 
     // Scan for the initial A/V streams
-    ret = ScanStreams(novideo);
+    int ret = ScanStreams(novideo);
     if (-1 == ret)
         return ret;
 
-- 
1.7.10.2

