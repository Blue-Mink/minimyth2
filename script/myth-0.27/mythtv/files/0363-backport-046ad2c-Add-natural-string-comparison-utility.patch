From 046ad2c5d046ead6fb676a537337a8d006365001 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Tue, 27 May 2014 14:26:04 +1000
Subject: [PATCH 1/3] Add natural string comparison utility

e.g. Season 2 < Season 10
---
 mythtv/libs/libmythbase/mythmiscutil.cpp |  206 ++++++++++++++++++++++++++++++
 mythtv/libs/libmythbase/mythmiscutil.h   |    3 +
 2 files changed, 209 insertions(+)

diff --git a/mythtv/libs/libmythbase/mythmiscutil.cpp b/mythtv/libs/libmythbase/mythmiscutil.cpp
index 6155409..f446971 100644
--- a/mythtv/libs/libmythbase/mythmiscutil.cpp
+++ b/mythtv/libs/libmythbase/mythmiscutil.cpp
@@ -1004,4 +1004,210 @@ QString xml_indent(uint level)
     return ret;
 }
 
+int naturalCompare(const QString &_a, const QString &_b, Qt::CaseSensitivity caseSensitivity)
+{
+    // This method chops the input a and b into pieces of
+    // digits and non-digits (a1.05 becomes a | 1 | . | 05)
+    // and compares these pieces of a and b to each other
+    // (first with first, second with second, ...).
+    //
+    // This is based on the natural sort order code code by Martin Pool
+    // http://sourcefrog.net/projects/natsort/
+    // Martin Pool agreed to license this under LGPL or GPL.
+
+    // FIXME: Using toLower() to implement case insensitive comparison is
+    // sub-optimal, but is needed because we compare strings with
+    // localeAwareCompare(), which does not know about case sensitivity.
+    // A task has been filled for this in Qt Task Tracker with ID 205990.
+    // http://trolltech.com/developer/task-tracker/index_html?method=entry&id=205990
+
+    QString a;
+    QString b;
+
+    if (caseSensitivity == Qt::CaseSensitive)
+    {
+        a = _a;
+        b = _b;
+    }
+    else
+    {
+        a = _a.toLower();
+        b = _b.toLower();
+    }
+
+    const QChar* currA = a.unicode(); // iterator over a
+    const QChar* currB = b.unicode(); // iterator over b
+
+    if (currA == currB)
+    {
+        return 0;
+    }
+
+    while (!currA->isNull() && !currB->isNull())
+    {
+        const QChar* begSeqA = currA; // beginning of a new character sequence of a
+        const QChar* begSeqB = currB;
+
+        if (currA->unicode() == QChar::ObjectReplacementCharacter)
+        {
+            return 1;
+        }
+
+        if (currB->unicode() == QChar::ObjectReplacementCharacter)
+        {
+            return -1;
+        }
+
+        if (currA->unicode() == QChar::ReplacementCharacter)
+        {
+            return 1;
+        }
+
+        if (currB->unicode() == QChar::ReplacementCharacter)
+        {
+            return -1;
+        }
+
+        // find sequence of characters ending at the first non-character
+        while (!currA->isNull() && !currA->isDigit() && !currA->isPunct() &&
+               !currA->isSpace())
+        {
+            ++currA;
+        }
+
+        while (!currB->isNull() && !currB->isDigit() && !currB->isPunct() &&
+               !currB->isSpace())
+        {
+            ++currB;
+        }
+
+        // compare these sequences
+        const QStringRef& subA(a.midRef(begSeqA - a.unicode(), currA - begSeqA));
+        const QStringRef& subB(b.midRef(begSeqB - b.unicode(), currB - begSeqB));
+        const int cmp = QStringRef::localeAwareCompare(subA, subB);
+
+        if (cmp != 0)
+        {
+            return cmp < 0 ? -1 : +1;
+        }
+
+        if (currA->isNull() || currB->isNull())
+        {
+            break;
+        }
+
+        // find sequence of characters ending at the first non-character
+        while ((currA->isPunct() || currA->isSpace()) &&
+               (currB->isPunct() || currB->isSpace()))
+        {
+            if (*currA != *currB)
+            {
+                return (*currA < *currB) ? -1 : +1;
+            }
+            ++currA;
+            ++currB;
+            if (currA->isNull() || currB->isNull())
+            {
+                break;
+            }
+        }
+
+        // now some digits follow...
+        if ((*currA == QLatin1Char('0')) || (*currB == QLatin1Char('0')))
+        {
+            // one digit-sequence starts with 0 -> assume we are in a fraction part
+            // do left aligned comparison (numbers are considered left aligned)
+            while (1)
+            {
+                if (!currA->isDigit() && !currB->isDigit())
+                {
+                    break;
+                }
+                else if (!currA->isDigit())
+                {
+                    return +1;
+                }
+                else if (!currB->isDigit())
+                {
+                    return -1;
+                }
+                else if (*currA < *currB)
+                {
+                    return -1;
+                }
+                else if (*currA > *currB)
+                {
+                    return + 1;
+                }
+                ++currA;
+                ++currB;
+            }
+        }
+        else
+        {
+            // No digit-sequence starts with 0 -> assume we are looking at some integer
+            // do right aligned comparison.
+            //
+            // The longest run of digits wins. That aside, the greatest
+            // value wins, but we can't know that it will until we've scanned
+            // both numbers to know that they have the same magnitude.
+
+            bool isFirstRun = true;
+            int weight = 0;
+
+            while (1)
+            {
+                if (!currA->isDigit() && !currB->isDigit())
+                {
+                    if (weight != 0)
+                    {
+                        return weight;
+                    }
+                    break;
+                }
+                else if (!currA->isDigit())
+                {
+                    if (isFirstRun)
+                    {
+                        return *currA < *currB ? -1 : +1;
+                    }
+                    else
+                    {
+                        return -1;
+                    }
+                }
+                else if (!currB->isDigit())
+                {
+                    if (isFirstRun)
+                    {
+                        return *currA < *currB ? -1 : +1;
+                    }
+                    else
+                    {
+                        return +1;
+                    }
+                }
+                else if ((*currA < *currB) && (weight == 0))
+                {
+                    weight = -1;
+                }
+                else if ((*currA > *currB) && (weight == 0))
+                {
+                    weight = + 1;
+                }
+                ++currA;
+                ++currB;
+                isFirstRun = false;
+            }
+        }
+    }
+
+    if (currA->isNull() && currB->isNull())
+    {
+        return 0;
+    }
+
+    return currA->isNull() ? -1 : + 1;
+}
+
 /* vim: set expandtab tabstop=4 shiftwidth=4: */
diff --git a/mythtv/libs/libmythbase/mythmiscutil.h b/mythtv/libs/libmythbase/mythmiscutil.h
index 91dea13..72181b7 100644
--- a/mythtv/libs/libmythbase/mythmiscutil.h
+++ b/mythtv/libs/libmythbase/mythmiscutil.h
@@ -81,6 +81,9 @@ MBASE_PUBLIC bool MythRemoveDirectory(QDir &aDir);
 
 MBASE_PUBLIC void setHttpProxy(void);
 
+MBASE_PUBLIC int naturalCompare(const QString &_a, const QString &_b,
+                                Qt::CaseSensitivity caseSensitivity = Qt::CaseSensitive);
+
 // CPU Tick timing function
 #ifdef MMX
 #ifdef _WIN32
-- 
1.7.10.2

