From b4bce955608303e9613d9efb7d6e64a105969ae8 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Fri, 30 May 2014 23:12:10 +1000
Subject: [PATCH 09/28] =?UTF-8?q?Update=20DecodeAudio=20to=20use=20new=20FFm?=
 =?UTF-8?q?peg=E2=80=99s=20audio=20API?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 mythtv/libs/libmyth/audio/audiooutput.cpp     |   27 +++++++++++++++++--------
 mythtv/libs/libmyth/audio/audiooutput.h       |    9 ++++++++-
 mythtv/libs/libmyth/audio/audiooutpututil.cpp |   21 ++++++++++++-------
 mythtv/libs/libmyth/audio/audiooutpututil.h   |    4 ++++
 4 files changed, 45 insertions(+), 16 deletions(-)

diff --git a/mythtv/libs/libmyth/audio/audiooutput.cpp b/mythtv/libs/libmyth/audio/audiooutput.cpp
index 3908762..97ebae4 100644
--- a/mythtv/libs/libmyth/audio/audiooutput.cpp
+++ b/mythtv/libs/libmyth/audio/audiooutput.cpp
@@ -216,6 +216,7 @@ AudioOutput::~AudioOutput()
     if (pulsewassuspended)
         PulseHandler::Suspend(PulseHandler::kPulseResume);
 #endif
+    av_frame_free(&_frame);
 }
 
 void AudioOutput::SetStretchFactor(float /*factor*/)
@@ -550,14 +551,24 @@ int AudioOutput::DecodeAudio(AVCodecContext *ctx,
                              uint8_t *buffer, int &data_size,
                              const AVPacket *pkt)
 {
-    AVFrame frame;
     int got_frame = 0;
     int ret;
     char error[AV_ERROR_MAX_STRING_SIZE];
 
     data_size = 0;
-    avcodec_get_frame_defaults(&frame);
-    ret = avcodec_decode_audio4(ctx, &frame, &got_frame, pkt);
+    if (!_frame)
+    {
+        if (!(_frame = av_frame_alloc()))
+        {
+            return AVERROR(ENOMEM);
+        }
+    }
+    else
+    {
+        av_frame_unref(_frame);
+    }
+
+    ret = avcodec_decode_audio4(ctx, _frame, &got_frame, pkt);
     if (ret < 0)
     {
         LOG(VB_AUDIO, LOG_ERR, LOC +
@@ -574,11 +585,11 @@ int AudioOutput::DecodeAudio(AVCodecContext *ctx,
         return ret;
     }
 
-    AVSampleFormat format = (AVSampleFormat)frame.format;
+    AVSampleFormat format = (AVSampleFormat)_frame->format;
     AudioFormat fmt =
         AudioOutputSettings::AVSampleFormatToFormat(format, ctx->bits_per_raw_sample);
 
-    data_size = frame.nb_samples * frame.channels * av_get_bytes_per_sample(format);
+    data_size = _frame->nb_samples * _frame->channels * av_get_bytes_per_sample(format);
 
     // May need to convert audio to S16
     AudioConvert converter(fmt, CanProcess(fmt) ? fmt : FORMAT_S16);
@@ -587,15 +598,15 @@ int AudioOutput::DecodeAudio(AVCodecContext *ctx,
     if (av_sample_fmt_is_planar(format))
     {
         src = buffer;
-        converter.InterleaveSamples(frame.channels,
+        converter.InterleaveSamples(_frame->channels,
                                     src,
-                                    (const uint8_t **)frame.extended_data,
+                                    (const uint8_t **)_frame->extended_data,
                                     data_size);
     }
     else
     {
         // data is already compacted...
-        src = frame.extended_data[0];
+        src = _frame->extended_data[0];
     }
 
     uint8_t* transit = buffer;
diff --git a/mythtv/libs/libmyth/audio/audiooutput.h b/mythtv/libs/libmyth/audio/audiooutput.h
index aa34d29..0628290 100644
--- a/mythtv/libs/libmyth/audio/audiooutput.h
+++ b/mythtv/libs/libmyth/audio/audiooutput.h
@@ -17,6 +17,7 @@
 // forward declaration
 struct AVCodecContext;
 struct AVPacket;
+struct AVFrame;
 
 class MPUBLIC AudioOutput : public VolumeBase, public OutputListeners
 {
@@ -60,7 +61,8 @@ class MPUBLIC AudioOutput : public VolumeBase, public OutputListeners
 
     AudioOutput() :
         VolumeBase(),             OutputListeners(),
-        lastError(QString::null), lastWarn(QString::null), pulsewassuspended(false) {}
+        lastError(QString::null), lastWarn(QString::null),
+        pulsewassuspended(false), _frame(NULL) {}
 
     virtual ~AudioOutput();
 
@@ -172,6 +174,10 @@ class MPUBLIC AudioOutput : public VolumeBase, public OutputListeners
     int DecodeAudio(AVCodecContext *ctx,
                     uint8_t *buffer, int &data_size,
                     const AVPacket *pkt);
+    /**
+     * MAX_SIZE_BUFFER is the maximum size of a buffer to be used with DecodeAudio
+     */
+    static const int MAX_SIZE_BUFFER = 192000;
 
   protected:
     void Error(const QString &msg);
@@ -183,6 +189,7 @@ class MPUBLIC AudioOutput : public VolumeBase, public OutputListeners
     QString lastError;
     QString lastWarn;
     bool pulsewassuspended;
+    AVFrame *_frame;
 };
 
 #endif
diff --git a/mythtv/libs/libmyth/audio/audiooutpututil.cpp b/mythtv/libs/libmyth/audio/audiooutpututil.cpp
index e2dccbf..af3c049 100644
--- a/mythtv/libs/libmyth/audio/audiooutpututil.cpp
+++ b/mythtv/libs/libmyth/audio/audiooutpututil.cpp
@@ -243,20 +243,25 @@ int AudioOutputUtil::DecodeAudio(AVCodecContext *ctx,
                                  uint8_t *buffer, int &data_size,
                                  const AVPacket *pkt)
 {
-    AVFrame frame;
+    AVFrame *frame;
     int got_frame = 0;
     int ret;
     char error[AV_ERROR_MAX_STRING_SIZE];
 
     data_size = 0;
-    avcodec_get_frame_defaults(&frame);
-    ret = avcodec_decode_audio4(ctx, &frame, &got_frame, pkt);
+    if (!(frame = av_frame_alloc()))
+    {
+        return AVERROR(ENOMEM);
+    }
+
+    ret = avcodec_decode_audio4(ctx, frame, &got_frame, pkt);
     if (ret < 0)
     {
         LOG(VB_AUDIO, LOG_ERR, LOC +
             QString("audio decode error: %1 (%2)")
             .arg(av_make_error_string(error, sizeof(error), ret))
             .arg(got_frame));
+        av_frame_free(&frame);
         return ret;
     }
 
@@ -264,24 +269,26 @@ int AudioOutputUtil::DecodeAudio(AVCodecContext *ctx,
     {
         LOG(VB_AUDIO, LOG_DEBUG, LOC +
             QString("audio decode, no frame decoded (%1)").arg(ret));
+        av_frame_free(&frame);
         return ret;
     }
 
-    AVSampleFormat format = (AVSampleFormat)frame.format;
+    AVSampleFormat format = (AVSampleFormat)frame->format;
 
-    data_size = frame.nb_samples * frame.channels * av_get_bytes_per_sample(format);
+    data_size = frame->nb_samples * frame->channels * av_get_bytes_per_sample(format);
 
     if (av_sample_fmt_is_planar(format))
     {
         InterleaveSamples(AudioOutputSettings::AVSampleFormatToFormat(format, ctx->bits_per_raw_sample),
-                          frame.channels, buffer, (const uint8_t **)frame.extended_data,
+                          frame->channels, buffer, (const uint8_t **)frame->extended_data,
                           data_size);
     }
     else
     {
         // data is already compacted... simply copy it
-        memcpy(buffer, frame.extended_data[0], data_size);
+        memcpy(buffer, frame->extended_data[0], data_size);
     }
+    av_frame_free(&frame);
 
     return ret;
 }
diff --git a/mythtv/libs/libmyth/audio/audiooutpututil.h b/mythtv/libs/libmyth/audio/audiooutpututil.h
index f0f63a1..73270f7 100644
--- a/mythtv/libs/libmyth/audio/audiooutpututil.h
+++ b/mythtv/libs/libmyth/audio/audiooutpututil.h
@@ -22,6 +22,10 @@ class MPUBLIC AudioOutputUtil
     static int DecodeAudio(AVCodecContext *ctx,
                            uint8_t *buffer, int &data_size,
                            const AVPacket *pkt);
+    /**
+     * MAX_SIZE_BUFFER is the maximum size of a buffer to be used with DecodeAudio
+     */
+    static const int MAX_SIZE_BUFFER = 192000;
 
     // Actually now in AudioConvert class, kept here for compatibility
     static int  toFloat(AudioFormat format, void *out, const void *in, int bytes);
-- 
1.7.10.2

