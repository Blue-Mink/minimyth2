From e5282175cbd6453677b1934b51fc1de00c805c40 Mon Sep 17 00:00:00 2001
From: Stuart Morgan <smorgan@mythtv.org>
Date: Thu, 28 Aug 2014 22:14:14 +0100
Subject: [PATCH 1/9] Set the VID_AVC flag where applicable recordings by
 inspecting the video codec during recording.

---
 mythtv/libs/libmythtv/mpeg/mpegtables.h            |    2 +-
 .../libmythtv/recorders/NuppelVideoRecorder.cpp    |    7 +-
 mythtv/libs/libmythtv/recorders/dtvrecorder.cpp    |   88 ++++++++++++++++++--
 mythtv/libs/libmythtv/recorders/dtvrecorder.h      |    2 +
 mythtv/libs/libmythtv/recorders/recorderbase.cpp   |   24 +++++-
 mythtv/libs/libmythtv/recorders/recorderbase.h     |   10 ++-
 6 files changed, 120 insertions(+), 13 deletions(-)

diff --git a/mythtv/libs/libmythtv/mpeg/mpegtables.h b/mythtv/libs/libmythtv/mpeg/mpegtables.h
index 88f4a99..a42a0f5 100644
--- a/mythtv/libs/libmythtv/mpeg/mpegtables.h
+++ b/mythtv/libs/libmythtv/mpeg/mpegtables.h
@@ -113,7 +113,7 @@ class MTV_PUBLIC StreamID
         MPEG2Video     = 0x02, ///< ISO 13818-2 & ITU H.262 (aka MPEG-2)
         MPEG4Video     = 0x10, ///< ISO 14492-2 (aka MPEG-4)
         H264Video      = 0x1b, ///< ISO 14492-10 & ITU H.264 (aka MPEG-4-AVC)
-        OpenCableVideo = 0x80,
+        OpenCableVideo = 0x80, ///< Not a clue
         VC1Video       = 0xea, ///< SMPTE 421M video codec (aka VC1) in Blu-Ray
 
         // audio
diff --git a/mythtv/libs/libmythtv/recorders/NuppelVideoRecorder.cpp b/mythtv/libs/libmythtv/recorders/NuppelVideoRecorder.cpp
index 1671a87..69e5c6a 100644
--- a/mythtv/libs/libmythtv/recorders/NuppelVideoRecorder.cpp
+++ b/mythtv/libs/libmythtv/recorders/NuppelVideoRecorder.cpp
@@ -2846,11 +2846,8 @@ void NuppelVideoRecorder::FinishRecording(void)
 
     WriteSeekTable();
 
-    if (curRecording)
-    {
-        curRecording->SaveFilesize(ringBuffer->GetRealFileSize());
-        SavePositionMap(true);
-    }
+    RecorderBase::FinishRecording();
+    
     positionMapLock.lock();
     positionMap.clear();
     positionMapDelta.clear();
diff --git a/mythtv/libs/libmythtv/recorders/dtvrecorder.cpp b/mythtv/libs/libmythtv/recorders/dtvrecorder.cpp
index 4cfee82..ec33759 100644
--- a/mythtv/libs/libmythtv/recorders/dtvrecorder.cpp
+++ b/mythtv/libs/libmythtv/recorders/dtvrecorder.cpp
@@ -29,6 +29,9 @@
 #include "tv_rec.h"
 #include "mythsystemevent.h"
 
+// For primary Audio/Video codec info
+#include "mythcodecid.h"
+
 extern "C" {
 #include "libavcodec/mpegvideo.h"
 }
@@ -167,12 +170,11 @@ void DTVRecorder::FinishRecording(void)
 
     if (curRecording)
     {
-        if (ringBuffer)
-            curRecording->SaveFilesize(ringBuffer->GetRealFileSize());
-        SavePositionMap(true);
-        curRecording->SaveTotalDuration((int64_t)(_total_duration * 1000));
-        curRecording->SaveTotalFrames(_frames_written_count);
+        SetDuration((int64_t)(_total_duration * 1000));
+        SetTotalFrames(_frames_written_count);
     }
+
+    RecorderBase::FinishRecording();
 }
 
 void DTVRecorder::ResetForNewFile(void)
@@ -1338,9 +1340,85 @@ void DTVRecorder::HandleSingleProgramPMT(ProgramMapTable *pmt, bool insert)
         return;
     }
 
+    // We only want to do these checks once per recording
+    bool seenVideo = (m_primaryVideoCodec != AV_CODEC_ID_NONE);
+    bool seenAudio = (m_primaryAudioCodec != AV_CODEC_ID_NONE);
+    uint bestAudioCodec = 0;
     // collect stream types for H.264 (MPEG-4 AVC) keyframe detection
     for (uint i = 0; i < pmt->StreamCount(); ++i)
+    {
+        // We only care about the first identifiable video stream
+        if (!seenVideo && (m_primaryVideoCodec == AV_CODEC_ID_NONE) &&
+            StreamID::IsVideo(pmt->StreamType(i)))
+        {
+            seenVideo = true; // Ignore other video streams
+            switch (pmt->StreamType(i))
+            {
+                case StreamID::MPEG1Video:
+                    m_primaryVideoCodec = AV_CODEC_ID_MPEG1VIDEO;
+                    break;
+                case StreamID::MPEG2Video:
+                    m_primaryVideoCodec = AV_CODEC_ID_MPEG2VIDEO;
+                    break;
+                case StreamID::MPEG4Video:
+                    m_primaryVideoCodec = AV_CODEC_ID_MPEG4;
+                    break;
+                case StreamID::H264Video:
+                    m_primaryVideoCodec = AV_CODEC_ID_H264;
+                    break;
+                case StreamID::OpenCableVideo:
+                    m_primaryVideoCodec = AV_CODEC_ID_MPEG2VIDEO; // TODO Will it always be MPEG2?
+                    break;
+                case StreamID::VC1Video:
+                    m_primaryVideoCodec = AV_CODEC_ID_VC1;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        // We want the 'best' identifiable audio stream, where 'best' is
+        // subjective and no-one will likely agree.
+        // For now it's the 'best' codec, assuming mpeg stream types range
+        // from worst to best, which it does
+        if (!seenAudio && StreamID::IsAudio(pmt->StreamType(i)) &&
+            pmt->StreamType(i) > bestAudioCodec)
+        {
+            bestAudioCodec = pmt->StreamType(i);
+            switch (pmt->StreamType(i))
+            {
+                case StreamID::MPEG1Audio:
+                    m_primaryAudioCodec = AV_CODEC_ID_MP1;
+                    break;
+                case StreamID::MPEG2Audio:
+                    m_primaryAudioCodec = AV_CODEC_ID_MP2;
+                    break;
+                case StreamID::MPEG2AACAudio:
+                    m_primaryAudioCodec = AV_CODEC_ID_AAC;
+                    break;
+                case StreamID::MPEG2AudioAmd1:
+                    m_primaryAudioCodec = AV_CODEC_ID_AAC_LATM;
+                    break;
+                case StreamID::AC3Audio:
+                    m_primaryAudioCodec = AV_CODEC_ID_AC3;
+                    break;
+                case StreamID::EAC3Audio:
+                    m_primaryAudioCodec = AV_CODEC_ID_EAC3;
+                    break;
+                case StreamID::DTSAudio:
+                    m_primaryAudioCodec = AV_CODEC_ID_DTS;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+//         LOG(VB_GENERAL, LOG_DEBUG, QString("Recording(%1): Stream #%2: %3 ")
+//             .arg(curRecording ? QString::number(curRecording->GetRecordingID()) : "")
+//             .arg(i)
+//             .arg(StreamID::GetDescription(pmt->StreamType(i))));
         _stream_id[pmt->StreamPID(i)] = pmt->StreamType(i);
+    }
 
     if (!ringBuffer)
         return;
diff --git a/mythtv/libs/libmythtv/recorders/dtvrecorder.h b/mythtv/libs/libmythtv/recorders/dtvrecorder.h
index 8759f4a..88535ce 100644
--- a/mythtv/libs/libmythtv/recorders/dtvrecorder.h
+++ b/mythtv/libs/libmythtv/recorders/dtvrecorder.h
@@ -10,6 +10,7 @@
 #define DTVRECORDER_H
 
 #include <vector>
+
 using namespace std;
 
 #include <QAtomicInt>
@@ -22,6 +23,7 @@ using namespace std;
 class MPEGStreamData;
 class TSPacket;
 class QTime;
+class StreamID;
 
 class DTVRecorder :
     public RecorderBase,
diff --git a/mythtv/libs/libmythtv/recorders/recorderbase.cpp b/mythtv/libs/libmythtv/recorders/recorderbase.cpp
index c5f6eb2..dc7ffdb 100644
--- a/mythtv/libs/libmythtv/recorders/recorderbase.cpp
+++ b/mythtv/libs/libmythtv/recorders/recorderbase.cpp
@@ -43,7 +43,10 @@ const uint RecorderBase::kTimeOfLatestDataIntervalTarget = 5000;
 
 RecorderBase::RecorderBase(TVRec *rec)
     : tvrec(rec),               ringBuffer(NULL),
-      weMadeBuffer(true),       videocodec("rtjpeg"),
+      weMadeBuffer(true),
+      m_primaryVideoCodec(AV_CODEC_ID_NONE),
+      m_primaryAudioCodec(AV_CODEC_ID_NONE),
+      videocodec("rtjpeg"),
       ntsc(true),               ntsc_framerate(true),
       video_frame_rate(29.97),
       m_videoAspect(0),         m_videoHeight(0),
@@ -411,6 +414,25 @@ void RecorderBase::ClearStatistics(void)
     recordingGaps.clear();
 }
 
+void RecorderBase::FinishRecording(void)
+{
+    if (curRecording)
+    {
+        if (m_primaryVideoCodec == AV_CODEC_ID_H264)
+            curRecording->SaveVideoProperties(VID_AVC, VID_AVC);
+
+        if (ringBuffer)
+            curRecording->SaveFilesize(ringBuffer->GetRealFileSize());
+        SavePositionMap(true);
+    }
+
+    LOG(VB_GENERAL, LOG_NOTICE, QString("Finished Recording: "
+                                        "Video Codec: %1 "
+                                        "Audio Codec: %2")
+                                        .arg(avcodec_get_name(m_primaryVideoCodec))
+                                        .arg(avcodec_get_name(m_primaryAudioCodec)));
+}
+
 RecordingQuality *RecorderBase::GetRecordingQuality(
     const RecordingInfo *r) const
 {
diff --git a/mythtv/libs/libmythtv/recorders/recorderbase.h b/mythtv/libs/libmythtv/recorders/recorderbase.h
index f985823..19beb23 100644
--- a/mythtv/libs/libmythtv/recorders/recorderbase.h
+++ b/mythtv/libs/libmythtv/recorders/recorderbase.h
@@ -17,6 +17,11 @@
 #include "mythtimer.h"
 #include "mythtvexp.h"
 
+extern "C"
+{
+#include "libavcodec/avcodec.h" // for Video/Audio codec enums
+}
+
 class FireWireDBOptions;
 class GeneralDBOptions;
 class RecordingProfile;
@@ -251,7 +256,7 @@ class MTV_PUBLIC RecorderBase : public QRunnable
     virtual void SetRecordingStatus(RecStatusType status,
                                     const QString& file, int line);
     virtual void ClearStatistics(void);
-    virtual void FinishRecording(void) = 0;
+    virtual void FinishRecording(void);
     virtual void StartNewFile(void) { }
 
     /** \brief Set seektable type
@@ -282,6 +287,9 @@ class MTV_PUBLIC RecorderBase : public QRunnable
     RingBuffer    *ringBuffer;
     bool           weMadeBuffer;
 
+
+    AVCodecID      m_primaryVideoCodec;
+    AVCodecID      m_primaryAudioCodec;
     QString        videocodec;
     QString        videodevice;
 
-- 
1.7.10.2

