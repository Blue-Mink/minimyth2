From d56fef8807fea73357d0d4e29e9856c7770e6b15 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Sun, 8 Jun 2014 02:02:10 +1000
Subject: [PATCH 085/945] Allow MasterServerIP, BackendServerIP and
 BackendServerIP6 to be a hostname
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This became a requirement following 5594a6f32e73b0519b556b63983786a01a0f2228.
It was assumed in that commit that MasterServerIP was always an IP address as itâ€™s the only thing mythtv-setup will allow.
However, pre-0.25 it was possible to set a hostname. Breaking grand-fathered network configuration

Add MythCoreContext::resolveSettingAddress and resolveAddress utility method to resolve hostnames
---
 mythtv/libs/libmythbase/mythcorecontext.cpp |  143 ++++++++++++++++++++++-----
 mythtv/libs/libmythbase/mythcorecontext.h   |    8 ++
 2 files changed, 126 insertions(+), 25 deletions(-)

diff --git a/mythtv/libs/libmythbase/mythcorecontext.cpp b/mythtv/libs/libmythbase/mythcorecontext.cpp
index 71876e3..2ee96c0 100644
--- a/mythtv/libs/libmythbase/mythcorecontext.cpp
+++ b/mythtv/libs/libmythbase/mythcorecontext.cpp
@@ -9,6 +9,7 @@
 #include <QNetworkInterface>
 #include <QAbstractSocket>
 #include <QHostAddress>
+#include <QHostInfo>
 #include <QNetworkInterface>
 #include <QNetworkAddressEntry>
 #include <QLocale>
@@ -860,10 +861,7 @@ double MythCoreContext::GetFloatSettingOnHost(const QString &key,
  */
 QString MythCoreContext::GetMasterServerIP(void)
 {
-    QHostAddress addr(GetSetting("MasterServerIP", "localhost"));
-    addr.setScopeId(QString());
-
-    return addr.toString();
+    return resolveSettingAddress("MasterServerIP");
 }
 
 /**
@@ -960,16 +958,7 @@ QString MythCoreContext::GetBackendServerIP4(void)
  */
 QString MythCoreContext::GetBackendServerIP4(const QString &host)
 {
-    QHostAddress addr(GetSettingOnHost("BackendServerIP", host, ""));
-
-    if (!addr.isNull())
-    {
-        return addr.toString();
-    }
-    else
-    {
-        return QString();
-    }
+    return resolveSettingAddress("BackendServerIP", host, ResolveIPv4);
 }
 
 /**
@@ -990,17 +979,7 @@ QString MythCoreContext::GetBackendServerIP6(void)
  */
 QString MythCoreContext::GetBackendServerIP6(const QString &host)
 {
-    QHostAddress addr(GetSettingOnHost("BackendServerIP6", host, ""));
-    if (!addr.isNull())
-    {
-        // remove scope Id
-        addr.setScopeId(QString());
-        return addr.toString();
-    }
-    else
-    {
-        return QString();
-    }
+    return resolveSettingAddress("BackendServerIP6", host, ResolveIPv6);
 }
 
 /**
@@ -1084,6 +1063,120 @@ void MythCoreContext::SetScopeForAddress(const QHostAddress &addr, int scope)
     d->m_scopes.insert(addr1.toString(), QString::number(scope));
 }
 
+/**
+ * \fn QString resolveSettingAddress(const QString &name, const QString &host, int type)
+ * Retrieve IP setting "name" for "host". If host is empty retrieve for local machine.
+ * The value returned for the given setting name, will be returned if it's an IP address
+ * or resolved otherwise.
+ * If the setting's value is null, an empty string will be returned,
+ * or if the name can't be resolved, localhost will be returned.
+ * If type == 0 an IPv4 will be returned
+ * If type == 1 an IPv6 will be returned
+ * If type < 0, either IPv4 or IPv6 will be returned with a priority given to IPv6
+ * If keepscope boolean is clear (default), the scopeId will be removed
+ */
+QString MythCoreContext::resolveSettingAddress(const QString &name,
+                                               const QString &host,
+                                               ResolveType type, bool keepscope)
+{
+    QString value;
+
+    if (host.isEmpty())
+    {
+        value = gCoreContext->GetSetting(name);
+    }
+    else
+    {
+        value = gCoreContext->GetSettingOnHost(name, host);
+    }
+
+    return resolveAddress(value, type, keepscope);
+}
+
+/**
+ * \fn QString resolveAddress(const QString &host, int type)
+ * if host is an IP address, it will be returned
+ * or resolved otherwise.
+ * If host is empty, an empty string will be returned,
+ * if host can't be resolved, localhost will be returned.
+ * If type == 0 an IPv4 will be returned or 127.0.0.1
+ * If type == 1 an IPv6 will be returned or ::1
+ * If type < 0 (default), either IPv4 or IPv6 will be returned with a priority
+ * given to IPv6
+ * If keepscope boolean is clear (default), the scopeId will be removed
+ */
+QString MythCoreContext::resolveAddress(const QString &host, ResolveType type,
+                                        bool keepscope) const
+{
+    QHostAddress addr(host);
+
+    if (!host.isEmpty() && addr.isNull())
+    {
+        // address is likely a hostname, attempts to resolve it
+        QHostInfo info = QHostInfo::fromName(host);
+        QList<QHostAddress> list = info.addresses();
+
+        if (list.isEmpty())
+        {
+            LOG(VB_GENERAL, LOG_WARNING, LOC +
+                QString("Can't resolve hostname:'%1', using localhost").arg(host));
+#if defined(QT_NO_IPV6)
+            return "127.0.0.1";
+#else
+            return type == ResolveIPv4 ? "127.0.0.1" : "::1";
+#endif
+        }
+        QHostAddress v4, v6;
+
+        // Return the first address fitting the type critera
+        for (int i=0; i < list.size(); i++)
+        {
+            addr = list[i];
+            QAbstractSocket::NetworkLayerProtocol prot = addr.protocol();
+
+            if (prot == QAbstractSocket::IPv4Protocol)
+            {
+                v4 = addr;
+                if (type == 0)
+                    break;
+            }
+#if !defined(QT_NO_IPV6)
+            else if (prot == QAbstractSocket::IPv6Protocol)
+            {
+                v6 = addr;
+                if (type != 0)
+                    break;
+            }
+#endif
+        }
+        switch (type)
+        {
+            case ResolveIPv4:
+                addr = v4.isNull() ? QHostAddress::LocalHost : v4;
+                break;
+#if !defined(QT_NO_IPV6)
+            case ResolveIPv6:
+                addr = v6.isNull() ? QHostAddress::LocalHostIPv6 : v6;
+                break;
+#endif
+            default:
+                addr = v6.isNull() ?
+                    (v4.isNull() ? QHostAddress::LocalHostIPv6 : v4) : v6;
+                break;
+        }
+    }
+    else if (host.isEmpty())
+    {
+        return QString();
+    }
+
+    if (!keepscope)
+    {
+        addr.setScopeId(QString());
+    }
+    return addr.toString();
+}
+
 void MythCoreContext::OverrideSettingForSession(const QString &key,
                                                 const QString &value)
 {
diff --git a/mythtv/libs/libmythbase/mythcorecontext.h b/mythtv/libs/libmythbase/mythcorecontext.h
index a2a93c9..7a264a9 100644
--- a/mythtv/libs/libmythbase/mythcorecontext.h
+++ b/mythtv/libs/libmythbase/mythcorecontext.h
@@ -170,6 +170,14 @@ class MBASE_PUBLIC MythCoreContext : public QObject, public MythObservable, publ
     bool GetScopeForAddress(QHostAddress &addr) const;
     void SetScopeForAddress(const QHostAddress &addr);
     void SetScopeForAddress(const QHostAddress &addr, int scope);
+    enum ResolveType { ResolveAny = -1, ResolveIPv4 = 0, ResolveIPv6 = 1 };
+    QString resolveSettingAddress(const QString &name,
+                                  const QString &host = QString(),
+                                  ResolveType type = ResolveAny,
+                                  bool keepscope = false);
+    QString resolveAddress(const QString &host,
+                           ResolveType = ResolveAny,
+                           bool keepscope = false) const;
 
     void ClearSettingsCache(const QString &myKey = QString(""));
     void ActivateSettingsCache(bool activate = true);
-- 
1.7.10.2

