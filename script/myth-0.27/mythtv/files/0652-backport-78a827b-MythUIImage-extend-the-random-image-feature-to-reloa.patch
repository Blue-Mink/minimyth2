From 78a827b8fdbf0d4fab4525a8007c2c8c7deb4cc1 Mon Sep 17 00:00:00 2001
From: Paul Harrison <pharrison@mythtv.org>
Date: Tue, 9 Dec 2014 20:50:00 +0000
Subject: [PATCH 10/11] MythUIImage: extend the random image feature to reload
 if a delay is used

If the <filename> is set to a directory and the <delay> is set to a value > 0
then keep reloading a random image from the directory after <delay>
milliseconds has passed.

For example this will display a random image from the themes 'background'
directory changing the image every minute (60000ms) :-

<imagetype name="background">
    <area>0,0,1280,720</area>
    <filename>backgrounds/</filename>
    <delay>60000</delay>
</imagetype>
---
 mythtv/libs/libmythui/mythuiimage.cpp |  124 ++++++++++++++++++++-------------
 mythtv/libs/libmythui/mythuiimage.h   |    5 ++
 2 files changed, 82 insertions(+), 47 deletions(-)

diff --git a/mythtv/libs/libmythui/mythuiimage.cpp b/mythtv/libs/libmythui/mythuiimage.cpp
index a930a6e..4b31768 100644
--- a/mythtv/libs/libmythui/mythuiimage.cpp
+++ b/mythtv/libs/libmythui/mythuiimage.cpp
@@ -691,6 +691,8 @@ void MythUIImage::Init(void)
     m_animatedImage = false;
 
     m_runningThreads = 0;
+
+    m_showingRandomImage = false;
 }
 
 /**
@@ -1164,7 +1166,7 @@ bool MythUIImage::Load(bool allowLoadInBackground, bool forceStat)
  */
 void MythUIImage::Pulse(void)
 {
-    QWriteLocker updateLocker(&d->m_UpdateLock);
+    d->m_UpdateLock.lockForWrite();
 
     int delay = -1;
 
@@ -1176,39 +1178,51 @@ void MythUIImage::Pulse(void)
     if (delay > 0 &&
         abs(m_LastDisplay.msecsTo(QTime::currentTime())) > delay)
     {
-        m_ImagesLock.lock();
-
-        if (m_animationCycle == kCycleStart)
+        if (m_showingRandomImage)
         {
-            ++m_CurPos;
-
-            if (m_CurPos >= (uint)m_Images.size())
-                m_CurPos = 0;
+            FindRandomImage();
+            d->m_UpdateLock.unlock();
+            Load();
+            d->m_UpdateLock.lockForWrite();
         }
-        else if (m_animationCycle == kCycleReverse)
+        else
         {
-            if ((m_CurPos + 1) >= (uint)m_Images.size())
+            m_ImagesLock.lock();
+
+            if (m_animationCycle == kCycleStart)
             {
-                m_animationReverse = true;
+                ++m_CurPos;
+
+                if (m_CurPos >= (uint)m_Images.size())
+                    m_CurPos = 0;
             }
-            else if (m_CurPos == 0)
+            else if (m_animationCycle == kCycleReverse)
             {
-                m_animationReverse = false;
+                if ((m_CurPos + 1) >= (uint)m_Images.size())
+                {
+                    m_animationReverse = true;
+                }
+                else if (m_CurPos == 0)
+                {
+                    m_animationReverse = false;
+                }
+
+                if (m_animationReverse)
+                    --m_CurPos;
+                else
+                    ++m_CurPos;
             }
 
-            if (m_animationReverse)
-                --m_CurPos;
-            else
-                ++m_CurPos;
+            m_ImagesLock.unlock();
         }
 
-        m_ImagesLock.unlock();
-
         SetRedraw();
         m_LastDisplay = QTime::currentTime();
     }
 
     MythUIType::Pulse();
+
+    d->m_UpdateLock.unlock();
 }
 
 /**
@@ -1307,34 +1321,10 @@ bool MythUIImage::ParseElement(
 
         if (m_imageProperties.filename.endsWith('/'))
         {
-            QDir imageDir(m_imageProperties.filename);
-
-            if (!imageDir.exists())
-            {
-                QString themeDir = GetMythUI()->GetThemeDir() + '/';
-                imageDir = themeDir + m_imageProperties.filename;
-            }
-
-            QStringList imageTypes;
-
-            QList< QByteArray > exts = QImageReader::supportedImageFormats();
-            QList< QByteArray >::Iterator it = exts.begin();
-
-            for (; it != exts.end(); ++it)
-            {
-                imageTypes.append(QString("*.").append(*it));
-            }
-
-            imageDir.setNameFilters(imageTypes);
+            m_showingRandomImage = true;
+            m_imageDirectory = m_imageProperties.filename;
 
-            QStringList imageList = imageDir.entryList();
-            QString randFile;
-
-            if (imageList.size())
-                randFile = QString("%1%2").arg(m_imageProperties.filename)
-                           .arg(imageList.takeAt(random() % imageList.size()));
-
-            m_OrigFilename = m_imageProperties.filename = randFile;
+            FindRandomImage();
         }
     }
     else if (element.tagName() == "filepattern")
@@ -1507,6 +1497,9 @@ void MythUIImage::CopyFrom(MythUIType *base)
     m_animationCycle = im->m_animationCycle;
     m_animatedImage = im->m_animatedImage;
 
+    m_showingRandomImage = im->m_showingRandomImage;
+    m_imageDirectory = im->m_imageDirectory;
+
     MythUIType::CopyFrom(base);
 
     // We need to update forceSize in case the parent area has changed
@@ -1696,6 +1689,43 @@ void MythUIImage::customEvent(QEvent *event)
         // No Images were loaded, so trigger Reset to default
         Reset();
     }
+}
 
+void MythUIImage::FindRandomImage(void)
+{
+    QDir imageDir(m_imageDirectory);
 
-}
+    if (!imageDir.exists())
+    {
+        QString themeDir = GetMythUI()->GetThemeDir() + '/';
+        imageDir = themeDir + m_imageDirectory;
+    }
+
+    QStringList imageTypes;
+
+    QList< QByteArray > exts = QImageReader::supportedImageFormats();
+    QList< QByteArray >::Iterator it = exts.begin();
+
+    for (; it != exts.end(); ++it)
+    {
+        imageTypes.append(QString("*.").append(*it));
+    }
+
+    imageDir.setNameFilters(imageTypes);
+
+    QStringList imageList = imageDir.entryList();
+    QString randFile;
+
+    if (imageList.size())
+    {
+        // try to find a different image
+        do
+        {
+            randFile = QString("%1%2").arg(m_imageDirectory)
+                                      .arg(imageList.takeAt(random() % imageList.size()));
+
+        } while (imageList.size() > 1 && randFile == m_OrigFilename);
+    }
+
+    m_OrigFilename = m_imageProperties.filename = randFile;
+}
\ No newline at end of file
diff --git a/mythtv/libs/libmythui/mythuiimage.h b/mythtv/libs/libmythui/mythuiimage.h
index 690723c4..dbd7901 100644
--- a/mythtv/libs/libmythui/mythuiimage.h
+++ b/mythtv/libs/libmythui/mythuiimage.h
@@ -149,6 +149,8 @@ class MUI_PUBLIC MythUIImage : public MythUIType
     void SetCropRect(int x, int y, int width, int height);
     void SetCropRect(const MythRect &rect);
 
+    void FindRandomImage(void);
+
     QString m_Filename;
     QString m_OrigFilename;
 
@@ -169,6 +171,9 @@ class MUI_PUBLIC MythUIImage : public MythUIType
 
     int m_runningThreads;
 
+    bool m_showingRandomImage;
+    QString m_imageDirectory;
+
     MythUIImagePrivate *d;
 
     enum AnimationCycle {kCycleStart, kCycleReverse};
-- 
1.7.10.2

