From 1ef850f64abef8f037026c4cd122cfdd4eec2153 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Thu, 26 Jun 2014 21:08:10 +1000
Subject: [PATCH 05/16] Add support for frames where pitch > width

This allows to create frames where all lines are 16-bytes aligned, allowing for more efficient SSE acceleration.
Add frame conversion and copy utility routines, to simplify the code
---
 mythtv/libs/libmythtv/myth_imgconvert.cpp          |   10 +-
 mythtv/libs/libmythtv/myth_imgconvert.h            |    4 +-
 mythtv/libs/libmythtv/mythavutil.h                 |  131 ++++++++++++++++++++
 mythtv/libs/libmythtv/mythframe.h                  |   66 ++++++++++
 mythtv/libs/libmythtv/mythplayer.cpp               |   13 +-
 mythtv/libs/libmythtv/nuppeldecoder.cpp            |   57 ++++-----
 mythtv/libs/libmythtv/nuppeldecoder.h              |    2 -
 mythtv/libs/libmythtv/openglvideo.cpp              |   16 +--
 mythtv/libs/libmythtv/privatedecoder_crystalhd.cpp |   38 +++---
 mythtv/libs/libmythtv/privatedecoder_vda.cpp       |   15 +--
 mythtv/libs/libmythtv/videoout_d3d.cpp             |   43 +------
 mythtv/libs/libmythtv/videoout_xv.cpp              |   20 +--
 mythtv/libs/libmythtv/videooutbase.cpp             |   78 +++---------
 13 files changed, 289 insertions(+), 204 deletions(-)

diff --git a/mythtv/libs/libmythtv/myth_imgconvert.cpp b/mythtv/libs/libmythtv/myth_imgconvert.cpp
index b83de11..c3893e3 100644
--- a/mythtv/libs/libmythtv/myth_imgconvert.cpp
+++ b/mythtv/libs/libmythtv/myth_imgconvert.cpp
@@ -34,17 +34,19 @@ extern "C" {
 #include "mythlogging.h"
 #include "myth_imgconvert.h"
 
-int myth_sws_img_convert(AVPicture *dst, PixelFormat dst_pix_fmt, AVPicture *src,
-                PixelFormat pix_fmt, int width, int height)
+int myth_sws_img_convert(AVPicture *dst, PixelFormat dst_pix_fmt,
+                         const AVPicture *src, PixelFormat pix_fmt,
+                         int width, int height)
 {
     static QMutex ctx_lock;
-    static struct SwsContext *convert_ctx;
+    static struct SwsContext *convert_ctx = NULL;
 
     QMutexLocker locker(&ctx_lock);
     convert_ctx = sws_getCachedContext(convert_ctx, width, height, pix_fmt,
                                        width, height, dst_pix_fmt,
                                        SWS_FAST_BILINEAR, NULL, NULL, NULL);
-    if (convert_ctx == NULL) {
+    if (convert_ctx == NULL)
+    {
         LOG(VB_GENERAL, LOG_ERR, "myth_sws_img_convert: Cannot initialize "
                                  "the image conversion context");
         return -1;
diff --git a/mythtv/libs/libmythtv/myth_imgconvert.h b/mythtv/libs/libmythtv/myth_imgconvert.h
index 4277bbc..a41aba0 100644
--- a/mythtv/libs/libmythtv/myth_imgconvert.h
+++ b/mythtv/libs/libmythtv/myth_imgconvert.h
@@ -38,7 +38,7 @@ extern "C" {
  * the software scaler (swscale).
  */
 MTV_PUBLIC int myth_sws_img_convert(AVPicture *dst, PixelFormat dst_pix_fmt,
-                                 AVPicture *src, PixelFormat pix_fmt,
-                                 int width, int height);
+                                    const AVPicture *src, PixelFormat pix_fmt,
+                                    int width, int height);
 
 #endif /* MYTH_IMGCONVERT_H */
diff --git a/mythtv/libs/libmythtv/mythavutil.h b/mythtv/libs/libmythtv/mythavutil.h
index 4e48c34..ca10a66 100644
--- a/mythtv/libs/libmythtv/mythavutil.h
+++ b/mythtv/libs/libmythtv/mythavutil.h
@@ -12,6 +12,8 @@
 extern "C" {
 #include "libavcodec/avcodec.h"
 }
+#include "mythframe.h"
+#include "myth_imgconvert.h"
 
 /** MythAVFrame
  * little utility class that act as a safe way to allocate an AVFrame
@@ -62,4 +64,133 @@ private:
     AVFrame *m_frame;
 };
 
+static inline AVPixelFormat FrameTypeToPixelFormat(VideoFrameType type)
+{
+    switch (type)
+    {
+        case FMT_NV12:
+            return AV_PIX_FMT_NV12;
+        case FMT_YUV422P:
+            return AV_PIX_FMT_YUV422P;
+        case FMT_BGRA:
+            return AV_PIX_FMT_BGRA;
+        case FMT_YUY2:
+            return AV_PIX_FMT_UYVY422;
+        case FMT_RGB24:
+            return AV_PIX_FMT_RGB24;
+        case FMT_RGB32:
+            return AV_PIX_FMT_RGB32;
+        default:
+            return AV_PIX_FMT_YUV420P;
+    }
+}
+
+static inline VideoFrameType PixelFormatToFrameType(AVPixelFormat fmt)
+{
+    switch (fmt)
+    {
+        case AV_PIX_FMT_NV12:
+            return FMT_NV12;
+        case AV_PIX_FMT_YUV422P:
+            return FMT_YUV422P;
+        case AV_PIX_FMT_RGB32:
+            return FMT_RGB32;
+        case AV_PIX_FMT_UYVY422:
+            return FMT_YUY2;
+        case AV_PIX_FMT_RGB24:
+            return FMT_RGB24;
+        default:
+            return FMT_YV12;
+    }
+}
+
+/**
+ * AVPictureFill
+ * Initialise AVPicture pic with content from VideoFrame frame
+ */
+static inline int AVPictureFill(AVPicture *pic, const VideoFrame *frame,
+                                AVPixelFormat fmt = AV_PIX_FMT_NONE)
+{
+    if (fmt == AV_PIX_FMT_NONE)
+    {
+        fmt = FrameTypeToPixelFormat(frame->codec);
+    }
+
+    avpicture_fill(pic, frame->buf, fmt, frame->width, frame->height);
+    pic->data[1] = frame->buf + frame->offsets[1];
+    pic->data[2] = frame->buf + frame->offsets[2];
+    pic->linesize[0] = frame->pitches[0];
+    pic->linesize[1] = frame->pitches[1];
+    pic->linesize[2] = frame->pitches[2];
+    return (int)buffersize(frame->codec, frame->width, frame->height);
+}
+
+/**
+ * AVPictureCopy
+ * Initialise AVPicture pic, create buffer if required and copy content of
+ * VideoFrame frame into it, performing the required conversion if any
+ * Returns size of buffer allocated
+ * Data would have to be deleted once finished with object with:
+ * av_freep(pic->data[0])
+ */
+static inline int AVPictureCopy(AVPicture *pic, const VideoFrame *frame,
+                                unsigned char *buffer = NULL,
+                                AVPixelFormat fmt = AV_PIX_FMT_YUV420P)
+{
+    VideoFrameType type = PixelFormatToFrameType(fmt);
+    int size = buffersize(type, frame->width, frame->height, 0) + 16;
+    unsigned char *sbuf = buffer ? buffer : (unsigned char*)av_malloc(size);
+
+    if (!sbuf)
+    {
+        return 0;
+    }
+
+    avpicture_fill(pic, sbuf, fmt, frame->width, frame->height);
+    if ((type == FMT_YV12 || type == FMT_NV12) &&
+        (frame->codec == FMT_NV12 || frame->codec == FMT_YV12))
+    {
+        copybuffer(sbuf, frame, pic->linesize[0], type);
+    }
+    else
+    {
+        AVPixelFormat fmt_in = FrameTypeToPixelFormat(frame->codec);
+        AVPicture img_in;
+        AVPictureFill(&img_in, frame);
+        myth_sws_img_convert(pic, fmt, &img_in, fmt_in,
+                             frame->width, frame->height);
+    }
+
+    return size;
+}
+
+/**
+ * AVPictureCopy
+ * Copy AVPicture pic into VideoFrame frame, performing the required conversion
+ * Returns size of frame data
+ */
+static inline int AVPictureCopy(VideoFrame *frame, const AVPicture *pic,
+                                AVPixelFormat fmt = AV_PIX_FMT_YUV420P)
+{
+    VideoFrameType type = PixelFormatToFrameType(fmt);
+    int size = buffersize(type, frame->width, frame->height, 0) + 16;
+    unsigned char *sbuf = (unsigned char*)av_malloc(size);
+
+    if ((type == FMT_YV12 || type == FMT_NV12) &&
+        (frame->codec == FMT_NV12 || frame->codec == FMT_YV12))
+    {
+        copybuffer(sbuf, frame, pic->linesize[0], type);
+    }
+    else
+    {
+        // Can't handle those natively, convert it first
+        AVPixelFormat fmt_out = FrameTypeToPixelFormat(frame->codec);
+        AVPicture img_out;
+        AVPictureFill(&img_out, frame);
+        myth_sws_img_convert(&img_out, fmt_out, pic, fmt,
+                             frame->width, frame->height);
+    }
+    return frame->size;
+}
+
 #endif
diff --git a/mythtv/libs/libmythtv/mythframe.h b/mythtv/libs/libmythtv/mythframe.h
index 258d111..3b4665f 100644
--- a/mythtv/libs/libmythtv/mythframe.h
+++ b/mythtv/libs/libmythtv/mythframe.h
@@ -17,6 +17,7 @@ typedef enum FrameType_
     FMT_YV12,
     FMT_IA44,
     FMT_AI44,
+    FMT_RGB32,   // endian dependent format, ARGB or BGRA
     FMT_ARGB32,
     FMT_RGBA32,
     FMT_YUV422P,
@@ -262,6 +263,7 @@ static inline int bitsperpixel(VideoFrameType type)
         case FMT_BGRA:
         case FMT_RGBA32:
         case FMT_ARGB32:
+        case FMT_RGB32:
             res = 32;
             break;
         case FMT_RGB24:
@@ -308,6 +310,70 @@ static inline uint buffersize(VideoFrameType type, int width, int height,
     return (adj_w * height * bpp + 4/* to round up */) / bpb;
 }
 
+static inline void copybuffer(VideoFrame *dst, uint8_t *buffer,
+                              int pitch, VideoFrameType type = FMT_YV12)
+{
+    if (type == FMT_YV12)
+    {
+        VideoFrame framein;
+        int chroma_pitch  = pitch >> 1;
+        int chroma_height = dst->height >> 1;
+        int offsets[3] =
+            { 0,
+              pitch * dst->height,
+              pitch * dst->height + chroma_pitch * chroma_height };
+        int pitches[3] = { pitch, chroma_pitch, chroma_pitch };
+
+        init(&framein, type, buffer, dst->width, dst->height, dst->size,
+             pitches, offsets);
+        copy(dst, &framein);
+    }
+    else if (type == FMT_NV12)
+    {
+        VideoFrame framein;
+        int offsets[3] = { 0, pitch * dst->height, 0 };
+        int pitches[3] = { pitch, pitch, 0 };
+
+        init(&framein, type, buffer, dst->width, dst->height, dst->size,
+             pitches, offsets);
+        copy(dst, &framein);
+    }
+}
+
+static inline void copybuffer(uint8_t *dstbuffer, const VideoFrame *src,
+                              int pitch = 0, VideoFrameType type = FMT_YV12)
+{
+    if (pitch == 0)
+    {
+        pitch = src->width;
+    }
+
+    if (type == FMT_YV12)
+    {
+        VideoFrame frameout;
+        int chroma_pitch  = pitch >> 1;
+        int chroma_height = src->height >> 1;
+        int offsets[3] =
+            { 0,
+              pitch * src->height,
+              pitch * src->height + chroma_pitch * chroma_height };
+        int pitches[3] = { pitch, chroma_pitch, chroma_pitch };
+
+        init(&frameout, type, dstbuffer, src->width, src->height, src->size,
+             pitches, offsets);
+        copy(&frameout, src);
+    }
+    else if (type == FMT_NV12)
+    {
+        VideoFrame frameout;
+        int offsets[3] = { 0, pitch * src->height, 0 };
+        int pitches[3] = { pitch, pitch, 0 };
+
+        init(&frameout, type, dstbuffer, src->width, src->height, src->size,
+             pitches, offsets);
+        copy(&frameout, src);
+    }
+}
 #endif /* __cplusplus */
 
 #endif
diff --git a/mythtv/libs/libmythtv/mythplayer.cpp b/mythtv/libs/libmythtv/mythplayer.cpp
index 73068fb..96f3227 100644
--- a/mythtv/libs/libmythtv/mythplayer.cpp
+++ b/mythtv/libs/libmythtv/mythplayer.cpp
@@ -64,6 +64,7 @@ using namespace std;
 #include "icringbuffer.h"
 #include "audiooutput.h"
 #include "cardutil.h"
+#include "mythavutil.h"
 
 extern "C" {
 #include "vbitext/vbi.h"
@@ -4437,21 +4438,13 @@ char *MythPlayer::GetScreenGrabAtFrame(uint64_t frameNum, bool absolute,
         return NULL;
     }
 
-    avpicture_fill(&orig, data, PIX_FMT_YUV420P,
-                   video_dim.width(), video_dim.height());
-
+    AVPictureFill(&orig, frame);
     avpicture_deinterlace(&orig, &orig, PIX_FMT_YUV420P,
                           video_dim.width(), video_dim.height());
 
     bufflen = video_dim.width() * video_dim.height() * 4;
     outputbuf = new unsigned char[bufflen];
-
-    avpicture_fill(&retbuf, outputbuf, PIX_FMT_RGB32,
-                   video_dim.width(), video_dim.height());
-
-    myth_sws_img_convert(
-        &retbuf, PIX_FMT_RGB32, &orig, PIX_FMT_YUV420P,
-                video_dim.width(), video_dim.height());
+    AVPictureCopy(&retbuf, frame, outputbuf, AV_PIX_FMT_RGB32);
 
     vw = video_disp_dim.width();
     vh = video_disp_dim.height();
diff --git a/mythtv/libs/libmythtv/nuppeldecoder.cpp b/mythtv/libs/libmythtv/nuppeldecoder.cpp
index 83f6091..239901c 100644
--- a/mythtv/libs/libmythtv/nuppeldecoder.cpp
+++ b/mythtv/libs/libmythtv/nuppeldecoder.cpp
@@ -49,14 +49,13 @@ NuppelDecoder::NuppelDecoder(MythPlayer *parent,
       directframe(NULL),            decoded_video_frame(NULL),
       mpa_vidcodec(0), mpa_vidctx(0), mpa_audcodec(0), mpa_audctx(0),
       directrendering(false),
-      lastct('1'), strm_buf(0), strm(0), buf(0), buf2(0),
+      lastct('1'), strm(0), buf(0), buf2(0),
       videosizetotal(0), videoframesread(0), setreadahead(false)
 {
     // initialize structures
     memset(&fileheader, 0, sizeof(rtfileheader));
     memset(&frameheader, 0, sizeof(rtframeheader));
     memset(&extradata, 0, sizeof(extendeddata));
-    memset(&tmppicture, 0, sizeof(AVPicture));
     planes[0] = planes[1] = planes[2] = 0;
     m_audioSamples = (uint8_t *)av_mallocz(AudioOutputUtil::MAX_SIZE_BUFFER);
 
@@ -91,11 +90,11 @@ NuppelDecoder::~NuppelDecoder()
     if (ffmpeg_extradata)
         delete [] ffmpeg_extradata;
     if (buf)
-        delete [] buf;
+        av_freep(&buf);
     if (buf2)
-        delete [] buf2;
-    if (strm_buf)
-        delete [] strm_buf;
+        av_freep(&buf2);
+    if (strm)
+        av_freep(&strm);
 
     av_freep(&m_audioSamples);
 
@@ -617,9 +616,8 @@ int NuppelDecoder::OpenFile(RingBuffer *rbuffer, bool novideo,
 
     ringBuffer->Seek(startpos, SEEK_SET);
 
-    buf = new unsigned char[video_size];
-    strm_buf = new unsigned char[video_size * 2 + 16];
-    strm = (unsigned char*) (((long)strm_buf + 15) & ~0xf);
+    buf = (unsigned char*)av_malloc(video_size);
+    strm = (unsigned char*)av_malloc(video_size * 2);
 
     if (hasFullPositionMap)
         return 1;
@@ -819,17 +817,9 @@ void NuppelDecoder::CloseAVCodecAudio(void)
 static void CopyToVideo(unsigned char *buf, int video_width,
                         int video_height, VideoFrame *frame)
 {
-    uint ysize = video_width * video_height;
-    uint uvsize = ysize >> 2;
-
-    unsigned char *planes[3];
-    planes[0] = buf;
-    planes[1] = planes[0] + ysize;
-    planes[2] = planes[1] + uvsize;
-
-    memcpy(frame->buf + frame->offsets[0], planes[0], ysize);
-    memcpy(frame->buf + frame->offsets[1], planes[1], uvsize);
-    memcpy(frame->buf + frame->offsets[2], planes[2], uvsize);
+    (void)video_width;
+    (void)video_height;
+    copybuffer(frame, buf, frame->width);
 }
 
 bool NuppelDecoder::DecodeFrame(struct rtframeheader *frameheader,
@@ -839,26 +829,30 @@ bool NuppelDecoder::DecodeFrame(struct rtframeheader *frameheader,
     lzo_uint out_len;
     int compoff = 0;
 
-    unsigned char *outbuf = frame->buf;
     directframe = frame;
 
     if (!buf2)
     {
-        buf2 = new unsigned char[video_size + 64];
+        buf2 = (unsigned char*)av_malloc(video_size + 64);
         planes[0] = buf;
         planes[1] = planes[0] + video_width * video_height;
         planes[2] = planes[1] + (video_width * video_height) / 4;
     }
 
-    if (frameheader->comptype == 'N') {
-        memset(outbuf, 0, video_width * video_height);
-        memset(outbuf + video_width * video_height, 127,
-               (video_width * video_height)/2);
+    if (frameheader->comptype == 'N')
+    {
+        memset(frame->buf, 0, frame->pitches[0] * video_height);
+        memset(frame->buf + frame->offsets[1], 127,
+               frame->pitches[1] * frame->height / 2);
+        memset(frame->buf + frame->offsets[2], 127,
+               frame->pitches[2] * frame->height / 2);
         return true;
     }
 
-    if (frameheader->comptype == 'L') {
-        switch(lastct) {
+    if (frameheader->comptype == 'L')
+    {
+        switch(lastct)
+        {
             case '0': case '3':
                 CopyToVideo(buf2, video_width, video_height, frame);
                 break;
@@ -962,13 +956,8 @@ bool NuppelDecoder::DecodeFrame(struct rtframeheader *frameheader,
         if (directrendering)
             return true;
 
-        avpicture_fill(&tmppicture, outbuf, PIX_FMT_YUV420P, video_width,
-                       video_height);
-
         AVFrame *tmp = mpa_pic;
-        myth_sws_img_convert(
-            &tmppicture, PIX_FMT_YUV420P, (AVPicture *)tmp,
-                    mpa_vidctx->pix_fmt, video_width, video_height);
+        AVPictureCopy(frame, (AVPicture*)tmp, mpa_vidctx->pix_fmt);
     }
 
     return true;
diff --git a/mythtv/libs/libmythtv/nuppeldecoder.h b/mythtv/libs/libmythtv/nuppeldecoder.h
index 896f7ea..a548e36 100644
--- a/mythtv/libs/libmythtv/nuppeldecoder.h
+++ b/mythtv/libs/libmythtv/nuppeldecoder.h
@@ -109,14 +109,12 @@ class NuppelDecoder : public DecoderBase
     AVCodecContext *mpa_vidctx;
     AVCodec *mpa_audcodec;
     AVCodecContext *mpa_audctx;
-    AVPicture tmppicture;
     uint8_t *m_audioSamples;
 
     bool directrendering;
 
     char lastct;
 
-    unsigned char *strm_buf;
     unsigned char *strm;
     unsigned char *buf;
     unsigned char *buf2;
diff --git a/mythtv/libs/libmythtv/openglvideo.cpp b/mythtv/libs/libmythtv/openglvideo.cpp
index 2de7d4c..6501d1c 100644
--- a/mythtv/libs/libmythtv/openglvideo.cpp
+++ b/mythtv/libs/libmythtv/openglvideo.cpp
@@ -4,11 +4,7 @@
 #include "openglvideo.h"
 #include "myth_imgconvert.h"
 #include "mythrender_opengl.h"
-
-// AVLib header
-extern "C" {
-#include "libavcodec/avcodec.h"
-}
+#include "mythavutil.h"
 
 #define LOC QString("GLVid: ")
 #define COLOUR_UNIFORM "m_colourMatrix"
@@ -813,7 +809,7 @@ void OpenGLVideo::UpdateInputFrame(const VideoFrame *frame, bool soft_bob)
         MYTHTV_UYVY == videoTextureType)
     {
         // software conversion
-        AVPicture img_in, img_out;
+        AVPicture img_out;
         PixelFormat out_fmt = PIX_FMT_BGRA;
         if ((GL_YCBCR_MESA == videoTextureType) ||
             (GL_YCBCR_422_APPLE == videoTextureType) ||
@@ -821,13 +817,7 @@ void OpenGLVideo::UpdateInputFrame(const VideoFrame *frame, bool soft_bob)
         {
             out_fmt = PIX_FMT_UYVY422;
         }
-
-        avpicture_fill(&img_out, (uint8_t *)buf, out_fmt,
-                       frame->width, frame->height);
-        avpicture_fill(&img_in, (uint8_t *)frame->buf, PIX_FMT_YUV420P,
-                       frame->width, frame->height);
-        myth_sws_img_convert(&img_out, out_fmt, &img_in, PIX_FMT_YUV420P,
-                       frame->width, frame->height);
+        AVPictureCopy(&img_out, frame, (unsigned char*)buf, out_fmt);
     }
     else if (frame->interlaced_frame && !soft_bob)
     {
diff --git a/mythtv/libs/libmythtv/privatedecoder_crystalhd.cpp b/mythtv/libs/libmythtv/privatedecoder_crystalhd.cpp
index 8ed56ca..85b5cce 100644
--- a/mythtv/libs/libmythtv/privatedecoder_crystalhd.cpp
+++ b/mythtv/libs/libmythtv/privatedecoder_crystalhd.cpp
@@ -1,6 +1,7 @@
 #include "privatedecoder_crystalhd.h"
 #include "myth_imgconvert.h"
 #include "mythlogging.h"
+#include "mythavutil.h"
 
 #define LOC  QString("CrystalHD: ")
 #define ERR  QString("CrystalHD Err: ")
@@ -16,7 +17,7 @@ void FetcherThread::run(void)
     RunEpilog();
 }
 
-PixelFormat bcmpixfmt_to_pixfmt(BC_OUTPUT_FORMAT fmt);
+AVPixelFormat bcmpixfmt_to_pixfmt(BC_OUTPUT_FORMAT fmt);
 QString device_to_string(BC_DEVICE_TYPE device);
 QString bcmerr_to_string(BC_STATUS err);
 QString bcmpixfmt_to_string(BC_OUTPUT_FORMAT fmt);
@@ -635,17 +636,14 @@ void PrivateDecoderCrystalHD::FillFrame(BC_DTS_PROC_OUT *out)
     int in_height  = out->PicInfo.height;
     int out_width  = (in_width + 15) & (~0xf);
     int out_height = in_height;
-    int size       = buffersize(FMT_YV12, out_width, out_height);
     uint8_t* src   = out->Ybuff;
 
     if (!m_frame)
     {
-        unsigned char* buf  = (unsigned char*)av_malloc(size);
+        int size = buffersize(FMT_YV12, out_width, out_height);
+        unsigned char* buf = (unsigned char*)av_malloc(size);
         m_frame = new VideoFrame();
-        // Force pitches to be equal to the width as the code below
-        // is likely wrong if that's not the case
-        init(m_frame, FMT_YV12, buf, out_width, out_height, size,
-             NULL, NULL, -1.0f, -1.0f, 0);
+        init(m_frame, FMT_YV12, buf, out_width, out_height, size);
         m_frame->timecode = (int64_t)out->PicInfo.timeStamp;
         m_frame->frameNumber = out->PicInfo.picture_number;
     }
@@ -660,23 +658,23 @@ void PrivateDecoderCrystalHD::FillFrame(BC_DTS_PROC_OUT *out)
         m_frame->qstride = size; // don't try this at home
     }
 
-    PixelFormat out_fmt = PIX_FMT_YUV420P;
-    PixelFormat in_fmt  = bcmpixfmt_to_pixfmt(m_pix_fmt);
-    AVPicture img_in, img_out;
-    avpicture_fill(&img_out, (uint8_t *)m_frame->buf, out_fmt,
-                   out_width, out_height);
-    avpicture_fill(&img_in, src, in_fmt,
-                   in_width, in_height);
+    AVPixelFormat out_fmt = AV_PIX_FMT_YUV420P;
+    AVPixelFormat in_fmt  = bcmpixfmt_to_pixfmt(m_pix_fmt);
+    AVPicture img_in;
+
+    avpicture_fill(&img_in, src, in_fmt, in_width, in_height);
 
     if (!(out->PicInfo.flags & VDEC_FLAG_INTERLACED_SRC))
     {
-        myth_sws_img_convert(&img_out, out_fmt, &img_in, in_fmt,
-                             in_width, in_height);
+        AVPictureCopy(m_frame, &img_in, in_fmt);
         m_frame->interlaced_frame = 0;
         AddFrameToQueue();
     }
     else
     {
+        AVPicture img_out;
+
+        AVPictureFill(&img_out, m_frame);
         img_out.linesize[0] *= 2;
         img_out.linesize[1] *= 2;
         img_out.linesize[2] *= 2;
@@ -930,13 +928,13 @@ QString poutflags_to_string(int flags)
     return res;
 }
 
-PixelFormat bcmpixfmt_to_pixfmt(BC_OUTPUT_FORMAT fmt)
+AVPixelFormat bcmpixfmt_to_pixfmt(BC_OUTPUT_FORMAT fmt)
 {
     switch (fmt)
     {
-        case OUTPUT_MODE420:      return PIX_FMT_YUV420P;
-        case OUTPUT_MODE422_YUY2: return PIX_FMT_YUYV422;
-        case OUTPUT_MODE422_UYVY: return PIX_FMT_UYVY422;
+        case OUTPUT_MODE420:      return AV_PIX_FMT_YUV420P;
+        case OUTPUT_MODE422_YUY2: return AV_PIX_FMT_YUYV422;
+        case OUTPUT_MODE422_UYVY: return AV_PIX_FMT_UYVY422;
     }
     return PIX_FMT_YUV420P;
 }
diff --git a/mythtv/libs/libmythtv/privatedecoder_vda.cpp b/mythtv/libs/libmythtv/privatedecoder_vda.cpp
index e19ba74..62851b6 100644
--- a/mythtv/libs/libmythtv/privatedecoder_vda.cpp
+++ b/mythtv/libs/libmythtv/privatedecoder_vda.cpp
@@ -9,6 +9,8 @@
 #include "myth_imgconvert.h"
 #include "util-osx-cocoa.h"
 #include "privatedecoder_vda.h"
+#include "mythavutil.h"
+
 #ifdef USING_QUARTZ_VIDEO
 #undef CodecType
 #import  "QuickTime/ImageCompression.h"
@@ -655,26 +657,19 @@ int  PrivateDecoderVDA::GetFrame(AVStream *stream,
     VideoFrame *frame         = (VideoFrame*)picture->opaque;
 
     PixelFormat in_fmt  = PIX_FMT_NONE;
-    PixelFormat out_fmt = PIX_FMT_NONE;
     if (vdaframe.format == 'BGRA')
         in_fmt = PIX_FMT_BGRA;
     else if (vdaframe.format == '2vuy')
         in_fmt = PIX_FMT_UYVY422;
 
-    if (frame->codec == FMT_YV12)
-        out_fmt = PIX_FMT_YUV420P;
-
-    if (out_fmt != PIX_FMT_NONE && in_fmt != PIX_FMT_NONE && frame->buf)
+    if (frame->codec == FMT_YV12 && in_fmt != PIX_FMT_NONE && frame->buf)
     {
         CVPixelBufferLockBaseAddress(vdaframe.buffer, 0);
         uint8_t* base = (uint8_t*)CVPixelBufferGetBaseAddressOfPlane(vdaframe.buffer, 0);
-        AVPicture img_in, img_out;
-        avpicture_fill(&img_out, (uint8_t *)frame->buf, out_fmt,
-                       frame->width, frame->height);
+        AVPicture img_in;
         avpicture_fill(&img_in, base, in_fmt,
                        frame->width, frame->height);
-        myth_sws_img_convert(&img_out, out_fmt, &img_in, in_fmt,
-                       frame->width, frame->height);
+        AVPictureCopy(frame, &img_in, in_fmt);
         CVPixelBufferUnlockBaseAddress(vdaframe.buffer, 0);
     }
     else
diff --git a/mythtv/libs/libmythtv/videoout_d3d.cpp b/mythtv/libs/libmythtv/videoout_d3d.cpp
index 1633c07..a4c4527 100644
--- a/mythtv/libs/libmythtv/videoout_d3d.cpp
+++ b/mythtv/libs/libmythtv/videoout_d3d.cpp
@@ -14,16 +14,13 @@ using namespace std;
 #include "mythmainwindow.h"
 #include "myth_imgconvert.h"
 #include "mythplayer.h"
+#include "mythavutil.h"
 
 #include "mmsystem.h"
 #include "tv.h"
 
 #undef UNICODE
 
-extern "C" {
-#include "libavcodec/avcodec.h"
-}
-
 const int kNumBuffers = 31;
 const int kNeedFreeFrames = 1;
 const int kPrebufferFramesNormal = 10;
@@ -464,47 +461,15 @@ void VideoOutputD3D::UpdateFrame(VideoFrame *frame, D3D9Image *img)
     uint8_t *buf = img->GetBuffer(hardware_conv, pitch);
     if (buf && hardware_conv)
     {
-        int i;
-        uint8_t *dst      = buf;
-        uint8_t *src      = frame->buf;
-        int chroma_width  = frame->width >> 1;
-        int chroma_height = frame->height >> 1;
-        int chroma_pitch  = pitch >> 1;
-        for (i = 0; i < frame->height; i++)
-        {
-            memcpy(dst, src, frame->width);
-            dst += pitch;
-            src += frame->width;
-        }
-
-        dst = buf +  (frame->height * pitch);
-        src = frame->buf + (frame->height * frame->width * 5/4);
-        for (i = 0; i < chroma_height; i++)
-        {
-            memcpy(dst, src, chroma_width);
-            dst += chroma_pitch;
-            src += chroma_width;
-        }
-
-        dst = buf + (frame->height * pitch * 5/4);
-        src = frame->buf + (frame->height * frame->width);
-        for (i = 0; i < chroma_height; i++)
-        {
-            memcpy(dst, src, chroma_width);
-            dst += chroma_pitch;
-            src += chroma_width;
-        }
+        copybuffer(buf, frame, pitch);
     }
     else if (buf && !hardware_conv)
     {
-        AVPicture image_in, image_out;
+        AVPicture image_out;
         avpicture_fill(&image_out, (uint8_t*)buf,
                        PIX_FMT_RGB32, frame->width, frame->height);
         image_out.linesize[0] = pitch;
-        avpicture_fill(&image_in, frame->buf,
-                       PIX_FMT_YUV420P, frame->width, frame->height);
-        myth_sws_img_convert(&image_out, PIX_FMT_RGB32, &image_in,
-                             PIX_FMT_YUV420P, frame->width, frame->height);
+        AVPictureCopy(&image_out, frame,(uint8_t*)buf, PIX_FMT_RGB32);
     }
     img->ReleaseBuffer();
 }
diff --git a/mythtv/libs/libmythtv/videoout_xv.cpp b/mythtv/libs/libmythtv/videoout_xv.cpp
index cb9da54..243d341 100644
--- a/mythtv/libs/libmythtv/videoout_xv.cpp
+++ b/mythtv/libs/libmythtv/videoout_xv.cpp
@@ -46,6 +46,7 @@ using namespace std;
 #include "mythmainwindow.h"
 #include "myth_imgconvert.h"
 #include "mythuihelper.h"
+#include "mythavutil.h"
 
 #define LOC      QString("VideoOutputXv: ")
 
@@ -1437,23 +1438,22 @@ void VideoOutputXv::PrepareFrameMem(VideoFrame *buffer, FrameScanType /*scan*/)
 
     int out_width  = display_visible_rect.width()  & ~0x1;
     int out_height = display_visible_rect.height() & ~0x1;
-    int size       = buffersize(FMT_YV12, out_width, out_height);
-    unsigned char *sbuf = (unsigned char*)av_malloc(size);
     AVPicture image_in, image_out;
-    static struct SwsContext  *scontext;
-
-    avpicture_fill(&image_out, (uint8_t *)sbuf, PIX_FMT_YUV420P,
-                   out_width, out_height);
+    static struct SwsContext  *scontext = NULL;
 
     if ((out_width  == width) &&
         (out_height == height))
     {
-        memcpy(sbuf, buffer->buf, width * height * 3 / 2);
+        AVPictureCopy(&image_out, buffer);
     }
     else
     {
-        avpicture_fill(&image_in, buffer->buf, PIX_FMT_YUV420P,
-                       width, height);
+        int size = buffersize(FMT_YV12, out_width, out_height);
+        unsigned char *sbuf = (unsigned char*)av_malloc(size);
+
+        avpicture_fill(&image_out, (uint8_t *)sbuf, PIX_FMT_YUV420P,
+                       out_width, out_height);
+        AVPictureFill(&image_in, buffer);
         scontext = sws_getCachedContext(scontext, width, height,
                        PIX_FMT_YUV420P, out_width,
                        out_height, PIX_FMT_YUV420P,
@@ -1484,7 +1484,7 @@ void VideoOutputXv::PrepareFrameMem(VideoFrame *buffer, FrameScanType /*scan*/)
         disp->Unlock();
     }
 
-    av_freep(&sbuf);
+    av_freep(&image_out.data[0]);
 }
 
 // this is documented in videooutbase.cpp
diff --git a/mythtv/libs/libmythtv/videooutbase.cpp b/mythtv/libs/libmythtv/videooutbase.cpp
index 0573b1f..9333ddb 100644
--- a/mythtv/libs/libmythtv/videooutbase.cpp
+++ b/mythtv/libs/libmythtv/videooutbase.cpp
@@ -15,6 +15,7 @@
 #include "mythpainter_yuva.h"
 #include "util-osd.h"
 #include "mythxdisplay.h"
+#include "mythavutil.h"
 
 #ifdef USING_XV
 #include "videoout_xv.h"
@@ -998,9 +999,10 @@ void VideoOutput::DoPipResize(int pipwidth, int pipheight)
     pip_video_size   = vid_size;
     pip_display_size = pip_desired_display_size;
 
-    int sz = pip_display_size.height() * pip_display_size.width() * 3 / 2;
-    pip_tmp_buf = new unsigned char[sz];
-    pip_tmp_buf2 = new unsigned char[sz];
+    int sz = buffersize(FMT_YV12,
+                        pip_display_size.width(), pip_display_size.height());
+    pip_tmp_buf = (unsigned char*)av_malloc(sz);
+    pip_tmp_buf2 = (unsigned char*)av_malloc(sz);
 
     pip_scaling_context = sws_getCachedContext(pip_scaling_context,
                               pip_video_size.width(), pip_video_size.height(),
@@ -1021,14 +1023,12 @@ void VideoOutput::ShutdownPipResize(void)
 {
     if (pip_tmp_buf)
     {
-        delete [] pip_tmp_buf;
-        pip_tmp_buf   = NULL;
+        av_freep(&pip_tmp_buf);
     }
 
     if (pip_tmp_buf2)
     {
-        delete [] pip_tmp_buf2;
-        pip_tmp_buf2 = NULL;
+        av_freep(&pip_tmp_buf2);
     }
 
     if (pip_scaling_context)
@@ -1108,13 +1108,11 @@ void VideoOutput::ShowPIP(VideoFrame  *frame,
         if (pip_tmp_buf && pip_scaling_context)
         {
             AVPicture img_in, img_out;
-
-            avpicture_fill(
+            int size = avpicture_fill(
                 &img_out, (uint8_t *)pip_tmp_buf, PIX_FMT_YUV420P,
                 pip_display_size.width(), pip_display_size.height());
 
-            avpicture_fill(&img_in, (uint8_t *)pipimage->buf, PIX_FMT_YUV420P,
-                           pipw, piph);
+            AVPictureFill(&img_in, pipimage);
 
             sws_scale(pip_scaling_context, img_in.data, img_in.linesize, 0,
                       piph, img_out.data, img_out.linesize);
@@ -1138,11 +1136,17 @@ void VideoOutput::ShowPIP(VideoFrame  *frame,
             {
                 pipbuf = pip_tmp_buf;
             }
-
+            int pitches[3] = { img_out.linesize[0],
+                               img_out.linesize[1],
+                               img_out.linesize[2] };
+            int offsets[3] = { 0,
+                               img_out.data[1] - img_out.data[0],
+                               img_out.data[2] - img_out.data[0] };
             pipw = pip_display_size.width();
             piph = pip_display_size.height();
 
-            init(&pip_tmp_image, FMT_YV12, pipbuf, pipw, piph, sizeof(*pipbuf));
+            init(&pip_tmp_image, FMT_YV12, pipbuf, pipw, piph, size,
+                 pitches, offsets);
         }
     }
 
@@ -1507,53 +1511,7 @@ void VideoOutput::CopyFrame(VideoFrame *to, const VideoFrame *from)
     to->frameNumber = from->frameNumber;
     to->disp_timecode = from->disp_timecode;
 
-    // guaranteed to be correct sizes.
-    if (from->size == to->size)
-        memcpy(to->buf, from->buf, from->size);
-    else if ((to->pitches[0] == from->pitches[0]) &&
-             (to->pitches[1] == from->pitches[1]) &&
-             (to->pitches[2] == from->pitches[2]))
-    {
-        memcpy(to->buf + to->offsets[0], from->buf + from->offsets[0],
-               from->pitches[0] * from->height);
-        memcpy(to->buf + to->offsets[1], from->buf + from->offsets[1],
-               from->pitches[1] * (from->height>>1));
-        memcpy(to->buf + to->offsets[2], from->buf + from->offsets[2],
-               from->pitches[2] * (from->height>>1));
-    }
-    else if ((from->height >= 0) && (to->height >= 0))
-    {
-        int f[3] = { from->height,   from->height>>1, from->height>>1, };
-        int t[3] = { to->height,     to->height>>1,   to->height>>1,   };
-        int h[3] = { min(f[0],t[0]), min(f[1],t[1]),  min(f[2],t[2]),  };
-        for (uint i = 0; i < 3; i++)
-        {
-            for (int j = 0; j < h[i]; j++)
-            {
-                memcpy(to->buf   + to->offsets[i]   + (j * to->pitches[i]),
-                       from->buf + from->offsets[i] + (j * from->pitches[i]),
-                       min(from->pitches[i], to->pitches[i]));
-            }
-        }
-    }
-
-/* XXX: Broken.
-    if (from->qstride > 0 && from->qscale_table != NULL)
-    {
-        int tablesize = from->qstride * ((from->height + 15) / 16);
-
-        if (to->qstride != from->qstride || to->qscale_table == NULL)
-        {
-            to->qstride = from->qstride;
-            if (to->qscale_table)
-                delete [] to->qscale_table;
-
-            to->qscale_table = new unsigned char[tablesize];
-        }
-
-        memcpy(to->qscale_table, from->qscale_table, tablesize);
-    }
-*/
+    copy(to, from);
 }
 
 QRect VideoOutput::GetImageRect(const QRect &rect, QRect *display)
-- 
1.7.10.2

