From b22277efbc776a70f3cff8215a9ae9f3bd5faf9a Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Sat, 28 Jun 2014 22:13:03 -0700
Subject: [PATCH 16/16] Fix compilation of mythplugins
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Using inline code was a bad idea to start withâ€¦
---
 mythtv/libs/libmythtv/libmythtv.pro  |    4 +-
 mythtv/libs/libmythtv/mythavutil.cpp |  120 ++++++++++++++++++++++++++++++++++
 mythtv/libs/libmythtv/mythavutil.h   |  120 +++-------------------------------
 3 files changed, 132 insertions(+), 112 deletions(-)
 create mode 100644 mythtv/libs/libmythtv/mythavutil.cpp

diff --git a/mythtv/libs/libmythtv/libmythtv.pro b/mythtv/libs/libmythtv/libmythtv.pro
index ea3df12..91ddae1 100644
--- a/mythtv/libs/libmythtv/libmythtv.pro
+++ b/mythtv/libs/libmythtv/libmythtv.pro
@@ -166,7 +166,7 @@ SOURCES += avfringbuffer.cpp
 SOURCES += ringbuffer.cpp           fileringBuffer.cpp
 SOURCES += streamingringbuffer.cpp  metadataimagehelper.cpp
 SOURCES += icringbuffer.cpp
-SOURCES += mythframe.cpp
+SOURCES += mythframe.cpp            mythavutil.cpp
 
 # DiSEqC
 HEADERS += diseqc.h                 diseqcsettings.h
@@ -246,7 +246,7 @@ SOURCES += srtwriter.cpp
 inc.path = $${PREFIX}/include/mythtv/
 inc.files  = playgroup.h
 inc.files += mythtvexp.h            metadataimagehelper.h
-inc.files += mythavutil.h           mythframe.h
+inc.files += mythavutil.h
 
 INSTALLS += inc
 
diff --git a/mythtv/libs/libmythtv/mythavutil.cpp b/mythtv/libs/libmythtv/mythavutil.cpp
new file mode 100644
index 0000000..0cc6554
--- /dev/null
+++ b/mythtv/libs/libmythtv/mythavutil.cpp
@@ -0,0 +1,120 @@
+//
+//  mythavutil.cpp
+//  MythTV
+//
+//  Created by Jean-Yves Avenard on 28/06/2014.
+//  Copyright (c) 2014 Bubblestuff Pty Ltd. All rights reserved.
+//
+
+#include "mythframe.h"
+#include "mythavutil.h"
+#include "myth_imgconvert.h"
+
+AVPixelFormat FrameTypeToPixelFormat(VideoFrameType type)
+{
+    switch (type)
+    {
+        case FMT_NV12:
+            return AV_PIX_FMT_NV12;
+        case FMT_YUV422P:
+            return AV_PIX_FMT_YUV422P;
+        case FMT_BGRA:
+            return AV_PIX_FMT_BGRA;
+        case FMT_YUY2:
+            return AV_PIX_FMT_UYVY422;
+        case FMT_RGB24:
+            return AV_PIX_FMT_RGB24;
+        case FMT_RGB32:
+            return AV_PIX_FMT_RGB32;
+        default:
+            return AV_PIX_FMT_YUV420P;
+    }
+}
+
+VideoFrameType PixelFormatToFrameType(AVPixelFormat fmt)
+{
+    switch (fmt)
+    {
+        case AV_PIX_FMT_NV12:
+            return FMT_NV12;
+        case AV_PIX_FMT_YUV422P:
+            return FMT_YUV422P;
+        case AV_PIX_FMT_RGB32:
+            return FMT_RGB32;
+        case AV_PIX_FMT_UYVY422:
+            return FMT_YUY2;
+        case AV_PIX_FMT_RGB24:
+            return FMT_RGB24;
+        default:
+            return FMT_YV12;
+    }
+}
+
+int AVPictureFill(AVPicture *pic, const VideoFrame *frame, AVPixelFormat fmt)
+{
+    if (fmt == AV_PIX_FMT_NONE)
+    {
+        fmt = FrameTypeToPixelFormat(frame->codec);
+    }
+
+    avpicture_fill(pic, frame->buf, fmt, frame->width, frame->height);
+    pic->data[1] = frame->buf + frame->offsets[1];
+    pic->data[2] = frame->buf + frame->offsets[2];
+    pic->linesize[0] = frame->pitches[0];
+    pic->linesize[1] = frame->pitches[1];
+    pic->linesize[2] = frame->pitches[2];
+    return (int)buffersize(frame->codec, frame->width, frame->height);
+}
+
+int AVPictureCopy(AVPicture *pic, const VideoFrame *frame,
+                  unsigned char *buffer, AVPixelFormat fmt)
+{
+    VideoFrameType type = PixelFormatToFrameType(fmt);
+    int size = buffersize(type, frame->width, frame->height, 0) + 16;
+    unsigned char *sbuf = buffer ? buffer : (unsigned char*)av_malloc(size);
+
+    if (!sbuf)
+    {
+        return 0;
+    }
+
+    avpicture_fill(pic, sbuf, fmt, frame->width, frame->height);
+    if ((type == FMT_YV12 || type == FMT_NV12) &&
+        (frame->codec == FMT_NV12 || frame->codec == FMT_YV12))
+    {
+        copybuffer(sbuf, frame, pic->linesize[0], type);
+    }
+    else
+    {
+        AVPixelFormat fmt_in = FrameTypeToPixelFormat(frame->codec);
+        AVPicture img_in;
+        AVPictureFill(&img_in, frame);
+        myth_sws_img_convert(pic, fmt, &img_in, fmt_in,
+                             frame->width, frame->height);
+    }
+
+    return size;
+}
+
+int AVPictureCopy(VideoFrame *frame, const AVPicture *pic, AVPixelFormat fmt)
+{
+    VideoFrameType type = PixelFormatToFrameType(fmt);
+    int size = buffersize(type, frame->width, frame->height, 0) + 16;
+    unsigned char *sbuf = (unsigned char*)av_malloc(size);
+
+    if ((type == FMT_YV12 || type == FMT_NV12) &&
+        (frame->codec == FMT_NV12 || frame->codec == FMT_YV12))
+    {
+        copybuffer(sbuf, frame, pic->linesize[0], type);
+    }
+    else
+    {
+        // Can't handle those natively, convert it first
+        AVPixelFormat fmt_out = FrameTypeToPixelFormat(frame->codec);
+        AVPicture img_out;
+        AVPictureFill(&img_out, frame);
+        myth_sws_img_convert(&img_out, fmt_out, pic, fmt,
+                             frame->width, frame->height);
+    }
+    return frame->size;
+}
diff --git a/mythtv/libs/libmythtv/mythavutil.h b/mythtv/libs/libmythtv/mythavutil.h
index ca10a66..cf2f483 100644
--- a/mythtv/libs/libmythtv/mythavutil.h
+++ b/mythtv/libs/libmythtv/mythavutil.h
@@ -9,11 +9,11 @@
 #ifndef MythTV_mythavutil_h
 #define MythTV_mythavutil_h
 
+#include "mythtvexp.h" // for MUNUSED
+
 extern "C" {
 #include "libavcodec/avcodec.h"
 }
-#include "mythframe.h"
-#include "myth_imgconvert.h"
 
 /** MythAVFrame
  * little utility class that act as a safe way to allocate an AVFrame
@@ -64,66 +64,14 @@ private:
     AVFrame *m_frame;
 };
 
-static inline AVPixelFormat FrameTypeToPixelFormat(VideoFrameType type)
-{
-    switch (type)
-    {
-        case FMT_NV12:
-            return AV_PIX_FMT_NV12;
-        case FMT_YUV422P:
-            return AV_PIX_FMT_YUV422P;
-        case FMT_BGRA:
-            return AV_PIX_FMT_BGRA;
-        case FMT_YUY2:
-            return AV_PIX_FMT_UYVY422;
-        case FMT_RGB24:
-            return AV_PIX_FMT_RGB24;
-        case FMT_RGB32:
-            return AV_PIX_FMT_RGB32;
-        default:
-            return AV_PIX_FMT_YUV420P;
-    }
-}
-
-static inline VideoFrameType PixelFormatToFrameType(AVPixelFormat fmt)
-{
-    switch (fmt)
-    {
-        case AV_PIX_FMT_NV12:
-            return FMT_NV12;
-        case AV_PIX_FMT_YUV422P:
-            return FMT_YUV422P;
-        case AV_PIX_FMT_RGB32:
-            return FMT_RGB32;
-        case AV_PIX_FMT_UYVY422:
-            return FMT_YUY2;
-        case AV_PIX_FMT_RGB24:
-            return FMT_RGB24;
-        default:
-            return FMT_YV12;
-    }
-}
+typedef struct VideoFrame_ VideoFrame;
 
 /**
  * AVPictureFill
  * Initialise AVPicture pic with content from VideoFrame frame
  */
-static inline int AVPictureFill(AVPicture *pic, const VideoFrame *frame,
-                                AVPixelFormat fmt = AV_PIX_FMT_NONE)
-{
-    if (fmt == AV_PIX_FMT_NONE)
-    {
-        fmt = FrameTypeToPixelFormat(frame->codec);
-    }
-
-    avpicture_fill(pic, frame->buf, fmt, frame->width, frame->height);
-    pic->data[1] = frame->buf + frame->offsets[1];
-    pic->data[2] = frame->buf + frame->offsets[2];
-    pic->linesize[0] = frame->pitches[0];
-    pic->linesize[1] = frame->pitches[1];
-    pic->linesize[2] = frame->pitches[2];
-    return (int)buffersize(frame->codec, frame->width, frame->height);
-}
+int MTV_PUBLIC AVPictureFill(AVPicture *pic, const VideoFrame *frame,
+                             AVPixelFormat fmt = AV_PIX_FMT_NONE);
 
 /**
  * AVPictureCopy
@@ -133,64 +81,16 @@ static inline int AVPictureFill(AVPicture *pic, const VideoFrame *frame,
  * Data would have to be deleted once finished with object with:
  * av_freep(pic->data[0])
  */
-static inline int AVPictureCopy(AVPicture *pic, const VideoFrame *frame,
-                                unsigned char *buffer = NULL,
-                                AVPixelFormat fmt = AV_PIX_FMT_YUV420P)
-{
-    VideoFrameType type = PixelFormatToFrameType(fmt);
-    int size = buffersize(type, frame->width, frame->height, 0) + 16;
-    unsigned char *sbuf = buffer ? buffer : (unsigned char*)av_malloc(size);
-
-    if (!sbuf)
-    {
-        return 0;
-    }
-
-    avpicture_fill(pic, sbuf, fmt, frame->width, frame->height);
-    if ((type == FMT_YV12 || type == FMT_NV12) &&
-        (frame->codec == FMT_NV12 || frame->codec == FMT_YV12))
-    {
-        copybuffer(sbuf, frame, pic->linesize[0], type);
-    }
-    else
-    {
-        AVPixelFormat fmt_in = FrameTypeToPixelFormat(frame->codec);
-        AVPicture img_in;
-        AVPictureFill(&img_in, frame);
-        myth_sws_img_convert(pic, fmt, &img_in, fmt_in,
-                             frame->width, frame->height);
-    }
-
-    return size;
-}
+int MTV_PUBLIC AVPictureCopy(AVPicture *pic, const VideoFrame *frame,
+                             unsigned char *buffer = NULL,
+                             AVPixelFormat fmt = AV_PIX_FMT_YUV420P);
 
 /**
  * AVPictureCopy
  * Copy AVPicture pic into VideoFrame frame, performing the required conversion
  * Returns size of frame data
  */
-static inline int AVPictureCopy(VideoFrame *frame, const AVPicture *pic,
-                                AVPixelFormat fmt = AV_PIX_FMT_YUV420P)
-{
-    VideoFrameType type = PixelFormatToFrameType(fmt);
-    int size = buffersize(type, frame->width, frame->height, 0) + 16;
-    unsigned char *sbuf = (unsigned char*)av_malloc(size);
-
-    if ((type == FMT_YV12 || type == FMT_NV12) &&
-        (frame->codec == FMT_NV12 || frame->codec == FMT_YV12))
-    {
-        copybuffer(sbuf, frame, pic->linesize[0], type);
-    }
-    else
-    {
-        // Can't handle those natively, convert it first
-        AVPixelFormat fmt_out = FrameTypeToPixelFormat(frame->codec);
-        AVPicture img_out;
-        AVPictureFill(&img_out, frame);
-        myth_sws_img_convert(&img_out, fmt_out, pic, fmt,
-                             frame->width, frame->height);
-    }
-    return frame->size;
-}
+int MTV_PUBLIC AVPictureCopy(VideoFrame *frame, const AVPicture *pic,
+                             AVPixelFormat fmt = AV_PIX_FMT_YUV420P);
 
 #endif
-- 
1.7.10.2

