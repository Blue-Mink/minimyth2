From 1ae6a1fd64e5721099c9f80f34a6d0ba19f0c614 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Sun, 11 May 2014 21:08:11 +0930
Subject: [PATCH 56/57] Rework IPTV and RTSP recorders
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Lots of issues fixed and addition of missing (but required) features

- Add IPv6 support
- Handle RTCP channel (not 100% sure it’s the right information sent, but it allows to keep alive the connection with some server, and doesn’t impact playback)
- Handle Keep Alive and maintain the RTSP TCP connection life so the rtsp server doesn’t drop us (seen with VLC rtsp server and FreeBox IPTV stream)
- Can use hostnames in URL instead of just IP addresses
- Proper support of rtsp’s SDP

Fixes #11949

(cherry picked from commit 57b64c4af16aedee1608119f8e68ee01e2343d6f)

Conflicts:
	mythtv/libs/libmythtv/recorders/iptvstreamhandler.cpp
---
 mythtv/libs/libmythtv/libmythtv.pro                |    1 +
 mythtv/libs/libmythtv/recorders/cetonrtsp.cpp      |  345 ++++++++++++++++++--
 mythtv/libs/libmythtv/recorders/cetonrtsp.h        |   40 ++-
 .../libs/libmythtv/recorders/iptvstreamhandler.cpp |  224 ++++++++++---
 .../libs/libmythtv/recorders/iptvstreamhandler.h   |   38 ++-
 .../libs/libmythtv/recorders/rtp/rtcpdatapacket.h  |  157 +++++++++
 6 files changed, 700 insertions(+), 105 deletions(-)
 create mode 100644 mythtv/libs/libmythtv/recorders/rtp/rtcpdatapacket.h

diff --git a/mythtv/libs/libmythtv/libmythtv.pro b/mythtv/libs/libmythtv/libmythtv.pro
index eb8564c..c0a3145 100644
--- a/mythtv/libs/libmythtv/libmythtv.pro
+++ b/mythtv/libs/libmythtv/libmythtv.pro
@@ -639,6 +639,7 @@ using_backend {
     HEADERS += recorders/rtp/rtppacketbuffer.h
     HEADERS += recorders/rtp/rtpdatapacket.h
     HEADERS += recorders/rtp/rtpfecpacket.h
+    HEADERS += recorders/rtp/rtcpdatapacket.h
 
     SOURCES += recorders/cetonrtsp.cpp
     SOURCES += recorders/iptvchannel.cpp
diff --git a/mythtv/libs/libmythtv/recorders/cetonrtsp.cpp b/mythtv/libs/libmythtv/recorders/cetonrtsp.cpp
index eaef536..4d59e0d 100644
--- a/mythtv/libs/libmythtv/recorders/cetonrtsp.cpp
+++ b/mythtv/libs/libmythtv/recorders/cetonrtsp.cpp
@@ -7,46 +7,106 @@
 #include <QStringList>
 #include <QTcpSocket>
 #include <QUrl>
+#include <QVector>
 
 // MythTV includes
 #include "cetonrtsp.h"
 #include "mythlogging.h"
+#include "mythsocket.h"
 
 
-#define LOC QString("CetonRTSP(%1): ").arg(_requestUrl)
+#define LOC QString("CetonRTSP(%1): ").arg(_requestUrl.toString())
 
 QMutex CetonRTSP::_rtspMutex;
 
 CetonRTSP::CetonRTSP(const QString &ip, uint tuner, ushort port) :
-    _ip(ip),
-    _port(port),
+    _socket(NULL),
     _sequenceNumber(0),
     _sessionId("0"),
-    _responseCode(-1)
+    _responseCode(-1),
+    _timeout(60),
+    _timer(0)
 {
-    _requestUrl = QString("rtsp://%1:%2/cetonmpeg%3")
-        .arg(ip).arg(port).arg(tuner);
+    _requestUrl.setHost(ip);
+    _requestUrl.setPort(port);
+    _requestUrl.setScheme("rtsp");
+    _requestUrl.setPath(QString("cetonmpeg%1").arg(tuner));
 }
 
 CetonRTSP::CetonRTSP(const QUrl &url) :
-    _ip(url.host()),
-    _port((url.port() >= 0) ? url.port() : 554),
+    _socket(NULL),
     _sequenceNumber(0),
     _sessionId("0"),
-    _responseCode(-1)
+    _requestUrl(url),
+    _responseCode(-1),
+    _timeout(60),
+    _timer(0)
 {
-    _requestUrl = url.toString();
+    if (url.port() < 0)
+    {
+        // default rtsp port
+        _requestUrl.setPort(554);
+    }
+}
+
+CetonRTSP::~CetonRTSP()
+{
+    StopKeepAlive();
 }
 
 bool CetonRTSP::ProcessRequest(
-    const QString &method, const QStringList* headers)
+    const QString &method, const QStringList* headers,
+    bool use_control, bool waitforanswer)
 {
     QMutexLocker locker(&_rtspMutex);
-    QTcpSocket socket;
-    socket.connectToHost(_ip, _port);
+
+    _responseHeaders.clear();
+    _responseContent.clear();
+
+    // Create socket if socket object has never been created or in non-connected state
+    if (!_socket || _socket->state() != QAbstractSocket::ConnectedState)
+    {
+        if (!_socket)
+        {
+            _socket = new QTcpSocket();
+        }
+        else
+        {
+            _socket->close();
+        }
+        _socket->connectToHost(_requestUrl.host(), _requestUrl.port(),
+                               QAbstractSocket::ReadWrite);
+        bool ok = _socket->waitForConnected();
+
+        if (!ok)
+        {
+            LOG(VB_GENERAL, LOG_ERR, LOC +
+                QString("Could not connect to server %1:%2")
+                .arg(_requestUrl.host()).arg(_requestUrl.port()));
+            delete _socket;
+            _socket = NULL;
+            return false;
+        }
+    }
+    else
+    {
+        // empty socket's waiting data just in case
+        _socket->waitForReadyRead(30);
+        do
+        {
+            QVector<char> trash;
+            uint avail = _socket->bytesAvailable();
+            trash.resize(std::max((uint)trash.size(), avail));
+            _socket->read(trash.data(), avail);
+            _socket->waitForReadyRead(30);
+        }
+        while (_socket->bytesAvailable() > 0);
+    }
 
     QStringList requestHeaders;
-    requestHeaders.append(QString("%1 %2 RTSP/1.0").arg(method, _requestUrl));
+    requestHeaders.append(QString("%1 %2 RTSP/1.0")
+        .arg(method)
+        .arg(use_control ? _controlUrl.toString() :  _requestUrl.toString()));
     requestHeaders.append(QString("User-Agent: MythTV Ceton Recorder"));
     requestHeaders.append(QString("CSeq: %1").arg(++_sequenceNumber));
     if (_sessionId != "0")
@@ -64,11 +124,14 @@ bool CetonRTSP::ProcessRequest(
 
 
     LOG(VB_RECORD, LOG_DEBUG, LOC + QString("write: %1").arg(request));
-    socket.write(request.toLatin1());
+    _socket->write(request.toLatin1());
 
     _responseHeaders.clear();
     _responseContent.clear();
 
+    if (!waitforanswer)
+        return true;
+
     QRegExp firstLineRegex(
         "^RTSP/1.0 (\\d+) ([^\r\n]+)", Qt::CaseSensitive, QRegExp::RegExp2);
     QRegExp headerRegex(
@@ -79,18 +142,18 @@ bool CetonRTSP::ProcessRequest(
     bool firstLine = true;
     while (true)
     {
-        if (!socket.canReadLine())
+        if (!_socket->canReadLine())
         {
-            bool ready = socket.waitForReadyRead();
+            bool ready = _socket->waitForReadyRead(30 * 1000);
             if (!ready)
             {
-                LOG(VB_RECORD, LOG_ERR, LOC + "RTSP server did not respond");
+                LOG(VB_RECORD, LOG_ERR, LOC + "RTSP server did not respond after 30s");
                 return false;
             }
             continue;
         }
 
-        QString line = socket.readLine();
+        QString line = _socket->readLine();
         LOG(VB_RECORD, LOG_DEBUG, LOC + QString("read: %1").arg(line));
 
         if (firstLine)
@@ -108,6 +171,13 @@ bool CetonRTSP::ProcessRequest(
             _responseCode = parts.at(1).toInt();
             _responseMessage = parts.at(2);
 
+            if (_responseCode != 200)
+            {
+                _responseMessage =
+                    QString("Server couldn't process the request: '%1'")
+                    .arg(_responseMessage);
+                return false;
+            }
             firstLine = false;
             continue;
         }
@@ -125,7 +195,25 @@ bool CetonRTSP::ProcessRequest(
         _responseHeaders.insert(parts.at(1), parts.at(2));
     }
 
-    QString cSeq = _responseHeaders.value("CSeq");
+    QString cSeq;
+
+    if (_responseHeaders.contains("CSeq"))
+    {
+        cSeq = _responseHeaders["CSeq"];
+    }
+    else
+    {
+        // Handle broken implementation, such as VLC
+        // doesn't respect the case of "CSeq", so find it regardless of the spelling
+        foreach (QString key, _responseHeaders.keys())
+        {
+            if (key.compare("CSeq", Qt::CaseInsensitive) == 0)
+            {
+                cSeq = _responseHeaders.value(key);
+                break;
+            }
+        }
+    }
     if (cSeq != QString("%1").arg(_sequenceNumber))
     {
         LOG(VB_RECORD, LOG_WARNING, LOC +
@@ -142,10 +230,10 @@ bool CetonRTSP::ProcessRequest(
         int bytesRead = 0;
         while (bytesRead < contentLength)
         {
-            if (socket.bytesAvailable() == 0)
-                socket.waitForReadyRead();
+            if (_socket->bytesAvailable() == 0)
+                _socket->waitForReadyRead();
 
-            int count = socket.read(data+bytesRead, contentLength-bytesRead);
+            int count = _socket->read(data+bytesRead, contentLength-bytesRead);
             if (count == -1)
             {
                 _responseCode = -1;
@@ -154,6 +242,8 @@ bool CetonRTSP::ProcessRequest(
             }
             bytesRead += count;
         }
+        LOG(VB_RECORD, LOG_DEBUG, LOC +
+            QString("received: %1").arg(_responseContent.constData()));
     }
     return true;
 }
@@ -168,22 +258,150 @@ bool CetonRTSP::GetOptions(QStringList &options)
     return false;
 }
 
+/**
+ * splitLines. prepare SDP content for easy read
+ */
+QStringList CetonRTSP::splitLines(const QByteArray &lines)
+{
+    QStringList list;
+    QTextStream stream(lines);
+    QString line;
+
+    do
+    {
+        line = stream.readLine();
+        if (!line.isNull())
+        {
+            list.append(line);
+        }
+    }
+    while (!line.isNull());
+
+    return list;
+}
+
+/**
+ * readParamaters. Scan a line like: Session: 1234556;destination=xx;client_port
+ * and return the first entry and fill the arguments in the provided Params
+ */
+QString CetonRTSP::readParamaters(const QString &key, Params &parameters)
+{
+    QString val;
+
+    if (!_responseHeaders.contains(key))
+    {
+        return val;
+    }
+
+    QStringList header = _responseHeaders.value(key).split(";");
+
+    for (int i = 0; i < header.size(); i++)
+    {
+        QString entry = header[i].trimmed();
+
+        if (i ==0)
+        {
+            val = entry;
+            continue;
+        }
+        QStringList args = entry.split("=");
+
+        parameters.insert(args[0].trimmed(),
+                          args.size() > 1 ? args[1].trimmed() : QString());
+    }
+    return val;
+}
+
+/**
+ * Return the base URL for the last DESCRIBE answer
+ */
+QUrl CetonRTSP::GetBaseUrl(void)
+{
+    if (_responseHeaders.contains("Content-Base"))
+    {
+        return _responseHeaders["Content-Base"];
+    }
+    if (_responseHeaders.contains("Content-Location"))
+    {
+        return _responseHeaders["Content-Location"];
+    }
+    return _requestUrl;
+}
+
 bool CetonRTSP::Describe(void)
 {
-    if (!ProcessRequest("DESCRIBE"))
+    QStringList headers;
+
+    headers.append("Accept: application/sdp");
+
+    if (!ProcessRequest("DESCRIBE", &headers))
         return false;
 
-    if (!_responseContent.contains("m=video 0 RTP/AVP 33"))
+    // find control url
+    QStringList lines = splitLines(_responseContent);
+    bool found = false;
+    QUrl base = _controlUrl = GetBaseUrl();
+
+    foreach (QString line, lines)
+    {
+        if (line.startsWith("m="))
+        {
+            if (found)
+            {
+                // another new stream, no need to parse further
+                break;
+            }
+            if (!line.startsWith("m=video"))
+            {
+                // not a video stream
+                continue;
+            }
+            QStringList args = line.split(" ");
+            if (args[2] == "RTP/AVP" && args[3] == "33")
+            {
+                found = true;
+            }
+            continue;
+        }
+        if (line.startsWith("c="))
+        {
+            // TODO, connection parameter
+            // assume we will always get a control entry
+            continue;
+        }
+        if (line.startsWith("a=control:"))
+        {
+            // Per RFC: a=control:rtsp://example.com/foo
+            // This attribute may contain either relative and absolute URLs,
+            // following the rules and conventions set out in RFC 1808 [25].
+            QString url = line.mid(10).trimmed();
+            _controlUrl = url;
+            if (url == "*")
+            {
+                _controlUrl = base;
+            }
+            else if (_controlUrl.isRelative())
+            {
+                _controlUrl = base.resolved(_controlUrl);
+            }
+            continue;
+        }
+    }
+
+    if (!found)
     {
         LOG(VB_RECORD, LOG_ERR, LOC + "expected content to be type "
             "\"m=video 0 RTP/AVP 33\" but it appears not to be");
+        _controlUrl = QUrl();
         return false;
     }
 
     return true;
 }
 
-bool CetonRTSP::Setup(ushort clientPort1, ushort clientPort2)
+bool CetonRTSP::Setup(ushort clientPort1, ushort clientPort2,
+                      ushort &rtpPort, ushort &rtcpPort,
+                      uint32_t &ssrc)
 {
     LOG(VB_GENERAL, LOG_INFO, QString("CetonRTSP: ") +
         QString("Transport: RTP/AVP;unicast;client_port=%1-%2")
@@ -194,28 +412,95 @@ bool CetonRTSP::Setup(ushort clientPort1, ushort clientPort2)
         QString("Transport: RTP/AVP;unicast;client_port=%1-%2")
         .arg(clientPort1).arg(clientPort2));
 
-    if (!ProcessRequest("SETUP", &extraHeaders))
+    if (!ProcessRequest("SETUP", &extraHeaders, true))
         return false;
 
-    _sessionId = _responseHeaders.value("Session");
-    if (_sessionId.size() < 8)
+    Params params;
+    QString session = readParamaters("Session", params);
+
+    if (session.isEmpty())
     {
         LOG(VB_RECORD, LOG_ERR, LOC +
             "session id not found in SETUP response");
         return false;
     }
+    if (session.size() < 8)
+    {
+        LOG(VB_RECORD, LOG_WARNING, LOC +
+            "invalid session id received");
+    }
+    _sessionId = session;
+
+    if (params.contains("timeout"))
+    {
+        _timeout = params["timeout"].toInt();
+    }
+
+    QString transport = readParamaters("Transport", params);
+    if (params.contains("ssrc"))
+    {
+        bool ok;
+        ssrc = params["ssrc"].toUInt(&ok, 16);
+    }
+    if (params.contains("server_port"))
+    {
+        QString line = params["server_port"];
+        QStringList val = line.split("-");
+
+        rtpPort = val[0].toInt();
+        rtcpPort = val.size() > 1 ? val[1].toInt() : 0;
+    }
 
     return true;
 }
 
 bool CetonRTSP::Play(void)
 {
-    return ProcessRequest("PLAY");
+    bool result = ProcessRequest("PLAY");
+
+    StartKeepAlive();
+    return result;
 }
 
 bool CetonRTSP::Teardown(void)
 {
+    StopKeepAlive();
+
     bool result = ProcessRequest("TEARDOWN");
+
+    QMutexLocker locker(&_rtspMutex);
+
+    delete _socket;
+    _socket = NULL;
+
     _sessionId = "0";
     return result;
 }
+
+void CetonRTSP::StartKeepAlive()
+{
+    if (_timer)
+        return;
+    int timeout = std::max(_timeout - 5, 5);
+    LOG(VB_RECORD, LOG_DEBUG, LOC +
+        QString("Start KeepAlive, every %1s").arg(timeout));
+    _timer = startTimer(timeout * 1000);
+}
+
+void CetonRTSP::StopKeepAlive()
+{
+    if (_timer)
+    {
+        killTimer(_timer);
+        LOG(VB_RECORD, LOG_DEBUG, LOC + "Stop KeepAlive");
+    }
+    _timer = 0;
+}
+
+void CetonRTSP::timerEvent(QTimerEvent*)
+{
+    QStringList dummy;
+
+    LOG(VB_RECORD, LOG_DEBUG, LOC + "Sending KeepAlive");
+    ProcessRequest("GET_PARAMETER", NULL, false, false);
+}
diff --git a/mythtv/libs/libmythtv/recorders/cetonrtsp.h b/mythtv/libs/libmythtv/recorders/cetonrtsp.h
index c0caeb4..43f7b54 100644
--- a/mythtv/libs/libmythtv/recorders/cetonrtsp.h
+++ b/mythtv/libs/libmythtv/recorders/cetonrtsp.h
@@ -7,40 +7,58 @@
 #ifndef CETONRTSP_H
 #define CETONRTSP_H
 
-#include <QObject>
-#include <QHash>
+#include <QMap>
 #include <QString>
 #include <QMutex>
+#include <QUrl>
 
-class QUrl;
+class QTcpSocket;
+class QUdpSocket;
 
-class CetonRTSP
+typedef QMap<QString, QString> Params;
+
+class CetonRTSP : QObject
 {
+    Q_OBJECT
+
   public:
     explicit CetonRTSP(const QString &ip, uint tuner, ushort port);
     explicit CetonRTSP(const QUrl&);
+    ~CetonRTSP();
 
     bool GetOptions(QStringList &options);
     bool Describe(void);
-    bool Setup(ushort clientPort1, ushort clientPort2);
+    bool Setup(ushort clientPort1, ushort clientPort2,
+               ushort &rtpPort, ushort &rtcpPort, uint32_t &ssrc);
     bool Play(void);
     bool Teardown(void);
 
-  protected:
+    void StartKeepAlive(void);
+    void StopKeepAlive(void);
+
+protected:
     bool ProcessRequest(
-        const QString &method, const QStringList *headers = NULL);
+        const QString &method, const QStringList *headers = NULL,
+                        bool use_control = false, bool waitforanswer = true);
 
   private:
-    QString     _ip;
-    ushort      _port;
+    QStringList splitLines(const QByteArray &lines);
+    QString readParamaters(const QString &key, Params &parameters);
+    QUrl GetBaseUrl(void);
+    void timerEvent(QTimerEvent*);
+
+    QTcpSocket *_socket;
     uint        _sequenceNumber;
     QString     _sessionId;
-    QString     _requestUrl;
+    QUrl        _requestUrl;
+    QUrl        _controlUrl;
 
     int                     _responseCode;
     QString                 _responseMessage;
-    QHash<QString,QString>  _responseHeaders;
+    Params                  _responseHeaders;
     QByteArray              _responseContent;
+    int                     _timeout;
+    int                     _timer;
 
     static QMutex _rtspMutex;
 
diff --git a/mythtv/libs/libmythtv/recorders/iptvstreamhandler.cpp b/mythtv/libs/libmythtv/recorders/iptvstreamhandler.cpp
index 416a561..89c14f3 100644
--- a/mythtv/libs/libmythtv/recorders/iptvstreamhandler.cpp
+++ b/mythtv/libs/libmythtv/recorders/iptvstreamhandler.cpp
@@ -14,6 +14,8 @@
 
 // Qt headers
 #include <QUdpSocket>
+#include <QByteArray>
+#include <QHostInfo>
 
 // MythTV headers
 #include "iptvstreamhandler.h"
@@ -22,6 +24,7 @@
 #include "rtptsdatapacket.h"
 #include "rtpdatapacket.h"
 #include "rtpfecpacket.h"
+#include "rtcpdatapacket.h"
 #include "mythlogging.h"
 #include "cetonrtsp.h"
 
@@ -107,7 +110,10 @@ IPTVStreamHandler::IPTVStreamHandler(const IPTVTuningData &tuning) :
     StreamHandler(tuning.GetDeviceKey()),
     m_tuning(tuning),
     m_write_helper(NULL),
-    m_buffer(NULL)
+    m_buffer(NULL),
+    m_rtsp_rtp_port(0),
+    m_rtsp_rtcp_port(0),
+    m_rtsp_ssrc(0)
 {
     memset(m_sockets, 0, sizeof(m_sockets));
     memset(m_read_helpers, 0, sizeof(m_read_helpers));
@@ -133,9 +139,9 @@ void IPTVStreamHandler::run(void)
 
         // Check RTSP capabilities
         QStringList options;
-        if (!(rtsp->GetOptions(options)     && options.contains("OPTIONS")  &&
-              options.contains("DESCRIBE")  && options.contains("SETUP")    &&
-              options.contains("PLAY")      && options.contains("TEARDOWN")))
+        if (!(rtsp->GetOptions(options)     && options.contains("DESCRIBE") &&
+              options.contains("SETUP")     && options.contains("PLAY")     &&
+              options.contains("TEARDOWN")))
         {
             LOG(VB_RECORD, LOG_ERR, LOC +
                 "RTSP interface did not support the necessary options");
@@ -155,31 +161,75 @@ void IPTVStreamHandler::run(void)
             return;
         }
 
-        tuning = IPTVTuningData(
-            QString("rtp://%1@%2:0")
-            .arg(m_tuning.GetURL(0).host())
-            .arg(QHostAddress(QHostAddress::Any).toString()), 0,
-            IPTVTuningData::kNone,
-            QString("rtp://%1@%2:0")
-            .arg(m_tuning.GetURL(0).host())
-            .arg(QHostAddress(QHostAddress::Any).toString()), 0,
-            "", 0);
+        m_use_rtp_streaming = true;
+
+        QUrl urltuned = m_tuning.GetURL(0);
+        urltuned.setScheme("rtp");
+        urltuned.setPort(0);
+        tuning = IPTVTuningData(urltuned.toString(), 0, IPTVTuningData::kNone,
+                                urltuned.toString(), 0, "", 0);
     }
 
     bool error = false;
+    int start_port = 0;
     for (uint i = 0; i < IPTV_SOCKET_COUNT; i++)
     {
         QUrl url = tuning.GetURL(i);
         if (url.port() < 0)
             continue;
 
+        LOG(VB_RECORD, LOG_DEBUG, LOC +
+            QString("setting up url[%1]:%2").arg(i).arg(url.toString()));
+
+        // always ensure we use consecutive port numbers
+        int port = start_port ? start_port + 1 : url.port();
+        QString host = url.host();
+        QHostAddress dest_addr(host);
+
+        if (!host.isEmpty() && dest_addr.isNull())
+        {
+            // address is a hostname, attempts to resolve it
+            QHostInfo info = QHostInfo::fromName(host);
+            QList<QHostAddress> list = info.addresses();
+
+            if (list.isEmpty())
+            {
+                LOG(VB_RECORD, LOG_ERR, LOC +
+                    QString("Can't resolve hostname:'%1'").arg(host));
+            }
+            else
+            {
+                for (int i=0; i < list.size(); i++)
+                {
+                    dest_addr = list[i];
+                    if (list[i].protocol() == QAbstractSocket::IPv6Protocol)
+                    {
+                        // We prefer first IPv4
+                        break;
+                    }
+                }
+                LOG(VB_RECORD, LOG_DEBUG, LOC +
+                    QString("resolved %1 as %2").arg(host).arg(dest_addr.toString()));
+            }
+        }
+        bool ipv6 = dest_addr.protocol() == QAbstractSocket::IPv6Protocol;
+        bool is_multicast = ipv6 ?
+            dest_addr.isInSubnet(QHostAddress::parseSubnet("ff00::/8")) :
+            (dest_addr.toIPv4Address() & 0xf0000000) == 0xe0000000;
+
         m_sockets[i] = new QUdpSocket();
+        if (!is_multicast)
+        {
+            // this allow to filter incoming traffic, and make sure it's from
+            // the requested server
+            m_sender[i] = dest_addr;
+        }
         m_read_helpers[i] = new IPTVStreamHandlerReadHelper(
             this, m_sockets[i], i);
 
         // we need to open the descriptor ourselves so we
         // can set some socket options
-        int fd = socket(AF_INET, SOCK_DGRAM, 0); // create IPv4 socket
+        int fd = socket(ipv6 ? AF_INET6 : AF_INET, SOCK_DGRAM, 0); // create IPv4 socket
         if (fd < 0)
         {
             LOG(VB_GENERAL, LOG_ERR, LOC +
@@ -189,55 +239,44 @@ void IPTVStreamHandler::run(void)
         int buf_size = 2 * 1024 * max(tuning.GetBitrate(i)/1000, 500U);
         if (!tuning.GetBitrate(i))
             buf_size = 2 * 1024 * 1024;
-        int ok = setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
+        int err = setsockopt(fd, SOL_SOCKET, SO_RCVBUF,
                             (char *)&buf_size, sizeof(buf_size));
-        if (ok)
+        if (err)
         {
             LOG(VB_GENERAL, LOG_INFO, LOC +
                 QString("Increasing buffer size to %1 failed")
                 .arg(buf_size) + ENO);
         }
-        /*
-          int broadcast = 1;
-          ok = setsockopt(fd, SOL_SOCKET, SO_BROADCAST,
-          (char *)&broadcast, sizeof(broadcast));
-          if (ok)
-          {
-          LOG(VB_GENERAL, LOG_INFO, LOC +
-          QString("Enabling broadcast failed") + ENO);
-          }
-        */
+
         m_sockets[i]->setSocketDescriptor(
             fd, QAbstractSocket::UnconnectedState, QIODevice::ReadOnly);
 
-        QHostAddress dest_addr(tuning.GetURL(i).host());
-
-        if (!m_sockets[i]->bind(dest_addr, url.port()))
+        // we bind to destination address if it's a multicast address, or
+        // the local ones otherwise
+        if (!m_sockets[i]->bind(is_multicast ?
+                                dest_addr :
+                                (ipv6 ? QHostAddress::AnyIPv6 : QHostAddress::Any),
+                                port))
         {
             LOG(VB_GENERAL, LOG_ERR, LOC + "Binding to port failed.");
             error = true;
         }
+        else
+        {
+            start_port = m_sockets[i]->localPort();
+        }
 
-        if (dest_addr != QHostAddress::Any)
+        if (is_multicast)
         {
-            //m_sockets[i]->joinMulticastGroup(dest_addr); // needs Qt 4.8
+            m_sockets[i]->joinMulticastGroup(dest_addr);
             LOG(VB_GENERAL, LOG_INFO, LOC + QString("Joining %1")
                 .arg(dest_addr.toString()));
-            struct ip_mreq imr;
-            memset(&imr, 0, sizeof(struct ip_mreq));
-            imr.imr_multiaddr.s_addr = inet_addr(
-                dest_addr.toString().toLatin1().constData());
-            imr.imr_interface.s_addr = htonl(INADDR_ANY);
-            if (setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
-                           &imr, sizeof(imr)) < 0)
-            {
-                LOG(VB_GENERAL, LOG_ERR, LOC +
-                    "setsockopt - IP_ADD_MEMBERSHIP " + ENO);
-            }
         }
 
-        if (!url.userInfo().isEmpty())
-            m_sender[i] = QHostAddress(url.userInfo());
+        if (!is_multicast && rtsp && i == 1)
+        {
+            m_rtcp_dest = dest_addr;
+        }
     }
 
     if (!error)
@@ -246,21 +285,27 @@ void IPTVStreamHandler::run(void)
             m_buffer = new RTPPacketBuffer(tuning.GetBitrate(0));
         else
             m_buffer = new UDPPacketBuffer(tuning.GetBitrate(0));
-        m_write_helper = new IPTVStreamHandlerWriteHelper(this);
+        m_write_helper =
+            new IPTVStreamHandlerWriteHelper(this);
         m_write_helper->Start();
     }
 
     if (!error && rtsp)
     {
         // Start Streaming
-        if (!rtsp->Setup(m_sockets[0]->localPort(),
-                         m_sockets[1]->localPort()) ||
+        if (!rtsp->Setup(m_sockets[0]->localPort(), m_sockets[1]->localPort(),
+                         m_rtsp_rtp_port, m_rtsp_rtcp_port, m_rtsp_ssrc) ||
             !rtsp->Play())
         {
             LOG(VB_RECORD, LOG_ERR, LOC +
                 "Starting recording (RTP initialization failed). Aborting.");
             error = true;
         }
+        if (m_rtsp_rtcp_port > 0)
+        {
+            m_write_helper->SendRTCPReport();
+            m_write_helper->StartRTCPRR();
+        }
     }
 
     if (!error)
@@ -304,6 +349,8 @@ IPTVStreamHandlerReadHelper::IPTVStreamHandlerReadHelper(
             this,     SLOT(ReadPending()));
 }
 
+#define LOC_WH QString("IPTVSH(%1): ").arg(m_parent->_device)
+
 void IPTVStreamHandlerReadHelper::ReadPending(void)
 {
     QHostAddress sender;
@@ -320,7 +367,17 @@ void IPTVStreamHandlerReadHelper::ReadPending(void)
             m_socket->readDatagram(data.data(), data.size(),
                                    &sender, &senderPort);
             if (sender_null || sender == m_sender)
+            {
                 m_parent->m_buffer->PushDataPacket(packet);
+            }
+            else
+            {
+                LOG(VB_RECORD, LOG_WARNING, LOC_WH +
+                    QString("Received on socket(%1) %2 bytes from non expected "
+                            "sender:%3 (expected:%4) ignoring")
+                    .arg(m_stream).arg(data.size())
+                    .arg(sender.toString()).arg(m_sender.toString()));
+            }
         }
     }
     else
@@ -333,15 +390,51 @@ void IPTVStreamHandlerReadHelper::ReadPending(void)
             m_socket->readDatagram(data.data(), data.size(),
                                    &sender, &senderPort);
             if (sender_null || sender == m_sender)
+            {
                 m_parent->m_buffer->PushFECPacket(packet, m_stream - 1);
+            }
+            else
+            {
+                LOG(VB_RECORD, LOG_WARNING, LOC_WH +
+                    QString("Received on socket(%1) %2 bytes from non expected "
+                            "sender:%3 (expected:%4) ignoring")
+                    .arg(m_stream).arg(data.size())
+                    .arg(sender.toString()).arg(m_sender.toString()));
+            }
         }
     }
 }
 
-#define LOC_WH QString("IPTVSH(%1): ").arg(m_parent->_device)
+IPTVStreamHandlerWriteHelper::IPTVStreamHandlerWriteHelper(IPTVStreamHandler *p)
+  : m_parent(p),                m_timer(0),             m_timer_rtcp(0),
+    m_last_sequence_number(0),  m_last_timestamp(0),
+    m_lost(0),                  m_lost_interval(0)
+{
+}
 
-void IPTVStreamHandlerWriteHelper::timerEvent(QTimerEvent*)
+IPTVStreamHandlerWriteHelper::~IPTVStreamHandlerWriteHelper()
 {
+    if (m_timer)
+    {
+        killTimer(m_timer);
+    }
+    if (m_timer_rtcp)
+    {
+        killTimer(m_timer_rtcp);
+    }
+    m_timer = 0;
+    m_timer_rtcp = 0;
+    m_parent = NULL;
+}
+
+void IPTVStreamHandlerWriteHelper::timerEvent(QTimerEvent* event)
+{
+    if (event->timerId() == m_timer_rtcp)
+    {
+        SendRTCPReport();
+        return;
+    }
+
     if (!m_parent->m_buffer->HasAvailablePacket())
         return;
 
@@ -401,8 +494,17 @@ void IPTVStreamHandlerWriteHelper::timerEvent(QTimerEvent*)
                 LOG(VB_RECORD, LOG_INFO, LOC_WH +
                     QString("Sequence number mismatch %1!=%2")
                     .arg(seq_num).arg(exp_seq_num));
+                if (seq_num > exp_seq_num)
+                {
+                    m_lost_interval = seq_num - exp_seq_num;
+                    m_lost += m_lost_interval;
+                }
             }
             m_last_sequence_number = seq_num;
+            m_last_timestamp = ts_packet.GetTimeStamp();
+            LOG(VB_RECORD, LOG_DEBUG,
+                QString("Processing RTP packet(seq:%1 ts:%2)")
+                .arg(m_last_sequence_number).arg(m_last_timestamp));
 
             m_parent->_listener_lock.lock();
 
@@ -424,7 +526,29 @@ void IPTVStreamHandlerWriteHelper::timerEvent(QTimerEvent*)
                     .arg(ts_packet.GetTSDataSize()).arg(remainder));
             }
         }
-
         m_parent->m_buffer->FreePacket(packet);
     }
 }
+
+void IPTVStreamHandlerWriteHelper::SendRTCPReport(void)
+{
+    if (m_parent->m_rtcp_dest.isNull())
+    {
+        // no point sending data if we don't know where to
+        return;
+    }
+    int seq_delta = m_last_sequence_number - m_previous_last_sequence_number;
+    RTCPDataPacket rtcp =
+        RTCPDataPacket(m_last_timestamp, m_last_timestamp + RTCP_TIMER * 1000,
+                       m_last_sequence_number, m_last_sequence_number + seq_delta,
+                       m_lost, m_lost_interval, m_parent->m_rtsp_ssrc);
+    QByteArray buf = rtcp.GetData();
+
+    LOG(VB_RECORD, LOG_DEBUG, LOC_WH +
+        QString("Sending RTCPReport to %1:%2")
+        .arg(m_parent->m_rtcp_dest.toString())
+        .arg(m_parent->m_rtsp_rtcp_port));
+    m_parent->m_sockets[1]->writeDatagram(buf.constData(), buf.size(),
+                                          m_parent->m_rtcp_dest, m_parent->m_rtsp_rtcp_port);
+    m_previous_last_sequence_number = m_last_sequence_number;
+}
diff --git a/mythtv/libs/libmythtv/recorders/iptvstreamhandler.h b/mythtv/libs/libmythtv/recorders/iptvstreamhandler.h
index 19915da..27f1a05 100644
--- a/mythtv/libs/libmythtv/recorders/iptvstreamhandler.h
+++ b/mythtv/libs/libmythtv/recorders/iptvstreamhandler.h
@@ -15,7 +15,8 @@ using namespace std;
 #include "channelutil.h"
 #include "streamhandler.h"
 
-#define IPTV_SOCKET_COUNT 3
+#define IPTV_SOCKET_COUNT   3
+#define RTCP_TIMER          10
 
 class IPTVStreamHandler;
 class DTVSignalMonitor;
@@ -45,28 +46,29 @@ class IPTVStreamHandlerWriteHelper : QObject
 {
     Q_OBJECT
 
-  public:
-    IPTVStreamHandlerWriteHelper(IPTVStreamHandler *p) :
-        m_parent(p), m_timer(0), m_last_sequence_number(0) { }
-    ~IPTVStreamHandlerWriteHelper()
-    {
-        killTimer(m_timer);
-        m_timer = 0;
-        m_parent = NULL;
-    }
+public:
+    IPTVStreamHandlerWriteHelper(IPTVStreamHandler *);
+    ~IPTVStreamHandlerWriteHelper();
 
     void Start(void)
     {
         m_timer = startTimer(200);
     }
+    void StartRTCPRR(void)
+    {
+        m_timer_rtcp = startTimer(RTCP_TIMER * 1000);
+    }
 
-  private:
+    void SendRTCPReport(void);
+
+private:
     void timerEvent(QTimerEvent*);
 
-  private:
+private:
     IPTVStreamHandler *m_parent;
-    int m_timer;
-    uint m_last_sequence_number;
+    int m_timer, m_timer_rtcp;
+    uint m_last_sequence_number, m_last_timestamp, m_previous_last_sequence_number;
+    int m_lost, m_lost_interval;
 };
 
 class IPTVStreamHandler : public StreamHandler
@@ -97,12 +99,20 @@ class IPTVStreamHandler : public StreamHandler
     QHostAddress m_sender[IPTV_SOCKET_COUNT];
     IPTVStreamHandlerWriteHelper *m_write_helper;
     PacketBuffer *m_buffer;
+
     bool m_use_rtp_streaming;
+    ushort m_rtsp_rtp_port, m_rtsp_rtcp_port;
+    uint32_t m_rtsp_ssrc;
+    QHostAddress m_rtcp_dest;
 
     // for implementing Get & Return
     static QMutex                            s_handlers_lock;
     static QMap<QString, IPTVStreamHandler*> s_handlers;
     static QMap<QString, uint>               s_handlers_refcnt;
+
+private:
+    void timerEvent(QTimerEvent*);
+
 };
 
 #endif // _IPTVSTREAMHANDLER_H_
diff --git a/mythtv/libs/libmythtv/recorders/rtp/rtcpdatapacket.h b/mythtv/libs/libmythtv/recorders/rtp/rtcpdatapacket.h
new file mode 100644
index 0000000..2b6e41e
--- /dev/null
+++ b/mythtv/libs/libmythtv/recorders/rtp/rtcpdatapacket.h
@@ -0,0 +1,157 @@
+//
+//  rtcpdatapacket.h
+//  MythTV
+//
+//  Created by Jean-Yves Avenard on 6/05/2014.
+//  Copyright (c) 2014 Bubblestuff Pty Ltd. All rights reserved.
+//
+
+#ifndef MythTV_rtcpdatapacket_h
+#define MythTV_rtcpdatapacket_h
+
+#include <QHostAddress>
+#include <QByteArray>
+#include <QtEndian>
+
+#include "udppacket.h"
+#include "mythlogging.h"
+
+#define RTP_VERSION 2
+#define RTCP_RR     201
+#define RTCP_SDES   202
+
+/** \brief RTCP Data Packet
+ *
+ *  The RTCP Header exists for all RTP packets, it contains a payload
+ *  type, timestamp and a sequence number for packet reordering.
+ *
+ *  Different RTP Data Packet types have their own sub-classes for
+ *  accessing the data portion of the packet.
+ *
+ *  The data is stored in a QByteArray which is a reference counted
+ *  shared data container, so an RTPDataPacket can be assigned to a
+ *  subclass efficiently.
+ */
+
+class RTCPDataPacket : public UDPPacket
+{
+public:
+    RTCPDataPacket(const RTCPDataPacket &o)
+  : UDPPacket(o),
+    m_timestamp(o.m_timestamp), m_last_timestamp(o.m_last_timestamp),
+    m_sequence(o.m_sequence),   m_last_sequence(o.m_last_sequence),
+    m_lost(o.m_lost),           m_ssrc(o.m_ssrc)
+    { }
+
+    RTCPDataPacket(uint32_t timestamp, uint32_t last_timestamp,
+                   uint32_t sequence, uint32_t last_sequence,
+                   uint32_t m_lost, uint32_t lost_interval,
+                   uint32_t ssrc)
+  : m_timestamp(timestamp),     m_last_timestamp(last_timestamp),
+    m_sequence(sequence),       m_last_sequence(last_sequence),
+    m_lost(m_lost),             m_lost_interval(lost_interval),
+    m_ssrc(ssrc) { }
+
+    QByteArray GetData(void) const
+    {
+        QByteArray buffer;
+
+        if (m_sequence == 0)
+        {
+            // No packet received yet, send an empty RTPC RR packet
+            uchar rtcp[10];
+
+            rtcp[0] = RTP_VERSION << 6;         // RTP version
+            rtcp[1] = RTCP_RR;                  // RTCP_RR
+            qToBigEndian((qint16)1, &rtcp[2]);  // length in words - 1
+            qToBigEndian((qint32)0, &rtcp[4]);  // our own SSRC
+            buffer = QByteArray((char *)rtcp, 10);
+        }
+        else
+        {
+            static char *hostname = (char *)"MythTV";
+            uint32_t len = strlen(hostname);
+            uchar *rtcp = new uchar[46 + len + 1];
+
+            rtcp[0] = (RTP_VERSION << 6) + 1;   // 1 report block
+            rtcp[1] = RTCP_RR;                  // RTCP_RR)
+            qToBigEndian((qint16)7, &rtcp[2]);  // length in words - 1
+                                                // our own SSRC: we use the server's SSRC + 1 to avoid conflicts
+            qToBigEndian((quint32)m_ssrc + 1, &rtcp[4]);
+            qToBigEndian((quint32)m_ssrc, &rtcp[8]);
+            // some placeholders we should really fill...
+            // RFC 1889/p 27
+
+//            extended_max          = stats->cycles + stats->max_seq;
+//            expected              = extended_max - stats->base_seq;
+//            lost                  = expected - stats->received;
+//            lost                  = FFMIN(lost, 0xffffff); // clamp it since it's only 24 bits...
+//            expected_interval     = expected - stats->expected_prior;
+//            stats->expected_prior = expected;
+//            received_interval     = stats->received - stats->received_prior;
+//            stats->received_prior = stats->received;
+//            lost_interval         = expected_interval - received_interval;
+//            if (expected_interval == 0 || lost_interval <= 0)
+//            fraction = 0;
+//            else
+//            fraction = (lost_interval << 8) / expected_interval;
+//
+//            fraction = (fraction << 24) | lost;
+//            avio_wb32(pb, fraction); /* 8 bits of fraction, 24 bits of total packets lost */
+//            avio_wb32(pb, extended_max); /* max sequence received */
+//            avio_wb32(pb, stats->jitter >> 4); /* jitter */
+//
+//            if (s->last_rtcp_ntp_time == AV_NOPTS_VALUE) {
+//                avio_wb32(pb, 0); /* last SR timestamp */
+//                avio_wb32(pb, 0); /* delay since last SR */
+//            } else {
+//                uint32_t middle_32_bits   = s->last_rtcp_ntp_time >> 16; // this is valid, right? do we need to handle 64 bit values special?
+//                uint32_t delay_since_last = av_rescale(av_gettime() - s->last_rtcp_reception_time,
+//                                                       65536, AV_TIME_BASE);
+//
+//                avio_wb32(pb, middle_32_bits); /* last SR timestamp */
+//                avio_wb32(pb, delay_since_last); /* delay since last SR */
+//            }
+
+            qToBigEndian((quint32) 0, &rtcp[12]); /* 8 bits of fraction, 24 bits of total packets lost */
+            qToBigEndian((quint32) 0, &rtcp[16]); /* max sequence received */
+            qToBigEndian((quint32) 0, &rtcp[20]); /* jitter */
+
+            qToBigEndian((quint32) m_timestamp, &rtcp[24]); /* last SR timestamp */
+            qToBigEndian((quint32) m_last_timestamp, &rtcp[28]); /* delay since last SR timestamp */
+
+            // CNAME
+            rtcp[32] = (RTP_VERSION << 6) + 1;  // 1 report block
+            rtcp[33] = RTCP_SDES;               // RTCP_SDES)
+            qToBigEndian((qint16)((7 + len + 3) / 4), &rtcp[34]); /* length in words - 1 */
+            qToBigEndian((quint32)m_ssrc, &rtcp[36]);
+            qToBigEndian((quint32)m_ssrc + 1, &rtcp[40]);
+
+            buffer = QByteArray((char *)rtcp, 44);
+
+            buffer.append((char)0x01); //44
+            buffer.append((char)len);  //45
+            buffer.append(hostname, len); //46
+            buffer.append((char)0); // 46 + len   END
+
+            // padding
+            for (len = (7 + len) % 4; len % 4; len++)
+            {
+                buffer.append((char)0);
+            }
+            delete[] rtcp;
+        }
+        return buffer;
+    }
+
+    uint GetSequenceNumber(void) const
+    {
+        return m_sequence;
+    }
+
+protected:
+    uint32_t m_timestamp, m_last_timestamp;
+    uint32_t m_sequence, m_last_sequence, m_lost, m_lost_interval;
+    uint32_t m_ssrc;
+};
+#endif
-- 
1.7.10.2

