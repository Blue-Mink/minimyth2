From 90730e55cebf249ffb5c9cf26df2c8688f31eda4 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Thu, 10 Jul 2014 17:38:31 +1000
Subject: [PATCH] Do not wait too quickly when reaching EOF

DVD Ringbuffer seeks a lot, in small files, causing the readahead to pause for one second once it reaches EOF, and preventing readsdesired to be updated. As a consequence WaitForReadsAllowed would timeout.
Also, after a seek, make sure the readahead thread is woken up, this reduce next read time by up to 1s.

Fixes #12205
---
 mythtv/libs/libmythtv/ringbuffer.cpp |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/mythtv/libs/libmythtv/ringbuffer.cpp b/mythtv/libs/libmythtv/ringbuffer.cpp
index 8eba948..3ed6e5d 100644
--- a/mythtv/libs/libmythtv/ringbuffer.cpp
+++ b/mythtv/libs/libmythtv/ringbuffer.cpp
@@ -552,6 +552,8 @@ long long RingBuffer::Seek(long long pos, int whence, bool has_lock)
         ret = SeekInternal(pos, whence);
     }
 
+    generalWait.wakeAll();
+
     if (!has_lock)
     {
         rwlock.unlock();
@@ -961,7 +963,7 @@ void RingBuffer::run(void)
 
         // These are conditions where we want to sleep to allow
         // other threads to do stuff.
-        if (setswitchtonext || (ateof && readsallowed))
+        if (setswitchtonext || (ateof && readsdesired))
         {
             ignore_for_read_timing = true;
             generalWait.wait(&rwlock, 1000);
@@ -1270,7 +1272,7 @@ bool RingBuffer::WaitForReadsAllowed(void)
            !request_pause && !commserror && readaheadrunning)
     {
         generalWait.wait(&rwlock, clamp(timeout_ms - t.elapsed(), 10, 100));
-        if (!readsallowed && t.elapsed() > 1000 && (count % 10) == 0)
+        if (!check && t.elapsed() > 1000 && (count % 10) == 0)
         {
             LOG(VB_GENERAL, LOG_WARNING, LOC +
                 "Taking too long to be allowed to read..");
@@ -1506,6 +1508,7 @@ int RingBuffer::ReadPriv(void *buf, int count, bool peek)
         rwlock.lockForWrite();
         ateof = true;
         wanttoread = 0;
+        generalWait.wakeAll();
         rwlock.unlock();
         return count;
     }
-- 
1.7.10.2

