From 75b438c383e82446db73b2eb03c6ea8e3fce5357 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Mon, 30 Jun 2014 12:16:26 -0700
Subject: [PATCH 04/12] Add MythAVCopy class

Currently, all frames conversions are done using myth_sws_img_convert, which in practice serialise all conversions made no matter how many threads we have running. This is extremely inefficient. Also, under typical use, myth_sws_img_convert will constantly delete and recreate the SwsContext.

This class will also centralise all future conversion optimisations
---
 mythtv/libs/libmythtv/mythavutil.cpp |  169 +++++++++++++++++++++++++++++++++-
 mythtv/libs/libmythtv/mythavutil.h   |   42 +++++++++
 2 files changed, 206 insertions(+), 5 deletions(-)

diff --git a/mythtv/libs/libmythtv/mythavutil.cpp b/mythtv/libs/libmythtv/mythavutil.cpp
index 0cc6554..d1645b7 100644
--- a/mythtv/libs/libmythtv/mythavutil.cpp
+++ b/mythtv/libs/libmythtv/mythavutil.cpp
@@ -8,7 +8,9 @@
 
 #include "mythframe.h"
 #include "mythavutil.h"
-#include "myth_imgconvert.h"
+extern "C" {
+#include "libswscale/swscale.h"
+}
 
 AVPixelFormat FrameTypeToPixelFormat(VideoFrameType type)
 {
@@ -89,8 +91,8 @@ int AVPictureCopy(AVPicture *pic, const VideoFrame *frame,
         AVPixelFormat fmt_in = FrameTypeToPixelFormat(frame->codec);
         AVPicture img_in;
         AVPictureFill(&img_in, frame);
-        myth_sws_img_convert(pic, fmt, &img_in, fmt_in,
-                             frame->width, frame->height);
+        MythAVCopy copy;
+        copy.Copy(pic, fmt, &img_in, fmt_in, frame->width, frame->height);
     }
 
     return size;
@@ -113,8 +115,165 @@ int AVPictureCopy(VideoFrame *frame, const AVPicture *pic, AVPixelFormat fmt)
         AVPixelFormat fmt_out = FrameTypeToPixelFormat(frame->codec);
         AVPicture img_out;
         AVPictureFill(&img_out, frame);
-        myth_sws_img_convert(&img_out, fmt_out, pic, fmt,
-                             frame->width, frame->height);
+        MythAVCopy copy;
+        copy.Copy(&img_out, fmt_out, pic, fmt, frame->width, frame->height);
     }
     return frame->size;
 }
+
+class MythAVCopyPrivate
+{
+public:
+    MythAVCopyPrivate(bool uswc)
+    : swsctx(NULL), copyctx(new MythUSWCCopy(4096, !uswc)),
+      width(0), height(0), size(0), format(AV_PIX_FMT_NONE)
+    {
+    }
+
+    ~MythAVCopyPrivate()
+    {
+        if (swsctx)
+        {
+            sws_freeContext(swsctx);
+        }
+        delete copyctx;
+    }
+
+    int SizeData(int _width, int _height, AVPixelFormat _fmt)
+    {
+        if (_width == width && _height == height && _fmt == format)
+        {
+            return size;
+        }
+        size    = avpicture_get_size(_fmt, _width, _height);
+        width   = _width;
+        height  = _height;
+        format  = _fmt;
+        return size;
+    }
+
+    SwsContext *swsctx;
+    MythUSWCCopy *copyctx;
+    int width, height, size;
+    AVPixelFormat format;
+};
+
+MythAVCopy::MythAVCopy(bool uswc) : d(new MythAVCopyPrivate(uswc))
+{
+}
+
+MythAVCopy::~MythAVCopy()
+{
+    delete d;
+}
+
+void MythAVCopy::FillFrame(VideoFrame *frame, const AVPicture *pic, int pitch,
+                           int width, int height, AVPixelFormat pix_fmt)
+{
+    int size = avpicture_get_size(pix_fmt, width, height);
+
+    if (pix_fmt == AV_PIX_FMT_YUV420P)
+    {
+        int chroma_pitch  = pitch >> 1;
+        int chroma_height = height >> 1;
+        int offsets[3] =
+            { 0,
+              pitch * height,
+              pitch * height + chroma_pitch * chroma_height };
+        int pitches[3] = { pitch, chroma_pitch, chroma_pitch };
+
+        init(frame, FMT_YV12, pic->data[0], width, height, size, pitches, offsets);
+    }
+    else if (pix_fmt == AV_PIX_FMT_NV12)
+    {
+        int offsets[3] = { 0, pitch * height, 0 };
+        int pitches[3] = { pitch, pitch, 0 };
+
+        init(frame, FMT_NV12, pic->data[0], width, height, size, pitches, offsets);
+    }
+}
+
+int MythAVCopy::Copy(AVPicture *dst, AVPixelFormat dst_pix_fmt,
+                 const AVPicture *src, AVPixelFormat pix_fmt,
+                 int width, int height)
+{
+    if ((pix_fmt == AV_PIX_FMT_YUV420P || pix_fmt == AV_PIX_FMT_NV12) &&
+        (dst_pix_fmt == AV_PIX_FMT_YUV420P || dst_pix_fmt == AV_PIX_FMT_NV12))
+    {
+        VideoFrame framein, frameout;
+
+        FillFrame(&framein, src, width, width, height, pix_fmt);
+        FillFrame(&frameout, dst, width, width, height, dst_pix_fmt);
+
+        d->copyctx->copy(&frameout, &framein);
+        return frameout.size;
+    }
+
+    d->swsctx = sws_getCachedContext(d->swsctx, width, height, pix_fmt,
+                                     width, height, dst_pix_fmt,
+                                     SWS_FAST_BILINEAR, NULL, NULL, NULL);
+    if (d->swsctx == NULL)
+    {
+        return -1;
+    }
+
+    sws_scale(d->swsctx, src->data, src->linesize,
+              0, height, dst->data, dst->linesize);
+
+    return d->SizeData(width, height, dst_pix_fmt);
+}
+
+int MythAVCopy::Copy(VideoFrame *dst, const VideoFrame *src)
+{
+    if ((src->codec == FMT_YV12 || src->codec == FMT_NV12) &&
+        (dst->codec == FMT_YV12 || dst->codec == FMT_NV12))
+    {
+        d->copyctx->copy(dst, src);
+        return dst->size;
+    }
+
+    AVPicture srcpic, dstpic;
+
+    AVPictureFill(&srcpic, src);
+    AVPictureFill(&dstpic, dst);
+
+    return Copy(&dstpic, FrameTypeToPixelFormat(dst->codec),
+                &srcpic, FrameTypeToPixelFormat(src->codec),
+                src->width, src->height);
+}
+
+int MythAVCopy::Copy(AVPicture *pic, const VideoFrame *frame,
+                 unsigned char *buffer, AVPixelFormat fmt)
+{
+    VideoFrameType type = PixelFormatToFrameType(fmt);
+    int size = buffersize(type, frame->width, frame->height, 0) + 16;
+    unsigned char *sbuf = buffer ? buffer : (unsigned char*)av_malloc(size);
+
+    if (!sbuf)
+    {
+        return 0;
+    }
+
+    AVPicture pic_in;
+    AVPixelFormat fmt_in = FrameTypeToPixelFormat(frame->codec);
+
+    AVPictureFill(&pic_in, frame, fmt_in);
+    avpicture_fill(pic, sbuf, fmt, frame->width, frame->height);
+    return Copy(pic, fmt, &pic_in, fmt_in, frame->width, frame->height);
+}
+
+int MythAVCopy::Copy(VideoFrame *frame, const AVPicture *pic, AVPixelFormat fmt)
+{
+    if (fmt == AV_PIX_FMT_NV12 || AV_PIX_FMT_YUV420P)
+    {
+        VideoFrame framein;
+        FillFrame(&framein, pic, frame->width, frame->width, frame->height, fmt);
+        return Copy(frame, &framein);
+    }
+
+    AVPicture frame_out;
+    AVPixelFormat fmt_out = FrameTypeToPixelFormat(frame->codec);
+
+    AVPictureFill(&frame_out, frame, fmt_out);
+    return Copy(&frame_out, fmt_out, pic, fmt, frame->width, frame->height);
+}
diff --git a/mythtv/libs/libmythtv/mythavutil.h b/mythtv/libs/libmythtv/mythavutil.h
index cf2f483..de018b6 100644
--- a/mythtv/libs/libmythtv/mythavutil.h
+++ b/mythtv/libs/libmythtv/mythavutil.h
@@ -93,4 +93,46 @@ int MTV_PUBLIC AVPictureCopy(AVPicture *pic, const VideoFrame *frame,
 int MTV_PUBLIC AVPictureCopy(VideoFrame *frame, const AVPicture *pic,
                              AVPixelFormat fmt = AV_PIX_FMT_YUV420P);
 
+class MythAVCopyPrivate;
+
+/**
+ * AVCopy
+ * Copy picture/frame pic, performing the required conversion
+ * Returns size of frame data
+ */
+
+class MTV_PUBLIC MythAVCopy
+{
+public:
+    MythAVCopy(bool USWC=true);
+    virtual ~MythAVCopy();
+
+    int Copy(VideoFrame *dst, const VideoFrame *src);
+    /**
+     * Copy
+     * Initialise AVPicture pic, create buffer if required and copy content of
+     * VideoFrame frame into it, performing the required conversion if any
+     * Returns size of buffer allocated
+     * Data would have to be deleted once finished with object with:
+     * av_freep(pic->data[0])
+     */
+    int Copy(AVPicture *pic, const VideoFrame *frame,
+             unsigned char *buffer = NULL,
+             AVPixelFormat fmt = AV_PIX_FMT_YUV420P);
+    /**
+     * Copy
+     * Copy AVPicture pic into VideoFrame frame, performing the required conversion
+     * Returns size of frame data
+     */
+    int Copy(VideoFrame *frame, const AVPicture *pic,
+             AVPixelFormat fmt = AV_PIX_FMT_YUV420P);
+    int Copy(AVPicture *dst, PixelFormat dst_pix_fmt,
+             const AVPicture *src, AVPixelFormat pix_fmt,
+             int width, int height);
+
+private:
+    void FillFrame(VideoFrame *frame, const AVPicture *pic, int pitch,
+                   int width, int height, AVPixelFormat pix_fmt);
+    MythAVCopyPrivate *d;
+};
 #endif
-- 
1.7.10.2

