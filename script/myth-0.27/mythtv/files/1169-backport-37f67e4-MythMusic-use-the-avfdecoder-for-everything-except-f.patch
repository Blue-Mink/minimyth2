diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/avfdecoder.cpp mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/avfdecoder.cpp
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/avfdecoder.cpp	2014-10-16 19:23:59.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/avfdecoder.cpp	2014-10-16 19:28:33.482145700 +0200
@@ -22,6 +22,7 @@
 #include <QObject>
 #include <QIODevice>
 #include <QFile>
+#include <QTimer>
 
 // Myth headers
 #include <mythconfig.h>
@@ -43,67 +44,124 @@
 #include "metaiomp4.h"
 #include "metaiowavpack.h"
 #include "decoderhandler.h"
+#include "musicplayer.h"
 
 extern "C" {
 #include "libavformat/avio.h"
+#include "libavutil/opt.h"
 }
 
-// size of the buffer used for streaming
-#define BUFFER_SIZE 65536
+/****************************************************************************/
 
-// streaming callbacks
-static int ReadFunc(void *opaque, uint8_t *buf, int buf_size)
+typedef QMap<QString,QString> ShoutCastMetaMap;
+
+class ShoutCastMetaParser
 {
-    QIODevice *io = (QIODevice*)opaque;
+  public:
+    ShoutCastMetaParser(void) :
+        m_meta_artist_pos(-1), m_meta_title_pos(-1), m_meta_album_pos(-1) { }
+    ~ShoutCastMetaParser(void) { }
 
-    buf_size = min(buf_size, (int) io->bytesAvailable());
-    return io->read((char*)buf, buf_size);
-}
+    void setMetaFormat(const QString &metaformat);
+    ShoutCastMetaMap parseMeta(const QString &meta);
 
-static int WriteFunc(void *opaque, uint8_t *buf, int buf_size)
-{
-    (void)opaque;
-    (void)buf;
-    (void)buf_size;
-    // we don't support writing to the steam
-    return -1;
-}
+  private:
+    QString m_meta_format;
+    int m_meta_artist_pos;
+    int m_meta_title_pos;
+    int m_meta_album_pos;
+};
 
-static int64_t SeekFunc(void *opaque, int64_t offset, int whence)
+void ShoutCastMetaParser::setMetaFormat(const QString &metaformat)
 {
-    QIODevice *io = (QIODevice*)opaque;
+/*
+  We support these metatags :
+  %a - artist
+  %t - track
+  %b - album
+  %r - random bytes
+ */
+    m_meta_format = metaformat;
 
-    if (whence == AVSEEK_SIZE)
-    {
-        return io->size();
-    }
-    else if (whence == SEEK_SET)
-    {
-        if (offset <= io->size())
-            return io->seek(offset);
-        else
-            return -1;
-    }
-    else if (whence == SEEK_END)
+    m_meta_artist_pos = 0;
+    m_meta_title_pos = 0;
+    m_meta_album_pos = 0;
+
+    int assign_index = 1;
+    int pos = 0;
+
+    pos = m_meta_format.indexOf("%", pos);
+    while (pos >= 0)
     {
-        int64_t newPos = io->size() + offset;
-        if (newPos >= 0 && newPos <= io->size())
-            return io->seek(newPos);
+        pos++;
+        QChar ch = m_meta_format.at(pos);
+
+        if (ch == '%')
+        {
+            pos++;
+        }
+        else if (ch == 'r' || ch == 'a' || ch == 'b' || ch == 't')
+        {
+            if (ch == 'a')
+                m_meta_artist_pos = assign_index;
+
+            if (ch == 'b')
+                m_meta_album_pos = assign_index;
+
+            if (ch == 't')
+                m_meta_title_pos = assign_index;
+
+            assign_index++;
+        }
         else
-            return -1;
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("ShoutCastMetaParser: malformed metaformat '%1'")
+                    .arg(m_meta_format));
+
+        pos = m_meta_format.indexOf("%", pos);
     }
-    else if (whence == SEEK_CUR)
+
+    m_meta_format.replace("%a", "(.*)");
+    m_meta_format.replace("%t", "(.*)");
+    m_meta_format.replace("%b", "(.*)");
+    m_meta_format.replace("%r", "(.*)");
+    m_meta_format.replace("%%", "%");
+}
+
+ShoutCastMetaMap ShoutCastMetaParser::parseMeta(const QString &mdata)
+{
+    ShoutCastMetaMap result;
+    int title_begin_pos = mdata.indexOf("StreamTitle='");
+    int title_end_pos;
+
+    if (title_begin_pos >= 0)
     {
-        int64_t newPos = io->pos() + offset;
-        if (newPos >= 0 && newPos < io->size())
-            return io->seek(newPos);
-        else
-            return -1;
+        title_begin_pos += 13;
+        title_end_pos = mdata.indexOf("';", title_begin_pos);
+        QString title = mdata.mid(title_begin_pos, title_end_pos - title_begin_pos);
+        QRegExp rx;
+        rx.setPattern(m_meta_format);
+        if (rx.indexIn(title) != -1)
+        {
+            LOG(VB_PLAYBACK, LOG_INFO, QString("ShoutCast: Meta     : '%1'")
+                    .arg(mdata));
+            LOG(VB_PLAYBACK, LOG_INFO,
+                QString("ShoutCast: Parsed as: '%1' by '%2'")
+                    .arg(rx.cap(m_meta_title_pos))
+                    .arg(rx.cap(m_meta_artist_pos)));
+
+            if (m_meta_title_pos > 0)
+                result["title"] = rx.cap(m_meta_title_pos);
+
+            if (m_meta_artist_pos > 0)
+                result["artist"] = rx.cap(m_meta_artist_pos);
+
+            if (m_meta_album_pos > 0)
+                result["album"] = rx.cap(m_meta_album_pos);
+        }
     }
-    else
-        return -1;
 
-     return -1;
+    return result;
 }
 
 static void myth_av_log(void *ptr, int level, const char* fmt, va_list vl)
@@ -182,10 +240,10 @@
     m_seekTime(-1.0),             m_devicename(""),
     m_inputFormat(NULL),          m_inputContext(NULL),
     m_audioDec(NULL),             m_inputIsFile(false),
-    m_byteIOContext(NULL),        m_errCode(0)
+    m_mdataTimer(NULL),           m_errCode(0)
 {
-    setObjectName("avfDecoder");
-    setFilename(file);
+    MThread::setObjectName("avfDecoder");
+    setURL(file);
 
     m_outputBuffer =
         (uint8_t *)av_malloc(AudioOutput::MAX_SIZE_BUFFER);
@@ -197,6 +255,9 @@
 
 avfDecoder::~avfDecoder(void)
 {
+    if (m_mdataTimer)
+        delete m_mdataTimer;
+
     if (m_inited)
         deinit();
     if (m_outputBuffer)
@@ -233,88 +294,52 @@
 
     output()->PauseUntilBuffered();
 
-    m_inputIsFile = (dynamic_cast<QFile*>(input()) != NULL);
-
     if (m_inputContext)
-        avformat_free_context(m_inputContext);
+        delete m_inputContext;
 
-    m_inputContext = avformat_alloc_context();
+    m_inputContext = new RemoteAVFormatContext(getURL());
 
-    // open device
-    if (m_inputIsFile)
+    if (!m_inputContext->getContext())
     {
-        filename = ((QFile *)input())->fileName();
-        LOG(VB_PLAYBACK, LOG_INFO,
-            QString("avfDecoder: playing file %1").arg(filename));
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Could not open url (%1)").arg(m_url));
+        error(QString("Could not open url  (%1)").arg(m_url));
+        deinit();
+        return false;
     }
-    else
+
+    // if this is a ice/shoutcast or MMS stream start polling for metadata changes and buffer status
+    if (getURL().startsWith("http://") || getURL().startsWith("mmsh://"))
     {
-        // if the input is not a file then setup the buffer
-        // and iocontext to stream from it
-        bool isSG = dynamic_cast<MusicSGIODevice*>(input());
-        unsigned char *buffer =
-            (unsigned char*)av_malloc(BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
-        m_byteIOContext = avio_alloc_context(buffer, BUFFER_SIZE, 0, input(),
-                                             &ReadFunc, &WriteFunc, &SeekFunc);
+        m_mdataTimer = new QTimer;
+        m_mdataTimer->setSingleShot(false);
+        connect(m_mdataTimer, SIGNAL(timeout()), this, SLOT(checkMetatdata()));
 
-        // we can only seek in files streamed using MusicSGIODevice
-        m_byteIOContext->seekable = isSG;
+        m_mdataTimer->start(500);
 
-        if (!isSG)
+        // we don't get metadata updates for MMS streams so grab the metadata from the headers
+        if (getURL().startsWith("mmsh://"))
         {
-            // probe the stream
-            filename = "stream";
-            AVProbeData probe_data;
-            probe_data.filename = filename.toLocal8Bit().constData();
-            probe_data.buf_size = min(BUFFER_SIZE, (int)input()->bytesAvailable());
-            probe_data.buf = buffer;
-            input()->peek((char*)probe_data.buf, probe_data.buf_size);
-            m_inputFormat = av_probe_input_format(&probe_data, 1);
+            AVDictionaryEntry *tag = NULL;
+            MusicMetadata mdata =  gPlayer->getDecoderHandler()->getMetadata();
 
-            if (!m_inputFormat)
-            {
-                error("Could not identify the stream type in "
-                      "avfDecoder::initialize");
-                deinit();
-                return false;
-            }
+            tag = av_dict_get(m_inputContext->getContext()->metadata, "title", tag, AV_DICT_IGNORE_SUFFIX);
+            mdata.setTitle(tag->value);
 
-            LOG(VB_PLAYBACK, LOG_INFO,
-                QString("avfDecoder: playing stream, format probed is: %1")
-                    .arg(m_inputFormat->long_name));
-        }
-    }
+            tag = av_dict_get(m_inputContext->getContext()->metadata, "artist", tag, AV_DICT_IGNORE_SUFFIX);
+            mdata.setArtist(tag->value);
 
-    // open the media file
-    // this should populate the input context
-    int err;
-    if (m_inputIsFile)
-    {
-        err = avformat_open_input(&m_inputContext,
-                                  filename.toLocal8Bit().constData(),
-                                  m_inputFormat, NULL);
-    }
-    else
-    {
-        m_inputContext->pb = m_byteIOContext;
-        err = avformat_open_input(&m_inputContext, "decoder",
-                                  m_inputFormat, NULL);
-    }
+            mdata.setAlbum("");
+            mdata.setLength(-1);
 
-    if (err < 0)
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("Could not open file (%1)").arg(filename));
-        LOG(VB_GENERAL, LOG_ERR, QString("AV decoder. Error: %1").arg(err));
-        error(QString("Could not open file  (%1)").arg(filename) +
-              QString("\nAV decoder. Error: %1").arg(err));
-        deinit();
-        return false;
+            DecoderHandlerEvent ev(DecoderHandlerEvent::Meta, mdata);
+            dispatch(ev);
+        }
     }
 
     // determine the stream format
     // this also populates information needed for metadata
-    if (avformat_find_stream_info(m_inputContext, NULL) < 0)
+    if (avformat_find_stream_info(m_inputContext->getContext(), NULL) < 0)
     {
         error("Could not determine the stream format.");
         deinit();
@@ -324,7 +349,7 @@
     // let FFmpeg finds the best audio stream (should only be one), also catter
     // should the file/stream not be an audio one
     AVCodec *codec;
-    int selTrack = av_find_best_stream(m_inputContext, AVMEDIA_TYPE_AUDIO,
+    int selTrack = av_find_best_stream(m_inputContext->getContext(), AVMEDIA_TYPE_AUDIO,
                                        -1, -1, &codec, 0);
 
     if (selTrack < 0)
@@ -335,10 +360,10 @@
     }
 
     // Store the audio codec of the stream
-    m_audioDec = m_inputContext->streams[selTrack]->codec;
+    m_audioDec = m_inputContext->getContext()->streams[selTrack]->codec;
 
     // Store the input format of the context
-    m_inputFormat = m_inputContext->iformat;
+    m_inputFormat = m_inputContext->getContext()->iformat;
 
     if (avcodec_open2(m_audioDec, codec, NULL) < 0)
     {
@@ -384,8 +409,11 @@
 
 void avfDecoder::seek(double pos)
 {
-    if (m_inputIsFile || (m_byteIOContext && m_byteIOContext->seekable))
+    if (m_inputContext->getContext() && m_inputContext->getContext()->pb &&
+        m_inputContext->getContext()->pb->seekable)
+    {
         m_seekTime = pos;
+    }
 }
 
 void avfDecoder::deinit()
@@ -396,25 +424,18 @@
     setOutput(0);
 
     // Cleanup here
-    if (m_inputContext)
+    if (m_inputContext && m_inputContext->getContext())
     {
-        for (uint i = 0; i < m_inputContext->nb_streams; i++)
+        for (uint i = 0; i < m_inputContext->getContext()->nb_streams; i++)
         {
-            AVStream *st = m_inputContext->streams[i];
+            AVStream *st = m_inputContext->getContext()->streams[i];
             if (st->codec && st->codec->codec)
                 avcodec_close(st->codec);
         }
-        avformat_close_input(&m_inputContext);
     }
 
     m_audioDec = NULL;
     m_inputFormat = NULL;
-
-    if (m_byteIOContext)
-    {
-        av_freep(&m_byteIOContext->buffer);
-        av_freep(&m_byteIOContext);
-    }
 }
 
 void avfDecoder::run()
@@ -436,7 +457,7 @@
         dispatch(e);
     }
 
-    av_read_play(m_inputContext);
+    av_read_play(m_inputContext->getContext());
 
     while (!m_finish && !m_userStop)
     {
@@ -446,7 +467,7 @@
             LOG(VB_GENERAL, LOG_INFO, QString("avfdecoder.o: seek time %1")
                     .arg(m_seekTime));
 
-            if (av_seek_frame(m_inputContext, -1,
+            if (av_seek_frame(m_inputContext->getContext(), -1,
                               (int64_t)(m_seekTime * AV_TIME_BASE), 0) < 0)
                 LOG(VB_GENERAL, LOG_ERR, "Error seeking");
 
@@ -456,13 +477,13 @@
         while (!m_finish && !m_userStop && m_seekTime <= 0.0)
         {
             // Read a packet from the input context
-            int res = av_read_frame(m_inputContext, &pkt);
+            int res = av_read_frame(m_inputContext->getContext(), &pkt);
             if (res < 0)
             {
                 if (res != AVERROR_EOF)
                 {
                     LOG(VB_GENERAL, LOG_ERR, QString("Read frame failed: %1").arg(res));
-                    LOG(VB_FILE, LOG_ERR, ("... for file '" + filename) + "'");
+                    LOG(VB_FILE, LOG_ERR, ("... for file '" + m_url) + "'");
                 }
 
                 m_finish = true;
@@ -538,6 +559,47 @@
     RunEpilog();
 }
 
+void avfDecoder::checkMetatdata(void)
+{
+    uint8_t *mdata = NULL;
+
+    if (av_opt_get(m_inputContext->getContext(), "icy_metadata_packet", AV_OPT_SEARCH_CHILDREN, &mdata) >= 0)
+    {
+        QString s = QString::fromUtf8((const char*) mdata);
+
+        if (m_lastMetadata != s)
+        {
+            m_lastMetadata = s;
+
+            LOG(VB_PLAYBACK, LOG_INFO, QString("avfDecoder: shoutcast metadata changed - %1").arg(m_lastMetadata));
+
+            ShoutCastMetaParser parser;
+            parser.setMetaFormat(gPlayer->getDecoderHandler()->getMetadata().MetadataFormat());
+
+            ShoutCastMetaMap meta_map = parser.parseMeta(m_lastMetadata);
+
+            MusicMetadata mdata =  gPlayer->getDecoderHandler()->getMetadata();
+            mdata.setTitle(meta_map["title"]);
+            mdata.setArtist(meta_map["artist"]);
+            mdata.setAlbum(meta_map["album"]);
+            mdata.setLength(-1);
+
+            DecoderHandlerEvent ev(DecoderHandlerEvent::Meta, mdata);
+            dispatch(ev);
+        }
+
+        av_free(mdata);
+    }
+
+    if (m_inputContext->getContext()->pb)
+    {
+        int available = (int) (m_inputContext->getContext()->pb->buf_end - m_inputContext->getContext()->pb->buffer);
+        int maxSize = m_inputContext->getContext()->pb->buffer_size;
+        DecoderHandlerEvent ev(DecoderHandlerEvent::BufferStatus, available, maxSize);
+        dispatch(ev);
+    }
+}
+
 bool avfDecoderFactory::supports(const QString &source) const
 {
     QStringList list = extension().split("|", QString::SkipEmptyParts);
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/avfdecoder.h mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/avfdecoder.h
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/avfdecoder.h	2014-10-16 19:23:59.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/avfdecoder.h	2014-10-16 19:28:33.482145700 +0200
@@ -3,17 +3,19 @@
 
 #include <stdint.h>
 
+#include <QObject>
+
 #include "decoder.h"
 
 #include <audiooutputsettings.h>
+#include "remoteavformatcontext.h"
 
-extern "C" {
-#include <libavformat/avformat.h>
-#include <libavcodec/avcodec.h>
-}
+class QTimer;
 
-class avfDecoder : public Decoder
+class avfDecoder : public QObject, public Decoder
 {
+  Q_OBJECT
+
   public:
     avfDecoder(const QString &file, DecoderFactory *, AudioOutput *);
     virtual ~avfDecoder(void);
@@ -23,6 +25,9 @@
     void seek(double);
     void stop();
 
+  protected slots:
+    void checkMetatdata(void);
+
   private:
     void run();
 
@@ -40,11 +45,13 @@
     QString m_devicename;
 
     AVInputFormat *m_inputFormat;
-    AVFormatContext *m_inputContext;
+    RemoteAVFormatContext *m_inputContext;
     AVCodecContext *m_audioDec;
 
     bool m_inputIsFile;
-    AVIOContext *m_byteIOContext;
+
+    QTimer *m_mdataTimer;
+    QString m_lastMetadata;
 
     int m_errCode;
 };
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/cddecoder.cpp mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/cddecoder.cpp
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/cddecoder.cpp	2014-10-16 19:24:08.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/cddecoder.cpp	2014-10-16 19:28:33.482145700 +0200
@@ -109,7 +109,7 @@
     m_end(CDIO_INVALID_LSN),
     m_curpos(CDIO_INVALID_LSN)
 {
-    setFilename(file);
+    setURL(file);
 }
 
 // virtual
@@ -177,7 +177,7 @@
     if (output())
         output()->PauseUntilBuffered();
 
-    m_tracknum = getFilename().section('.', 0, 0).toUInt();
+    m_tracknum = getURL().section('.', 0, 0).toUInt();
 
     QMutexLocker lock(&getCdioMutex());
 
@@ -562,11 +562,11 @@
     track_t tracknum = 0;
 
     if (-1 == m_settracknum)
-        tracknum = getFilename().toUInt();
+        tracknum = getURL().toUInt();
     else
     {
         tracknum = m_settracknum;
-        setFilename(QString("%1" CDEXT).arg(tracknum));
+        setURL(QString("%1" CDEXT).arg(tracknum));
     }
 
     QMutexLocker lock(&getCdioMutex());
@@ -768,7 +768,7 @@
     if (title.isEmpty())
         title = tr("Track %1").arg(tracknum);
 
-    MusicMetadata *m = new MusicMetadata(getFilename(), artist, compilation_artist,
+    MusicMetadata *m = new MusicMetadata(getURL(), artist, compilation_artist,
         album, title, genre, year, tracknum, length);
     if (m)
         m->setCompilation(isCompilation);
@@ -809,7 +809,7 @@
     }
     else
     {
-        decoder->setFilename(file);
+        decoder->setURL(file);
         decoder->setOutput(output);
     }
 
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoder.cpp mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoder.cpp
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoder.cpp	2014-07-16 11:43:10.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoder.cpp	2014-10-16 19:28:33.482145700 +0200
@@ -31,25 +31,27 @@
     (QEvent::Type) QEvent::registerEventType();
 
 Decoder::Decoder(DecoderFactory *d, AudioOutput *o) :
-    MThread("MythMusicDecoder"), fctry(d), out(o)
+    MThread("MythMusicDecoder"), m_fctry(d), m_out(o)
 {
 }
 
 Decoder::~Decoder()
 {
-    fctry = 0;
-    out = 0;
+    m_fctry = 0;
+    m_out = 0;
 }
 
-QIODevice *Decoder::input(void)
+/*
+QString Decoder::getURL(void)
 {
-    return gPlayer->getDecoderHandler()->getIOFactory()->getInput();
+    return gPlayer->getDecoderHandler()->getUrl();
 }
+*/
 
 void Decoder::setOutput(AudioOutput *o)
 {
     lock();
-    out = o;
+    m_out = o;
     unlock();
 }
 
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoder.h mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoder.h
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoder.h	2014-07-16 11:43:10.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoder.h	2014-10-16 19:28:33.482145700 +0200
@@ -73,21 +73,19 @@
     virtual void seek(double) = 0;
     virtual void stop() = 0;
 
-    DecoderFactory *factory() const { return fctry; }
+    DecoderFactory *factory() const { return m_fctry; }
 
-    QIODevice *input(void);
-    AudioOutput *output() { return out; }
+    AudioOutput *output() { return m_out; }
     void setOutput(AudioOutput *);
-    void setFilename(const QString &newName) { filename = newName; }
+    void setURL(const QString &url) { m_url = url; }
 
-    virtual void lock(void) { return mtx.lock(); }
-    virtual void unlock(void) { return mtx.unlock(); }
-    virtual bool tryLock(void) { return mtx.tryLock(); }
-    //virtual bool locked(void) { return mtx.locked(); }
+    virtual void lock(void) { return m_mtx.lock(); }
+    virtual void unlock(void) { return m_mtx.unlock(); }
+    virtual bool tryLock(void) { return m_mtx.tryLock(); }
 
-    QWaitCondition *cond() { return &cnd; }
+    QWaitCondition *cond() { return &m_cnd; }
 
-    QString getFilename(void) const { return filename; }
+    QString getURL(void) const { return m_url; }
 
     // static methods
     static QStringList all();
@@ -97,18 +95,18 @@
 
   protected:
     Decoder(DecoderFactory *, AudioOutput *);
-    QMutex* getMutex(void) { return &mtx; }
+    QMutex* getMutex(void) { return &m_mtx; }
     void error(const QString &);
 
-    QString filename;
+    QString m_url;
 
   private:
-    DecoderFactory *fctry;
+    DecoderFactory *m_fctry;
 
-    AudioOutput *out;
+    AudioOutput *m_out;
 
-    QMutex mtx;
-    QWaitCondition cnd;
+    QMutex m_mtx;
+    QWaitCondition m_cnd;
 
 };
 
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoderhandler.cpp mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoderhandler.cpp
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoderhandler.cpp	2014-10-16 19:24:11.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoderhandler.cpp	2014-10-16 19:28:33.482145700 +0200
@@ -21,7 +21,6 @@
 // mythmusic
 #include "decoderhandler.h"
 #include "decoder.h"
-#include "shoutcast.h"
 
 /**********************************************************************/
 
@@ -71,225 +70,9 @@
 
 /**********************************************************************/
 
-DecoderIOFactory::DecoderIOFactory(DecoderHandler *parent) 
-{
-    m_handler = parent;
-}
-
-DecoderIOFactory::~DecoderIOFactory(void)
-{
-}
-
-void DecoderIOFactory::doConnectDecoder(const QString &format)
-{
-    m_handler->doOperationStop();
-    m_handler->doConnectDecoder(m_handler->getUrl(), format);
-}
-
-Decoder *DecoderIOFactory::getDecoder(void)
-{
-    return m_handler->getDecoder();
-}
-
-void DecoderIOFactory::doFailed(const QString &message)
-{
-    m_handler->doOperationStop();
-    m_handler->doFailed(m_handler->getUrl(), message);
-}
-
-void DecoderIOFactory::doOperationStart(const QString &name)
-{
-    m_handler->doOperationStart(name);
-}
-
-void DecoderIOFactory::doOperationStop(void)
-{
-    m_handler->doOperationStop();
-}
-
-/**********************************************************************/
-
-DecoderIOFactoryFile::DecoderIOFactoryFile(DecoderHandler *parent)
-    : DecoderIOFactory(parent), m_input (NULL)
-{
-}
-
-DecoderIOFactoryFile::~DecoderIOFactoryFile(void)
-{
-    if (m_input)
-        delete m_input;
-}
-
-QIODevice* DecoderIOFactoryFile::getInput(void)
-{
-    return m_input;
-}
-
-void DecoderIOFactoryFile::start(void)
-{
-    QString sourcename = m_handler->getMetadata().Filename();
-
-    LOG(VB_PLAYBACK, LOG_INFO,
-        QString("DecoderIOFactory: Opening Local File %1").arg(sourcename));
-
-    m_input = new QFile(sourcename);
-    doConnectDecoder(m_handler->getUrl().toLocalFile());
-}
-
-/**********************************************************************/
-
-DecoderIOFactorySG::DecoderIOFactorySG(DecoderHandler *parent)
-    : DecoderIOFactory(parent), m_input(NULL)
-{
-}
-
-DecoderIOFactorySG::~DecoderIOFactorySG(void)
-{
-    if (m_input)
-        delete m_input;
-}
-
-QIODevice* DecoderIOFactorySG::getInput(void)
-{
-    return m_input;
-}
-
-void DecoderIOFactorySG::start(void)
-{
-    QString url = m_handler->getUrl().toString();
-    LOG(VB_PLAYBACK, LOG_INFO,
-        QString("DecoderIOFactorySG: Opening Myth URL %1").arg(url));
-    m_input = new MusicSGIODevice(url);
-
-    QString path = m_handler->getUrl().path();
-
-    if (m_handler->getUrl().hasFragment())
-        path += '#' + m_handler->getUrl().fragment();
-
-    doConnectDecoder(path);
-}
-
-/**********************************************************************/
-
-DecoderIOFactoryUrl::DecoderIOFactoryUrl(DecoderHandler *parent)
-    : DecoderIOFactory(parent), m_started(false),
-    m_accessManager(new QNetworkAccessManager(this)),
-    m_reply(NULL), m_input(new MusicIODevice()),
-    m_redirectCount(0), m_bytesWritten(0)
-
-{
-    connect(m_input, SIGNAL(freeSpaceAvailable()), SLOT(readyRead()));
-
-    m_input->open(QIODevice::ReadWrite);
-}
-
-DecoderIOFactoryUrl::~DecoderIOFactoryUrl(void)
-{
-    doClose();
-
-    m_accessManager->deleteLater();
-
-    if (m_input)
-        delete m_input;
-}
-
-QIODevice* DecoderIOFactoryUrl::getInput(void)
-{
-    return m_input;
-}
-
-void DecoderIOFactoryUrl::start(void)
-{
-    LOG(VB_PLAYBACK, LOG_INFO,
-        QString("DecoderIOFactory: Url %1").arg(m_handler->getUrl().toString()));
-
-    m_started = false;
-
-    doOperationStart(tr("Fetching remote file"));
-
-    m_reply = m_accessManager->get(QNetworkRequest(m_handler->getUrl()));
-
-    connect(m_reply, SIGNAL(readyRead()), this, SLOT(readyRead()));
-    connect(m_accessManager, SIGNAL(finished(QNetworkReply*)),
-            this, SLOT(replyFinished(QNetworkReply*)));
-}
-
-void DecoderIOFactoryUrl::stop(void)
-{
-    doClose();
-}
-
-void DecoderIOFactoryUrl::replyFinished(QNetworkReply *reply)
-{
-    if (reply->error() != QNetworkReply::NoError) 
-    {
-        doFailed("Cannot retrieve remote file.");
-        return;
-    }
-
-    QUrl possibleRedirectUrl = reply->attribute(QNetworkRequest::RedirectionTargetAttribute).toUrl();
-
-    if (!possibleRedirectUrl.isEmpty() && (m_redirectedURL != possibleRedirectUrl))
-    {
-        LOG(VB_PLAYBACK, LOG_INFO,
-            QString("DecoderIOFactory: Got redirected to %1")
-                .arg(possibleRedirectUrl.toString()));
-
-        m_redirectCount++;
-
-        if (m_redirectCount > MaxRedirects)
-        {
-            doFailed("Too many redirects");
-        }
-        else
-        {
-            m_handler->setUrl(possibleRedirectUrl);
-            m_redirectedURL = possibleRedirectUrl;
-            start();
-        }
-
-        return;
-    }
-
-    m_redirectedURL.clear();
-
-    if (!m_started)
-        doStart();
-}
-
-void DecoderIOFactoryUrl::readyRead(void)
-{
-    int available = DecoderIOFactory::DefaultBufferSize - m_input->bytesAvailable();
-    QByteArray data = m_reply->read(available);
-
-    m_bytesWritten += data.size();
-    m_input->writeData(data.data(), data.size());
-
-    if (!m_started && m_bytesWritten > DecoderIOFactory::DefaultPrebufferSize)
-    {
-        m_reply->setReadBufferSize(DecoderIOFactory::DefaultPrebufferSize);
-        doStart();
-    }
-}
-
-void DecoderIOFactoryUrl::doStart(void)
-{
-    doConnectDecoder(m_handler->getUrl().toString());
-    m_started = true;
-}
-
-void DecoderIOFactoryUrl::doClose(void)
-{
-    if (m_input && m_input->isOpen())
-        m_input->close();
-}
-
-/**********************************************************************/
-
 DecoderHandler::DecoderHandler(void) :
     m_state(STOPPED),
     m_playlist_pos(0),
-    m_io_factory(NULL),
     m_decoder(NULL),
     m_op(false),
     m_redirects(0)
@@ -387,14 +170,16 @@
 
     LOG(VB_PLAYBACK, LOG_INFO, QString("Now playing '%1'").arg(m_url.toString()));
 
-    deleteIOFactory();
-    createIOFactory(m_url);
-
-    if (! haveIOFactory())
-        return false;
+    // we use the avfdecoder for everything except CD tracks
+    if (m_url.toString().endsWith(".cda"))
+        doConnectDecoder(m_url, ".cda");
+    else
+    {
+        // we don't know what format radio stations are so fake a format
+        // and hope avfdecoder can decode it
+        doConnectDecoder(m_url, ".mp3");
+    }
 
-    getIOFactory()->addListener(this);
-    getIOFactory()->start();
     m_state = ACTIVE;
 
     return true;
@@ -425,7 +210,6 @@
         m_decoder = NULL;
     }
 
-    deleteIOFactory();
     doOperationStop();
 
     m_state = STOPPED;
@@ -569,7 +353,7 @@
         }
     }
 
-    m_decoder->setFilename(url.toString());
+    m_decoder->setURL(url.toString());
 
     DecoderHandlerEvent ev(DecoderHandlerEvent::Ready);
     dispatch(ev);
@@ -599,217 +383,3 @@
     DecoderHandlerEvent ev(DecoderHandlerEvent::OperationStop);
     dispatch(ev);
 }
-
-void DecoderHandler::createIOFactory(const QUrl &url)
-{
-    if (haveIOFactory())
-        deleteIOFactory();
-
-    if (url.scheme() == "myth")
-        m_io_factory = new DecoderIOFactorySG(this);
-    else if (m_meta.Format() == "cast")
-        m_io_factory = new DecoderIOFactoryShoutCast(this);
-    else if (url.scheme() == "http")
-        m_io_factory = new DecoderIOFactoryUrl(this);
-    else
-        m_io_factory = new DecoderIOFactoryFile(this);
-}
-
-void DecoderHandler::deleteIOFactory(void)
-{
-    if (!haveIOFactory())
-        return;
-
-    if (m_state == ACTIVE)
-        m_io_factory->stop();
-
-    m_io_factory->removeListener(this);
-    m_io_factory->disconnect();
-    m_io_factory->deleteLater();
-    m_io_factory = NULL;
-}
-
-/**********************************************************************/
-
-qint64 MusicBuffer::read(char *data, qint64 max, bool doRemove)
-{
-    QMutexLocker holder (&m_mutex);
-    const char *buffer_data = m_buffer.data();
-
-    if (max > m_buffer.size())
-        max = m_buffer.size();
-
-    memcpy(data, buffer_data, max);
-
-    if (doRemove)
-        m_buffer.remove(0, max);
-
-    return max;
-}
-
-qint64 MusicBuffer::read(QByteArray &data, qint64 max, bool doRemove)
-{
-    QMutexLocker holder (&m_mutex);
-    const char *buffer_data = m_buffer.data();
-
-    if (max > m_buffer.size())
-        max = m_buffer.size();
-
-    data.append(buffer_data, max);
-
-    if (doRemove)
-        m_buffer.remove(0, max);
-
-    return max;
-}
-
-void MusicBuffer::write(const char *data, uint sz)
-{
-    if (sz == 0)
-        return;
-
-    QMutexLocker holder(&m_mutex);
-    m_buffer.append(data, sz);
-}
-
-void MusicBuffer::write(QByteArray &array)
-{
-    if (array.size() == 0)
-        return;
-
-    QMutexLocker holder(&m_mutex);
-    m_buffer.append(array);
-}
-
-void MusicBuffer::remove(int index, int len)
-{
-    QMutexLocker holder(&m_mutex);
-    m_buffer.remove(index, len);
-}
-
-/**********************************************************************/
-
-MusicIODevice::MusicIODevice(void)
-{
-    m_buffer = new MusicBuffer;
-    setOpenMode(ReadWrite);
-}
-
-MusicIODevice::~MusicIODevice(void)
-{
-    delete m_buffer;
-}
-
-bool MusicIODevice::open(OpenMode)
-{
-    return true;
-}
-
-qint64 MusicIODevice::size(void) const
-{
-    return m_buffer->readBufAvail(); 
-}
-
-qint64 MusicIODevice::readData(char *data, qint64 maxlen)
-{
-    qint64 res = m_buffer->read(data, maxlen);
-    emit freeSpaceAvailable();
-    return res;
-}
-
-qint64 MusicIODevice::writeData(const char *data, qint64 sz)
-{
-    m_buffer->write(data, sz);
-    return sz;
-}
-
-qint64 MusicIODevice::bytesAvailable(void) const
-{
-    return m_buffer->readBufAvail();
-}
-
-int MusicIODevice::getch(void)
-{
-    assert(0);
-    return -1;
-}
-
-int MusicIODevice::putch(int)
-{
-    assert(0);
-    return -1;
-}
-
-int MusicIODevice::ungetch(int)
-{
-    assert(0);
-    return -1;
-}
-
-/**********************************************************************/
-
-MusicSGIODevice::MusicSGIODevice(const QString &url)
-{
-    m_remotefile = new RemoteFile(url);
-    setOpenMode(ReadWrite);
-}
-
-MusicSGIODevice::~MusicSGIODevice(void)
-{
-    delete m_remotefile;
-}
-
-bool MusicSGIODevice::open(OpenMode)
-{
-    return m_remotefile->isOpen();
-}
-
-bool MusicSGIODevice::seek(qint64 pos)
-{
-    long int newPos = -1;
-
-    if (m_remotefile)
-        newPos = m_remotefile->Seek(pos, 0);
-
-    return (newPos == pos);
-}
-
-qint64 MusicSGIODevice::size(void) const
-{
-    return m_remotefile->GetFileSize();
-}
-
-qint64 MusicSGIODevice::readData(char *data, qint64 maxlen)
-{
-    qint64 res = m_remotefile->Read(data, maxlen);
-    return res;
-}
-
-qint64 MusicSGIODevice::writeData(const char *data, qint64 sz)
-{
-    m_remotefile->Write(data, sz);
-    return sz;
-}
-
-qint64 MusicSGIODevice::bytesAvailable(void) const
-{
-    return m_remotefile->GetFileSize();
-}
-
-int MusicSGIODevice::getch(void)
-{
-    assert(0);
-    return -1;
-}
-
-int MusicSGIODevice::putch(int)
-{
-    assert(0);
-    return -1;
-}
-
-int MusicSGIODevice::ungetch(int)
-{
-    assert(0);
-    return -1;
-}
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoderhandler.h mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoderhandler.h
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/decoderhandler.h	2014-07-16 11:43:10.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/decoderhandler.h	2014-10-16 19:28:33.482145700 +0200
@@ -19,19 +19,7 @@
 
 #include "pls.h"
 
-class MusicBuffer;
-class RemoteFile;
-
-class QUrl;
-class QNetworkAccessManager;
-class QNetworkReply;
-
 class Decoder;
-class MusicMetadata;
-class DecoderIOFactory;
-class DecoderHandler;
-class MusicBuffer;
-class MusicIODevice;
 
 /** \brief Events sent by the \p DecoderHandler and it's helper classes.
  */
@@ -78,16 +66,12 @@
 
     It operates on a playlist, either created with a single file, by
     loading a .pls or downloading it, and for each entry creates an
-    appropriate DecoderIOFactory. The creator is simply a intermediate
-    class that translates the next URL in the playlist to
-    QIODevice. Ie. the DecoderIOFactoryFile just returns a QFile,
-    whereas the DecoderIOFactoryShoutcast returns a QSocket subclass,
-    where reads do the necessary translation of the shoutcast stream.
+    appropriate Decoder.
  */
 class DecoderHandler : public QObject, public MythObservable
 {
   Q_OBJECT
-    friend class DecoderIOFactory;
+
   public:
     typedef enum 
     {
@@ -100,7 +84,6 @@
     virtual ~DecoderHandler(void);
 
     Decoder *getDecoder(void) { return m_decoder; }
-    DecoderIOFactory *getIOFactory(void) { return m_io_factory; }
 
     void start(MusicMetadata *mdata);
 
@@ -128,14 +111,9 @@
     void createPlaylistFromFile(const QUrl &url);
     void createPlaylistFromRemoteUrl(const QUrl &url);
 
-    bool haveIOFactory(void) { return m_io_factory != NULL; }
-    void createIOFactory(const QUrl &url);
-    void deleteIOFactory(void);
-
     int               m_state;
     int               m_playlist_pos;
     PlayListFile      m_playlist;
-    DecoderIOFactory *m_io_factory;
     Decoder          *m_decoder;
     MusicMetadata     m_meta;
     QUrl              m_url;
@@ -145,173 +123,4 @@
     static const uint MaxRedirects = 3;
 };
 
-/** \brief The glue between the DecoderHandler and the Decoder
-    
-    The DecoderIOFactory is responsible for opening the QIODevice that
-    is given to the Decoder....
- */
-class DecoderIOFactory : public QObject, public MythObservable
-{
-  public:
-    DecoderIOFactory(DecoderHandler *parent);
-    virtual ~DecoderIOFactory();
-
-    virtual void start(void) = 0;
-    virtual void stop(void) = 0;
-    virtual QIODevice *getInput(void) = 0;
-
-    static const uint DefaultPrebufferSize = 128 * 1024;
-    static const uint DefaultBufferSize = 256 * 1024;
-    static const uint MaxRedirects = 3;
-
-  protected:
-    void doConnectDecoder(const QString &format);
-    Decoder *getDecoder(void);
-    void doFailed(const QString &message);
-    void doOperationStart(const QString &name);
-    void doOperationStop(void);
-
-    DecoderHandler *m_handler;
-};
-
-class DecoderIOFactoryFile : public DecoderIOFactory
-{
-  Q_OBJECT
-
-  public:
-    DecoderIOFactoryFile(DecoderHandler *parent);
-    ~DecoderIOFactoryFile(void);
-    void start(void);
-    void stop() {}
-    QIODevice *getInput(void);
-
-  private:
-    QIODevice *m_input;
-};
-
-class DecoderIOFactorySG : public DecoderIOFactory
-{
-  Q_OBJECT
-
-  public:
-    DecoderIOFactorySG(DecoderHandler *parent);
-    ~DecoderIOFactorySG(void);
-    void start(void);
-    void stop() {}
-    QIODevice *getInput(void);
-
-  private:
-    QIODevice *m_input;
-};
-
-class DecoderIOFactoryUrl : public DecoderIOFactory 
-{
-  Q_OBJECT
-
-  public:
-    DecoderIOFactoryUrl(DecoderHandler *parent);
-    ~DecoderIOFactoryUrl(void);
-
-    void start(void);
-    void stop(void);
-    QIODevice *getInput(void);
-
-  protected slots:
-    void replyFinished(QNetworkReply *reply);
-    void readyRead(void);
-
-  private:
-    void doStart(void);
-    void doClose(void);
-
-    bool m_started;
-    QNetworkAccessManager *m_accessManager;
-    QNetworkReply    *m_reply;
-    MusicIODevice *m_input;
-    QUrl   m_redirectedURL;
-    uint   m_redirectCount;
-    uint   m_bytesWritten;
-};
-
-class MusicBuffer
-{
-  public:
-    MusicBuffer(void) { }
-    ~MusicBuffer(void) { }
-
-    qint64 read(char *data, qint64 max, bool doRemove = true);
-    qint64 read(QByteArray &array, qint64 max, bool doRemove = true);
-
-    void   write(const char *data, uint sz);
-    void   write(QByteArray &array);
-
-    void   remove(int index, int len);
-
-    qint64 readBufAvail(void) const { return m_buffer.size(); }
-
-  private:
-    QByteArray m_buffer;
-    QMutex     m_mutex;
-};
-
-class MusicIODevice : public QIODevice
-{
-  Q_OBJECT
-
-  public:
-    MusicIODevice(void);
-    ~MusicIODevice(void);
-
-    virtual bool open(OpenMode mode);
-    virtual void close(void) { };
-    bool flush(void);
-
-    qint64 size(void) const;
-    qint64 pos(void) const { return 0; }
-    qint64 bytesAvailable(void) const;
-    bool   isSequential(void) const { return true; }
-
-    qint64 readData(char *data, qint64 sz);
-    qint64 writeData(const char *data, qint64 sz);
-
-    int getch(void);
-    int putch(int c);
-    int ungetch(int);
-
-  signals:
-    void freeSpaceAvailable(void);
-
-  protected:
-    MusicBuffer *m_buffer;
-};
-
-class MusicSGIODevice : public QIODevice
-{
-  Q_OBJECT
-
-  public:
-    MusicSGIODevice(const QString &url);
-    virtual ~MusicSGIODevice(void);
-
-    virtual bool open(OpenMode mode);
-    virtual void close(void) { };
-    bool flush(void);
-
-    qint64 size(void) const;
-    qint64 pos(void) const { return 0; }
-    qint64 bytesAvailable(void) const;
-    bool   isSequential(void) const { return false; }
-    bool   seek(qint64 pos);
-
-    qint64 readData(char *data, qint64 sz);
-    qint64 writeData(const char *data, qint64 sz);
-
-    int getch(void);
-    int putch(int c);
-    int ungetch(int);
-
-  protected:
-    RemoteFile *m_remotefile;
-};
-
 #endif /* DECODERHANDLER_H_ */
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/musicplayer.cpp mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/musicplayer.cpp
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/musicplayer.cpp	2014-10-16 19:24:12.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/musicplayer.cpp	2014-10-16 19:28:33.482145700 +0200
@@ -1523,7 +1523,7 @@
         return;
 
     LOG(VB_PLAYBACK, LOG_INFO, QString ("decoder handler is ready, decoding %1")
-            .arg(getDecoder()->getFilename()));
+            .arg(getDecoder()->getURL()));
 
 #ifdef HAVE_CDIO
     CdDecoder *cddecoder = dynamic_cast<CdDecoder*>(getDecoder());
@@ -1583,7 +1583,7 @@
     else
     {
         LOG(VB_PLAYBACK, LOG_ERR, QString("Cannot initialise decoder for %1")
-                .arg(getDecoder()->getFilename()));
+                .arg(getDecoder()->getURL()));
         return;
     }
 
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/mythmusic.pro mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/mythmusic.pro
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/mythmusic.pro	2014-10-16 19:24:08.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/mythmusic.pro	2014-10-16 19:28:33.482145700 +0200
@@ -38,11 +38,12 @@
 HEADERS += editmetadata.h smartplaylist.h genres.h
 HEADERS += musicplayer.h miniplayer.h
 HEADERS += playlistcontainer.h musicdata.h
-HEADERS += musiccommon.h decoderhandler.h pls.h shoutcast.h
+HEADERS += musiccommon.h decoderhandler.h pls.h
 HEADERS += playlistview.h playlisteditorview.h 
 HEADERS += visualizerview.h searchview.h streamview.h
 HEADERS += generalsettings.h visualizationsettings.h
 HEADERS += importsettings.h playersettings.h ratingsettings.h
+HEADERS += remoteavformatcontext.h
 
 SOURCES += decoder.cpp
 SOURCES += flacencoder.cpp main.cpp
@@ -57,7 +58,7 @@
 SOURCES += avfdecoder.cpp editmetadata.cpp smartplaylist.cpp
 SOURCES += musicplayer.cpp miniplayer.cpp
 SOURCES += playlistcontainer.cpp musicdata.cpp
-SOURCES += musiccommon.cpp decoderhandler.cpp pls.cpp shoutcast.cpp
+SOURCES += musiccommon.cpp decoderhandler.cpp pls.cpp
 SOURCES += playlistview.cpp playlisteditorview.cpp 
 SOURCES += visualizerview.cpp searchview.cpp streamview.cpp
 SOURCES += generalsettings.cpp visualizationsettings.cpp
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/remoteavformatcontext.h	2014-10-16 19:28:33.482145700 +0200
@@ -0,0 +1,152 @@
+// Wrapper for AVFormatContext (av_open_input_file/stream)
+// supporting myth remote files
+#ifndef REMOTEAVFORMATCONTEXT_H
+#define REMOTEAVFORMATCONTEXT_H
+
+#include <iostream>
+#include <QString>
+
+#include <remotefile.h>
+#include <mythlogging.h>
+
+extern "C" {
+#include <libavformat/avformat.h>
+#include <libavformat/avio.h>
+#include "libavutil/opt.h"
+}
+
+class RemoteAVFormatContext
+{
+  public:
+    RemoteAVFormatContext(const QString &filename = "") :
+        m_inputFC(NULL), m_inputIsRemote(false), m_rf(NULL), m_byteIOContext(NULL), m_buffer(NULL)
+    { if (!filename.isEmpty()) Open(filename); }
+
+    ~RemoteAVFormatContext()
+    {
+        Close();
+        if (m_buffer)
+            av_free(m_buffer);
+    }
+
+    AVFormatContext *getContext(void) { return m_inputFC; }
+
+    bool Open(const QString &filename)
+    {
+        if (isOpen())
+            return false;
+
+        if (m_inputFC)
+            avformat_free_context(m_inputFC);
+        m_inputFC = avformat_alloc_context();
+
+        if (m_rf)
+            delete m_rf;
+
+        m_inputIsRemote = filename.startsWith("myth://");
+        if (m_inputIsRemote)
+        {
+            m_rf = new RemoteFile(filename);
+
+            if (!m_rf->isOpen())
+                return false;
+
+            const int BUFFER_SIZE = 0x8000;
+            if (!m_buffer)
+            {
+                m_buffer = (unsigned char*)av_malloc(BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);
+                if (!m_buffer)
+                    return false;
+            }
+            m_byteIOContext = avio_alloc_context(m_buffer, BUFFER_SIZE, 0,
+                    m_rf, &ReadFunc, &WriteFunc, &SeekFunc);
+
+            m_byteIOContext->seekable = 1;
+
+            // probe the stream
+            AVProbeData probe_data;
+            probe_data.filename = "stream";
+            probe_data.buf_size = m_rf->Read(m_buffer, BUFFER_SIZE);
+            probe_data.buf = m_buffer;
+
+            AVInputFormat *fmt = av_probe_input_format(&probe_data, 1);
+            if (!fmt)
+                return false;
+
+            m_rf->Seek(0, SEEK_SET);
+
+            m_inputFC->pb = m_byteIOContext;
+
+            int ret = avformat_open_input(&m_inputFC, "stream", fmt, NULL);
+            if (ret)
+                return false;
+        }
+        else
+        {
+            // if this is a ice/shoutcast stream setup grabbing the inline metadata
+            AVDictionary *options = NULL;
+
+            if (filename.startsWith("http://"))
+                av_dict_set(&options, "icy", "1", 0);
+
+            int ret = avformat_open_input(&m_inputFC,  qPrintable(filename), NULL, &options);
+            if (ret)
+                return false;
+        }
+
+        return true;
+    }
+
+    void Close()
+    {
+        if (m_inputFC)
+        {
+            avformat_close_input(&m_inputFC);
+            m_inputFC = NULL;
+        }
+
+        if (m_rf)
+        {
+            delete m_rf;
+            m_rf = NULL;
+        }
+    }
+
+    bool isOpen() const
+    {
+        if (m_inputIsRemote)
+            return (m_inputFC != NULL && m_rf != NULL && m_rf->isOpen());
+        else
+            return (m_inputFC != NULL);
+    }
+
+    operator AVFormatContext * () const { return m_inputFC; }
+    //operator AVFormatContext & () const { return m_inputFC; }
+    AVFormatContext * operator -> () const { return m_inputFC; }
+
+  private:
+    static int ReadFunc(void *opaque, uint8_t *buf, int buf_size)
+    {
+        RemoteFile *rf = reinterpret_cast< RemoteFile* >(opaque);
+        return rf->Read(buf, buf_size);
+    }
+
+    static int WriteFunc(void *, uint8_t *, int) {  return -1; }
+
+    static int64_t SeekFunc(void *opaque, int64_t offset, int whence)
+    {
+        RemoteFile *rf = reinterpret_cast< RemoteFile* >(opaque);
+        if (whence == AVSEEK_SIZE)
+            return rf->GetFileSize();
+
+        return rf->Seek(offset, whence);
+    }
+
+  private:
+    AVFormatContext *m_inputFC;
+    bool m_inputIsRemote;
+    RemoteFile *m_rf;
+    AVIOContext *m_byteIOContext;
+    unsigned char *m_buffer;
+};
+#endif // REMOTEAVFORMATCONTEXT_H
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/shoutcast.cpp mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/shoutcast.cpp
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/shoutcast.cpp	2014-07-16 11:43:10.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/shoutcast.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,969 +0,0 @@
-/*
-  Shoutcast decoder for MythTV.
-  Eskil Heyn Olsen, 2005, distributed under the GPL as part of mythtv.
-  Paul Harrison, July 2010, Updated for Qt4
- */
-
-// c/c++
-#include <assert.h>
-#include <algorithm>
-
-// qt
-#include <QApplication>
-#include <QRegExp>
-#include <QAbstractSocket>
-#include <QTimer>
-
-// mythtv
-#include <mythcorecontext.h>
-#include <mcodecs.h>
-#include <mythversion.h>
-#include <musicmetadata.h>
-
-// mythmusic
-#include "shoutcast.h"
-
-
-/****************************************************************************/
-
-#define MAX_ALLOWED_HEADER_SIZE 1024 * 4
-#define MAX_ALLOWED_META_SIZE 1024 * 100
-#define MAX_REDIRECTS 3
-#define PREBUFFER_SECS 10
-#define ICE_UDP_PORT 6000
-
-/****************************************************************************/
-
-const char* ShoutCastIODevice::stateString (const State &s)
-{
-#define TO_STRING(a) case a: return #a
-    switch (s) {
-        TO_STRING (NOT_CONNECTED);
-        TO_STRING (RESOLVING);
-        TO_STRING (CONNECTING);
-        TO_STRING (CANT_RESOLVE);
-        TO_STRING (CANT_CONNECT);
-        TO_STRING (CONNECTED);
-        TO_STRING (WRITING_HEADER);
-        TO_STRING (READING_HEADER);
-        TO_STRING (PLAYING);
-        TO_STRING (STREAMING);
-        TO_STRING (STREAMING_META);
-        TO_STRING (STOPPED);
-    default:
-        return "unknown state";
-    }
-#undef TO_STRING
-}
-
-/****************************************************************************/
-
-class ShoutCastRequest
-{
-  public:
-    ShoutCastRequest(void) { }
-    ShoutCastRequest(const QUrl &url) { setUrl(url); }
-    ~ShoutCastRequest(void) { }
-    const char *data(void) { return m_data.data(); }
-    uint size(void) { return m_data.size(); }
-
-  private:
-    void setUrl(const QUrl &url)
-    {
-        QString hdr;
-        hdr = QString("GET %PATH% HTTP/1.1\r\n"
-                      "Host: %HOST%\r\n"
-                      "User-Agent: MythMusic/%VERSION%\r\n"
-                      "Accept: */*\r\n");
-
-        QString path = url.path();
-        QString host = url.host();
-
-        if (path.isEmpty())
-            path = "/";
-
-        if (url.hasQuery())
-            path += '?' + url.encodedQuery();
-
-        if (url.port() != -1)
-            host += QString(":%1").arg(url.port());
-
-        hdr.replace("%PATH%", path);
-        hdr.replace("%HOST%", host);
-        hdr.replace("%VERSION%", MYTH_BINARY_VERSION);
-
-        if (!url.userName().isEmpty() && !url.password().isEmpty()) 
-        {
-            QString authstring = url.userName() + ":" + url.password();
-            QString auth = QCodecs::base64Encode(authstring.toLocal8Bit());
-
-            hdr += "Authorization: Basic " + auth + "\r\n";
-        }
-
-        hdr += QString("TE: trailers\r\n"
-                       "Icy-Metadata: 1\r\n"
-                       "\r\n");
-
-        LOG(VB_NETWORK, LOG_INFO, QString("ShoutCastRequest: '%1'").arg(hdr));
-
-        m_data = hdr.toAscii();
-    }
-
-    QByteArray m_data;
-};
-
-class IceCastRequest
-{
-  public:
-    IceCastRequest(void) { }
-    IceCastRequest(const QUrl &url) { setUrl(url); }
-    ~IceCastRequest(void) { }
-    const char *data(void) { return m_data.data(); }
-    uint size(void) { return m_data.size(); }
-
-  private:
-    void setUrl(const QUrl &url)
-    {
-        QString hdr;
-        hdr = QString("GET %PATH% HTTP/1.1\r\n"
-                      "Host: %HOST%\r\n"
-                      "User-Agent: MythMusic/%VERSION%\r\n"
-                      "Accept: */*\r\n");
-
-        QString path = url.path();
-        QString host = url.host();
-
-        if (path.isEmpty())
-            path = "/";
-
-        if (url.hasQuery())
-            path += '?' + url.encodedQuery();
-
-        if (url.port() != -1)
-            host += QString(":%1").arg(url.port());
-
-        hdr.replace("%PATH%", path);
-        hdr.replace("%HOST%", host);
-        hdr.replace("%VERSION%", MYTH_BINARY_VERSION);
-
-        if (!url.userName().isEmpty() && !url.password().isEmpty()) 
-        {
-            QString authstring = url.userName() + ":" + url.password();
-            QString auth = QCodecs::base64Encode(authstring.toLocal8Bit());
-
-            hdr += "Authorization: Basic " + auth + "\r\n";
-        }
-
-        hdr += QString("TE: trailers\r\n"
-                       "x-audiocast-udpport: %1\r\n"
-                       "\r\n").arg(ICE_UDP_PORT);
-
-        LOG(VB_NETWORK, LOG_INFO, QString("IceCastRequest: '%1'").arg(hdr));
-
-        m_data = hdr.toAscii();
-    }
-
-    QByteArray m_data;
-};
-
-/****************************************************************************/
-
-
-class ShoutCastResponse 
-{
-  public:
-    ShoutCastResponse(void) { }
-    ~ShoutCastResponse(void) { }
-
-    int getMetaint(void)
-    {
-        if (m_data.contains("icy-metaint"))
-            return getInt("icy-metaint");
-        else
-            return -1;
-    }
-    int getBitrate(void) { return getInt("icy-br"); }
-    QString getGenre(void) { return getString("icy-genre"); }
-    QString getName(void) { return getString("icy-name"); }
-    int getStatus(void) { return getInt("status"); }
-    bool isICY(void) { return QString(m_data["protocol"]).left(3) == "ICY"; }
-    QString getContent(void) { return getString("content-type"); }
-    QString getLocation(void) { return getString("location"); }
-
-    QString getString(const QString &key) { return m_data[key]; }
-    int getInt(const QString &key) { return m_data[key].toInt(); }
-
-    int fillResponse(const char *data, int len);
-
-  private:
-    QMap<QString, QString> m_data;
-};
-
-/** \brief Consume bytes and parse shoutcast header
-    \returns number of bytes consumed
-*/
-int ShoutCastResponse::fillResponse(const char *s, int l)
-{
-    QByteArray d(s, l);
-    int result = 0;
-    // check each line
-    for (;;)
-    {
-        int pos = d.indexOf("\r");
-
-        if (pos <= 0)
-            break;
-
-        // Extract the line
-        QByteArray snip(d.data(), pos + 1);
-        d.remove(0, pos + 2);
-        result += pos + 2;
-
-        if (snip.left(4) == "ICY ")
-        {
-            int space = snip.indexOf(' ');
-            m_data["protocol"] = "ICY";
-            QString tmp = snip.mid(space).simplified();
-            int second_space = tmp.indexOf(' ');
-            if (second_space > 0) 
-                m_data["status"] = tmp.left(second_space);
-            else
-                m_data["status"] = tmp;
-        }
-        else if (snip.left(7) == "HTTP/1.")
-        {
-            int space = snip.indexOf(' ');
-            m_data["protocol"] = snip.left(space);
-            QString tmp = snip.mid(space).simplified();
-            int second_space = tmp.indexOf(' ');
-            if (second_space > 0)
-                m_data["status"] = tmp.left(second_space);
-            else
-                m_data["status"] = tmp;
-        } 
-        else if (snip.left(9).toLower() == "location:")
-        {
-            m_data["location"] = snip.mid(9).trimmed();
-        } 
-        else if (snip.left(13).toLower() == "content-type:")
-        {
-            m_data["content-type"] = snip.mid(13).trimmed();
-        }
-        else if (snip.left(4) == "icy-")
-        {
-            int pos = snip.indexOf(':');
-            QString key = snip.left(pos);
-            m_data[key.toAscii()] = snip.mid(pos+1).trimmed();
-        }
-    }
-
-    return result;
-}
-
-/****************************************************************************/
-
-class ShoutCastMetaParser
-{
-  public:
-    ShoutCastMetaParser(void) :
-        m_meta_artist_pos(-1), m_meta_title_pos(-1), m_meta_album_pos(-1) { }
-    ~ShoutCastMetaParser(void) { }
-
-    void setMetaFormat(const QString &metaformat);
-    ShoutCastMetaMap parseMeta(const QString &meta);
-
-  private:
-    QString m_meta_format;
-    int m_meta_artist_pos;
-    int m_meta_title_pos;
-    int m_meta_album_pos;
-};
-
-void ShoutCastMetaParser::setMetaFormat(const QString &metaformat)
-{
-/*
-  We support these metatags :
-  %a - artist
-  %t - track
-  %b - album
-  %r - random bytes
- */
-    m_meta_format = metaformat;
-
-    m_meta_artist_pos = 0;
-    m_meta_title_pos = 0;
-    m_meta_album_pos = 0;
-
-    int assign_index = 1;
-    int pos = 0;
-
-    pos = m_meta_format.indexOf("%", pos);
-    while (pos >= 0) 
-    {
-        pos++;
-        QChar ch = m_meta_format.at(pos);
-
-        if (ch == '%')
-        {
-            pos++;
-        }
-        else if (ch == 'r' || ch == 'a' || ch == 'b' || ch == 't')
-        {
-            if (ch == 'a')
-                m_meta_artist_pos = assign_index;
-
-            if (ch == 'b')
-                m_meta_album_pos = assign_index;
-
-            if (ch == 't')
-                m_meta_title_pos = assign_index;
-
-            assign_index++;
-        }
-        else
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("ShoutCastMetaParser: malformed metaformat '%1'")
-                    .arg(m_meta_format));
-
-        pos = m_meta_format.indexOf("%", pos);
-    }
-
-    m_meta_format.replace("%a", "(.*)");
-    m_meta_format.replace("%t", "(.*)");
-    m_meta_format.replace("%b", "(.*)");
-    m_meta_format.replace("%r", "(.*)");
-    m_meta_format.replace("%%", "%");
-}
-
-ShoutCastMetaMap ShoutCastMetaParser::parseMeta(const QString &mdata)
-{
-    ShoutCastMetaMap result;
-    int title_begin_pos = mdata.indexOf("StreamTitle='");
-    int title_end_pos;
-
-    if (title_begin_pos >= 0) 
-    {
-        title_begin_pos += 13;
-        title_end_pos = mdata.indexOf("';", title_begin_pos);
-        QString title = mdata.mid(title_begin_pos, title_end_pos - title_begin_pos);
-        QRegExp rx;
-        rx.setPattern(m_meta_format);
-        if (rx.indexIn(title) != -1)
-        {
-            LOG(VB_PLAYBACK, LOG_INFO, QString("ShoutCast: Meta     : '%1'")
-                    .arg(mdata));
-            LOG(VB_PLAYBACK, LOG_INFO,
-                QString("ShoutCast: Parsed as: '%1' by '%2'")
-                    .arg(rx.cap(m_meta_title_pos))
-                    .arg(rx.cap(m_meta_artist_pos)));
-
-            if (m_meta_title_pos > 0) 
-                result["title"] = rx.cap(m_meta_title_pos);
-
-            if (m_meta_artist_pos > 0) 
-                result["artist"] = rx.cap(m_meta_artist_pos);
-
-            if (m_meta_album_pos > 0) 
-                result["album"] = rx.cap(m_meta_album_pos);
-        }
-    }
-
-    return result;
-}
-
-/****************************************************************************/
-
-ShoutCastIODevice::ShoutCastIODevice(void)
-    :  m_redirects (0), 
-       m_scratchpad_pos (0),
-       m_state (NOT_CONNECTED)
-{
-    m_socket = new QTcpSocket;
-    m_response = new ShoutCastResponse;
-
-    connect(m_socket, SIGNAL(hostFound()), SLOT(socketHostFound()));
-    connect(m_socket, SIGNAL(connected()), SLOT(socketConnected()));
-    connect(m_socket, SIGNAL(disconnected()), SLOT(socketConnectionClosed()));
-    connect(m_socket, SIGNAL(readyRead()), SLOT(socketReadyRead()));
-    connect(m_socket, SIGNAL(error(QAbstractSocket::SocketError)), 
-            SLOT(socketError(QAbstractSocket::SocketError)));
-
-    switchToState(NOT_CONNECTED);
-
-    setOpenMode(ReadWrite);
-
-    m_socket->setReadBufferSize(DecoderIOFactory::DefaultPrebufferSize);
-}
-
-ShoutCastIODevice::~ShoutCastIODevice(void)
-{
-    delete m_response;
-    m_socket->close();
-    m_socket->disconnect(this);
-    m_socket->deleteLater();
-    m_socket = NULL;
-}
-
-void ShoutCastIODevice::connectToUrl(const QUrl &url)
-{
-    m_url = url;
-    switchToState (RESOLVING);
-    setOpenMode(ReadWrite);
-    open(ReadWrite);
-    return m_socket->connectToHost(m_url.host(), m_url.port() == -1 ? 80 : m_url.port());
-}
-
-void ShoutCastIODevice::close(void)
-{
-    return m_socket->close();
-}
-
-bool ShoutCastIODevice::flush(void)
-{
-    return m_socket->flush();
-}
-
-qint64 ShoutCastIODevice::size(void) const
-{
-    return m_buffer->readBufAvail(); 
-}
-
-qint64 ShoutCastIODevice::readData(char *data, qint64 maxlen)
-{
-    // the decoder wants more data from the stream
-    // but first we must filter out any headers and metadata
-
-    if (m_buffer->readBufAvail() == 0)
-    {
-        LOG(VB_PLAYBACK, LOG_ERR, "ShoutCastIODevice: No data in buffer!!");
-        switchToState(STOPPED);
-        return -1;
-    }
-
-    if (m_state == STREAMING_META && parseMeta())
-        switchToState(STREAMING);
-
-    if (m_state == STREAMING)
-    {
-        if (m_bytesTillNextMeta > 0)
-        {
-            // take maxlen or what ever is left till the next metadata
-            if (maxlen > m_bytesTillNextMeta)
-                maxlen = m_bytesTillNextMeta;
-
-            maxlen = m_buffer->read(data, maxlen);
-
-            m_bytesTillNextMeta -= maxlen;
-
-            if (m_bytesTillNextMeta == 0)
-                switchToState(STREAMING_META);
-        }
-        else
-            maxlen = m_buffer->read(data, maxlen);
-    }
-
-    if (m_state != STOPPED) 
-        LOG(VB_NETWORK, LOG_INFO,
-            QString("ShoutCastIODevice: %1 kb in buffer, btnm=%2/%3 "
-                    "state=%4, len=%5")
-                .arg(m_buffer->readBufAvail() / 1024, 4)
-                .arg(m_bytesTillNextMeta, 4)
-                .arg(m_response->getMetaint())
-                .arg(stateString (m_state))
-                .arg(maxlen));
-    else
-        LOG(VB_NETWORK, LOG_INFO, QString("ShoutCastIODevice: stopped"));
-
-    return maxlen;
-}
-
-qint64 ShoutCastIODevice::writeData(const char *data, qint64 sz)
-{
-    return m_socket->write(data, sz);
-}
-
-qint64 ShoutCastIODevice::bytesAvailable(void) const
-{
-    return m_buffer->readBufAvail();
-}
-
-void ShoutCastIODevice::socketHostFound(void)
-{
-    LOG(VB_NETWORK, LOG_INFO, "ShoutCastIODevice: Host Found");
-    switchToState(CONNECTING);
-}
-
-void ShoutCastIODevice::socketConnected(void)
-{
-    LOG(VB_NETWORK, LOG_INFO, "ShoutCastIODevice: Connected");
-    switchToState(CONNECTED);
-
-    ShoutCastRequest request(m_url);
-    qint64 written = m_socket->write(request.data(), request.size());
-    LOG(VB_NETWORK, LOG_INFO,
-        QString("ShoutCastIODevice: Sending Request, %1 of %2 bytes")
-            .arg(written).arg(request.size()));
-
-    if (written != request.size())
-    {
-        LOG(VB_NETWORK, LOG_INFO, "ShoutCastIODevice: buffering write");
-        m_scratchpad = QByteArray(request.data() + written, request.size() - written);
-        m_scratchpad_pos = 0;
-        connect(m_socket, SIGNAL (bytesWritten(qint64)), SLOT(socketBytesWritten(qint64)));
-        switchToState(WRITING_HEADER);
-    }
-    else
-        switchToState(READING_HEADER);
-
-    m_started = false;
-    m_bytesDownloaded = 0;
-    m_bytesTillNextMeta = 0;
-    m_response_gotten = false;
-}
-
-void ShoutCastIODevice::socketConnectionClosed(void)
-{
-    LOG(VB_NETWORK, LOG_INFO, "ShoutCastIODevice: Connection Closed");
-    switchToState(STOPPED);
-}
-
-void ShoutCastIODevice::socketReadyRead(void)
-{
-    // only read enough data to fill our buffer
-    int available = DecoderIOFactory::DefaultBufferSize - m_buffer->readBufAvail();
-
-    QByteArray data = m_socket->read(available);
-
-    m_bytesDownloaded += data.size();
-    m_buffer->write(data);
-
-    // send buffer status event
-    emit bufferStatus(m_buffer->readBufAvail(), DecoderIOFactory::DefaultBufferSize);
-
-    if (!m_started && m_bytesDownloaded > DecoderIOFactory::DefaultPrebufferSize)
-    {
-        m_socket->setReadBufferSize(DecoderIOFactory::DefaultBufferSize);
-        m_started = true;
-    }
-
-    // if we are waiting for the HEADER and we have enough data process that
-    if (m_state == READING_HEADER)
-    {
-        if (parseHeader())
-        {
-            if (m_response->getStatus() == 200)
-            {
-                switchToState(PLAYING);
-
-                m_response_gotten = true;
-
-                m_bytesTillNextMeta = m_response->getMetaint();
-
-                switchToState(STREAMING);
-            }
-            else if (m_response->getStatus() == 302 || m_response->getStatus() == 301)
-            {
-                if (++m_redirects > MAX_REDIRECTS)
-                {
-                    LOG(VB_NETWORK, LOG_ERR, QString("Too many redirects"));
-                    switchToState(STOPPED);
-                }
-                else
-                {
-                    LOG(VB_NETWORK, LOG_INFO, QString("Redirect to %1").arg(m_response->getLocation()));
-                    m_socket->close();
-                    QUrl redirectURL(m_response->getLocation());
-                    connectToUrl(redirectURL);
-                    return;
-                }
-            }
-            else
-            {
-                LOG(VB_NETWORK, LOG_ERR, QString("Unknown response status %1")
-                        .arg(m_response->getStatus()));
-                switchToState(STOPPED);
-            }
-        }
-    }
-}
-
-void ShoutCastIODevice::socketBytesWritten(qint64)
-{
-    qint64 written = m_socket->write(m_scratchpad.data() + m_scratchpad_pos,
-                                     m_scratchpad.size() - m_scratchpad_pos);
-    LOG(VB_NETWORK, LOG_INFO,
-        QString("ShoutCastIO: %1 bytes written").arg(written));
-
-    m_scratchpad_pos += written;
-    if (m_scratchpad_pos == m_scratchpad.size())
-    {
-        m_scratchpad.truncate(0);
-        disconnect (m_socket, SIGNAL(bytesWritten(qint64)), this, 0);
-        switchToState(READING_HEADER);
-    }
-}
-
-void ShoutCastIODevice::socketError(QAbstractSocket::SocketError error)
-{
-    switch (error)
-    {
-        case QAbstractSocket::ConnectionRefusedError:
-            LOG(VB_NETWORK, LOG_ERR,
-                "ShoutCastIODevice: Error Connection Refused");
-            switchToState(CANT_CONNECT);
-            break;
-        case QAbstractSocket::RemoteHostClosedError:
-            LOG(VB_NETWORK, LOG_ERR,
-                "ShoutCastIODevice: Error Remote Host Closed The Connection");
-            switchToState(CANT_CONNECT);
-            break;
-        case QAbstractSocket::HostNotFoundError:
-            LOG(VB_NETWORK, LOG_ERR,
-                "ShoutCastIODevice: Error Host Not Found");
-            switchToState(CANT_RESOLVE);
-            break;
-        case QAbstractSocket::SocketTimeoutError:
-            LOG(VB_NETWORK, LOG_ERR, "ShoutCastIODevice: Error Socket Timeout");
-            switchToState(STOPPED);
-            break;
-        default:
-            LOG(VB_NETWORK, LOG_ERR,
-                QString("ShoutCastIODevice: Got socket error '%1'")
-                    .arg(errorString()));
-            switchToState(STOPPED);
-            break;
-    }
-}
-
-void ShoutCastIODevice::switchToState(const State &state) 
-{
-    switch (state) 
-    {
-        case PLAYING:
-            LOG(VB_PLAYBACK, LOG_INFO, QString("Playing %1 (%2) at %3 kbps")
-                .arg(m_response->getName())
-                .arg(m_response->getGenre())
-                .arg(m_response->getBitrate()));
-            break;
-        case STREAMING:
-            if (m_state == STREAMING_META)
-                m_bytesTillNextMeta = m_response->getMetaint();
-            break;
-        case STOPPED:
-            m_socket->close();
-            break;
-        default:
-            break;
-    }
-
-    m_state = state;
-    emit changedState(m_state);
-}
-
-bool ShoutCastIODevice::parseHeader(void)
-{
-    int available = min(4096, (int)m_buffer->readBufAvail());
-    QByteArray data;
-    m_buffer->read(data, available, false);
-    int consumed = m_response->fillResponse(data.data(), data.size());
-
-    LOG(VB_NETWORK, LOG_INFO,
-        QString("ShoutCastIODevice: Receiving header, %1 bytes").arg(consumed));
-    {
-        QString tmp;
-        tmp = QString::fromAscii(data.data(), consumed);
-        LOG(VB_NETWORK, LOG_INFO,
-            QString("ShoutCastIODevice: Receiving header\n%1").arg(tmp));
-    }
-
-    m_buffer->remove(0, consumed);
-
-    if (m_buffer->readBufAvail() >= 2)
-    {
-        data.clear();
-        m_buffer->read(data, 2, false);
-        if (data.size() == 2 && data[0] == '\r' && data[1] == '\n')
-        {
-            m_buffer->remove(0, 2);
-            return true;
-        }
-    }
-
-    return false;
-}
-
-bool ShoutCastIODevice::getResponse(ShoutCastResponse &response)
-{
-    if (!m_response_gotten)
-        return false;
-
-    response = *m_response;
-    return true;
-}
-
-bool ShoutCastIODevice::parseMeta(void)
-{
-    QByteArray data;
-    m_buffer->read(data, 1);
-    unsigned char ch = data[0];
-
-    qint64 meta_size = 16 * ch;
-    if (meta_size == 0)
-        return true;
-
-    // sanity check 
-    if (meta_size > MAX_ALLOWED_META_SIZE)
-    {
-        LOG(VB_PLAYBACK, LOG_ERR,
-            QString("ShoutCastIODevice: Error in stream, got a meta size of %1")
-                .arg(meta_size));
-        switchToState(STOPPED);
-        return false;
-    }
-
-    LOG(VB_NETWORK, LOG_INFO,
-        QString("ShoutCastIODevice: Reading %1 bytes of meta").arg(meta_size));
-
-    // read metadata from our buffer
-    data.clear();
-    m_buffer->read(data, meta_size);
-
-    // sanity check, check we have enough data
-    if (meta_size > data.size())
-    {
-        LOG(VB_PLAYBACK, LOG_ERR,
-            QString("ShoutCastIODevice: Not enough data, we have %1, but the "
-                    "metadata size is %1")
-                .arg(data.size()).arg(meta_size));
-        switchToState(STOPPED);
-        return false;
-    }
-
-    QString metadataString = QString::fromUtf8(data.constData());
-
-    // avoid sending signals if the data hasn't changed
-    if (m_last_metadata == metadataString)
-        return true;
-
-    m_last_metadata = metadataString;
-    emit meta(metadataString);
-
-    return true;
-}
-
-/****************************************************************************/
-
-DecoderIOFactoryShoutCast::DecoderIOFactoryShoutCast(DecoderHandler *parent)
-    : DecoderIOFactory(parent), m_timer(NULL), m_input(NULL), m_prebuffer(160000)
-{
-    m_timer = new QTimer(this);
-}
-
-DecoderIOFactoryShoutCast::~DecoderIOFactoryShoutCast(void)
-{
-    closeIODevice();
-}
-
-QIODevice* DecoderIOFactoryShoutCast::getInput(void)
-{
-    return m_input;
-}
-
-void DecoderIOFactoryShoutCast::makeIODevice(void)
-{
-    closeIODevice();
-
-    m_input = new ShoutCastIODevice();
-
-    qRegisterMetaType<ShoutCastIODevice::State>("ShoutCastIODevice::State");
-    connect(m_input, SIGNAL(meta(const QString&)),
-            this,    SLOT(shoutcastMeta(const QString&)));
-    connect(m_input, SIGNAL(changedState(ShoutCastIODevice::State)),
-            this,    SLOT(shoutcastChangedState(ShoutCastIODevice::State)));
-    connect(m_input, SIGNAL(bufferStatus(int, int)),
-            this,    SLOT(shoutcastBufferStatus(int,int)));
-}
-
-void DecoderIOFactoryShoutCast::closeIODevice(void)
-{
-    if (m_input)
-    {
-        m_input->disconnect();
-        if (m_input->isOpen())
-        {
-            m_input->close();
-        }
-        m_input->deleteLater();
-        m_input = NULL;
-    }
-}
-
-void DecoderIOFactoryShoutCast::start(void)
-{
-    LOG(VB_PLAYBACK, LOG_INFO,
-        QString("DecoderIOFactoryShoutCast %1").arg(m_handler->getUrl().toString()));
-    doOperationStart(tr("Connecting"));
-
-    makeIODevice();
-    m_input->connectToUrl(m_handler->getUrl());
-}
-
-void DecoderIOFactoryShoutCast::stop(void)
-{
-    if (m_timer)
-        m_timer->disconnect();
-
-    doOperationStop();
-}
-
-void DecoderIOFactoryShoutCast::periodicallyCheckResponse(void)
-{
-    int res = checkResponseOK();
-
-    if (res == 0)
-    {
-        ShoutCastResponse response;
-        m_input->getResponse(response);
-        m_prebuffer = PREBUFFER_SECS * response.getBitrate() * 125; // 125 = 1000/8 (kilo, bits...)
-        LOG(VB_NETWORK, LOG_INFO,
-            QString("kbps is %1, prebuffering %2 secs = %3 kb")
-                .arg(response.getBitrate()).arg(PREBUFFER_SECS)
-                .arg(m_prebuffer/1024));
-        m_timer->stop();
-        m_timer->disconnect();
-        connect(m_timer, SIGNAL(timeout()), this, SLOT(periodicallyCheckBuffered()));
-        m_timer->start(500);
-    }
-    else if (res < 0)
-    {
-        m_timer->stop();
-        doFailed("Cannot parse this stream");
-    }
-}
-
-void DecoderIOFactoryShoutCast::periodicallyCheckBuffered(void)
-{
-    LOG(VB_NETWORK, LOG_INFO,
-        QString("DecoderIOFactoryShoutCast: prebuffered %1/%2KB")
-            .arg(m_input->bytesAvailable()/1024).arg(m_prebuffer/1024));
-
-    if (m_input->bytesAvailable() < m_prebuffer || m_input->bytesAvailable() == 0)
-        return;
-
-    ShoutCastResponse response;
-    m_input->getResponse(response);
-    LOG(VB_PLAYBACK, LOG_INFO,
-        QString("contents '%1'").arg(response.getContent()));
-    if (response.getContent() == "audio/mpeg")
-        doConnectDecoder("create-mp3-decoder.mp3");
-    else if (response.getContent() == "audio/aacp")
-        doConnectDecoder("create-aac-decoder.m4a");
-    else if (response.getContent() == "application/ogg")
-        doConnectDecoder("create-ogg-decoder.ogg");
-    else if (response.getContent() == "audio/aac")
-        doConnectDecoder("create-aac-decoder.aac");
-    else
-    {
-        doFailed(tr("Unsupported content type for ShoutCast stream: %1")
-                    .arg (response.getContent()));
-    }
-
-    m_timer->disconnect();
-    m_timer->stop();
-
-    m_lastStatusTime.start();
-}
-
-void DecoderIOFactoryShoutCast::shoutcastMeta(const QString &metadata)
-{
-    LOG(VB_PLAYBACK, LOG_INFO,
-        QString("DecoderIOFactoryShoutCast: metadata changed - %1")
-            .arg(metadata));
-    ShoutCastMetaParser parser;
-    parser.setMetaFormat(m_handler->getMetadata().MetadataFormat());
-
-    ShoutCastMetaMap meta_map = parser.parseMeta(metadata);
-
-    MusicMetadata mdata = m_handler->getMetadata();
-    mdata.setTitle(meta_map["title"]);
-    mdata.setArtist(meta_map["artist"]);
-    mdata.setAlbum(meta_map["album"]);
-    mdata.setLength(-1);
-
-    DecoderHandlerEvent ev(DecoderHandlerEvent::Meta, mdata);
-    dispatch(ev);
-}
-
-void DecoderIOFactoryShoutCast::shoutcastBufferStatus(int available, int maxSize)
-{
-    if (m_lastStatusTime.elapsed() < 1000)
-        return;
-
-    if (m_input->getState() == ShoutCastIODevice::PLAYING ||
-        m_input->getState() == ShoutCastIODevice::STREAMING ||
-        m_input->getState() == ShoutCastIODevice::STREAMING_META)
-    {
-        DecoderHandlerEvent ev(DecoderHandlerEvent::BufferStatus, available, maxSize);
-        dispatch(ev);
-    }
-
-    m_lastStatusTime.restart();
-}
-
-void DecoderIOFactoryShoutCast::shoutcastChangedState(ShoutCastIODevice::State state)
-{
-    LOG(VB_PLAYBACK, LOG_INFO, QString("ShoutCast changed state to %1")
-        .arg(ShoutCastIODevice::stateString(state)));
-
-    if (state == ShoutCastIODevice::RESOLVING)
-        doOperationStart(tr("Finding radio stream"));
-
-    if (state == ShoutCastIODevice::CANT_RESOLVE)
-        doFailed(tr("Cannot find radio.\nCheck the URL is correct."));
-
-    if (state == ShoutCastIODevice::CONNECTING)
-        doOperationStart(tr("Connecting to radio stream"));
-
-    if (state == ShoutCastIODevice::CANT_CONNECT)
-        doFailed(tr("Cannot connect to radio.\nCheck the URL is correct."));
-
-    if (state == ShoutCastIODevice::CONNECTED)
-    {
-        doOperationStart(tr("Connected to radio stream"));
-        m_timer->stop();
-        m_timer->disconnect();
-        connect(m_timer, SIGNAL(timeout()),
-                this, SLOT(periodicallyCheckResponse()));
-        m_timer->start(300);
-    }
-
-    if (state == ShoutCastIODevice::PLAYING)
-    {
-        doOperationStart(tr("Buffering"));
-    }
-
-    if (state == ShoutCastIODevice::STOPPED)
-        stop();
-}
-
-int DecoderIOFactoryShoutCast::checkResponseOK()
-{
-    ShoutCastResponse response;
-
-    if (!m_input->getResponse(response))
-        return 1;
-
-    if (!response.isICY() && response.getStatus() == 302 &&
-        !response.getLocation().isEmpty())
-    {
-        // restart with new location...
-        m_handler->setUrl(response.getLocation());
-        start();
-        return 1;
-    }
-
-    if (response.getStatus() != 200)
-        return -1;
-
-    return 0;
-}
diff -Naur mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/shoutcast.h mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/shoutcast.h
--- mythtv-0.27-20140716-gf4825ca-old/mythplugins/mythmusic/mythmusic/shoutcast.h	2014-07-16 11:43:10.000000000 +0200
+++ mythtv-0.27-20140716-gf4825ca-new/mythplugins/mythmusic/mythmusic/shoutcast.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
-/*
-  Shoutcast decoder for MythTV.
-  Eskil Heyn Olsen, 2005, distributed under the GPL as part of mythtv.
-  Paul Harrison July 2010, Updated for Qt4
-*/
-
-#ifndef SHOUTCAST_H_
-#define SHOUTCAST_H_
-
-// c
-#include <sys/time.h>
-#include <time.h>
-
-// qt
-#include <QObject>
-#include <QTcpSocket>
-#include <QBuffer>
-#include <QUrl>
-#include <QMutex>
-
-//mythtv
-#include "config.h"
-
-// mythmusic
-#include "decoder.h"
-#include "decoderhandler.h"
-
-class ShoutCastRequest;
-class ShoutCastResponse;
-
-typedef QMap<QString,QString> ShoutCastMetaMap;
-
-class ShoutCastIODevice : public MusicIODevice
-{
-  Q_OBJECT
-
-  public:
-    enum State
-    {
-        NOT_CONNECTED,
-        RESOLVING,
-        CONNECTING,
-        CANT_RESOLVE,
-        CANT_CONNECT,
-        CONNECTED,
-        WRITING_HEADER,
-        READING_HEADER,
-        PLAYING,
-        STREAMING,
-        STREAMING_META,
-        STOPPED
-    };
-    static const char* stateString(const State &s);
-
-    ShoutCastIODevice(void);
-    ~ShoutCastIODevice(void);
-
-    State getState(void) { return m_state; }
-
-    void connectToUrl(const QUrl &url);
-    void close(void);
-    bool flush(void);
-
-    qint64 size(void) const;
-    qint64 pos(void) const { return 0; }
-    qint64 bytesAvailable(void) const;
-    bool   isSequential(void) const { return true; }
-
-    qint64 readData(char *data, qint64 sz);
-    qint64 writeData(const char *data, qint64 sz);
-
-    bool getResponse(ShoutCastResponse &response);
-
-  signals:
-    void meta(const QString &metadata);
-    void changedState(ShoutCastIODevice::State newstate);
-    void bufferStatus(int available, int max);
-
-  private slots:
-    void socketHostFound(void);
-    void socketConnected(void);
-    void socketConnectionClosed(void);
-    void socketReadyRead(void);
-    void socketBytesWritten(qint64 );
-    void socketError(QAbstractSocket::SocketError error);
-
-  private:
-    void switchToState(const State &s);
-    bool parseHeader(void);
-    bool parseMeta(void);
-
-    // Our tools
-    ShoutCastResponse *m_response;
-    int                m_redirects;
-    QTcpSocket        *m_socket;
-
-    // Our scratchpad
-    QByteArray         m_scratchpad;
-    qint64             m_scratchpad_pos;
-
-    // Our state info
-    QUrl           m_url;
-    qint64         m_bytesTillNextMeta;
-    State          m_state;
-    QString        m_last_metadata;
-    qint64         m_bytesDownloaded;
-    bool           m_response_gotten;
-    bool           m_started;
-};
-
-class DecoderIOFactoryShoutCast : public DecoderIOFactory
-{
-  Q_OBJECT
-
-  public:
-    DecoderIOFactoryShoutCast(DecoderHandler *parent);
-    ~DecoderIOFactoryShoutCast(void);
-
-    void start(void);
-    void stop(void);
-    QIODevice *getInput(void);
-
-  protected slots:
-    void periodicallyCheckResponse(void);
-    void periodicallyCheckBuffered(void);
-    void shoutcastMeta(const QString &metadata);
-    void shoutcastChangedState(ShoutCastIODevice::State newstate);
-    void shoutcastBufferStatus(int available, int maxSize);
-
-  private:
-    int checkResponseOK(void);
-
-    void makeIODevice(void);
-    void closeIODevice(void);
-
-    QTimer *m_timer;
-
-    ShoutCastIODevice *m_input;
-    uint m_prebuffer;
-
-    QTime m_lastStatusTime;
-};
-
-#endif /* SHOUTCAST_H_ */
