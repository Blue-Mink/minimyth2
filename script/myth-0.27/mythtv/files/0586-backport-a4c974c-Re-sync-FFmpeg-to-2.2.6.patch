From a4c974c8ccfa88cf20bccc2b50c80e717cfd8545 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Sat, 9 Aug 2014 14:39:30 +1000
Subject: [PATCH] Re-sync FFmpeg to 2.2.6

To many merges to apply individual changes, so doing it as a big diff
---
 mythtv/external/FFmpeg/Changelog                   |   11 +++-
 mythtv/external/FFmpeg/README.sync                 |    1 +
 mythtv/external/FFmpeg/RELEASE                     |    2 +-
 mythtv/external/FFmpeg/VERSION                     |    1 -
 mythtv/external/FFmpeg/cmdutils_opencl.c           |    2 +-
 mythtv/external/FFmpeg/doc/Doxyfile                |    2 +-
 mythtv/external/FFmpeg/ffmpeg.c                    |    4 +-
 mythtv/external/FFmpeg/ffmpeg_filter.c             |    6 ++
 mythtv/external/FFmpeg/ffmpeg_opt.c                |    3 +-
 mythtv/external/FFmpeg/ffserver.c                  |    4 +-
 .../FFmpeg/libavcodec/arm/h264dsp_init_arm.c       |    6 +-
 mythtv/external/FFmpeg/libavcodec/avpacket.c       |    1 -
 mythtv/external/FFmpeg/libavcodec/dvdsub_parser.c  |    7 +-
 mythtv/external/FFmpeg/libavcodec/eamad.c          |   40 +++++++-----
 mythtv/external/FFmpeg/libavcodec/fft-test.c       |   22 ++++++-
 mythtv/external/FFmpeg/libavcodec/g2meet.c         |    9 ++-
 mythtv/external/FFmpeg/libavcodec/h264.h           |    2 +-
 .../FFmpeg/libavcodec/h264_mp4toannexb_bsf.c       |   19 +++++-
 mythtv/external/FFmpeg/libavcodec/h264_parser.c    |    4 +-
 mythtv/external/FFmpeg/libavcodec/hevc.c           |   31 +++++----
 mythtv/external/FFmpeg/libavcodec/hevc.h           |    2 +
 mythtv/external/FFmpeg/libavcodec/hevc_parser.c    |    3 +
 mythtv/external/FFmpeg/libavcodec/hevc_ps.c        |    6 ++
 mythtv/external/FFmpeg/libavcodec/huffyuvdec.c     |   69 ++++++++++----------
 mythtv/external/FFmpeg/libavcodec/jpeg2000.c       |   41 +++++++-----
 mythtv/external/FFmpeg/libavcodec/libmp3lame.c     |    8 ++-
 mythtv/external/FFmpeg/libavcodec/mpeg12dec.c      |    8 +++
 .../FFmpeg/libavcodec/mpegaudiodecheader.c         |    4 ++
 mythtv/external/FFmpeg/libavcodec/pgssubdec.c      |   12 ++--
 mythtv/external/FFmpeg/libavcodec/vc1dec.c         |    2 +-
 mythtv/external/FFmpeg/libavcodec/wavpackenc.c     |    4 +-
 mythtv/external/FFmpeg/libavdevice/v4l2enc.c       |    1 +
 mythtv/external/FFmpeg/libavfilter/af_compand.c    |   10 ++-
 mythtv/external/FFmpeg/libavfilter/f_ebur128.c     |    2 +-
 mythtv/external/FFmpeg/libavfilter/f_select.c      |   16 ++---
 mythtv/external/FFmpeg/libavfilter/vf_pullup.c     |    8 +--
 mythtv/external/FFmpeg/libavfilter/vf_pullup.h     |    6 +-
 .../external/FFmpeg/libavfilter/x86/vf_pullup.asm  |    2 +-
 .../FFmpeg/libavfilter/x86/vf_pullup_init.c        |    6 +-
 mythtv/external/FFmpeg/libavformat/avformat.h      |    1 +
 mythtv/external/FFmpeg/libavformat/dv.c            |   43 ++++++------
 mythtv/external/FFmpeg/libavformat/librtmp.c       |    9 +--
 mythtv/external/FFmpeg/libavformat/mp3enc.c        |   22 +++----
 mythtv/external/FFmpeg/libavformat/tee.c           |    2 +-
 mythtv/external/FFmpeg/libavformat/utils.c         |    8 ++-
 mythtv/external/FFmpeg/libavutil/lzo.c             |    2 +-
 mythtv/external/FFmpeg/libswscale/x86/scale.asm    |    2 +-
 mythtv/external/FFmpeg/tests/fate/fft.mak          |   32 ++++-----
 mythtv/external/FFmpeg/version.sh                  |    6 +-
 49 files changed, 324 insertions(+), 190 deletions(-)
 delete mode 100644 mythtv/external/FFmpeg/VERSION

diff --git a/mythtv/external/FFmpeg/Changelog b/mythtv/external/FFmpeg/Changelog
index ef8696f..8a87653 100644
--- a/mythtv/external/FFmpeg/Changelog
+++ b/mythtv/external/FFmpeg/Changelog
@@ -1,8 +1,17 @@
 Entries are sorted chronologically from oldest to youngest within each release,
 releases are sorted from youngest to oldest.
 
-version 2.2:
+version 2.2.6
+- fix infinite loop in dvbsub parser
+- fix some interlaced MPEG-2 videos
+- fix decoding issues in dv (Ticket2340, 2341)
+- fix v4l2 and v4l2enc crashes
+- fix theoretical librtmp crash
+- fix theoretical eamad crash
+- support dimension change in g2meet
+
 
+version 2.2:
 - HNM version 4 demuxer and video decoder
 - Live HDS muxer
 - setsar/setdar filters now support variables in ratio expressions
diff --git a/mythtv/external/FFmpeg/README.sync b/mythtv/external/FFmpeg/README.sync
index ca102d0..ef73999 100644
--- a/mythtv/external/FFmpeg/README.sync
+++ b/mythtv/external/FFmpeg/README.sync
@@ -18,6 +18,7 @@ git://source.ffmpeg.org/ffmpeg.git at SHA1 3d79041f on May 4th, 2014 (jya) (rele
 git://source.ffmpeg.org/ffmpeg.git at n2.2.2-30-gacafd18 on May 30th, 2014 (jya) (release/2.2 branch, release 2.2.2))
 git://source.ffmpeg.org/ffmpeg.git at n2.2.3 on May 6th, 2014 (jya) (release/2.2 branch, release 2.2.3))
 git://source.ffmpeg.org/ffmpeg.git at n2.2.3 on July 14th, 2014 (jya) (release/2.2 branch, release 2.2.4))
+git://source.ffmpeg.org/ffmpeg.git at n2.2.6 on August 9th, 2014 (jya) (release/2.2 branch, release 2.2.6))
 
 List of files modified from original FFmpeg:
 Makefile
diff --git a/mythtv/external/FFmpeg/RELEASE b/mythtv/external/FFmpeg/RELEASE
index 530cdd9..bda8fbe 100644
--- a/mythtv/external/FFmpeg/RELEASE
+++ b/mythtv/external/FFmpeg/RELEASE
@@ -1 +1 @@
-2.2.4
+2.2.6
diff --git a/mythtv/external/FFmpeg/VERSION b/mythtv/external/FFmpeg/VERSION
deleted file mode 100644
index 530cdd9..0000000
--- a/mythtv/external/FFmpeg/VERSION
+++ /dev/null
@@ -1 +0,0 @@
-2.2.4
diff --git a/mythtv/external/FFmpeg/cmdutils_opencl.c b/mythtv/external/FFmpeg/cmdutils_opencl.c
index 2a04db9..d7e3287 100644
--- a/mythtv/external/FFmpeg/cmdutils_opencl.c
+++ b/mythtv/external/FFmpeg/cmdutils_opencl.c
@@ -224,7 +224,7 @@ int opt_opencl_bench(void *optctx, const char *opt, const char *arg)
         av_log(NULL, AV_LOG_ERROR, "No OpenCL device detected!\n");
         return AVERROR(EINVAL);
     }
-    if (!(devices = av_malloc(sizeof(OpenCLDeviceBenchmark) * nb_devices))) {
+    if (!(devices = av_malloc_array(nb_devices, sizeof(OpenCLDeviceBenchmark)))) {
         av_log(NULL, AV_LOG_ERROR, "Could not allocate buffer\n");
         return AVERROR(ENOMEM);
     }
diff --git a/mythtv/external/FFmpeg/doc/Doxyfile b/mythtv/external/FFmpeg/doc/Doxyfile
index 1e5778c..e90c2b3 100644
--- a/mythtv/external/FFmpeg/doc/Doxyfile
+++ b/mythtv/external/FFmpeg/doc/Doxyfile
@@ -31,7 +31,7 @@ PROJECT_NAME           = FFmpeg
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 2.2.4
+PROJECT_NUMBER         = 2.2.6
 
 # With the PROJECT_LOGO tag one can specify a logo or icon that is included
 # in the documentation. The maximum height of the logo should not exceed 55
diff --git a/mythtv/external/FFmpeg/ffmpeg.c b/mythtv/external/FFmpeg/ffmpeg.c
index 4cc675e..a906186 100644
--- a/mythtv/external/FFmpeg/ffmpeg.c
+++ b/mythtv/external/FFmpeg/ffmpeg.c
@@ -1992,7 +1992,7 @@ static int output_packet(InputStream *ist, const AVPacket *pkt)
             if (avpkt.duration) {
                 duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);
             } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) {
-                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;
+                int ticks= av_stream_get_parser(ist->st) ? av_stream_get_parser(ist->st)->repeat_pict+1 : ist->st->codec->ticks_per_frame;
                 duration = ((int64_t)AV_TIME_BASE *
                                 ist->st->codec->time_base.num * ticks) /
                                 ist->st->codec->time_base.den;
@@ -2049,7 +2049,7 @@ static int output_packet(InputStream *ist, const AVPacket *pkt)
             } else if (pkt->duration) {
                 ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);
             } else if(ist->st->codec->time_base.num != 0) {
-                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;
+                int ticks= av_stream_get_parser(ist->st) ? av_stream_get_parser(ist->st)->repeat_pict + 1 : ist->st->codec->ticks_per_frame;
                 ist->next_dts += ((int64_t)AV_TIME_BASE *
                                   ist->st->codec->time_base.num * ticks) /
                                   ist->st->codec->time_base.den;
diff --git a/mythtv/external/FFmpeg/ffmpeg_filter.c b/mythtv/external/FFmpeg/ffmpeg_filter.c
index 582c661..f25ee86 100644
--- a/mythtv/external/FFmpeg/ffmpeg_filter.c
+++ b/mythtv/external/FFmpeg/ffmpeg_filter.c
@@ -828,6 +828,12 @@ static int configure_input_filter(FilterGraph *fg, InputFilter *ifilter,
     av_freep(&ifilter->name);
     DESCRIBE_FILTER_LINK(ifilter, in, 1);
 
+    if (!ifilter->ist->dec) {
+        av_log(NULL, AV_LOG_ERROR,
+               "No decoder for stream #%d:%d, filtering impossible\n",
+               ifilter->ist->file_index, ifilter->ist->st->index);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
     switch (avfilter_pad_get_type(in->filter_ctx->input_pads, in->pad_idx)) {
     case AVMEDIA_TYPE_VIDEO: return configure_input_video_filter(fg, ifilter, in);
     case AVMEDIA_TYPE_AUDIO: return configure_input_audio_filter(fg, ifilter, in);
diff --git a/mythtv/external/FFmpeg/ffmpeg_opt.c b/mythtv/external/FFmpeg/ffmpeg_opt.c
index ba2df02..3d50d77 100644
--- a/mythtv/external/FFmpeg/ffmpeg_opt.c
+++ b/mythtv/external/FFmpeg/ffmpeg_opt.c
@@ -2119,7 +2119,8 @@ static int opt_target(void *optctx, const char *opt, const char *arg)
             for (j = 0; j < nb_input_files; j++) {
                 for (i = 0; i < input_files[j]->nb_streams; i++) {
                     AVCodecContext *c = input_files[j]->ctx->streams[i]->codec;
-                    if (c->codec_type != AVMEDIA_TYPE_VIDEO)
+                    if (c->codec_type != AVMEDIA_TYPE_VIDEO ||
+                        !c->time_base.num)
                         continue;
                     fr = c->time_base.den * 1000 / c->time_base.num;
                     if (fr == 25000) {
diff --git a/mythtv/external/FFmpeg/ffserver.c b/mythtv/external/FFmpeg/ffserver.c
index c2d2180..d0038e6 100644
--- a/mythtv/external/FFmpeg/ffserver.c
+++ b/mythtv/external/FFmpeg/ffserver.c
@@ -2989,6 +2989,8 @@ static int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
     AVDictionaryEntry *entry = av_dict_get(stream->metadata, "title", NULL, 0);
     int i;
 
+    *pbuffer = NULL;
+
     avc =  avformat_alloc_context();
     if (avc == NULL || !rtp_format) {
         return -1;
@@ -3025,7 +3027,7 @@ static int prepare_sdp_description(FFStream *stream, uint8_t **pbuffer,
     av_free(avc);
     av_free(avs);
 
-    return strlen(*pbuffer);
+    return *pbuffer ? strlen(*pbuffer) : AVERROR(ENOMEM);
 }
 
 static void rtsp_cmd_options(HTTPContext *c, const char *url)
diff --git a/mythtv/external/FFmpeg/libavcodec/arm/h264dsp_init_arm.c b/mythtv/external/FFmpeg/libavcodec/arm/h264dsp_init_arm.c
index a0418fd..cb73857 100644
--- a/mythtv/external/FFmpeg/libavcodec/arm/h264dsp_init_arm.c
+++ b/mythtv/external/FFmpeg/libavcodec/arm/h264dsp_init_arm.c
@@ -108,8 +108,12 @@ av_cold void ff_h264dsp_init_arm(H264DSPContext *c, const int bit_depth,
 {
     int cpu_flags = av_get_cpu_flags();
 
-    if (have_armv6(cpu_flags))
+    if (have_armv6(cpu_flags) && !(have_vfpv3(cpu_flags) || have_neon(cpu_flags))) {
+        // This function uses the 'setend' instruction which is deprecated
+        // on ARMv8. This instruction is serializing on some ARMv7 cores as
+        // well. Therefore, only use the function on ARMv6.
         c->h264_find_start_code_candidate = ff_h264_find_start_code_candidate_armv6;
+    }
     if (have_neon(cpu_flags))
         h264dsp_init_neon(c, bit_depth, chroma_format_idc);
 }
diff --git a/mythtv/external/FFmpeg/libavcodec/avpacket.c b/mythtv/external/FFmpeg/libavcodec/avpacket.c
index f966bfe..3d05dff 100644
--- a/mythtv/external/FFmpeg/libavcodec/avpacket.c
+++ b/mythtv/external/FFmpeg/libavcodec/avpacket.c
@@ -507,7 +507,6 @@ int av_packet_copy_props(AVPacket *dst, const AVPacket *src)
     dst->convergence_duration = src->convergence_duration;
     dst->flags                = src->flags;
     dst->stream_index         = src->stream_index;
-    dst->side_data_elems      = src->side_data_elems;
 
     for (i = 0; i < src->side_data_elems; i++) {
          enum AVPacketSideDataType type = src->side_data[i].type;
diff --git a/mythtv/external/FFmpeg/libavcodec/dvdsub_parser.c b/mythtv/external/FFmpeg/libavcodec/dvdsub_parser.c
index e50c339..32a945e 100644
--- a/mythtv/external/FFmpeg/libavcodec/dvdsub_parser.c
+++ b/mythtv/external/FFmpeg/libavcodec/dvdsub_parser.c
@@ -45,8 +45,11 @@ static int dvdsub_parse(AVCodecParserContext *s,
     DVDSubParseContext *pc = s->priv_data;
 
     if (pc->packet_index == 0) {
-        if (buf_size < 2)
-            return 0;
+        if (buf_size < 2 || AV_RB16(buf) && buf_size < 6) {
+            if (buf_size)
+                av_log(avctx, AV_LOG_DEBUG, "Parser input %d too small\n", buf_size);
+            return buf_size;
+        }
         pc->packet_len = AV_RB16(buf);
         if (pc->packet_len == 0) /* HD-DVD subpicture packet */
             pc->packet_len = AV_RB32(buf+2);
diff --git a/mythtv/external/FFmpeg/libavcodec/eamad.c b/mythtv/external/FFmpeg/libavcodec/eamad.c
index 2d34d35..950d8f3 100644
--- a/mythtv/external/FFmpeg/libavcodec/eamad.c
+++ b/mythtv/external/FFmpeg/libavcodec/eamad.c
@@ -29,6 +29,7 @@
  */
 
 #include "avcodec.h"
+#include "bytestream.h"
 #include "get_bits.h"
 #include "aandcttab.h"
 #include "eaidct.h"
@@ -237,30 +238,32 @@ static int decode_frame(AVCodecContext *avctx,
 {
     const uint8_t *buf = avpkt->data;
     int buf_size       = avpkt->size;
-    const uint8_t *buf_end = buf+buf_size;
     MadContext *s     = avctx->priv_data;
     AVFrame *frame    = data;
+    GetByteContext gb;
     int width, height;
     int chunk_type;
     int inter, ret;
 
-    if (buf_size < 26) {
-        av_log(avctx, AV_LOG_ERROR, "Input buffer too small\n");
-        *got_frame = 0;
-        return AVERROR_INVALIDDATA;
-    }
+    bytestream2_init(&gb, buf, buf_size);
 
-    chunk_type = AV_RL32(&buf[0]);
+    chunk_type = bytestream2_get_le32(&gb);
     inter = (chunk_type == MADm_TAG || chunk_type == MADe_TAG);
-    buf += 8;
+    bytestream2_skip(&gb, 10);
 
     av_reduce(&avctx->time_base.num, &avctx->time_base.den,
-              AV_RL16(&buf[6]), 1000, 1<<30);
+              bytestream2_get_le16(&gb), 1000, 1<<30);
+
+    width  = bytestream2_get_le16(&gb);
+    height = bytestream2_get_le16(&gb);
+    bytestream2_skip(&gb, 1);
+    calc_quant_matrix(s, bytestream2_get_byte(&gb));
+    bytestream2_skip(&gb, 2);
 
-    width  = AV_RL16(&buf[8]);
-    height = AV_RL16(&buf[10]);
-    calc_quant_matrix(s, buf[13]);
-    buf += 16;
+    if (bytestream2_get_bytes_left(&gb) < 2) {
+        av_log(avctx, AV_LOG_ERROR, "Input data too small\n");
+        return AVERROR_INVALIDDATA;
+    }
 
     if (width < 16 || height < 16) {
         av_log(avctx, AV_LOG_ERROR, "Dimensions too small\n");
@@ -269,7 +272,7 @@ static int decode_frame(AVCodecContext *avctx,
 
     if (avctx->width != width || avctx->height != height) {
         av_frame_unref(s->last_frame);
-        if((width * height)/2048*7 > buf_end-buf)
+        if((width * height)/2048*7 > bytestream2_get_bytes_left(&gb))
             return AVERROR_INVALIDDATA;
         if ((ret = ff_set_dimensions(avctx, width, height)) < 0)
             return ret;
@@ -292,12 +295,13 @@ static int decode_frame(AVCodecContext *avctx,
     }
 
     av_fast_padded_malloc(&s->bitstream_buf, &s->bitstream_buf_size,
-                          buf_end - buf);
+                          bytestream2_get_bytes_left(&gb));
     if (!s->bitstream_buf)
         return AVERROR(ENOMEM);
-    s->dsp.bswap16_buf(s->bitstream_buf, (const uint16_t*)buf, (buf_end-buf)/2);
-    memset((uint8_t*)s->bitstream_buf + (buf_end-buf), 0, FF_INPUT_BUFFER_PADDING_SIZE);
-    init_get_bits(&s->gb, s->bitstream_buf, 8*(buf_end-buf));
+    s->dsp.bswap16_buf(s->bitstream_buf, (const uint16_t *)(buf + bytestream2_tell(&gb)),
+                         bytestream2_get_bytes_left(&gb) / 2);
+    memset((uint8_t*)s->bitstream_buf + bytestream2_get_bytes_left(&gb), 0, FF_INPUT_BUFFER_PADDING_SIZE);
+    init_get_bits(&s->gb, s->bitstream_buf, 8*(bytestream2_get_bytes_left(&gb)));
 
     for (s->mb_y=0; s->mb_y < (avctx->height+15)/16; s->mb_y++)
         for (s->mb_x=0; s->mb_x < (avctx->width +15)/16; s->mb_x++)
diff --git a/mythtv/external/FFmpeg/libavcodec/fft-test.c b/mythtv/external/FFmpeg/libavcodec/fft-test.c
index ef1d622..1ca4693 100644
--- a/mythtv/external/FFmpeg/libavcodec/fft-test.c
+++ b/mythtv/external/FFmpeg/libavcodec/fft-test.c
@@ -117,6 +117,7 @@ static void fft_ref(FFTComplex *tabr, FFTComplex *tab, int nbits)
     }
 }
 
+#if CONFIG_MDCT
 static void imdct_ref(FFTSample *out, FFTSample *in, int nbits)
 {
     int n = 1<<nbits;
@@ -151,8 +152,10 @@ static void mdct_ref(FFTSample *output, FFTSample *input, int nbits)
         output[k] = REF_SCALE(s, nbits - 1);
     }
 }
+#endif /* CONFIG_MDCT */
 
 #if FFT_FLOAT
+#if CONFIG_DCT
 static void idct_ref(FFTSample *output, FFTSample *input, int nbits)
 {
     int n = 1<<nbits;
@@ -185,6 +188,7 @@ static void dct_ref(FFTSample *output, FFTSample *input, int nbits)
         output[k] = s;
     }
 }
+#endif /* CONFIG_DCT */
 #endif
 
 
@@ -310,6 +314,7 @@ int main(int argc, char **argv)
     tab2 = av_malloc(fft_size * sizeof(FFTSample));
 
     switch (transform) {
+#if CONFIG_MDCT
     case TRANSFORM_MDCT:
         av_log(NULL, AV_LOG_INFO,"Scale factor is set to %f\n", scale);
         if (do_inverse)
@@ -318,6 +323,7 @@ int main(int argc, char **argv)
             av_log(NULL, AV_LOG_INFO,"MDCT");
         ff_mdct_init(m, fft_nbits, do_inverse, scale);
         break;
+#endif /* CONFIG_MDCT */
     case TRANSFORM_FFT:
         if (do_inverse)
             av_log(NULL, AV_LOG_INFO,"IFFT");
@@ -327,6 +333,7 @@ int main(int argc, char **argv)
         fft_ref_init(fft_nbits, do_inverse);
         break;
 #if FFT_FLOAT
+#    if CONFIG_RDFT
     case TRANSFORM_RDFT:
         if (do_inverse)
             av_log(NULL, AV_LOG_INFO,"IDFT_C2R");
@@ -335,6 +342,7 @@ int main(int argc, char **argv)
         ff_rdft_init(r, fft_nbits, do_inverse ? IDFT_C2R : DFT_R2C);
         fft_ref_init(fft_nbits, do_inverse);
         break;
+#    endif /* CONFIG_RDFT */
 #    if CONFIG_DCT
     case TRANSFORM_DCT:
         if (do_inverse)
@@ -343,7 +351,7 @@ int main(int argc, char **argv)
             av_log(NULL, AV_LOG_INFO,"DCT_II");
         ff_dct_init(d, fft_nbits, do_inverse ? DCT_III : DCT_II);
         break;
-#    endif
+#    endif /* CONFIG_DCT */
 #endif
     default:
         av_log(NULL, AV_LOG_ERROR, "Requested transform not supported\n");
@@ -362,6 +370,7 @@ int main(int argc, char **argv)
     av_log(NULL, AV_LOG_INFO,"Checking...\n");
 
     switch (transform) {
+#if CONFIG_MDCT
     case TRANSFORM_MDCT:
         if (do_inverse) {
             imdct_ref((FFTSample *)tab_ref, (FFTSample *)tab1, fft_nbits);
@@ -375,6 +384,7 @@ int main(int argc, char **argv)
             err = check_diff((FFTSample *)tab_ref, tab2, fft_size / 2, scale);
         }
         break;
+#endif /* CONFIG_MDCT */
     case TRANSFORM_FFT:
         memcpy(tab, tab1, fft_size * sizeof(FFTComplex));
         s->fft_permute(s, tab);
@@ -384,6 +394,7 @@ int main(int argc, char **argv)
         err = check_diff((FFTSample *)tab_ref, (FFTSample *)tab, fft_size * 2, 1.0);
         break;
 #if FFT_FLOAT
+#if CONFIG_RDFT
     case TRANSFORM_RDFT:
         fft_size_2 = fft_size >> 1;
         if (do_inverse) {
@@ -415,6 +426,8 @@ int main(int argc, char **argv)
             err = check_diff((float *)tab_ref, (float *)tab2, fft_size, 1.0);
         }
         break;
+#endif /* CONFIG_RDFT */
+#if CONFIG_DCT
     case TRANSFORM_DCT:
         memcpy(tab, tab1, fft_size * sizeof(FFTComplex));
         d->dct_calc(d, (FFTSample *)tab);
@@ -425,6 +438,7 @@ int main(int argc, char **argv)
         }
         err = check_diff((float *)tab_ref, (float *)tab, fft_size, 1.0);
         break;
+#endif /* CONFIG_DCT */
 #endif
     }
 
@@ -476,21 +490,25 @@ int main(int argc, char **argv)
     }
 
     switch (transform) {
+#if CONFIG_MDCT
     case TRANSFORM_MDCT:
         ff_mdct_end(m);
         break;
+#endif /* CONFIG_MDCT */
     case TRANSFORM_FFT:
         ff_fft_end(s);
         break;
 #if FFT_FLOAT
+#    if CONFIG_RDFT
     case TRANSFORM_RDFT:
         ff_rdft_end(r);
         break;
+#    endif /* CONFIG_RDFT */
 #    if CONFIG_DCT
     case TRANSFORM_DCT:
         ff_dct_end(d);
         break;
-#    endif
+#    endif /* CONFIG_DCT */
 #endif
     }
 
diff --git a/mythtv/external/FFmpeg/libavcodec/g2meet.c b/mythtv/external/FFmpeg/libavcodec/g2meet.c
index 70b5f26..aaf1abb 100644
--- a/mythtv/external/FFmpeg/libavcodec/g2meet.c
+++ b/mythtv/external/FFmpeg/libavcodec/g2meet.c
@@ -87,6 +87,7 @@ typedef struct G2MContext {
 
     int        compression;
     int        width, height, bpp;
+    int        orig_width, orig_height;
     int        tile_width, tile_height;
     int        tiles_x, tiles_y, tile_x, tile_y;
 
@@ -700,8 +701,8 @@ static int g2m_decode_frame(AVCodecContext *avctx, void *data,
             }
             c->width  = bytestream2_get_be32(&bc);
             c->height = bytestream2_get_be32(&bc);
-            if (c->width  < 16 || c->width  > avctx->width ||
-                c->height < 16 || c->height > avctx->height) {
+            if (c->width  < 16 || c->width  > c->orig_width ||
+                c->height < 16 || c->height > c->orig_height) {
                 av_log(avctx, AV_LOG_ERROR,
                        "Invalid frame dimensions %dx%d\n",
                        c->width, c->height);
@@ -867,6 +868,10 @@ static av_cold int g2m_decode_init(AVCodecContext *avctx)
 
     avctx->pix_fmt = AV_PIX_FMT_RGB24;
 
+    // store original sizes and check against those if resize happens
+    c->orig_width  = avctx->width;
+    c->orig_height = avctx->height;
+
     return 0;
 }
 
diff --git a/mythtv/external/FFmpeg/libavcodec/h264.h b/mythtv/external/FFmpeg/libavcodec/h264.h
index 4a41fff..188e749 100644
--- a/mythtv/external/FFmpeg/libavcodec/h264.h
+++ b/mythtv/external/FFmpeg/libavcodec/h264.h
@@ -691,7 +691,7 @@ typedef struct H264Context {
 
     int16_t slice_row[MAX_SLICES]; ///< to detect when MAX_SLICES is too low
 
-    uint8_t parse_history[4];
+    uint8_t parse_history[6];
     int parse_history_count;
     int parse_last_mb;
     uint8_t *edge_emu_buffer;
diff --git a/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c b/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c
index 0f142bb..a003a1d 100644
--- a/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c
+++ b/mythtv/external/FFmpeg/libavcodec/h264_mp4toannexb_bsf.c
@@ -28,6 +28,7 @@
 typedef struct H264BSFContext {
     uint8_t  length_size;
     uint8_t  first_idr;
+    uint8_t  idr_sps_pps_seen;
     int      extradata_parsed;
 } H264BSFContext;
 
@@ -155,6 +156,7 @@ static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
             return ret;
         ctx->length_size      = ret;
         ctx->first_idr        = 1;
+        ctx->idr_sps_pps_seen = 0;
         ctx->extradata_parsed = 1;
     }
 
@@ -174,8 +176,17 @@ static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
         if (buf + nal_size > buf_end || nal_size < 0)
             goto fail;
 
-        /* prepend only to the first type 5 NAL unit of an IDR picture */
-        if (ctx->first_idr && (unit_type == 5 || unit_type == 7 || unit_type == 8)) {
+        if (ctx->first_idr && (unit_type == 7 || unit_type == 8))
+            ctx->idr_sps_pps_seen = 1;
+
+        /* if this is a new IDR picture following an IDR picture, reset the idr flag.
+         * Just check first_mb_in_slice to be 0 as this is the simplest solution.
+         * This could be checking idr_pic_id instead, but would complexify the parsing. */
+        if (!ctx->first_idr && unit_type == 5 && (buf[1] & 0x80))
+            ctx->first_idr = 1;
+
+        /* prepend only to the first type 5 NAL unit of an IDR picture, if no sps/pps are already present */
+        if (ctx->first_idr && unit_type == 5 && !ctx->idr_sps_pps_seen) {
             if ((ret=alloc_and_copy(poutbuf, poutbuf_size,
                                avctx->extradata, avctx->extradata_size,
                                buf, nal_size)) < 0)
@@ -185,8 +196,10 @@ static int h264_mp4toannexb_filter(AVBitStreamFilterContext *bsfc,
             if ((ret=alloc_and_copy(poutbuf, poutbuf_size,
                                NULL, 0, buf, nal_size)) < 0)
                 goto fail;
-            if (!ctx->first_idr && unit_type == 1)
+            if (!ctx->first_idr && unit_type == 1) {
                 ctx->first_idr = 1;
+                ctx->idr_sps_pps_seen = 0;
+            }
         }
 
         buf        += nal_size;
diff --git a/mythtv/external/FFmpeg/libavcodec/h264_parser.c b/mythtv/external/FFmpeg/libavcodec/h264_parser.c
index 4432871..416f464 100644
--- a/mythtv/external/FFmpeg/libavcodec/h264_parser.c
+++ b/mythtv/external/FFmpeg/libavcodec/h264_parser.c
@@ -91,7 +91,7 @@ static int h264_find_frame_end(H264Context *h, const uint8_t *buf,
             state = 7;
         } else {
             h->parse_history[h->parse_history_count++]= buf[i];
-            if (h->parse_history_count>3) {
+            if (h->parse_history_count>5) {
                 unsigned int mb, last_mb= h->parse_last_mb;
                 GetBitContext gb;
 
@@ -119,7 +119,7 @@ found:
     pc->frame_start_found = 0;
     if (h->is_avc)
         return next_avc;
-    return i - (state & 5) - 3 * (state > 7);
+    return i - (state & 5) - 5 * (state > 7);
 }
 
 static int scan_mmco_reset(AVCodecParserContext *s)
diff --git a/mythtv/external/FFmpeg/libavcodec/hevc.c b/mythtv/external/FFmpeg/libavcodec/hevc.c
index 4aa1e55..5f719c8 100644
--- a/mythtv/external/FFmpeg/libavcodec/hevc.c
+++ b/mythtv/external/FFmpeg/libavcodec/hevc.c
@@ -102,26 +102,26 @@ static int pic_arrays_init(HEVCContext *s, const HEVCSPS *sps)
         goto fail;
 
     s->skip_flag    = av_malloc(pic_size_in_ctb);
-    s->tab_ct_depth = av_malloc(sps->min_cb_height * sps->min_cb_width);
+    s->tab_ct_depth = av_malloc_array(sps->min_cb_height, sps->min_cb_width);
     if (!s->skip_flag || !s->tab_ct_depth)
         goto fail;
 
-    s->cbf_luma = av_malloc(sps->min_tb_width * sps->min_tb_height);
+    s->cbf_luma = av_malloc_array(sps->min_tb_width, sps->min_tb_height);
     s->tab_ipm  = av_mallocz(min_pu_size);
     s->is_pcm   = av_malloc(min_pu_size);
     if (!s->tab_ipm || !s->cbf_luma || !s->is_pcm)
         goto fail;
 
     s->filter_slice_edges = av_malloc(ctb_count);
-    s->tab_slice_address  = av_malloc(pic_size_in_ctb *
+    s->tab_slice_address  = av_malloc_array(pic_size_in_ctb,
                                       sizeof(*s->tab_slice_address));
-    s->qp_y_tab           = av_malloc(pic_size_in_ctb *
+    s->qp_y_tab           = av_malloc_array(pic_size_in_ctb,
                                       sizeof(*s->qp_y_tab));
     if (!s->qp_y_tab || !s->filter_slice_edges || !s->tab_slice_address)
         goto fail;
 
-    s->horizontal_bs = av_mallocz(2 * s->bs_width * (s->bs_height + 1));
-    s->vertical_bs   = av_mallocz(2 * s->bs_width * (s->bs_height + 1));
+    s->horizontal_bs = av_mallocz_array(2 * s->bs_width, (s->bs_height + 1));
+    s->vertical_bs   = av_mallocz_array(2 * s->bs_width, (s->bs_height + 1));
     if (!s->horizontal_bs || !s->vertical_bs)
         goto fail;
 
@@ -652,9 +652,9 @@ static int hls_slice_header(HEVCContext *s)
             av_freep(&sh->entry_point_offset);
             av_freep(&sh->offset);
             av_freep(&sh->size);
-            sh->entry_point_offset = av_malloc(sh->num_entry_point_offsets * sizeof(int));
-            sh->offset = av_malloc(sh->num_entry_point_offsets * sizeof(int));
-            sh->size = av_malloc(sh->num_entry_point_offsets * sizeof(int));
+            sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
+            sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
+            sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int));
             if (!sh->entry_point_offset || !sh->offset || !sh->size) {
                 sh->num_entry_point_offsets = 0;
                 av_log(s->avctx, AV_LOG_ERROR, "Failed to allocate memory\n");
@@ -2059,8 +2059,8 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
 static int hls_slice_data_wpp(HEVCContext *s, const uint8_t *nal, int length)
 {
     HEVCLocalContext *lc = s->HEVClc;
-    int *ret = av_malloc((s->sh.num_entry_point_offsets + 1) * sizeof(int));
-    int *arg = av_malloc((s->sh.num_entry_point_offsets + 1) * sizeof(int));
+    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));
+    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));
     int offset;
     int startheader, cmpt = 0;
     int i, j, res = 0;
@@ -2818,6 +2818,8 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     for (i = 0; i < FF_ARRAY_ELEMS(s->pps_list); i++)
         av_buffer_unref(&s->pps_list[i]);
 
+    av_buffer_unref(&s->current_sps);
+
     av_freep(&s->sh.entry_point_offset);
     av_freep(&s->sh.offset);
     av_freep(&s->sh.size);
@@ -2939,6 +2941,13 @@ static int hevc_update_thread_context(AVCodecContext *dst,
         }
     }
 
+    av_buffer_unref(&s->current_sps);
+    if (s0->current_sps) {
+        s->current_sps = av_buffer_ref(s0->current_sps);
+        if (!s->current_sps)
+            return AVERROR(ENOMEM);
+    }
+
     if (s->sps != s0->sps)
         ret = set_sps(s, s0->sps);
 
diff --git a/mythtv/external/FFmpeg/libavcodec/hevc.h b/mythtv/external/FFmpeg/libavcodec/hevc.h
index a1c76fe..3d71871 100644
--- a/mythtv/external/FFmpeg/libavcodec/hevc.h
+++ b/mythtv/external/FFmpeg/libavcodec/hevc.h
@@ -776,6 +776,8 @@ typedef struct HEVCContext {
     AVBufferRef *sps_list[MAX_SPS_COUNT];
     AVBufferRef *pps_list[MAX_PPS_COUNT];
 
+    AVBufferRef *current_sps;
+
     AVBufferPool *tab_mvf_pool;
     AVBufferPool *rpl_tab_pool;
 
diff --git a/mythtv/external/FFmpeg/libavcodec/hevc_parser.c b/mythtv/external/FFmpeg/libavcodec/hevc_parser.c
index dc1f6d5..7284452 100644
--- a/mythtv/external/FFmpeg/libavcodec/hevc_parser.c
+++ b/mythtv/external/FFmpeg/libavcodec/hevc_parser.c
@@ -331,6 +331,9 @@ static void hevc_close(AVCodecParserContext *s)
     for (i = 0; i < FF_ARRAY_ELEMS(h->pps_list); i++)
         av_buffer_unref(&h->pps_list[i]);
 
+    av_buffer_unref(&h->current_sps);
+    h->sps = NULL;
+
     for (i = 0; i < h->nals_allocated; i++)
         av_freep(&h->nals[i].rbsp_buffer);
     av_freep(&h->nals);
diff --git a/mythtv/external/FFmpeg/libavcodec/hevc_ps.c b/mythtv/external/FFmpeg/libavcodec/hevc_ps.c
index 647f83e..c8350fb 100644
--- a/mythtv/external/FFmpeg/libavcodec/hevc_ps.c
+++ b/mythtv/external/FFmpeg/libavcodec/hevc_ps.c
@@ -956,6 +956,12 @@ int ff_hevc_decode_nal_sps(HEVCContext *s)
             if (s->pps_list[i] && ((HEVCPPS*)s->pps_list[i]->data)->sps_id == sps_id)
                 av_buffer_unref(&s->pps_list[i]);
         }
+        if (s->sps_list[sps_id] && s->sps == (HEVCSPS*)s->sps_list[sps_id]->data) {
+            av_buffer_unref(&s->current_sps);
+            s->current_sps = av_buffer_ref(s->sps_list[sps_id]);
+            if (!s->current_sps)
+                s->sps = NULL;
+        }
         av_buffer_unref(&s->sps_list[sps_id]);
         s->sps_list[sps_id] = sps_buf;
     }
diff --git a/mythtv/external/FFmpeg/libavcodec/huffyuvdec.c b/mythtv/external/FFmpeg/libavcodec/huffyuvdec.c
index 811347a..2746e27 100644
--- a/mythtv/external/FFmpeg/libavcodec/huffyuvdec.c
+++ b/mythtv/external/FFmpeg/libavcodec/huffyuvdec.c
@@ -186,7 +186,8 @@ static int generate_joint_tables(HYuvContext *s)
             }
         }
         ff_free_vlc(&s->vlc[4]);
-        if ((ret = init_vlc(&s->vlc[4], VLC_BITS, i, len, 1, 1, bits, 2, 2, 0)) < 0)
+        if ((ret = init_vlc(&s->vlc[4], VLC_BITS, i, len, 1, 1,
+                            bits, 2, 2, 0)) < 0)
             return ret;
     }
     return 0;
@@ -195,21 +196,20 @@ static int generate_joint_tables(HYuvContext *s)
 static int read_huffman_tables(HYuvContext *s, const uint8_t *src, int length)
 {
     GetBitContext gb;
-    int i;
-    int ret;
+    int i, ret;
     int count = 3;
 
-    init_get_bits(&gb, src, length * 8);
+    if ((ret = init_get_bits(&gb, src, length * 8)) < 0)
+        return ret;
 
     if (s->version > 2)
         count = 1 + s->alpha + 2*s->chroma;
 
     for (i = 0; i < count; i++) {
-        if (read_len_table(s->len[i], &gb, s->vlc_n) < 0)
-            return -1;
-        if (ff_huffyuv_generate_bits_table(s->bits[i], s->len[i], s->vlc_n) < 0) {
-            return -1;
-        }
+        if ((ret = read_len_table(s->len[i], &gb, s->vlc_n)) < 0)
+            return ret;
+        if ((ret = ff_huffyuv_generate_bits_table(s->bits[i], s->len[i], s->vlc_n)) < 0)
+            return ret;
         ff_free_vlc(&s->vlc[i]);
         if ((ret = init_vlc(&s->vlc[i], VLC_BITS, s->vlc_n, s->len[i], 1, 1,
                            s->bits[i], 4, 4, 0)) < 0)
@@ -225,18 +225,17 @@ static int read_huffman_tables(HYuvContext *s, const uint8_t *src, int length)
 static int read_old_huffman_tables(HYuvContext *s)
 {
     GetBitContext gb;
-    int i;
-    int ret;
+    int i, ret;
 
     init_get_bits(&gb, classic_shift_luma,
                   classic_shift_luma_table_size * 8);
-    if (read_len_table(s->len[0], &gb, 256) < 0)
-        return -1;
+    if ((ret = read_len_table(s->len[0], &gb, 256)) < 0)
+        return ret;
 
     init_get_bits(&gb, classic_shift_chroma,
                   classic_shift_chroma_table_size * 8);
-    if (read_len_table(s->len[1], &gb, 256) < 0)
-        return -1;
+    if ((ret = read_len_table(s->len[1], &gb, 256)) < 0)
+        return ret;
 
     for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];
     for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];
@@ -264,6 +263,7 @@ static int read_old_huffman_tables(HYuvContext *s)
 static av_cold int decode_init(AVCodecContext *avctx)
 {
     HYuvContext *s = avctx->priv_data;
+    int ret;
 
     memset(s->vlc, 0, 4 * sizeof(VLC));
 
@@ -313,10 +313,10 @@ static av_cold int decode_init(AVCodecContext *avctx)
         s->interlaced = (interlace == 1) ? 1 : (interlace == 2) ? 0 : s->interlaced;
         s->context = ((uint8_t*)avctx->extradata)[2] & 0x40 ? 1 : 0;
 
-        if ( read_huffman_tables(s, ((uint8_t*)avctx->extradata) + 4,
-                                 avctx->extradata_size - 4) < 0)
-            return AVERROR_INVALIDDATA;
-    }else{
+        if ((ret = read_huffman_tables(s, avctx->extradata + 4,
+                                       avctx->extradata_size - 4)) < 0)
+            return ret;
+    } else {
         switch (avctx->bits_per_coded_sample & 7) {
         case 1:
             s->predictor = LEFT;
@@ -342,8 +342,8 @@ static av_cold int decode_init(AVCodecContext *avctx)
         s->bitstream_bpp = avctx->bits_per_coded_sample & ~7;
         s->context = 0;
 
-        if (read_old_huffman_tables(s) < 0)
-            return AVERROR_INVALIDDATA;
+        if ((ret = read_old_huffman_tables(s)) < 0)
+            return ret;
     }
 
     if (s->version <= 2) {
@@ -524,9 +524,9 @@ static av_cold int decode_init(AVCodecContext *avctx)
         av_log(avctx, AV_LOG_ERROR, "width must be a multiple of 4 this colorspace and predictor\n");
         return AVERROR_INVALIDDATA;
     }
-    if (ff_huffyuv_alloc_temp(s)) {
+    if ((ret = ff_huffyuv_alloc_temp(s)) < 0) {
         ff_huffyuv_common_end(s);
-        return AVERROR(ENOMEM);
+        return ret;
     }
 
     return 0;
@@ -535,23 +535,23 @@ static av_cold int decode_init(AVCodecContext *avctx)
 static av_cold int decode_init_thread_copy(AVCodecContext *avctx)
 {
     HYuvContext *s = avctx->priv_data;
-    int i;
+    int i, ret;
 
-    if (ff_huffyuv_alloc_temp(s)) {
+    if ((ret = ff_huffyuv_alloc_temp(s)) < 0) {
         ff_huffyuv_common_end(s);
-        return AVERROR(ENOMEM);
+        return ret;
     }
 
     for (i = 0; i < 8; i++)
         s->vlc[i].table = NULL;
 
     if (s->version >= 2) {
-        if (read_huffman_tables(s, ((uint8_t*)avctx->extradata) + 4,
-                                avctx->extradata_size) < 0)
-            return AVERROR_INVALIDDATA;
+        if ((ret = read_huffman_tables(s, avctx->extradata + 4,
+                                       avctx->extradata_size)) < 0)
+            return ret;
     } else {
-        if (read_old_huffman_tables(s) < 0)
-            return AVERROR_INVALIDDATA;
+        if ((ret = read_old_huffman_tables(s)) < 0)
+            return ret;
     }
 
     return 0;
@@ -798,14 +798,15 @@ static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
     if (s->context) {
         table_size = read_huffman_tables(s, s->bitstream_buffer, buf_size);
         if (table_size < 0)
-            return AVERROR_INVALIDDATA;
+            return table_size;
     }
 
     if ((unsigned)(buf_size-table_size) >= INT_MAX / 8)
         return AVERROR_INVALIDDATA;
 
-    init_get_bits(&s->gb, s->bitstream_buffer+table_size,
-                  (buf_size-table_size) * 8);
+    if ((ret = init_get_bits(&s->gb, s->bitstream_buffer + table_size,
+                             (buf_size - table_size) * 8)) < 0)
+        return ret;
 
     fake_ystride = s->interlaced ? p->linesize[0] * 2  : p->linesize[0];
     fake_ustride = s->interlaced ? p->linesize[1] * 2  : p->linesize[1];
diff --git a/mythtv/external/FFmpeg/libavcodec/jpeg2000.c b/mythtv/external/FFmpeg/libavcodec/jpeg2000.c
index f3658c2..cbcf946 100644
--- a/mythtv/external/FFmpeg/libavcodec/jpeg2000.c
+++ b/mythtv/external/FFmpeg/libavcodec/jpeg2000.c
@@ -224,7 +224,7 @@ int ff_jpeg2000_init_component(Jpeg2000Component *comp,
         if (!comp->i_data)
             return AVERROR(ENOMEM);
     }
-    comp->reslevel = av_calloc(codsty->nreslevels, sizeof(*comp->reslevel));
+    comp->reslevel = av_mallocz_array(codsty->nreslevels, sizeof(*comp->reslevel));
     if (!comp->reslevel)
         return AVERROR(ENOMEM);
     /* LOOP on resolution levels */
@@ -272,7 +272,7 @@ int ff_jpeg2000_init_component(Jpeg2000Component *comp,
                                         reslevel->log2_prec_height) -
                 (reslevel->coord[1][0] >> reslevel->log2_prec_height);
 
-        reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));
+        reslevel->band = av_mallocz_array(reslevel->nbands, sizeof(*reslevel->band));
         if (!reslevel->band)
             return AVERROR(ENOMEM);
 
@@ -368,9 +368,9 @@ int ff_jpeg2000_init_component(Jpeg2000Component *comp,
             for (j = 0; j < 2; j++)
                 band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);
 
-            band->prec = av_calloc(reslevel->num_precincts_x *
-                                         (uint64_t)reslevel->num_precincts_y,
-                                         sizeof(*band->prec));
+            band->prec = av_mallocz_array(reslevel->num_precincts_x *
+                                          (uint64_t)reslevel->num_precincts_y,
+                                          sizeof(*band->prec));
             if (!band->prec)
                 return AVERROR(ENOMEM);
 
@@ -504,22 +504,29 @@ void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)
     for (reslevelno = 0;
          comp->reslevel && reslevelno < codsty->nreslevels;
          reslevelno++) {
-        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;
+        Jpeg2000ResLevel *reslevel;
+
+        if (!comp->reslevel)
+            continue;
 
+        reslevel = comp->reslevel + reslevelno;
         for (bandno = 0; bandno < reslevel->nbands; bandno++) {
-            if (reslevel->band) {
-                Jpeg2000Band *band = reslevel->band + bandno;
-                for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {
-                    if (band->prec) {
-                        Jpeg2000Prec *prec = band->prec + precno;
-                        av_freep(&prec->zerobits);
-                        av_freep(&prec->cblkincl);
-                        av_freep(&prec->cblk);
-                    }
+            Jpeg2000Band *band;
+
+            if (!reslevel->band)
+                continue;
+
+            band = reslevel->band + bandno;
+            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {
+                if (band->prec) {
+                    Jpeg2000Prec *prec = band->prec + precno;
+                    av_freep(&prec->zerobits);
+                    av_freep(&prec->cblkincl);
+                    av_freep(&prec->cblk);
                 }
-
-                av_freep(&band->prec);
             }
+
+            av_freep(&band->prec);
         }
         av_freep(&reslevel->band);
     }
diff --git a/mythtv/external/FFmpeg/libavcodec/libmp3lame.c b/mythtv/external/FFmpeg/libavcodec/libmp3lame.c
index e6cb64b..f2d455c 100644
--- a/mythtv/external/FFmpeg/libavcodec/libmp3lame.c
+++ b/mythtv/external/FFmpeg/libavcodec/libmp3lame.c
@@ -183,6 +183,7 @@ static int mp3lame_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
     MPADecodeHeader hdr;
     int len, ret, ch;
     int lame_result;
+    uint32_t h;
 
     if (frame) {
         switch (avctx->sample_fmt) {
@@ -238,7 +239,12 @@ static int mp3lame_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
        determine the frame size. */
     if (s->buffer_index < 4)
         return 0;
-    if (avpriv_mpegaudio_decode_header(&hdr, AV_RB32(s->buffer))) {
+    h = AV_RB32(s->buffer);
+    if (ff_mpa_check_header(h) < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid mp3 header at start of buffer\n");
+        return AVERROR_BUG;
+    }
+    if (avpriv_mpegaudio_decode_header(&hdr, h)) {
         av_log(avctx, AV_LOG_ERROR, "free format output not supported\n");
         return -1;
     }
diff --git a/mythtv/external/FFmpeg/libavcodec/mpeg12dec.c b/mythtv/external/FFmpeg/libavcodec/mpeg12dec.c
index 7189d2f..676ffea 100644
--- a/mythtv/external/FFmpeg/libavcodec/mpeg12dec.c
+++ b/mythtv/external/FFmpeg/libavcodec/mpeg12dec.c
@@ -1878,6 +1878,14 @@ static int mpeg_decode_slice(MpegEncContext *s, int mb_y,
                 } else
                     goto eos;
             }
+            if (s->mb_y >= ((s->height + 15) >> 4) &&
+                s->progressive_frame &&
+                !s->progressive_sequence &&
+                get_bits_left(&s->gb) <= 8 &&
+                get_bits_left(&s->gb) >= 0 &&
+                s->mb_skip_run == -1 &&
+                show_bits(&s->gb, 8) == 0)
+                goto eos;
 
             ff_init_block_index(s);
         }
diff --git a/mythtv/external/FFmpeg/libavcodec/mpegaudiodecheader.c b/mythtv/external/FFmpeg/libavcodec/mpegaudiodecheader.c
index a07604d..acebb3c 100644
--- a/mythtv/external/FFmpeg/libavcodec/mpegaudiodecheader.c
+++ b/mythtv/external/FFmpeg/libavcodec/mpegaudiodecheader.c
@@ -24,6 +24,8 @@
  * MPEG Audio header decoder.
  */
 
+#include "libavutil/common.h"
+
 #include "avcodec.h"
 #include "mpegaudio.h"
 #include "mpegaudiodata.h"
@@ -45,6 +47,8 @@ int avpriv_mpegaudio_decode_header(MPADecodeHeader *s, uint32_t header)
     s->layer = 4 - ((header >> 17) & 3);
     /* extract frequency */
     sample_rate_index = (header >> 10) & 3;
+    if (sample_rate_index >= FF_ARRAY_ELEMS(avpriv_mpa_freq_tab))
+        sample_rate_index = 0;
     sample_rate = avpriv_mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);
     sample_rate_index += 3 * (s->lsf + mpeg25);
     s->sample_rate_index = sample_rate_index;
diff --git a/mythtv/external/FFmpeg/libavcodec/pgssubdec.c b/mythtv/external/FFmpeg/libavcodec/pgssubdec.c
index d4b3f62..24474f9 100644
--- a/mythtv/external/FFmpeg/libavcodec/pgssubdec.c
+++ b/mythtv/external/FFmpeg/libavcodec/pgssubdec.c
@@ -215,6 +215,13 @@ static int parse_picture_segment(AVCodecContext *avctx,
     /* Decode rle bitmap length, stored size includes width/height data */
     rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;
 
+    if (buf_size > rle_bitmap_len) {
+        av_log(avctx, AV_LOG_ERROR,
+               "Buffer dimension %d larger than the expected RLE data %d\n",
+               buf_size, rle_bitmap_len);
+        return AVERROR_INVALIDDATA;
+    }
+
     /* Get bitmap dimensions from data */
     width  = bytestream_get_be16(&buf);
     height = bytestream_get_be16(&buf);
@@ -225,11 +232,6 @@ static int parse_picture_segment(AVCodecContext *avctx,
         return -1;
     }
 
-    if (buf_size > rle_bitmap_len) {
-        av_log(avctx, AV_LOG_ERROR, "too much RLE data\n");
-        return AVERROR_INVALIDDATA;
-    }
-
     ctx->pictures[picture_id].w = width;
     ctx->pictures[picture_id].h = height;
 
diff --git a/mythtv/external/FFmpeg/libavcodec/vc1dec.c b/mythtv/external/FFmpeg/libavcodec/vc1dec.c
index 593e69f..4e1b8bf 100644
--- a/mythtv/external/FFmpeg/libavcodec/vc1dec.c
+++ b/mythtv/external/FFmpeg/libavcodec/vc1dec.c
@@ -6005,7 +6005,7 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data,
 
     /* skip B-frames if we don't have reference frames */
     if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->droppable)) {
-        goto err;
+        goto end;
     }
     if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) ||
         (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||
diff --git a/mythtv/external/FFmpeg/libavcodec/wavpackenc.c b/mythtv/external/FFmpeg/libavcodec/wavpackenc.c
index d7a1c61..bf9f918 100644
--- a/mythtv/external/FFmpeg/libavcodec/wavpackenc.c
+++ b/mythtv/external/FFmpeg/libavcodec/wavpackenc.c
@@ -638,7 +638,7 @@ static uint32_t log2sample(uint32_t v, int limit, uint32_t *result)
 
     if ((v += v >> 9) < (1 << 8)) {
         dbits = nbits_table[v];
-        result += (dbits << 8) + wp_log2_table[(v << (9 - dbits)) & 0xff];
+        *result += (dbits << 8) + wp_log2_table[(v << (9 - dbits)) & 0xff];
     } else {
         if (v < (1L << 16))
             dbits = nbits_table[v >> 8] + 8;
@@ -647,7 +647,7 @@ static uint32_t log2sample(uint32_t v, int limit, uint32_t *result)
         else
             dbits = nbits_table[v >> 24] + 24;
 
-        result += dbits = (dbits << 8) + wp_log2_table[(v >> (dbits - 9)) & 0xff];
+        *result += dbits = (dbits << 8) + wp_log2_table[(v >> (dbits - 9)) & 0xff];
 
         if (limit && dbits >= limit)
             return 1;
diff --git a/mythtv/external/FFmpeg/libavdevice/v4l2enc.c b/mythtv/external/FFmpeg/libavdevice/v4l2enc.c
index 21f0ef6..db49465 100644
--- a/mythtv/external/FFmpeg/libavdevice/v4l2enc.c
+++ b/mythtv/external/FFmpeg/libavdevice/v4l2enc.c
@@ -22,6 +22,7 @@
 #include "avdevice.h"
 
 typedef struct {
+    AVClass *class;
     int fd;
 } V4L2Context;
 
diff --git a/mythtv/external/FFmpeg/libavfilter/af_compand.c b/mythtv/external/FFmpeg/libavfilter/af_compand.c
index deaaf44..60f8abe 100644
--- a/mythtv/external/FFmpeg/libavfilter/af_compand.c
+++ b/mythtv/external/FFmpeg/libavfilter/af_compand.c
@@ -278,7 +278,13 @@ static int compand_delay(AVFilterContext *ctx, AVFrame *frame)
     s->delay_index = dindex;
 
     av_frame_free(&frame);
-    return out_frame ? ff_filter_frame(ctx->outputs[0], out_frame) : 0;
+
+    if (out_frame) {
+        err = ff_filter_frame(ctx->outputs[0], out_frame);
+        return err;
+    }
+
+    return 0;
 }
 
 static int compand_drain(AVFilterLink *outlink)
@@ -533,7 +539,7 @@ static int request_frame(AVFilterLink *outlink)
 {
     AVFilterContext *ctx = outlink->src;
     CompandContext *s    = ctx->priv;
-    int ret;
+    int ret = 0;
 
     ret = ff_request_frame(ctx->inputs[0]);
 
diff --git a/mythtv/external/FFmpeg/libavfilter/f_ebur128.c b/mythtv/external/FFmpeg/libavfilter/f_ebur128.c
index 2e510db..a02cf28 100644
--- a/mythtv/external/FFmpeg/libavfilter/f_ebur128.c
+++ b/mythtv/external/FFmpeg/libavfilter/f_ebur128.c
@@ -412,7 +412,7 @@ static int config_audio_output(AVFilterLink *outlink)
     if (ebur128->peak_mode & PEAK_MODE_TRUE_PEAKS) {
         int ret;
 
-        ebur128->swr_buf    = av_malloc(19200 * nb_channels * sizeof(double));
+        ebur128->swr_buf    = av_malloc_array(nb_channels, 19200 * sizeof(double));
         ebur128->true_peaks = av_calloc(nb_channels, sizeof(*ebur128->true_peaks));
         ebur128->true_peaks_per_frame = av_calloc(nb_channels, sizeof(*ebur128->true_peaks_per_frame));
         ebur128->swr_ctx    = swr_alloc();
diff --git a/mythtv/external/FFmpeg/libavfilter/f_select.c b/mythtv/external/FFmpeg/libavfilter/f_select.c
index 1ffc006..4095573 100644
--- a/mythtv/external/FFmpeg/libavfilter/f_select.c
+++ b/mythtv/external/FFmpeg/libavfilter/f_select.c
@@ -308,6 +308,7 @@ static void select_frame(AVFilterContext *ctx, AVFrame *frame)
     select->var_values[VAR_PTS] = TS2D(frame->pts);
     select->var_values[VAR_T  ] = TS2D(frame->pts) * av_q2d(inlink->time_base);
     select->var_values[VAR_POS] = av_frame_get_pkt_pos(frame) == -1 ? NAN : av_frame_get_pkt_pos(frame);
+    select->var_values[VAR_KEY] = frame->key_frame;
 
     switch (inlink->type) {
     case AVMEDIA_TYPE_AUDIO:
@@ -337,21 +338,20 @@ static void select_frame(AVFilterContext *ctx, AVFrame *frame)
            select->var_values[VAR_N],
            select->var_values[VAR_PTS],
            select->var_values[VAR_T],
-           (int)select->var_values[VAR_KEY]);
+           frame->key_frame);
 
     switch (inlink->type) {
     case AVMEDIA_TYPE_VIDEO:
         av_log(inlink->dst, AV_LOG_DEBUG, " interlace_type:%c pict_type:%c scene:%f",
-               select->var_values[VAR_INTERLACE_TYPE] == INTERLACE_TYPE_P ? 'P' :
-               select->var_values[VAR_INTERLACE_TYPE] == INTERLACE_TYPE_T ? 'T' :
-               select->var_values[VAR_INTERLACE_TYPE] == INTERLACE_TYPE_B ? 'B' : '?',
-               av_get_picture_type_char(select->var_values[VAR_PICT_TYPE]),
+               (!frame->interlaced_frame) ? 'P' :
+               frame->top_field_first     ? 'T' : 'B',
+               av_get_picture_type_char(frame->pict_type),
                select->var_values[VAR_SCENE]);
         break;
     case AVMEDIA_TYPE_AUDIO:
-        av_log(inlink->dst, AV_LOG_DEBUG, " samples_n:%d consumed_samples_n:%d",
-               (int)select->var_values[VAR_SAMPLES_N],
-               (int)select->var_values[VAR_CONSUMED_SAMPLES_N]);
+        av_log(inlink->dst, AV_LOG_DEBUG, " samples_n:%d consumed_samples_n:%f",
+               frame->nb_samples,
+               select->var_values[VAR_CONSUMED_SAMPLES_N]);
         break;
     }
 
diff --git a/mythtv/external/FFmpeg/libavfilter/vf_pullup.c b/mythtv/external/FFmpeg/libavfilter/vf_pullup.c
index 5b448dd..c87b4b3 100644
--- a/mythtv/external/FFmpeg/libavfilter/vf_pullup.c
+++ b/mythtv/external/FFmpeg/libavfilter/vf_pullup.c
@@ -69,7 +69,7 @@ static int query_formats(AVFilterContext *ctx)
 
 #define ABS(a) (((a) ^ ((a) >> 31)) - ((a) >> 31))
 
-static int diff_c(const uint8_t *a, const uint8_t *b, int s)
+static int diff_c(const uint8_t *a, const uint8_t *b, ptrdiff_t s)
 {
     int i, j, diff = 0;
 
@@ -83,7 +83,7 @@ static int diff_c(const uint8_t *a, const uint8_t *b, int s)
     return diff;
 }
 
-static int comb_c(const uint8_t *a, const uint8_t *b, int s)
+static int comb_c(const uint8_t *a, const uint8_t *b, ptrdiff_t s)
 {
     int i, j, comb = 0;
 
@@ -98,7 +98,7 @@ static int comb_c(const uint8_t *a, const uint8_t *b, int s)
     return comb;
 }
 
-static int var_c(const uint8_t *a, const uint8_t *b, int s)
+static int var_c(const uint8_t *a, const uint8_t *b, ptrdiff_t s)
 {
     int i, j, var = 0;
 
@@ -531,7 +531,7 @@ static void pullup_release_frame(PullupFrame *f)
 
 static void compute_metric(PullupContext *s, int *dest,
                            PullupField *fa, int pa, PullupField *fb, int pb,
-                           int (*func)(const uint8_t *, const uint8_t *, int))
+                           int (*func)(const uint8_t *, const uint8_t *, ptrdiff_t))
 {
     int mp = s->metric_plane;
     int xstep = 8;
diff --git a/mythtv/external/FFmpeg/libavfilter/vf_pullup.h b/mythtv/external/FFmpeg/libavfilter/vf_pullup.h
index 3213b4d..8f59335 100644
--- a/mythtv/external/FFmpeg/libavfilter/vf_pullup.h
+++ b/mythtv/external/FFmpeg/libavfilter/vf_pullup.h
@@ -61,9 +61,9 @@ typedef struct PullupContext {
     PullupBuffer buffers[10];
     PullupFrame frame;
 
-    int (*diff)(const uint8_t *a, const uint8_t *b, int s);
-    int (*comb)(const uint8_t *a, const uint8_t *b, int s);
-    int (*var )(const uint8_t *a, const uint8_t *b, int s);
+    int (*diff)(const uint8_t *a, const uint8_t *b, ptrdiff_t s);
+    int (*comb)(const uint8_t *a, const uint8_t *b, ptrdiff_t s);
+    int (*var )(const uint8_t *a, const uint8_t *b, ptrdiff_t s);
 } PullupContext;
 
 void ff_pullup_init_x86(PullupContext *s);
diff --git a/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup.asm b/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup.asm
index 3689b04..4ce8b9b 100644
--- a/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup.asm
+++ b/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup.asm
@@ -68,7 +68,7 @@ cglobal pullup_filter_comb, 3, 5, 8, first, second, size
     sub        secondq, sizeq
 
 .loop:
-    movq       m0, [secondq]
+    movq       m0, [firstq]
     movq       m1, [secondq]
     punpcklbw  m0, m7
     movq       m2, [secondq+sizeq]
diff --git a/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup_init.c b/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup_init.c
index 9948abf..5b36b68 100644
--- a/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup_init.c
+++ b/mythtv/external/FFmpeg/libavfilter/x86/vf_pullup_init.c
@@ -23,9 +23,9 @@
 #include "libavutil/x86/cpu.h"
 #include "libavfilter/vf_pullup.h"
 
-int ff_pullup_filter_diff_mmx(const uint8_t *a, const uint8_t *b, int s);
-int ff_pullup_filter_comb_mmx(const uint8_t *a, const uint8_t *b, int s);
-int ff_pullup_filter_var_mmx (const uint8_t *a, const uint8_t *b, int s);
+int ff_pullup_filter_diff_mmx(const uint8_t *a, const uint8_t *b, ptrdiff_t s);
+int ff_pullup_filter_comb_mmx(const uint8_t *a, const uint8_t *b, ptrdiff_t s);
+int ff_pullup_filter_var_mmx (const uint8_t *a, const uint8_t *b, ptrdiff_t s);
 
 av_cold void ff_pullup_init_x86(PullupContext *s)
 {
diff --git a/mythtv/external/FFmpeg/libavformat/avformat.h b/mythtv/external/FFmpeg/libavformat/avformat.h
index 79f9831..a4768fe 100644
--- a/mythtv/external/FFmpeg/libavformat/avformat.h
+++ b/mythtv/external/FFmpeg/libavformat/avformat.h
@@ -1011,6 +1011,7 @@ typedef struct AVStream {
 
 AVRational av_stream_get_r_frame_rate(const AVStream *s);
 void       av_stream_set_r_frame_rate(AVStream *s, AVRational r);
+struct AVCodecParserContext *av_stream_get_parser(const AVStream *s);
 
 #define AV_PROGRAM_RUNNING 1
 
diff --git a/mythtv/external/FFmpeg/libavformat/dv.c b/mythtv/external/FFmpeg/libavformat/dv.c
index f972478..fd5ff4d 100644
--- a/mythtv/external/FFmpeg/libavformat/dv.c
+++ b/mythtv/external/FFmpeg/libavformat/dv.c
@@ -72,30 +72,33 @@ static inline uint16_t dv_audio_12to16(uint16_t sample)
     return result;
 }
 
-/*
- * This is the dumbest implementation of all -- it simply looks at
- * a fixed offset and if pack isn't there -- fails. We might want
- * to have a fallback mechanism for complete search of missing packs.
- */
 static const uint8_t *dv_extract_pack(uint8_t *frame, enum dv_pack_type t)
 {
     int offs;
+    int c;
 
-    switch (t) {
-    case dv_audio_source:
-        offs = (80 * 6 + 80 * 16 * 3 + 3);
-        break;
-    case dv_audio_control:
-        offs = (80 * 6 + 80 * 16 * 4 + 3);
-        break;
-    case dv_video_control:
-        offs = (80 * 5 + 48 + 5);
-        break;
-    case dv_timecode:
-        offs = (80*1 + 3 + 3);
-        break;
-    default:
-        return NULL;
+    for (c = 0; c < 10; c++) {
+        switch (t) {
+        case dv_audio_source:
+            if (c&1)    offs = (80 * 6 + 80 * 16 * 0 + 3 + c*12000);
+            else        offs = (80 * 6 + 80 * 16 * 3 + 3 + c*12000);
+            break;
+        case dv_audio_control:
+            if (c&1)    offs = (80 * 6 + 80 * 16 * 1 + 3 + c*12000);
+            else        offs = (80 * 6 + 80 * 16 * 4 + 3 + c*12000);
+            break;
+        case dv_video_control:
+            if (c&1)    offs = (80 * 3 + 8      + c*12000);
+            else        offs = (80 * 5 + 48 + 5 + c*12000);
+            break;
+        case dv_timecode:
+            offs = (80*1 + 3 + 3);
+            break;
+        default:
+            return NULL;
+        }
+        if (frame[offs] == t)
+            break;
     }
 
     return frame[offs] == t ? &frame[offs] : NULL;
diff --git a/mythtv/external/FFmpeg/libavformat/librtmp.c b/mythtv/external/FFmpeg/libavformat/librtmp.c
index f0b5929..94c0442 100644
--- a/mythtv/external/FFmpeg/libavformat/librtmp.c
+++ b/mythtv/external/FFmpeg/libavformat/librtmp.c
@@ -38,6 +38,7 @@ typedef struct LibRTMPContext {
     RTMP rtmp;
     char *app;
     char *playpath;
+    char *temp_filename;
 } LibRTMPContext;
 
 static void rtmp_log(int level, const char *fmt, va_list args)
@@ -62,6 +63,7 @@ static int rtmp_close(URLContext *s)
     RTMP *r = &ctx->rtmp;
 
     RTMP_Close(r);
+    av_freep(&ctx->temp_filename);
     return 0;
 }
 
@@ -101,7 +103,7 @@ static int rtmp_open(URLContext *s, const char *uri, int flags)
         if (ctx->app)      len += strlen(ctx->app)      + sizeof(" app=");
         if (ctx->playpath) len += strlen(ctx->playpath) + sizeof(" playpath=");
 
-        if (!(filename = av_malloc(len)))
+        if (!(ctx->temp_filename = filename = av_malloc(len)))
             return AVERROR(ENOMEM);
 
         av_strlcpy(filename, s->filename, len);
@@ -130,10 +132,9 @@ static int rtmp_open(URLContext *s, const char *uri, int flags)
     }
 
     s->is_streamed = 1;
-    rc = 0;
+    return 0;
 fail:
-    if (filename != s->filename)
-        av_freep(&filename);
+    av_freep(&ctx->temp_filename);
     if (rc)
         RTMP_Close(r);
 
diff --git a/mythtv/external/FFmpeg/libavformat/mp3enc.c b/mythtv/external/FFmpeg/libavformat/mp3enc.c
index 9c9bd5e..a4de004 100644
--- a/mythtv/external/FFmpeg/libavformat/mp3enc.c
+++ b/mythtv/external/FFmpeg/libavformat/mp3enc.c
@@ -262,19 +262,19 @@ static int mp3_write_audio_packet(AVFormatContext *s, AVPacket *pkt)
     if (pkt->data && pkt->size >= 4) {
         MPADecodeHeader mpah;
         int av_unused base;
-        uint32_t head = AV_RB32(pkt->data);
-
-        if (ff_mpa_check_header(head) < 0) {
+        uint32_t h;
+
+        h = AV_RB32(pkt->data);
+        if (ff_mpa_check_header(h) == 0) {
+            avpriv_mpegaudio_decode_header(&mpah, h);
+            if (!mp3->initial_bitrate)
+                mp3->initial_bitrate = mpah.bit_rate;
+            if ((mpah.bit_rate == 0) || (mp3->initial_bitrate != mpah.bit_rate))
+                mp3->has_variable_bitrate = 1;
+        } else {
             av_log(s, AV_LOG_WARNING, "Audio packet of size %d (starting with %08X...) "
-                   "is invalid, writing it anyway.\n", pkt->size, head);
-            return ff_raw_write_packet(s, pkt);
+                   "is invalid, writing it anyway.\n", pkt->size, h);
         }
-        avpriv_mpegaudio_decode_header(&mpah, head);
-
-        if (!mp3->initial_bitrate)
-            mp3->initial_bitrate = mpah.bit_rate;
-        if ((mpah.bit_rate == 0) || (mp3->initial_bitrate != mpah.bit_rate))
-            mp3->has_variable_bitrate = 1;
 
 #ifdef FILTER_VBR_HEADERS
         /* filter out XING and INFO headers. */
diff --git a/mythtv/external/FFmpeg/libavformat/tee.c b/mythtv/external/FFmpeg/libavformat/tee.c
index 12ea0ea..90c9759 100644
--- a/mythtv/external/FFmpeg/libavformat/tee.c
+++ b/mythtv/external/FFmpeg/libavformat/tee.c
@@ -468,7 +468,7 @@ static int tee_write_packet(AVFormatContext *avf, AVPacket *pkt)
         if ((ret = av_copy_packet(&pkt2, pkt)) < 0 ||
             (ret = av_dup_packet(&pkt2))< 0)
             if (!ret_all) {
-                ret = ret_all;
+                ret_all = ret;
                 continue;
             }
         tb  = avf ->streams[s ]->time_base;
diff --git a/mythtv/external/FFmpeg/libavformat/utils.c b/mythtv/external/FFmpeg/libavformat/utils.c
index badd180..d7d2f0a 100644
--- a/mythtv/external/FFmpeg/libavformat/utils.c
+++ b/mythtv/external/FFmpeg/libavformat/utils.c
@@ -117,6 +117,11 @@ MAKE_ACCESSORS(AVFormatContext, format, int, metadata_header_padding)
 MAKE_ACCESSORS(AVFormatContext, format, void *, opaque)
 MAKE_ACCESSORS(AVFormatContext, format, av_format_control_message, control_message_cb)
 
+struct AVCodecParserContext *av_stream_get_parser(const AVStream *st)
+{
+    return st->parser;
+}
+
 static AVCodec *find_decoder(AVFormatContext *s, AVStream *st, enum AVCodecID codec_id)
 {
     if (st->codec->codec)
@@ -1637,7 +1642,8 @@ int av_read_frame(AVFormatContext *s, AVPacket *pkt)
             }
 
             /* read packet from packet buffer, if there is data */
-            if (!(next_pkt->pts == AV_NOPTS_VALUE &&
+            st = s->streams[next_pkt->stream_index];
+            if (!(next_pkt->pts == AV_NOPTS_VALUE && st->discard < AVDISCARD_ALL &&
                   next_pkt->dts != AV_NOPTS_VALUE && !eof)) {
                 ret = read_from_packet_buffer(&s->packet_buffer,
                                                &s->packet_buffer_end, pkt);
diff --git a/mythtv/external/FFmpeg/libavutil/lzo.c b/mythtv/external/FFmpeg/libavutil/lzo.c
index 6104fc3..6a24a1d 100644
--- a/mythtv/external/FFmpeg/libavutil/lzo.c
+++ b/mythtv/external/FFmpeg/libavutil/lzo.c
@@ -110,7 +110,7 @@ static inline void copy(LZOContext *c, int cnt)
 /**
  * @brief Copies previously decoded bytes to current position.
  * @param back how many bytes back we start, must be > 0
- * @param cnt number of bytes to copy, must be >= 0
+ * @param cnt number of bytes to copy, must be > 0
  *
  * cnt > back is valid, this will copy the bytes we just copied,
  * thus creating a repeating pattern with a period length of back.
diff --git a/mythtv/external/FFmpeg/libswscale/x86/scale.asm b/mythtv/external/FFmpeg/libswscale/x86/scale.asm
index 940f357..7af92f7 100644
--- a/mythtv/external/FFmpeg/libswscale/x86/scale.asm
+++ b/mythtv/external/FFmpeg/libswscale/x86/scale.asm
@@ -424,7 +424,7 @@ INIT_MMX mmx
 SCALE_FUNCS2 0, 0, 0
 %endif
 INIT_XMM sse2
-SCALE_FUNCS2 6, 7, 8
+SCALE_FUNCS2 7, 6, 8
 INIT_XMM ssse3
 SCALE_FUNCS2 6, 6, 8
 INIT_XMM sse4
diff --git a/mythtv/external/FFmpeg/tests/fate/fft.mak b/mythtv/external/FFmpeg/tests/fate/fft.mak
index 1f3a262..9fdca2b 100644
--- a/mythtv/external/FFmpeg/tests/fate/fft.mak
+++ b/mythtv/external/FFmpeg/tests/fate/fft.mak
@@ -1,8 +1,8 @@
 define DEF_FFT
-FATE_FFT += fate-fft-$(1)   fate-ifft-$(1)   \
-            fate-mdct-$(1)  fate-imdct-$(1)  \
-            fate-rdft-$(1)  fate-irdft-$(1)  \
-            fate-dct1d-$(1) fate-idct1d-$(1)
+FATE_FFT-$(CONFIG_DCT)  += fate-dct1d-$(1) fate-idct1d-$(1)
+FATE_FFT-$(CONFIG_FFT)  += fate-fft-$(1)   fate-ifft-$(1)
+FATE_FFT-$(CONFIG_MDCT) += fate-mdct-$(1)  fate-imdct-$(1)
+FATE_FFT-$(CONFIG_RDFT) += fate-rdft-$(1)  fate-irdft-$(1)
 
 fate-fft-$(N):    ARGS = -n$(1)
 fate-ifft-$(N):   ARGS = -n$(1) -i
@@ -16,14 +16,14 @@ endef
 
 $(foreach N, 4 5 6 7 8 9 10 11 12, $(eval $(call DEF_FFT,$(N))))
 
-fate-fft-test: $(FATE_FFT)
-$(FATE_FFT): libavcodec/fft-test$(EXESUF)
-$(FATE_FFT): CMD = run libavcodec/fft-test $(CPUFLAGS:%=-c%) $(ARGS)
-$(FATE_FFT): REF = /dev/null
+fate-fft-float: $(FATE_FFT-yes)
+$(FATE_FFT-yes): libavcodec/fft-test$(EXESUF)
+$(FATE_FFT-yes): CMD = run libavcodec/fft-test $(CPUFLAGS:%=-c%) $(ARGS)
+$(FATE_FFT-yes): REF = /dev/null
 
 define DEF_FFT_FIXED
-FATE_FFT_FIXED += fate-fft-fixed-$(1)   fate-ifft-fixed-$(1)  \
-                  fate-mdct-fixed-$(1) fate-imdct-fixed-$(1)
+FATE_FFT_FIXED-$(CONFIG_FFT)  += fate-fft-fixed-$(1)  fate-ifft-fixed-$(1)
+FATE_FFT_FIXED-$(CONFIG_MDCT) += fate-mdct-fixed-$(1) fate-imdct-fixed-$(1)
 
 fate-fft-fixed-$(1):   ARGS = -n$(1)
 fate-ifft-fixed-$(1):  ARGS = -n$(1) -i
@@ -33,10 +33,10 @@ endef
 
 $(foreach N, 4 5 6 7 8 9 10 11 12, $(eval $(call DEF_FFT_FIXED,$(N))))
 
-fate-fft-fixed-test: $(FATE_FFT_FIXED)
-$(FATE_FFT_FIXED): libavcodec/fft-fixed-test$(EXESUF)
-$(FATE_FFT_FIXED): CMD = run libavcodec/fft-fixed-test $(CPUFLAGS:%=-c%) $(ARGS)
-$(FATE_FFT_FIXED): REF = /dev/null
+fate-fft-fixed: $(FATE_FFT_FIXED-yes)
+$(FATE_FFT_FIXED-yes): libavcodec/fft-fixed-test$(EXESUF)
+$(FATE_FFT_FIXED-yes): CMD = run libavcodec/fft-fixed-test $(CPUFLAGS:%=-c%) $(ARGS)
+$(FATE_FFT_FIXED-yes): REF = /dev/null
 
 define DEF_FFT_FIXED32
 FATE_FFT_FIXED32 += fate-fft-fixed32-$(1)   fate-ifft-fixed32-$(1)  \
@@ -55,5 +55,5 @@ $(FATE_FFT_FIXED32): libavcodec/fft-fixed32-test$(EXESUF)
 $(FATE_FFT_FIXED32): CMD = run libavcodec/fft-fixed32-test $(CPUFLAGS:%=-c%) $(ARGS)
 $(FATE_FFT_FIXED32): REF = /dev/null
 
-FATE-$(call ALLYES, AVCODEC FFT MDCT) += $(FATE_FFT) $(FATE_FFT_FIXED) $(FATE_FFT_FIXED32)
-fate-fft: $(FATE_FFT) $(FATE_FFT_FIXED) $(FATE_FFT_FIXED32)
+FATE-$(call ALLYES, AVCODEC FFT MDCT) += $(FATE_FFT-yes) $(FATE_FFT_FIXED-yes) $(FATE_FFT_FIXED32)
+fate-fft: $(FATE_FFT-yes) $(FATE_FFT_FIXED-yes) $(FATE_FFT_FIXED32)
diff --git a/mythtv/external/FFmpeg/version.sh b/mythtv/external/FFmpeg/version.sh
index 92edcb9..f9754eb 100755
--- a/mythtv/external/FFmpeg/version.sh
+++ b/mythtv/external/FFmpeg/version.sh
@@ -4,7 +4,11 @@
 
 # check for git short hash
 if ! test "$revision"; then
-    revision=$(cd "$1" && git describe --tags --match N 2> /dev/null)
+    if (cd "$1" && grep git RELEASE 2> /dev/null >/dev/null) ; then
+        revision=$(cd "$1" && git describe --tags --match N 2> /dev/null)
+    else
+        revision=$(cd "$1" && git describe --tags --always 2> /dev/null)
+    fi
 fi
 
 # Shallow Git clones (--depth) do not have the N tag:
-- 
1.7.10.2

