From b4d6129553e559f88fc923eb4449a1c3d381d606 Mon Sep 17 00:00:00 2001
From: Jean-Yves Avenard <jyavenard@mythtv.org>
Date: Thu, 11 Sep 2014 23:32:34 +1000
Subject: [PATCH 4/4] Playback: digital passthrough changes.

We use to always decode stereo so enabling upmixing on the fly was possible.

Change in behaviors and capabilities
* Now will bitstream even stereo signal.
* allows to upmix digital stereo and revert back to bitstreaming once disabled once again
---
 mythtv/libs/libmyth/audio/audiooutputbase.cpp |   11 +++++-----
 mythtv/libs/libmythtv/avformatdecoder.cpp     |   15 +++++++-------
 mythtv/libs/libmythtv/avformatdecoder.h       |    1 +
 mythtv/libs/libmythtv/decoderbase.h           |    2 ++
 mythtv/libs/libmythtv/mythplayer.cpp          |   27 +++++++++++++++++++++----
 mythtv/libs/libmythtv/mythplayer.h            |    3 +++
 mythtv/libs/libmythtv/tv_play.cpp             |    2 ++
 7 files changed, 45 insertions(+), 16 deletions(-)

diff --git a/mythtv/libs/libmyth/audio/audiooutputbase.cpp b/mythtv/libs/libmyth/audio/audiooutputbase.cpp
index c8b0719..833dff6 100644
--- a/mythtv/libs/libmyth/audio/audiooutputbase.cpp
+++ b/mythtv/libs/libmyth/audio/audiooutputbase.cpp
@@ -297,8 +297,8 @@ bool AudioOutputBase::CanPassthrough(int samplerate, int channels,
         return false;
     // Will passthrough if surround audio was defined. Amplifier will
     // do the downmix if required
-    ret &= max_channels >= 6 && channels > 2;
-    // Stereo content will always be decoded so it can later be upmixed
+    bool willupmix = max_channels >= 6 && (channels <= 2 && upmix_default);
+    ret &= !willupmix;
     // unless audio is configured for stereo. We can passthrough otherwise
     ret |= max_channels == 2;
 
@@ -414,13 +414,14 @@ bool AudioOutputBase::IsUpmixing(void)
 bool AudioOutputBase::ToggleUpmix(void)
 {
     // Can only upmix from mono/stereo to 6 ch
-    if (max_channels == 2 || source_channels > 2 || passthru)
+    if (max_channels == 2 || source_channels > 2)
         return false;
 
     upmix_default = !upmix_default;
 
     const AudioSettings settings(format, source_channels, codec,
-                                 source_samplerate, passthru);
+                                 source_samplerate,
+                                 upmix_default ? false : passthru);
     Reconfigure(settings);
     return IsUpmixing();
 }
@@ -430,7 +431,7 @@ bool AudioOutputBase::ToggleUpmix(void)
  */
 bool AudioOutputBase::CanUpmix(void)
 {
-    return !passthru && source_channels <= 2 && max_channels > 2;
+    return source_channels <= 2 && max_channels > 2;
 }
 
 /*
diff --git a/mythtv/libs/libmythtv/avformatdecoder.cpp b/mythtv/libs/libmythtv/avformatdecoder.cpp
index d6701ee..91b0863 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.cpp
+++ b/mythtv/libs/libmythtv/avformatdecoder.cpp
@@ -5136,11 +5136,6 @@ void *AvFormatDecoder::GetVideoCodecPrivate(void)
 
 void AvFormatDecoder::SetDisablePassThrough(bool disable)
 {
-    // can only disable never re-enable as once
-    // timestretch is on its on for the session
-    if (disable_passthru)
-        return;
-
     if (selectedTrack[kTrackTypeAudio].av_stream_index < 0)
     {
         disable_passthru = disable;
@@ -5154,11 +5149,17 @@ void AvFormatDecoder::SetDisablePassThrough(bool disable)
         LOG(VB_AUDIO, LOG_INFO, LOC + msg + " pass through");
 
         // Force pass through state to be reanalyzed
-        QMutexLocker locker(avcodeclock);
-        SetupAudioStream();
+        ForceSetupAudioStream();
     }
 }
 
+void AvFormatDecoder::ForceSetupAudioStream(void)
+{
+    QMutexLocker locker(avcodeclock);
+
+    SetupAudioStream();
+}
+
 inline bool AvFormatDecoder::DecoderWillDownmix(const AVCodecContext *ctx)
 {
     // Until ffmpeg properly implements dialnorm
diff --git a/mythtv/libs/libmythtv/avformatdecoder.h b/mythtv/libs/libmythtv/avformatdecoder.h
index 9d8adf8..d434f14 100644
--- a/mythtv/libs/libmythtv/avformatdecoder.h
+++ b/mythtv/libs/libmythtv/avformatdecoder.h
@@ -147,6 +147,7 @@ class AvFormatDecoder : public DecoderBase
     void        *GetVideoCodecPrivate(void);
 
     virtual void SetDisablePassThrough(bool disable);
+    virtual void ForceSetupAudioStream(void);
     void AddTextData(unsigned char *buf, int len, int64_t timecode, char type);
 
     virtual QString GetTrackDesc(uint type, uint trackNo) const;
diff --git a/mythtv/libs/libmythtv/decoderbase.h b/mythtv/libs/libmythtv/decoderbase.h
index abe2799..9b8051f 100644
--- a/mythtv/libs/libmythtv/decoderbase.h
+++ b/mythtv/libs/libmythtv/decoderbase.h
@@ -150,6 +150,8 @@ class DecoderBase
     virtual void SetLowBuffers(bool low) { lowbuffers = low; }
     /// Disables AC3/DTS pass through
     virtual void SetDisablePassThrough(bool disable) { (void)disable; }
+    // Reconfigure audio as necessary, following configuration change
+    virtual void ForceSetupAudioStream(void) { }
 
     virtual void SetWatchingRecording(bool mode);
     /// Demux, preprocess and possibly decode a frame of video/audio.
diff --git a/mythtv/libs/libmythtv/mythplayer.cpp b/mythtv/libs/libmythtv/mythplayer.cpp
index 203c6c0..2cfc903 100644
--- a/mythtv/libs/libmythtv/mythplayer.cpp
+++ b/mythtv/libs/libmythtv/mythplayer.cpp
@@ -228,7 +228,8 @@ MythPlayer::MythPlayer(PlayerFlags flags)
       // LiveTVChain stuff
       m_tv(NULL),                   isDummy(false),
       // Debugging variables
-      output_jmeter(new Jitterometer(LOC))
+      output_jmeter(new Jitterometer(LOC)),
+      disable_passthrough(false)
 {
     memset(&tc_lastval, 0, sizeof(tc_lastval));
     memset(&tc_wrap,    0, sizeof(tc_wrap));
@@ -5376,6 +5377,8 @@ void MythPlayer::SetDecoder(DecoderBase *dec)
         }
         decoder_change_lock.unlock();
     }
+    // reset passthrough override
+    disable_passthrough = false;
     syncWithAudioStretch();
     totalDecoderPause = false;
 }
@@ -5588,16 +5591,32 @@ void MythPlayer::syncWithAudioStretch()
     if (decoder && audio.HasAudioOut())
     {
         float stretch = audio.GetStretchFactor();
-        bool disable = (stretch < 0.99f) || (stretch > 1.01f);
+        disable_passthrough |= (stretch < 0.99f) || (stretch > 1.01f);
         LOG(VB_PLAYBACK, LOG_INFO, LOC +
             QString("Stretch Factor %1, %2 passthru ")
             .arg(audio.GetStretchFactor())
-            .arg((disable) ? "disable" : "allow"));
-        decoder->SetDisablePassThrough(disable);
+            .arg((disable_passthrough) ? "disable" : "allow"));
+        SetDisablePassThrough(disable_passthrough);
     }
     return;
 }
 
+void MythPlayer::SetDisablePassThrough(bool disabled)
+{
+    if (decoder && audio.HasAudioOut())
+    {
+        decoder->SetDisablePassThrough(disable_passthrough || disabled);
+    }
+}
+
+void MythPlayer::ForceSetupAudioStream(void)
+{
+    if (decoder && audio.HasAudioOut())
+    {
+        decoder->ForceSetupAudioStream();
+    }
+}
+
 static unsigned dbg_ident(const MythPlayer *player)
 {
     static QMutex   dbg_lock;
diff --git a/mythtv/libs/libmythtv/mythplayer.h b/mythtv/libs/libmythtv/mythplayer.h
index 56e4624..a4f4a75 100644
--- a/mythtv/libs/libmythtv/mythplayer.h
+++ b/mythtv/libs/libmythtv/mythplayer.h
@@ -270,6 +270,8 @@ class MTV_PUBLIC MythPlayer
     DecoderBase *GetDecoder(void) { return decoder; }
     void *GetDecoderContext(unsigned char* buf, uint8_t*& id);
     virtual bool HasReachedEof(void) const;
+    void SetDisablePassThrough(bool disabled);
+    void ForceSetupAudioStream(void);
 
     // Preview Image stuff
     void SaveScreenshot(void);
@@ -832,6 +834,7 @@ class MTV_PUBLIC MythPlayer
 
   private:
     void syncWithAudioStretch();
+    bool disable_passthrough;
 };
 
 #endif
diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index 9bed2ad..2a0c7b8 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -8920,6 +8920,8 @@ void TV::EnableUpmix(PlayerContext *ctx, bool enable, bool toggle)
         enabled = ctx->player->GetAudio()->EnableUpmix(false, true);
     else
         enabled = ctx->player->GetAudio()->EnableUpmix(enable);
+    // May have to disable digital passthrough
+    ctx->player->ForceSetupAudioStream();
     ctx->UnlockDeletePlayer(__FILE__, __LINE__);
 
     if (!browsehelper->IsBrowsing())
-- 
1.7.10.2

