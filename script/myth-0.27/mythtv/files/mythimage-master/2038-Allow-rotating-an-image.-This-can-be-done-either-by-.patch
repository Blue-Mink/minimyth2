From b3d33e62862eb38fa2b05b338c9f39b97bbb4e2c Mon Sep 17 00:00:00 2001
From: Robert Siebert <rsiebert@miroku.no-ip.com>
Date: Fri, 15 Mar 2013 10:54:38 +0100
Subject: [PATCH 038/760] Allow rotating an image. This can be done either by
 either calling Rotate(angle) or by the rotate tag
 and its attribute angle in the theme. The angle
 value should be multiple of 90 degrees.

Signed-off-by: Stuart Morgan <smorgan@mythtv.org>
---
 mythtv/libs/libmythbase/mythversion.h |    2 +-
 mythtv/libs/libmythui/mythimage.cpp   |   19 ++++++++++++++++
 mythtv/libs/libmythui/mythimage.h     |    4 ++++
 mythtv/libs/libmythui/mythuiimage.cpp |   40 +++++++++++++++++++++++++++++++++
 mythtv/libs/libmythui/mythuiimage.h   |    4 ++++
 5 files changed, 68 insertions(+), 1 deletion(-)

diff --git a/mythtv/libs/libmythui/mythimage.cpp b/mythtv/libs/libmythui/mythimage.cpp
index d22aed7..cb81752 100644
--- a/mythtv/libs/libmythui/mythimage.cpp
+++ b/mythtv/libs/libmythui/mythimage.cpp
@@ -41,6 +41,7 @@ MythImage::MythImage(MythPainter *parent, const char *name) :
     m_gradAlpha = 255;
     m_gradDirection = FillTopToBottom;
 
+    m_isRotated = false;
     m_isReflected = false;
     m_isYUV = false;
 
@@ -112,6 +113,24 @@ void MythImage::Assign(const QPixmap &pix)
     Assign(pix.toImage());
 }
 
+void MythImage::Rotate(int rotationAngle, QSize size)
+{
+    if (m_isRotated)
+        return;
+
+    QMatrix matrix;
+    matrix.rotate(rotationAngle);
+    Assign(transformed(matrix, Qt::SmoothTransformation));
+
+    // TODO: The rotated image is higher than the parent area
+    // the image needs to be resized to be with the areas dimensions
+    if (!size.isNull())
+    {
+        Resize(size, true);
+    }
+    m_isRotated = true;
+}
+
 void MythImage::Resize(const QSize &newSize, bool preserveAspect)
 {
     if ((size() == newSize) && !isNull())
diff --git a/mythtv/libs/libmythui/mythimage.h b/mythtv/libs/libmythui/mythimage.h
index 266d14b..92719e8 100644
--- a/mythtv/libs/libmythui/mythimage.h
+++ b/mythtv/libs/libmythui/mythimage.h
@@ -45,6 +45,7 @@ class MUI_PUBLIC MythImage : public QImage, public ReferenceCounter
 
     bool IsGradient() const { return m_isGradient; }
     bool IsReflected() const { return m_isReflected; }
+    bool IsRotated() const { return m_isRotated; }
 
     void SetToYUV(void) { m_isYUV = true; }
     void ConvertToYUV(void);
@@ -55,6 +56,7 @@ class MUI_PUBLIC MythImage : public QImage, public ReferenceCounter
     bool Load(MythImageReader *reader);
     bool Load(const QString &filename, bool scale = true);
 
+    void Rotate(int rotationAngle, QSize size);
     void Resize(const QSize &newSize, bool preserveAspect = false);
     void Reflect(ReflectAxis axis, int shear, int scale, int length,
                  int spacing = 0);
@@ -79,6 +81,7 @@ class MUI_PUBLIC MythImage : public QImage, public ReferenceCounter
     QString GetFileName(void) const { return m_FileName; }
 
     void setIsReflected(bool reflected) { m_isReflected = reflected; }
+    void setIsRotated(bool rotated) { m_isRotated = rotated; }
 
     void SetIsInCache(bool bCached);
 
@@ -103,6 +106,7 @@ class MUI_PUBLIC MythImage : public QImage, public ReferenceCounter
     int m_gradAlpha;
     FillDirection m_gradDirection;
 
+    bool m_isRotated;
     bool m_isReflected;
     bool m_isYUV;
 
diff --git a/mythtv/libs/libmythui/mythuiimage.cpp b/mythtv/libs/libmythui/mythuiimage.cpp
index c2e1e87..8b83edd 100644
--- a/mythtv/libs/libmythui/mythuiimage.cpp
+++ b/mythtv/libs/libmythui/mythuiimage.cpp
@@ -65,6 +65,7 @@ void ImageProperties::Init()
     preserveAspect = false;
     isGreyscale = false;
     isReflected = false;
+    isRotated = false;
     isMasked = false;
     reflectAxis = ReflectVertical;
     reflectScale = 100;
@@ -85,6 +86,7 @@ void ImageProperties::Copy(const ImageProperties &other)
     preserveAspect = other.preserveAspect;
     isGreyscale = other.isGreyscale;
     isReflected = other.isReflected;
+    isRotated = other.isRotated;
     isMasked = other.isMasked;
 
     reflectAxis = other.reflectAxis;
@@ -182,6 +184,12 @@ class ImageLoader
         if (imProps.isReflected)
             s_Attrib += "reflected";
 
+        if (imProps.isRotated)
+        {
+            s_Attrib += "rotated";
+            s_Attrib += QString("%1").arg(imProps.rotationAngle);
+        }
+
         if (imProps.isGreyscale)
             s_Attrib += "greyscale";
 
@@ -266,6 +274,9 @@ class ImageLoader
             if (imProps.isReflected)
                 image->setIsReflected(true);
 
+            if (imProps.isRotated)
+                image->setIsRotated(true);
+
             bFoundInCache = true;
         }
         else
@@ -331,6 +342,9 @@ class ImageLoader
                                imProps.reflectScale, imProps.reflectLength,
                                imProps.reflectSpacing);
 
+            if (imProps.isRotated)
+                image->Rotate(imProps.rotationAngle, imProps.forceSize);
+
             if (imProps.isGreyscale)
                 image->ToGreyscale();
 
@@ -757,6 +771,11 @@ void MythUIImage::SetImage(MythImage *img)
                      m_imageProperties.reflectLength,
                      m_imageProperties.reflectSpacing);
 
+    if (m_imageProperties.isRotated && !img->IsRotated() &&
+        m_imageProperties.rotationAngle != 0)
+        img->Rotate(m_imageProperties.rotationAngle,
+                    m_imageProperties.forceSize);
+
     if (m_imageProperties.isGreyscale && !img->isGrayscale())
         img->ToGreyscale();
 
@@ -821,6 +840,11 @@ void MythUIImage::SetImages(QVector<MythImage *> *images)
                         m_imageProperties.reflectLength,
                         m_imageProperties.reflectSpacing);
 
+        if (m_imageProperties.isRotated && !im->IsRotated() &&
+            m_imageProperties.rotationAngle != 0)
+            im->Rotate(m_imageProperties.rotationAngle,
+                       m_imageProperties.forceSize);
+
         if (m_imageProperties.isGreyscale && !im->isGrayscale())
             im->ToGreyscale();
 
@@ -892,6 +916,15 @@ void MythUIImage::ForceSize(const QSize &size)
 }
 
 /**
+ *  \brief Rotates the first image in the widget
+ */
+void MythUIImage::SetRotation(int rotationAngle)
+{
+    m_imageProperties.isRotated = true;
+    m_imageProperties.rotationAngle = rotationAngle;
+}
+
+/**
  *  \brief Set the size of the widget
  */
 void MythUIImage::SetSize(int width, int height)
@@ -1384,6 +1417,13 @@ bool MythUIImage::ParseElement(
     {
         m_imageProperties.isGreyscale = parseBool(element);
     }
+    else if (element.tagName() == "rotate")
+    {
+        m_imageProperties.isRotated = true;
+        QString tmp = element.attribute("angle");
+        if (!tmp.isEmpty())
+            m_imageProperties.rotationAngle = tmp.toInt();
+    }
     else
     {
         return MythUIType::ParseElement(filename, element, showWarnings);
diff --git a/mythtv/libs/libmythui/mythuiimage.h b/mythtv/libs/libmythui/mythuiimage.h
index 90901d3..27bacde 100644
--- a/mythtv/libs/libmythui/mythuiimage.h
+++ b/mythtv/libs/libmythui/mythuiimage.h
@@ -56,12 +56,14 @@ class ImageProperties
     bool isGreyscale;
     bool isReflected;
     bool isMasked;
+    bool isRotated;
 
     ReflectAxis reflectAxis;
     int reflectScale;
     int reflectLength;
     int reflectShear;
     int reflectSpacing;
+    int rotationAngle;
 
   private:
     void Init(void);
@@ -119,6 +121,8 @@ class MUI_PUBLIC MythUIImage : public MythUIType
 
     virtual void LoadNow(void);
 
+    void SetRotation(int rotationAngle);
+
   protected:
     virtual void DrawSelf(MythPainter *p, int xoffset, int yoffset,
                           int alphaMod, QRect clipRect);
-- 
1.7.10.2

