diff -Naur mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythimage.cpp mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythimage.cpp
--- mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythimage.cpp	2014-03-05 12:36:43.000000000 +0100
+++ mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythimage.cpp	2014-03-05 12:40:08.674313977 +0100
@@ -41,6 +41,7 @@
     m_gradAlpha = 255;
     m_gradDirection = FillTopToBottom;
 
+    m_isOriented = false;
     m_isReflected = false;
     m_isYUV = false;
 
@@ -112,6 +113,65 @@
     Assign(pix.toImage());
 }
 
+/**
+ * Changes the orientation angle of the image according to
+ * the exif rotation values. The image will be rotated accordingly.
+ * @brief MythImage::Orientation
+ * @param orientation
+ */
+void MythImage::Orientation(int orientation)
+{
+    if (m_isOriented)
+        return;
+
+    QMatrix matrix;
+    switch (orientation)
+    {
+    case 1: // If the image is in its original state
+        break;
+
+    case 2: // The image is horizontally flipped
+        Assign(mirrored(true, false));
+        break;
+
+    case 3: // The image is rotated 180°
+        matrix.rotate(180);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        break;
+
+    case 4: // The image is vertically flipped
+        Assign(mirrored(false, true));
+        break;
+
+    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
+        matrix.rotate(90);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        Assign(mirrored(true, false));
+        break;
+
+    case 6: // The image is rotated 90° CCW
+        matrix.rotate(270);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        break;
+
+    case 7: // The image is transversed  (rotated 90° CW and flipped vertically)
+        matrix.rotate(90);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        Assign(mirrored(false, true));
+        break;
+
+    case 8: // The image is rotated 90° CW
+        matrix.rotate(90);
+        Assign(transformed(matrix, Qt::SmoothTransformation));
+        break;
+
+    default:
+        break;
+    }
+
+    m_isOriented = true;
+}
+
 void MythImage::Resize(const QSize &newSize, bool preserveAspect)
 {
     if ((size() == newSize) && !isNull())
diff -Naur mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythimage.h mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythimage.h
--- mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythimage.h	2014-03-05 12:36:43.000000000 +0100
+++ mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythimage.h	2014-03-05 12:40:08.674313977 +0100
@@ -45,6 +45,7 @@
 
     bool IsGradient() const { return m_isGradient; }
     bool IsReflected() const { return m_isReflected; }
+    bool IsOriented() const { return m_isOriented; }
 
     void SetToYUV(void) { m_isYUV = true; }
     void ConvertToYUV(void);
@@ -55,6 +56,7 @@
     bool Load(MythImageReader *reader);
     bool Load(const QString &filename);
 
+    void Orientation(int orientation);
     void Resize(const QSize &newSize, bool preserveAspect = false);
     void Reflect(ReflectAxis axis, int shear, int scale, int length,
                  int spacing = 0);
@@ -79,6 +81,7 @@
     QString GetFileName(void) const { return m_FileName; }
 
     void setIsReflected(bool reflected) { m_isReflected = reflected; }
+    void setIsOriented(bool oriented) { m_isOriented = oriented; }
 
     void SetIsInCache(bool bCached);
 
@@ -103,6 +106,7 @@
     int m_gradAlpha;
     FillDirection m_gradDirection;
 
+    bool m_isOriented;
     bool m_isReflected;
     bool m_isYUV;
 
diff -Naur mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythuiimage.cpp mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythuiimage.cpp
--- mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythuiimage.cpp	2014-03-05 12:36:43.000000000 +0100
+++ mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythuiimage.cpp	2014-03-05 12:41:57.109108845 +0100
@@ -66,11 +66,13 @@
     isGreyscale = false;
     isReflected = false;
     isMasked = false;
+    isOriented = false;
     reflectAxis = ReflectVertical;
     reflectScale = 100;
     reflectLength = 100;
     reflectShear = 0;
-    reflectSpacing = 0,
+    reflectSpacing = 0;
+    orientation = 1;
     isThemeImage = false;
     maskImage = NULL;
 }
@@ -87,12 +89,14 @@
     isGreyscale = other.isGreyscale;
     isReflected = other.isReflected;
     isMasked = other.isMasked;
+    isOriented = other.isOriented;
 
     reflectAxis = other.reflectAxis;
     reflectScale = other.reflectScale;
     reflectLength = other.reflectLength;
     reflectShear = other.reflectShear;
     reflectSpacing = other.reflectSpacing;
+    orientation = other.orientation;
 
     isThemeImage = other.isThemeImage;
 
@@ -188,6 +192,12 @@
         if (imProps.isGreyscale)
             s_Attrib += "greyscale";
 
+        if (imProps.isOriented)
+        {
+            s_Attrib += "orientation";
+            s_Attrib += QString("%1").arg(imProps.orientation);
+        }
+
         int w = -1;
         int h = -1;
         if (!imProps.forceSize.isNull())
@@ -269,6 +279,9 @@
             if (imProps.isReflected)
                 image->setIsReflected(true);
 
+            if (imProps.isOriented)
+                image->setIsOriented(true);
+
             bFoundInCache = true;
         }
         else
@@ -353,6 +366,9 @@
             if (imProps.isGreyscale)
                 image->ToGreyscale();
 
+            if (imProps.isOriented)
+                image->Orientation(imProps.orientation);
+
             if (!imageReader)
                 GetMythUI()->CacheImage(cacheKey, image);
         }
@@ -786,6 +802,11 @@
     Clear();
     m_Delay = -1;
 
+    if (m_imageProperties.isOriented && !img->IsOriented() &&
+        (m_imageProperties.orientation >= 1 &&
+         m_imageProperties.orientation <= 8))
+        img->Orientation(m_imageProperties.orientation);
+
     if (m_imageProperties.forceSize.isNull())
         SetSize(img->size());
 
@@ -849,6 +870,11 @@
         if (m_imageProperties.isGreyscale && !im->isGrayscale())
             im->ToGreyscale();
 
+        if (m_imageProperties.isOriented && !im->IsOriented() &&
+            (m_imageProperties.orientation >= 1 &&
+             m_imageProperties.orientation <= 8))
+            im->Orientation(m_imageProperties.orientation);
+
         m_ImagesLock.lock();
         m_Images[m_Images.size()] = im;
         m_ImagesLock.unlock();
@@ -917,6 +943,15 @@
 }
 
 /**
+ *  \brief Saves the exif orientation value of the first image in the widget
+ */
+void MythUIImage::SetOrientation(int orientation)
+{
+    m_imageProperties.isOriented = true;
+    m_imageProperties.orientation = orientation;
+}
+
+/**
  *  \brief Set the size of the widget
  */
 void MythUIImage::SetSize(int width, int height)
diff -Naur mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythuiimage.h mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythuiimage.h
--- mythtv-0.27-20140303-gcb3b784-old/mythtv/libs/libmythui/mythuiimage.h	2014-03-05 12:36:43.000000000 +0100
+++ mythtv-0.27-20140303-gcb3b784-new/mythtv/libs/libmythui/mythuiimage.h	2014-03-05 12:40:08.677647157 +0100
@@ -56,6 +56,7 @@
     bool isGreyscale;
     bool isReflected;
     bool isMasked;
+    bool isOriented;
 
     ReflectAxis reflectAxis;
     int reflectScale;
@@ -65,6 +66,8 @@
 
     bool isThemeImage;
 
+    int orientation;
+
   private:
     void Init(void);
     void Copy(const ImageProperties &other);
@@ -121,6 +124,8 @@
 
     virtual void LoadNow(void);
 
+    void SetOrientation(int orientation);
+
   protected:
     virtual void DrawSelf(MythPainter *p, int xoffset, int yoffset,
                           int alphaMod, QRect clipRect);
