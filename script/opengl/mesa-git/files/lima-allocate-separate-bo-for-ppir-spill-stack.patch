From 290dad7d9d80fcd507480c2abe7fb1aaec1fd7cb Mon Sep 17 00:00:00 2001
From: Erico Nunes <nunes.erico@gmail.com>
Date: Wed, 7 Aug 2019 02:16:45 +0200
Subject: [PATCH] lima: allocate separate bo for ppir spill stack

The previous spill stack was fixed and too small, and caused instability
in programs requiring spilling for roughly more than one value.
This patch adds a dynamic calculation of the buffer size based on stack
utilization and switches it to a separate bo that can be resized to fit
the shader that requires the largest buffer.

Signed-off-by: Erico Nunes <nunes.erico@gmail.com>
---
 src/gallium/drivers/lima/lima_draw.c   | 51 +++++++++++++++++++++++---
 src/gallium/drivers/lima/lima_screen.c |  7 ++++
 src/gallium/drivers/lima/lima_screen.h | 14 ++++---
 3 files changed, 62 insertions(+), 10 deletions(-)

diff --git a/src/gallium/drivers/lima/lima_draw.c b/src/gallium/drivers/lima/lima_draw.c
index 87eeb0e795b..79296db78f1 100644
--- a/src/gallium/drivers/lima/lima_draw.c
+++ b/src/gallium/drivers/lima/lima_draw.c
@@ -1555,6 +1555,42 @@ lima_pack_pp_frame_reg(struct lima_context *ctx, uint32_t *frame_reg,
       lima_pack_wb_zsbuf_reg(ctx, wb_reg, wb_idx++);
 }
 
+static bool
+lima_update_pp_stack(struct lima_context *ctx)
+{
+   struct lima_screen *screen = lima_screen(ctx->base.screen);
+
+   if (ctx->fs == NULL || ctx->fs->stack_size == 0)
+      return true;
+
+   mtx_lock(&screen->pp_stack_lock);
+
+   unsigned int req_stack_size = ctx->fs->stack_size *
+      screen->num_pp * pp_stack_pp_size;
+
+   if (screen->pp_stack) {
+      if (screen->pp_stack->size >= req_stack_size) {
+         mtx_unlock(&screen->pp_stack_lock);
+         return true;
+      }
+      else
+         lima_bo_free(screen->pp_stack);
+   }
+
+   screen->pp_stack = lima_bo_create(screen, req_stack_size, 0);
+   if (!screen->pp_stack) {
+      fprintf(stderr, "lima: create fs shader stack fail\n");
+      mtx_unlock(&screen->pp_stack_lock);
+      return false;
+   }
+   lima_bo_map(screen->pp_stack);
+   lima_submit_add_bo(ctx->pp_submit, screen->pp_stack, LIMA_SUBMIT_BO_READ);
+   screen->pp_max_stack_size = ctx->fs->stack_size;
+
+   mtx_unlock(&screen->pp_stack_lock);
+   return true;
+}
+
 static void
 _lima_flush(struct lima_context *ctx, bool end_of_frame)
 {
@@ -1623,6 +1659,8 @@ _lima_flush(struct lima_context *ctx, bool end_of_frame)
       }
    }
 
+   lima_update_pp_stack(ctx);
+
    struct lima_pp_stream_state *ps = &ctx->pp_stream;
    if (screen->gpu_type == DRM_LIMA_PARAM_GPU_ID_MALI400) {
       struct drm_lima_m400_pp_frame pp_frame = {0};
@@ -1631,8 +1669,9 @@ _lima_flush(struct lima_context *ctx, bool end_of_frame)
 
       for (int i = 0; i < screen->num_pp; i++) {
          pp_frame.plbu_array_address[i] = ps->bo->va + ps->bo_offset + ps->offset[i];
-         pp_frame.fragment_stack_address[i] = screen->pp_buffer->va +
-            pp_stack_offset + pp_stack_pp_size * i;
+         if (screen->pp_stack)
+            pp_frame.fragment_stack_address[i] = screen->pp_stack->va +
+               screen->pp_max_stack_size * pp_stack_pp_size * i;
       }
 
       lima_dump_command_stream_print(
@@ -1646,9 +1685,11 @@ _lima_flush(struct lima_context *ctx, bool end_of_frame)
       lima_pack_pp_frame_reg(ctx, pp_frame.frame, pp_frame.wb);
       pp_frame.num_pp = screen->num_pp;
 
-      for (int i = 0; i < screen->num_pp; i++)
-         pp_frame.fragment_stack_address[i] = screen->pp_buffer->va +
-            pp_stack_offset + pp_stack_pp_size * i;
+      if (screen->pp_stack) {
+         for (int i = 0; i < screen->num_pp; i++)
+            pp_frame.fragment_stack_address[i] = screen->pp_stack->va +
+               screen->pp_max_stack_size * pp_stack_pp_size * i;
+      }
 
       if (ps->bo) {
          for (int i = 0; i < screen->num_pp; i++)
diff --git a/src/gallium/drivers/lima/lima_screen.c b/src/gallium/drivers/lima/lima_screen.c
index 13b5599c1a8..4dca69dba2e 100644
--- a/src/gallium/drivers/lima/lima_screen.c
+++ b/src/gallium/drivers/lima/lima_screen.c
@@ -63,6 +63,11 @@ lima_screen_destroy(struct pipe_screen *pscreen)
    if (screen->pp_buffer)
       lima_bo_free(screen->pp_buffer);
 
+   if (screen->pp_stack)
+      lima_bo_free(screen->pp_stack);
+
+   mtx_destroy(&screen->pp_stack_lock);
+
    lima_bo_table_fini(screen);
    ralloc_free(screen);
 }
@@ -568,6 +573,8 @@ lima_screen_create(int fd, struct renderonly *ro)
 
    screen->refcnt = 1;
 
+   mtx_init(&screen->pp_stack_lock, mtx_plain);
+
    return &screen->base;
 
 err_out2:
diff --git a/src/gallium/drivers/lima/lima_screen.h b/src/gallium/drivers/lima/lima_screen.h
index 29693168828..0488f831656 100644
--- a/src/gallium/drivers/lima/lima_screen.h
+++ b/src/gallium/drivers/lima/lima_screen.h
@@ -73,11 +73,15 @@ struct lima_screen {
    #define pp_reload_program_offset  0x0080
    #define pp_shared_index_offset    0x00c0
    #define pp_clear_gl_pos_offset    0x0100
-   #define pp_stack_offset           0x1000
-   #define pp_stack_pp_size           0x400 /* per pp, up to 8 pp */
-   #define pp_stack_offset_end       0x3000
-   #define pp_buffer_size            0x3000
-
+   #define pp_buffer_size            0x1000
+
+   /* pp stack */
+   mtx_t pp_stack_lock;
+   struct lima_bo *pp_stack;
+   /* This size is per pp and per item in the stack */
+   #define pp_stack_pp_size 0x400
+   /* Max number of elements in the current allocated stack */
+   int pp_max_stack_size;
 };
 
 static inline struct lima_screen *
-- 
2.21.0

