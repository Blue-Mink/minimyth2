From 89bc186d8a0db1578a8e273435b8bb6b38931868 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Mon, 20 Jun 2016 13:41:44 +0100
Subject: [PATCH 338/348] MythMusic: Add feature to delete a track or an
 entire album from storage

When in the playlist editor pressing the 'd' key prompts the user
to delete the selected track or all tracks from the selected album.

The function AllMusic::deleteTrack performs the work:

- Remove the selected track from in-memory structures.
- Remove the track from the mysql database
- Delete the associated file from storage and delete empty containing
  directory
- Remove unref'd entries from database tables: music_directories,
  music_albums & music_artists.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 .../mythmusic/mythmusic/playlistcontainer.cpp      |    9 ++
 .../mythmusic/mythmusic/playlistcontainer.h        |    2 +
 .../mythmusic/mythmusic/playlisteditorview.cpp     |   62 +++++++++
 .../mythmusic/mythmusic/playlisteditorview.h       |    1 +
 mythtv/libs/libmythmetadata/musicmetadata.cpp      |  131 ++++++++++++++++++++
 mythtv/libs/libmythmetadata/musicmetadata.h        |    2 +
 6 files changed, 207 insertions(+)

diff --git a/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp b/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp
index d310c5c..10c06b2 100644
--- a/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp
+++ b/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp
@@ -330,3 +330,12 @@ void PlaylistContainer::clearActive()
 {
     m_activePlaylist->removeAllTracks();
 }
+
+void PlaylistContainer::removeTrack(int id)
+{
+    QList<Playlist*>::iterator it = m_allPlaylists->begin();
+    for (; it != m_allPlaylists->end(); ++it)
+    {
+        (*it)->removeTrack(id);
+    }
+}
diff --git a/mythplugins/mythmusic/mythmusic/playlistcontainer.h b/mythplugins/mythmusic/mythmusic/playlistcontainer.h
index 7dd9b19..2f22422 100644
--- a/mythplugins/mythmusic/mythmusic/playlistcontainer.h
+++ b/mythplugins/mythmusic/mythmusic/playlistcontainer.h
@@ -68,6 +68,8 @@ class PlaylistContainer
     QList<Playlist*> *getPlaylists(void) { return m_allPlaylists; }
     QStringList       getPlaylistNames(void);
 
+    void            removeTrack(int index);
+
   private:
     Playlist            *m_activePlaylist;
     Playlist            *m_streamPlaylist;
diff --git a/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp b/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp
index 8652b77..fa0322d 100644
--- a/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp
+++ b/mythplugins/mythmusic/mythmusic/playlisteditorview.cpp
@@ -489,6 +489,24 @@ bool PlaylistEditorView::keyPressEvent(QKeyEvent *event)
                                     this, SLOT(deletePlaylist(bool)), true);
                         handled = true;
                     }
+                    else if (mnode->getAction() == "trackid")
+                    {
+                        QString name = mnode->GetText();
+
+                        ShowOkPopup(tr("Are you sure you want to delete this track?\n"
+                                       "Name: %1").arg(name),
+                                    this, SLOT(deleteNode(bool)), true);
+                        handled = true;
+                    }
+                    else if (mnode->getAction() == "album")
+                    {
+                        QString name = mnode->GetText();
+
+                        ShowOkPopup(tr("Are you sure you want to delete this album?\n"
+                                       "Name: %1").arg(name),
+                                    this, SLOT(deleteNode(bool)), true);
+                        handled = true;
+                    }
                 }
             }
         }
@@ -1777,3 +1795,47 @@ void PlaylistEditorView::deletePlaylist(bool ok)
         }
     }
 }
+
+void PlaylistEditorView::deleteNode(bool ok)
+{
+    if (!ok)
+        return;
+
+    MusicGenericTree *mnode = dynamic_cast<MusicGenericTree*> (
+                                    m_playlistTree->GetCurrentNode());
+    if (!mnode)
+        return;
+
+    if (mnode->getAction() == "trackid")
+    {
+        int id = mnode->getInt();
+
+        gPlayer->removeTrack(id);
+        gMusicData->all_music->deleteTrack(id);
+        gMusicData->all_playlists->removeTrack(id);
+
+        gPlayer->activePlaylistChanged(-1, true);
+        qApp->processEvents();
+
+        reloadTree();
+    }
+    else if (mnode->getAction() == "album")
+    {
+        MetadataPtrList *tracks = qVariantValue<MetadataPtrList*> (mnode->GetData());
+        for (int x = 0; x < tracks->count(); x++)
+        {
+            MusicMetadata *mdata = tracks->at(x);
+            if (mdata)
+            {
+                gPlayer->removeTrack(mdata->ID());
+                gMusicData->all_music->deleteTrack(mdata->ID());
+                gMusicData->all_playlists->removeTrack(mdata->ID());
+            }
+        }
+
+        gPlayer->activePlaylistChanged(-1, true);
+        qApp->processEvents();
+
+        reloadTree();
+    }
+}
diff --git a/mythplugins/mythmusic/mythmusic/playlisteditorview.h b/mythplugins/mythmusic/mythmusic/playlisteditorview.h
index 5eab838..2753750 100644
--- a/mythplugins/mythmusic/mythmusic/playlisteditorview.h
+++ b/mythplugins/mythmusic/mythmusic/playlisteditorview.h
@@ -84,6 +84,7 @@ class PlaylistEditorView : public MusicCommon
     void smartPLChanged(const QString &category, const QString &name);
     void deleteSmartPlaylist(bool ok);
     void deletePlaylist(bool ok);
+    void deleteNode(bool ok);
 
   private:
     void filterTracks(MusicGenericTree *node);
diff --git a/mythtv/libs/libmythmetadata/musicmetadata.cpp b/mythtv/libs/libmythmetadata/musicmetadata.cpp
index 117cbd2..09653f6 100644
--- a/mythtv/libs/libmythmetadata/musicmetadata.cpp
+++ b/mythtv/libs/libmythmetadata/musicmetadata.cpp
@@ -1723,6 +1723,137 @@ MusicMetadata* AllMusic::getCDMetadata(int the_track)
     return NULL;
 }
 
+void AllMusic::deleteTrack(int an_id)
+{
+    MusicMap::iterator i = music_map.find(an_id);
+    if (i == music_map.end())
+    {
+        LOG(VB_GENERAL, LOG_WARNING, QString(
+            "AllMusic::deleteTrack: no such ID: %1").arg(an_id));
+        return;
+    }
+
+    QScopedPointer<MusicMetadata> mdata(i.value());
+    music_map.erase(i);
+    if (!mdata)
+        return;
+
+    m_all_music.removeOne(mdata.data());
+
+    if (!mdata->isDBTrack())
+        return;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    query.prepare("DELETE FROM music_songs WHERE song_id = :ID");
+    query.bindValue(":ID", mdata->ID());
+    if (!query.exec())
+    {
+        MythDB::DBError("AllMusic::deleteTrack", query);
+        return;
+    }
+
+    // Delete the actual file
+    QString filename = mdata->Filename();
+    if (!RemoteFile::DeleteFile(filename))
+        LOG(VB_GENERAL, LOG_WARNING, QString(
+            "Delete track: failed to remove '%1'").arg(filename) );
+
+    StorageGroup storageGroup("Music", gCoreContext->GetHostName(), false);
+
+    // if no more refs to m_directoryid remove from music_directories
+    bool bFound = false;
+    QList<MusicMetadata*> ::iterator it;
+    for (it = m_all_music.begin(); !bFound && it != m_all_music.end(); ++it)
+        bFound = ((*it)->getDirectoryId() == mdata->getDirectoryId());
+    if (!bFound)
+    {
+        query.prepare("SELECT path, parent_id FROM music_directories"
+                      " WHERE directory_id = :ID");
+        query.bindValue(":ID", mdata->getDirectoryId());
+        if (!query.exec())
+            MythDB::DBError("AllMusic::deleteTrack2", query);
+        else if (!query.next())
+            LOG(VB_GENERAL, LOG_ERR, QString(
+                "Delete track: No such directory_id %1").arg(mdata->getDirectoryId()) );
+        else
+        {
+            QString path = query.value(0).toString();
+            //int parent_id = query.value(1).toInt();
+
+            // Remove any contained AlbumArt to permit directory removal
+            query.prepare("SELECT filename FROM music_albumart"
+                          " WHERE directory_id = :ID");
+            query.bindValue(":ID", mdata->getDirectoryId());
+            if (!query.exec())
+                MythDB::DBError("AllMusic::deleteTrack3", query);
+            else while (query.next())
+            {
+                filename = path + "/" + query.value(0).toString();
+                QString mythUrl = RemoteFile::FindFile(filename,
+                                    gCoreContext->GetHostName(), "Music");
+                if (mythUrl.isEmpty())
+                {
+                    LOG(VB_GENERAL, LOG_ERR, QString("Failed to find '%1'")
+                        .arg(filename) );
+                }
+                else if (!RemoteFile::DeleteFile(mythUrl))
+                {
+                    LOG(VB_GENERAL, LOG_ERR, QString("Failed to rm '%1'")
+                        .arg(filename) );
+                }
+            }
+
+            query.prepare("DELETE FROM music_albumart WHERE directory_id = :ID");
+            query.bindValue(":ID", mdata->getDirectoryId());
+            if (!query.exec())
+                MythDB::DBError("AllMusic::deleteTrack4", query);
+
+            // Remove the directory
+            QDir musicdir(storageGroup.FindFileDir(path));
+            if (!musicdir.rmdir(path))
+            {
+                // Not empty
+                LOG(VB_GENERAL, LOG_ERR, QString("Failed to rmdir '%1/%2'")
+                    .arg(musicdir.dirName()).arg(path) );
+            }
+            else
+            {
+                query.prepare("DELETE FROM music_directories WHERE directory_id = :ID");
+                query.bindValue(":ID", mdata->getDirectoryId());
+                if (!query.exec())
+                    MythDB::DBError("AllMusic::deleteTrack5", query);
+            }
+
+            // TODO remove empty parent directory
+        }
+    }
+
+    // if no more refs to album_id remove from music_albums
+    bFound = false;
+    for (it = m_all_music.begin(); !bFound && it != m_all_music.end(); ++it)
+        bFound = ((*it)->getAlbumId() == mdata->getAlbumId());
+    if (!bFound)
+    {
+        query.prepare("DELETE FROM music_albums WHERE album_id = :ID");
+        query.bindValue(":ID", mdata->getAlbumId());
+        if (!query.exec())
+            MythDB::DBError("AllMusic::deleteTrack6", query);
+    }
+
+    // if no more refs to artist_id remove from music_artists
+    bFound = false;
+    for (it = m_all_music.begin(); !bFound && it != m_all_music.end(); ++it)
+        bFound = ((*it)->getArtistId() == mdata->getArtistId());
+    if (!bFound)
+    {
+        query.prepare("DELETE FROM music_artists WHERE artist_id = :ID");
+        query.bindValue(":ID", mdata->getArtistId());
+        if (!query.exec())
+            MythDB::DBError("AllMusic::deleteTrack5", query);
+    }
+}
+
 /**************************************************************************/
 
 AllStream::AllStream(void)
diff --git a/mythtv/libs/libmythmetadata/musicmetadata.h b/mythtv/libs/libmythmetadata/musicmetadata.h
index 9e18a56..e51ce36 100644
--- a/mythtv/libs/libmythmetadata/musicmetadata.h
+++ b/mythtv/libs/libmythmetadata/musicmetadata.h
@@ -434,6 +434,8 @@ class META_PUBLIC AllMusic
 
     bool isValidID(int an_id);
 
+    void deleteTrack(int an_id);
+
   private:
     MetadataPtrList     m_all_music;
 
-- 
1.7.9.5

