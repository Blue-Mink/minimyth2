
This patch applies AXP305 dcdc3 offset - if regulator output is programmed above 1220mV

All kudos to sputnik2019 for his incredible help!

diff --git a/drivers/power/axp305.c b/drivers/power/axp305.c
index 0191e4d4..0668a346 100644
--- a/drivers/power/axp305.c
+++ b/drivers/power/axp305.c
@@ -31,7 +31,7 @@ int axp_set_dcdc4(unsigned int mvolt)
 {
 	int ret;
 	u8 cfg;
-
+#if 0
 	if (mvolt >= 1600)
 		cfg = AXP305_DCDC4_1600MV_OFFSET +
 			axp305_mvolt_to_cfg(mvolt, 1600, 3300, 100);
@@ -48,8 +48,38 @@ int axp_set_dcdc4(unsigned int mvolt)
 
 	return pmic_bus_setbits(AXP305_OUTPUT_CTRL1,
 				AXP305_OUTPUT_CTRL1_DCDCD_EN);
+#endif
+	return 0;
 }
 
+#define AXP305_DCDC3_1200MV_OFFSET 71
+int axp_set_dcdc3(unsigned int mvolt)
+{
+	int ret;
+	u8 cfg;
+
+	if (mvolt >= 1220)
+		cfg = AXP305_DCDC3_1200MV_OFFSET +
+			axp305_mvolt_to_cfg(mvolt, 1220, 1840, 20);
+	else
+		cfg = axp305_mvolt_to_cfg(mvolt, 500, 1200, 10);
+
+	if (mvolt == 0)
+		return pmic_bus_clrbits(AXP305_OUTPUT_CTRL1,
+					AXP305_OUTPUT_CTRL1_DCDCD_EN);
+
+	ret = pmic_bus_write(AXP305_DCDCD_VOLTAGE, cfg);
+	if (ret)
+		return ret;
+
+//	ret = pmic_bus_write(0x12, 0x7);
+//	if (ret)
+//		return ret;
+
+	return pmic_bus_setbits(AXP305_OUTPUT_CTRL1,
+				0x1f);
+ }
+ 
 int axp_init(void)
 {
 	u8 axp_chip_id;
@@ -63,9 +93,13 @@ int axp_init(void)
 	if (ret)
 		return ret;
 
-	if ((axp_chip_id & AXP305_CHIP_VERSION_MASK) != 0x40)
+	if ((axp_chip_id & AXP305_CHIP_VERSION_MASK) != 0x4b)
 		return -ENODEV;
 
+	printf("pmic id is 0x%x\n",axp_chip_id);
+
+	axp_set_dcdc3(1500);
+ 
 	return ret;
 }
 
