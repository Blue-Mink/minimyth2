diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h u-boot-2021.07/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
--- u-boot-2021.07/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h	2023-11-11 14:18:55.276684876 +0100
+++ u-boot-2021.07/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h	2023-11-11 14:06:57.516682458 +0100
@@ -130,6 +130,7 @@
 #define MSTR_DEVICETYPE_LPDDR2	BIT(2)
 #define MSTR_DEVICETYPE_LPDDR3	BIT(3)
 #define MSTR_DEVICETYPE_DDR4	BIT(4)
+#define MSTR_DEVICETYPE_LPDDR4	BIT(5)
 #define MSTR_DEVICETYPE_MASK	GENMASK(5, 0)
 #define MSTR_2TMODE		BIT(10)
 #define MSTR_BUSWIDTH_FULL	(0 << 12)
@@ -137,34 +138,35 @@
 #define MSTR_ACTIVE_RANKS(x)	(((x == 2) ? 3 : 1) << 24)
 #define MSTR_BURST_LENGTH(x)	(((x) >> 1) << 16)
 
-/* TODO: figure out what unknown features do */
-#define TPR10_UNKNOWN_FEAT0	BIT(16)
-#define TPR10_UNKNOWN_FEAT1	BIT(17)
-#define TPR10_UNKNOWN_FEAT2	BIT(18)
+#define TPR10_CA_BIT_DELAY	BIT(16)
+#define TPR10_DX_BIT_DELAY0	BIT(17)
+#define TPR10_DX_BIT_DELAY1	BIT(18)
 #define TPR10_WRITE_LEVELING	BIT(20)
 #define TPR10_READ_CALIBRATION	BIT(21)
 #define TPR10_READ_TRAINING	BIT(22)
 #define TPR10_WRITE_TRAINING	BIT(23)
-#define TPR10_UNKNOWN_FEAT3	BIT(30)
 
 struct dram_para {
 	u32 clk;
 	enum sunxi_dram_type type;
-	u8 cols;
-	u8 rows;
-	u8 ranks;
-	u8 bus_full_width;
 	u32 dx_odt;
 	u32 dx_dri;
 	u32 ca_dri;
 	u32 odt_en;
 	u32 tpr0;
 	u32 tpr2;
+	u32 tpr6;
 	u32 tpr10;
 	u32 tpr11;
 	u32 tpr12;
 };
 
+struct dram_config {
+	u8 cols;
+	u8 rows;
+	u8 ranks;
+	u8 bus_full_width;
+};
 
 static inline int ns_to_t(int nanoseconds)
 {
@@ -173,6 +175,6 @@
 	return DIV_ROUND_UP(ctrl_freq * nanoseconds, 1000);
 }
 
-void mctl_set_timing_params(struct dram_para *para);
+void mctl_set_timing_params(const struct dram_para *para);
 
 #endif /* _SUNXI_DRAM_SUN50I_H616_H */
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_sun50i_h616.c u-boot-2021.07/arch/arm/mach-sunxi/dram_sun50i_h616.c
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_sun50i_h616.c	2023-11-11 14:18:55.276684876 +0100
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_sun50i_h616.c	2023-11-11 14:06:57.516682458 +0100
@@ -31,7 +31,7 @@
 	MBUS_QOS_HIGHEST
 };
 
-inline void mbus_configure_port(u8 port,
+static void mbus_configure_port(u8 port,
 				bool bwlimit,
 				bool priority,
 				u8 qos,
@@ -92,7 +92,7 @@
 	dmb();
 }
 
-static void mctl_sys_init(struct dram_para *para)
+static void mctl_sys_init(u32 clk_rate)
 {
 	struct sunxi_ccm_reg * const ccm =
 			(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
@@ -114,7 +114,7 @@
 
 	/* Set PLL5 rate to doubled DRAM clock rate */
 	writel(CCM_PLL5_CTRL_EN | CCM_PLL5_LOCK_EN | CCM_PLL5_OUT_EN |
-	       CCM_PLL5_CTRL_N(para->clk * 2 / 24), &ccm->pll5_cfg);
+	       CCM_PLL5_CTRL_N(clk_rate * 2 / 24), &ccm->pll5_cfg);
 	mctl_await_completion(&ccm->pll5_cfg, CCM_PLL5_LOCK, CCM_PLL5_LOCK);
 
 	/* Configure DRAM mod clock */
@@ -141,15 +141,15 @@
 	writel(0x8000, &mctl_ctl->clken);
 }
 
-static void mctl_set_addrmap(struct dram_para *para)
+static void mctl_set_addrmap(const struct dram_config *config)
 {
 	struct sunxi_mctl_ctl_reg * const mctl_ctl =
 			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
-	u8 cols = para->cols;
-	u8 rows = para->rows;
-	u8 ranks = para->ranks;
+	u8 cols = config->cols;
+	u8 rows = config->rows;
+	u8 ranks = config->ranks;
 
-	if (!para->bus_full_width)
+	if (!config->bus_full_width)
 		cols -= 1;
 
 	/* Ranks */
@@ -227,75 +227,68 @@
 	mctl_ctl->addrmap[8] = 0x3F3F;
 }
 
-static const u8 phy_init_ddr3[] = {
+static const u8 phy_init[] = {
+#ifdef CONFIG_SUNXI_DRAM_H616_DDR3_1333
 	0x07, 0x0b, 0x02, 0x16, 0x0d, 0x0e, 0x14, 0x19,
 	0x0a, 0x15, 0x03, 0x13, 0x04, 0x0c, 0x10, 0x06,
 	0x0f, 0x11, 0x1a, 0x01, 0x12, 0x17, 0x00, 0x08,
 	0x09, 0x05, 0x18
-};
-
-static const u8 phy_init_lpddr3[] = {
+#elif defined(CONFIG_SUNXI_DRAM_H616_LPDDR3)
 	0x18, 0x06, 0x00, 0x05, 0x04, 0x03, 0x09, 0x02,
 	0x08, 0x01, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x07,
 	0x17, 0x19, 0x1a
+#elif defined(CONFIG_SUNXI_DRAM_H616_LPDDR4)
+	0x02, 0x00, 0x17, 0x05, 0x04, 0x19, 0x06, 0x07,
+	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x01,
+	0x18, 0x03, 0x1a
+#endif
 };
 
-static void mctl_phy_configure_odt(struct dram_para *para)
+#define MASK_BYTE(reg, nr) (((reg) >> ((nr) * 8)) & 0x1f)
+static void mctl_phy_configure_odt(const struct dram_para *para)
 {
-	unsigned int val;
-
-	val = para->dx_dri & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x388);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x38c);
-
-	val = (para->dx_dri >> 8) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3c8);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3cc);
-
-	val = (para->dx_dri >> 16) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x408);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x40c);
-
-	val = (para->dx_dri >> 24) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x448);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x44c);
-
-	val = para->ca_dri & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x340);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x344);
-
-	val = (para->ca_dri >> 8) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x348);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x34c);
-
-	val = para->dx_odt & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x380);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x384);
+	uint32_t val_lo, val_hi;
 
-	val = (para->dx_odt >> 8) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3c0);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x3c4);
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x390, BIT(5), BIT(4));
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x3d0, BIT(5), BIT(4));
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x410, BIT(5), BIT(4));
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x450, BIT(5), BIT(4));
 
-	val = (para->dx_odt >> 16) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x400);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x404);
+	val_lo = para->dx_dri;
+	val_hi = (para->type == SUNXI_DRAM_TYPE_LPDDR4) ? 0x04040404 : para->dx_dri;
+	writel_relaxed(MASK_BYTE(val_lo, 0), SUNXI_DRAM_PHY0_BASE + 0x388);
+	writel_relaxed(MASK_BYTE(val_hi, 0), SUNXI_DRAM_PHY0_BASE + 0x38c);
+	writel_relaxed(MASK_BYTE(val_lo, 1), SUNXI_DRAM_PHY0_BASE + 0x3c8);
+	writel_relaxed(MASK_BYTE(val_hi, 1), SUNXI_DRAM_PHY0_BASE + 0x3cc);
+	writel_relaxed(MASK_BYTE(val_lo, 2), SUNXI_DRAM_PHY0_BASE + 0x408);
+	writel_relaxed(MASK_BYTE(val_hi, 2), SUNXI_DRAM_PHY0_BASE + 0x40c);
+	writel_relaxed(MASK_BYTE(val_lo, 3), SUNXI_DRAM_PHY0_BASE + 0x448);
+	writel_relaxed(MASK_BYTE(val_hi, 3), SUNXI_DRAM_PHY0_BASE + 0x44c);
 
-	val = (para->dx_odt >> 24) & 0x1f;
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x440);
-	writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x444);
+	val_lo = para->ca_dri;
+	val_hi = para->ca_dri;
+	writel_relaxed(MASK_BYTE(val_lo, 0), SUNXI_DRAM_PHY0_BASE + 0x340);
+	writel_relaxed(MASK_BYTE(val_hi, 0), SUNXI_DRAM_PHY0_BASE + 0x344);
+	writel_relaxed(MASK_BYTE(val_lo, 1), SUNXI_DRAM_PHY0_BASE + 0x348);
+	writel_relaxed(MASK_BYTE(val_hi, 1), SUNXI_DRAM_PHY0_BASE + 0x34c);
 
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3){
-		writel_relaxed(0, SUNXI_DRAM_PHY0_BASE + 0x380);
-		writel_relaxed(0, SUNXI_DRAM_PHY0_BASE + 0x3c0);
-		writel_relaxed(0, SUNXI_DRAM_PHY0_BASE + 0x400);
-		writel_relaxed(0, SUNXI_DRAM_PHY0_BASE + 0x440);
-	}
+	val_lo = (para->type == SUNXI_DRAM_TYPE_LPDDR3) ? 0 : para->dx_odt;
+	val_hi = (para->type == SUNXI_DRAM_TYPE_LPDDR4) ? 0 : para->dx_odt;
+	writel_relaxed(MASK_BYTE(val_lo, 0), SUNXI_DRAM_PHY0_BASE + 0x380);
+	writel_relaxed(MASK_BYTE(val_hi, 0), SUNXI_DRAM_PHY0_BASE + 0x384);
+	writel_relaxed(MASK_BYTE(val_lo, 1), SUNXI_DRAM_PHY0_BASE + 0x3c0);
+	writel_relaxed(MASK_BYTE(val_hi, 1), SUNXI_DRAM_PHY0_BASE + 0x3c4);
+	writel_relaxed(MASK_BYTE(val_lo, 2), SUNXI_DRAM_PHY0_BASE + 0x400);
+	writel_relaxed(MASK_BYTE(val_hi, 2), SUNXI_DRAM_PHY0_BASE + 0x404);
+	writel_relaxed(MASK_BYTE(val_lo, 3), SUNXI_DRAM_PHY0_BASE + 0x440);
+	writel_relaxed(MASK_BYTE(val_hi, 3), SUNXI_DRAM_PHY0_BASE + 0x444);
 
 	dmb();
 }
 
-static bool mctl_phy_write_leveling(struct dram_para *para)
+static bool mctl_phy_write_leveling(const struct dram_config *config)
 {
 	bool result = true;
 	u32 val;
@@ -306,7 +299,7 @@
 
 	setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 4);
 
-	if (para->bus_full_width)
+	if (config->bus_full_width)
 		val = 0xf;
 	else
 		val = 3;
@@ -330,12 +323,12 @@
 
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0xc0);
 
-	if (para->ranks == 2) {
+	if (config->ranks == 2) {
 		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0xc0, 0x40);
 
 		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 4);
 
-		if (para->bus_full_width)
+		if (config->bus_full_width)
 			val = 0xf;
 		else
 			val = 3;
@@ -350,7 +343,7 @@
 	return result;
 }
 
-static bool mctl_phy_read_calibration(struct dram_para *para)
+static bool mctl_phy_read_calibration(const struct dram_config *config)
 {
 	bool result = true;
 	u32 val, tmp;
@@ -359,7 +352,7 @@
 
 	setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
 
-	if (para->bus_full_width)
+	if (config->bus_full_width)
 		val = 0xf;
 	else
 		val = 3;
@@ -375,7 +368,7 @@
 
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30);
 
-	if (para->ranks == 2) {
+	if (config->ranks == 2) {
 		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30, 0x10);
 
 		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
@@ -409,7 +402,7 @@
 	return result;
 }
 
-static bool mctl_phy_read_training(struct dram_para *para)
+static bool mctl_phy_read_training(const struct dram_config *config)
 {
 	u32 val1, val2, *ptr1, *ptr2;
 	bool result = true;
@@ -428,7 +421,7 @@
 	if (readl(SUNXI_DRAM_PHY0_BASE + 0x840) & 3)
 		result = false;
 
-	if (para->bus_full_width) {
+	if (config->bus_full_width) {
 		mctl_await_completion((u32 *)(SUNXI_DRAM_PHY0_BASE + 0xa40), 0xc, 0xc);
 		if (readl(SUNXI_DRAM_PHY0_BASE + 0xa40) & 3)
 			result = false;
@@ -451,7 +444,7 @@
 			result = false;
 	}
 
-	if (para->bus_full_width) {
+	if (config->bus_full_width) {
 		ptr1 = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0xa98);
 		ptr2 = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0xa50);
 		for (i = 0; i < 9; i++) {
@@ -473,7 +466,7 @@
 
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 3);
 
-	if (para->ranks == 2) {
+	if (config->ranks == 2) {
 		/* maybe last parameter should be 1? */
 		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 3, 2);
 
@@ -484,7 +477,7 @@
 		if (readl(SUNXI_DRAM_PHY0_BASE + 0x840) & 3)
 			result = false;
 
-		if (para->bus_full_width) {
+		if (config->bus_full_width) {
 			mctl_await_completion((u32 *)(SUNXI_DRAM_PHY0_BASE + 0xa40), 0xc, 0xc);
 			if (readl(SUNXI_DRAM_PHY0_BASE + 0xa40) & 3)
 				result = false;
@@ -498,7 +491,7 @@
 	return result;
 }
 
-static bool mctl_phy_write_training(struct dram_para *para)
+static bool mctl_phy_write_training(const struct dram_config *config)
 {
 	u32 val1, val2, *ptr1, *ptr2;
 	bool result = true;
@@ -518,7 +511,7 @@
 	if (readl(SUNXI_DRAM_PHY0_BASE + 0x8e0) & 0xc)
 		result = false;
 
-	if (para->bus_full_width) {
+	if (config->bus_full_width) {
 		mctl_await_completion((u32 *)(SUNXI_DRAM_PHY0_BASE + 0xae0), 3, 3);
 		if (readl(SUNXI_DRAM_PHY0_BASE + 0xae0) & 0xc)
 			result = false;
@@ -541,7 +534,7 @@
 			result = false;
 	}
 
-	if (para->bus_full_width) {
+	if (config->bus_full_width) {
 		ptr1 = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0xb38);
 		ptr2 = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0xaf0);
 		for (i = 0; i < 9; i++) {
@@ -562,7 +555,7 @@
 
 	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x60);
 
-	if (para->ranks == 2) {
+	if (config->ranks == 2) {
 		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 0xc, 4);
 
 		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x10);
@@ -572,7 +565,7 @@
 		if (readl(SUNXI_DRAM_PHY0_BASE + 0x8e0) & 0xc)
 			result = false;
 
-		if (para->bus_full_width) {
+		if (config->bus_full_width) {
 			mctl_await_completion((u32 *)(SUNXI_DRAM_PHY0_BASE + 0xae0), 3, 3);
 			if (readl(SUNXI_DRAM_PHY0_BASE + 0xae0) & 0xc)
 				result = false;
@@ -586,17 +579,19 @@
 	return result;
 }
 
-static void mctl_phy_bit_delay_compensation(struct dram_para *para)
+static void mctl_phy_bit_delay_compensation(const struct dram_para *para)
 {
 	u32 *ptr, val;
 	int i;
 
-	if (para->tpr10 & TPR10_UNKNOWN_FEAT2) {
+	if (para->tpr10 & TPR10_DX_BIT_DELAY1) {
 		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x60, 1);
 		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 8);
 		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x10);
+		if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+			clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x4, 0x80);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = para->tpr11 & 0x3f;
 		else
 			val = (para->tpr11 & 0xf) << 1;
@@ -608,7 +603,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 15) & 0x1e;
 		else
 			val = (para->tpr11 >> 15) & 0x1e;
@@ -618,7 +613,7 @@
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x4cc);
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x58c);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->tpr11 >> 8) & 0x3f;
 		else
 			val = (para->tpr11 >> 3) & 0x1e;
@@ -630,7 +625,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 19) & 0x1e;
 		else
 			val = (para->tpr11 >> 19) & 0x1e;
@@ -640,7 +635,7 @@
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x520);
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5e0);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->tpr11 >> 16) & 0x3f;
 		else
 			val = (para->tpr11 >> 7) & 0x1e;
@@ -652,7 +647,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 23) & 0x1e;
 		else
 			val = (para->tpr11 >> 23) & 0x1e;
@@ -662,7 +657,7 @@
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x64c);
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x70c);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->tpr11 >> 24) & 0x3f;
 		else
 			val = (para->tpr11 >> 11) & 0x1e;
@@ -674,7 +669,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 27) & 0x1e;
 		else
 			val = (para->tpr11 >> 27) & 0x1e;
@@ -689,11 +684,11 @@
 		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x60, 1);
 	}
 
-	if (para->tpr10 & TPR10_UNKNOWN_FEAT1) {
+	if (para->tpr10 & TPR10_DX_BIT_DELAY0) {
 		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x54, 0x80);
 		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 4);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = para->tpr12 & 0x3f;
 		else
 			val = (para->tpr12 & 0xf) << 1;
@@ -705,7 +700,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en << 1) & 0x1e;
 		else
 			val = (para->tpr12 >> 15) & 0x1e;
@@ -715,7 +710,7 @@
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x4c8);
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x588);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->tpr12 >> 8) & 0x3f;
 		else
 			val = (para->tpr12 >> 3) & 0x1e;
@@ -727,7 +722,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 3) & 0x1e;
 		else
 			val = (para->tpr12 >> 19) & 0x1e;
@@ -737,7 +732,7 @@
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x51c);
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x5dc);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->tpr12 >> 16) & 0x3f;
 		else
 			val = (para->tpr12 >> 7) & 0x1e;
@@ -749,7 +744,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 7) & 0x1e;
 		else
 			val = (para->tpr12 >> 23) & 0x1e;
@@ -759,7 +754,7 @@
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x648);
 		writel_relaxed(val, SUNXI_DRAM_PHY0_BASE + 0x708);
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->tpr12 >> 24) & 0x3f;
 		else
 			val = (para->tpr12 >> 11) & 0x1e;
@@ -771,7 +766,7 @@
 			ptr += 2;
 		}
 
-		if (para->tpr10 & TPR10_UNKNOWN_FEAT3)
+		if (para->tpr10 & BIT(30))
 			val = (para->odt_en >> 11) & 0x1e;
 		else
 			val = (para->tpr12 >> 27) & 0x1e;
@@ -787,7 +782,86 @@
 	}
 }
 
-static bool mctl_phy_init(struct dram_para *para)
+static void mctl_phy_ca_bit_delay_compensation(const struct dram_para *para,
+					       const struct dram_config *config)
+{
+	u32 val, *ptr;
+	int i;
+
+	if (para->tpr0 & BIT(30))
+		val = (para->tpr0 >> 7) & 0x3e;
+	else
+		val = (para->tpr10 >> 3) & 0x1e;
+
+	ptr = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0x780);
+	for (i = 0; i < 32; i++)
+		writel(val, &ptr[i]);
+
+	val = (para->tpr10 << 1) & 0x1e;
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x7d8);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x7dc);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x7e0);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x7f4);
+
+	val = (para->tpr10 >> 7) & 0x1e;
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
+		if (para->tpr2 & 1) {
+			writel(val, SUNXI_DRAM_PHY0_BASE + 0x794);
+			if (config->ranks == 2) {
+				val = (para->tpr10 >> 11) & 0x1e;
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7e4);
+			}
+			if (para->tpr0 & BIT(31)) {
+				val = (para->tpr0 << 1) & 0x3e;
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x790);
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7b8);
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7cc);
+			}
+		} else {
+			writel(val, SUNXI_DRAM_PHY0_BASE + 0x7d4);
+			if (config->ranks == 2) {
+				val = (para->tpr10 >> 11) & 0x1e;
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x79c);
+			}
+			if (para->tpr0 & BIT(31)) {
+				val = (para->tpr0 << 1) & 0x3e;
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x78c);
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7a4);
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7b8);
+			}
+		}
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		if (para->tpr2 & 1) {
+			writel(val, SUNXI_DRAM_PHY0_BASE + 0x7a0);
+			if (config->ranks == 2) {
+				val = (para->tpr10 >> 11) & 0x1e;
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x79c);
+			}
+		} else {
+			writel(val, SUNXI_DRAM_PHY0_BASE + 0x7e8);
+			if (config->ranks == 2) {
+				val = (para->tpr10 >> 11) & 0x1e;
+				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7f8);
+			}
+		}
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		if (para->tpr2 & 1) {
+			writel(val, SUNXI_DRAM_PHY0_BASE + 0x788);
+		} else {
+			writel(val, SUNXI_DRAM_PHY0_BASE + 0x794);
+		};
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
+}
+
+static bool mctl_phy_init(const struct dram_para *para,
+			  const struct dram_config *config)
 {
 	struct sunxi_mctl_com_reg * const mctl_com =
 			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
@@ -796,13 +870,17 @@
 	u32 val, val2, *ptr, mr0, mr2;
 	int i;
 
-	if (para->bus_full_width)
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x4,0x80);
+
+	if (config->bus_full_width)
 		val = 0xf;
 	else
 		val = 3;
 	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x3c, 0xf, val);
 
-	if (para->type == SUNXI_DRAM_TYPE_DDR3) {
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
 		if (para->tpr2 & 0x100) {
 			val = 9;
 			val2 = 7;
@@ -810,116 +888,82 @@
 			val = 13;
 			val2 = 9;
 		}
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		if (para->tpr2 & 0x100) {
+			val = 12;
+			val2 = 6;
+		} else {
+			val = 14;
+			val2 = 8;
+		}
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		val = 20;
+		val2 = 10;
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
 
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x14);
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x35c);
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x368);
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x374);
-
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x18);
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x360);
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x36c);
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x378);
-
-		writel(val2, SUNXI_DRAM_PHY0_BASE + 0x1c);
-		writel(val2, SUNXI_DRAM_PHY0_BASE + 0x364);
-		writel(val2, SUNXI_DRAM_PHY0_BASE + 0x370);
-		writel(val2, SUNXI_DRAM_PHY0_BASE + 0x37c);
-	}
-
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
-		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x14);
-		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x35c);
-		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x368);
-		writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x374);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x14);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x35c);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x368);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x374);
 
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x18);
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x360);
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x36c);
-		writel(0, SUNXI_DRAM_PHY0_BASE + 0x378);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x18);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x360);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x36c);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x378);
 
-		writel(8, SUNXI_DRAM_PHY0_BASE + 0x1c);
-		writel(8, SUNXI_DRAM_PHY0_BASE + 0x364);
-		writel(8, SUNXI_DRAM_PHY0_BASE + 0x370);
-		writel(8, SUNXI_DRAM_PHY0_BASE + 0x37c);	
-	}
+	writel(val2, SUNXI_DRAM_PHY0_BASE + 0x1c);
+	writel(val2, SUNXI_DRAM_PHY0_BASE + 0x364);
+	writel(val2, SUNXI_DRAM_PHY0_BASE + 0x370);
+	writel(val2, SUNXI_DRAM_PHY0_BASE + 0x37c);
 
 	ptr = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0xc0);
+	for (i = 0; i < ARRAY_SIZE(phy_init); i++)
+		writel(phy_init[i], &ptr[i]);
 
-	if (para->type == SUNXI_DRAM_TYPE_DDR3)
-		for (i = 0; i < ARRAY_SIZE(phy_init_ddr3); i++)
-			writel(phy_init_ddr3[i], &ptr[i]);
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
-		for (i = 0; i < ARRAY_SIZE(phy_init_lpddr3); i++)
-			writel(phy_init_lpddr3[i], &ptr[i]);
-
-
-	if (para->tpr10 & TPR10_UNKNOWN_FEAT0) {
-		if (para->tpr0 & BIT(30))
-			val = (para->tpr0 >> 7) & 0x3e;
-		else
-			val = (para->tpr10 >> 3) & 0x1e;
-
-		ptr = (u32 *)(SUNXI_DRAM_PHY0_BASE + 0x780);
-		for (i = 0; i < 32; i++)
-			writel(val, &ptr[i]);
-
-		val = (para->tpr10 << 1) & 0x1e;
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x7d8);
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x7dc);
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x7e0);
-		writel(val, SUNXI_DRAM_PHY0_BASE + 0x7f4);
+	if (para->tpr10 & TPR10_CA_BIT_DELAY)
+		mctl_phy_ca_bit_delay_compensation(para, config);
 
-		if (para->type == SUNXI_DRAM_TYPE_DDR3) {
-			/* following configuration is DDR3 specific */
-			val = (para->tpr10 >> 7) & 0x1e;
-			if (para->tpr2 & 1) {
-				writel(val, SUNXI_DRAM_PHY0_BASE + 0x794);
-				if (para->ranks == 2) {
-					val = (para->tpr10 >> 11) & 0x1e;
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x7e4);
-				}
-				if (para->tpr0 & BIT(31)) {
-					val = (para->tpr0 << 1) & 0x3e;
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x790);
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x7b8);
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x7cc);
-				}
-			} else {
-				writel(val, SUNXI_DRAM_PHY0_BASE + 0x7d4);
-				if (para->ranks == 2) {
-					val = (para->tpr10 >> 11) & 0x1e;
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x79c);
-				}
-				if (para->tpr0 & BIT(31)) {
-					val = (para->tpr0 << 1) & 0x3e;
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x78c);
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x7a4);
-					writel(val, SUNXI_DRAM_PHY0_BASE + 0x7b8);
-				}
-			}
-		}
-		if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
-			writel(6, SUNXI_DRAM_PHY0_BASE + 0x7e8);
-			writel(6, SUNXI_DRAM_PHY0_BASE + 0x7f8);
-		}
-	}
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
+		val = para->tpr6 & 0xff;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		val = para->tpr6 >> 8 & 0xff;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		val = para->tpr6 >> 24 & 0xff;
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
 
-	if (para->type == SUNXI_DRAM_TYPE_DDR3) {
-		writel(0x80, SUNXI_DRAM_PHY0_BASE + 0x3dc);
-		writel(0x80, SUNXI_DRAM_PHY0_BASE + 0x45c);
-	}
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
-		writel(0xc0, SUNXI_DRAM_PHY0_BASE + 0x3dc);
-		writel(0xc0, SUNXI_DRAM_PHY0_BASE + 0x45c);
-	}
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x3dc);
+	writel(val, SUNXI_DRAM_PHY0_BASE + 0x45c);
 
 	mctl_phy_configure_odt(para);
 
-	if (para->type == SUNXI_DRAM_TYPE_DDR3)
-		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 7, 0xa);
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
-		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 7, 0xb);
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
+		val = 0x0a;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		val = 0x0b;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		val = 0x0d;
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 0x7, val);
 
 	if (para->clk <= 672)
 		writel(0xf, SUNXI_DRAM_PHY0_BASE + 0x20);
@@ -960,20 +1004,16 @@
 
 	writel(1, &mctl_ctl->swctl);
 	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
-	
-	/*
-	 * TODO: The values for each type of memory should be 
-	 * specified below.
-	 */
-	if (para->type == SUNXI_DRAM_TYPE_DDR3) {
-		if (para->tpr2 & 0x100) {
-			mr0 = 0x1b50;
-			mr2 = 0x10;
-		} else {
-			mr0 = 0x1f14;
-			mr2 = 0x20;
-		}
 
+	if (para->tpr2 & 0x100) {
+		mr0 = 0x1b50;
+		mr2 = 0x10;
+	} else {
+		mr0 = 0x1f14;
+		mr2 = 0x20;
+	}
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
 		writel(mr0, &mctl_ctl->mrctrl1);
 		writel(0x80000030, &mctl_ctl->mrctrl0);
 		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
@@ -989,9 +1029,9 @@
 		writel(0, &mctl_ctl->mrctrl1);
 		writel(0x80003030, &mctl_ctl->mrctrl0);
 		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
-	}
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
-		writel(0x1f14, &mctl_ctl->mrctrl1);
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		writel(mr0, &mctl_ctl->mrctrl1);
 		writel(0x800000f0, &mctl_ctl->mrctrl0);
 		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
 
@@ -999,15 +1039,55 @@
 		writel(0x800000f0, &mctl_ctl->mrctrl0);
 		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
 
-		writel(0x20, &mctl_ctl->mrctrl1);
+		writel(mr2, &mctl_ctl->mrctrl1);
 		writel(0x800000f0, &mctl_ctl->mrctrl0);
 		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
 
 		writel(0x301, &mctl_ctl->mrctrl1);
 		writel(0x800000f0, &mctl_ctl->mrctrl0);
 		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
-	}
-	
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		writel(0x0, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x134, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x21b, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x333, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x403, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0xb04, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0xc72, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0xe09, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+		writel(0x1624, &mctl_ctl->mrctrl1);
+		writel(0x80000030, &mctl_ctl->mrctrl0);
+		mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
 
 	writel(0, SUNXI_DRAM_PHY0_BASE + 0x54);
 
@@ -1017,7 +1097,7 @@
 
 	if (para->tpr10 & TPR10_WRITE_LEVELING) {
 		for (i = 0; i < 5; i++)
-			if (mctl_phy_write_leveling(para))
+			if (mctl_phy_write_leveling(config))
 				break;
 		if (i == 5) {
 			debug("write leveling failed!\n");
@@ -1027,7 +1107,7 @@
 
 	if (para->tpr10 & TPR10_READ_CALIBRATION) {
 		for (i = 0; i < 5; i++)
-			if (mctl_phy_read_calibration(para))
+			if (mctl_phy_read_calibration(config))
 				break;
 		if (i == 5) {
 			debug("read calibration failed!\n");
@@ -1037,7 +1117,7 @@
 
 	if (para->tpr10 & TPR10_READ_TRAINING) {
 		for (i = 0; i < 5; i++)
-			if (mctl_phy_read_training(para))
+			if (mctl_phy_read_training(config))
 				break;
 		if (i == 5) {
 			debug("read training failed!\n");
@@ -1047,7 +1127,7 @@
 
 	if (para->tpr10 & TPR10_WRITE_TRAINING) {
 		for (i = 0; i < 5; i++)
-			if (mctl_phy_write_training(para))
+			if (mctl_phy_write_training(config))
 				break;
 		if (i == 5) {
 			debug("write training failed!\n");
@@ -1062,7 +1142,8 @@
 	return true;
 }
 
-static bool mctl_ctrl_init(struct dram_para *para)
+static bool mctl_ctrl_init(const struct dram_para *para,
+			   const struct dram_config *config)
 {
 	struct sunxi_mctl_com_reg * const mctl_com =
 			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
@@ -1075,44 +1156,62 @@
 
 	setbits_le32(&mctl_com->unk_0x008, 0xff00);
 
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		writel(1, SUNXI_DRAM_COM_BASE + 0x50);
 	clrsetbits_le32(&mctl_ctl->sched[0], 0xff00, 0x3000);
 
 	writel(0, &mctl_ctl->hwlpctl);
 
 	setbits_le32(&mctl_com->unk_0x008, 0xff00);
 
-	reg_val = MSTR_BURST_LENGTH(8) | MSTR_ACTIVE_RANKS(para->ranks);
-	if (para->type == SUNXI_DRAM_TYPE_DDR3)
-		reg_val |= MSTR_DEVICETYPE_DDR3 | MSTR_2TMODE;
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3)
-		reg_val |= MSTR_DEVICETYPE_LPDDR3;
-	if (para->bus_full_width)
+	reg_val = MSTR_ACTIVE_RANKS(config->ranks);
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
+		reg_val |= MSTR_BURST_LENGTH(8) | MSTR_DEVICETYPE_DDR3 | MSTR_2TMODE;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		reg_val |= MSTR_BURST_LENGTH(8) | MSTR_DEVICETYPE_LPDDR3;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		reg_val |= MSTR_BURST_LENGTH(16) | MSTR_DEVICETYPE_LPDDR4;
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
+	if (config->bus_full_width)
 		reg_val |= MSTR_BUSWIDTH_FULL;
 	else
 		reg_val |= MSTR_BUSWIDTH_HALF;
 	writel(BIT(31) | BIT(30) | reg_val, &mctl_ctl->mstr);
 
-	if (para->ranks == 2)
+	if (config->ranks == 2)
 		writel(0x0303, &mctl_ctl->odtmap);
 	else
 		writel(0x0201, &mctl_ctl->odtmap);
 
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
-		writel(0x06000400, &mctl_ctl->odtcfg);
-		writel(0x06000400, &mctl_ctl->unk_0x2240);
-		writel(0x06000400, &mctl_ctl->unk_0x3240);
-		writel(0x06000400, &mctl_ctl->unk_0x4240);
-	}
-	if (para->type == SUNXI_DRAM_TYPE_LPDDR3) {
-		writel(0x09020400, &mctl_ctl->odtcfg);
-		writel(0x09020400, &mctl_ctl->unk_0x2240);
-		writel(0x09020400, &mctl_ctl->unk_0x3240);
-		writel(0x09020400, &mctl_ctl->unk_0x4240);
-	}
+	switch (para->type) {
+	case SUNXI_DRAM_TYPE_DDR3:
+		reg_val = 0x06000400;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR3:
+		reg_val = 0x09020400;
+		break;
+	case SUNXI_DRAM_TYPE_LPDDR4:
+		reg_val = 0x04000400;
+		break;
+	case SUNXI_DRAM_TYPE_DDR4:
+	default:
+		panic("This DRAM setup is currently not supported.\n");
+	};
+	writel(reg_val, &mctl_ctl->odtcfg);
+	writel(reg_val, &mctl_ctl->unk_0x2240);
+	writel(reg_val, &mctl_ctl->unk_0x3240);
+	writel(reg_val, &mctl_ctl->unk_0x4240);
 
 	writel(BIT(31), &mctl_com->cr);
 
-	mctl_set_addrmap(para);
+	mctl_set_addrmap(config);
 
 	mctl_set_timing_params(para);
 
@@ -1124,6 +1223,9 @@
 	setbits_le32(&mctl_ctl->unk_0x3180, BIT(31) | BIT(30));
 	setbits_le32(&mctl_ctl->unk_0x4180, BIT(31) | BIT(30));
 
+	if (para->type == SUNXI_DRAM_TYPE_LPDDR4)
+		setbits_le32(&mctl_ctl->dbictl, 1);
+
 	setbits_le32(&mctl_ctl->rfshctl3, BIT(0));
 	clrbits_le32(&mctl_ctl->dfimisc, BIT(0));
 
@@ -1138,7 +1240,7 @@
 	/* this write seems to enable PHY MMIO region */
 	setbits_le32(&mctl_com->unk_0x500, BIT(24));
 
-	if (!mctl_phy_init(para))
+	if (!mctl_phy_init(para, config))
 		return false;
 
 	writel(0, &mctl_ctl->swctl);
@@ -1155,18 +1257,20 @@
 	return true;
 }
 
-static bool mctl_core_init(struct dram_para *para)
+static bool mctl_core_init(const struct dram_para *para,
+			   const struct dram_config *config)
 {
-	mctl_sys_init(para);
+	mctl_sys_init(para->clk);
 
-	return mctl_ctrl_init(para);
+	return mctl_ctrl_init(para, config);
 }
 
-static void mctl_auto_detect_rank_width(struct dram_para *para)
+static void mctl_auto_detect_rank_width(const struct dram_para *para,
+					struct dram_config *config)
 {
 	/* this is minimum size that it's supported */
-	para->cols = 8;
-	para->rows = 13;
+	config->cols = 8;
+	config->rows = 13;
 
 	/*
 	 * Strategy here is to test most demanding combination first and least
@@ -1177,98 +1281,104 @@
 	 */
 
 	debug("testing 32-bit width, rank = 2\n");
-	para->bus_full_width = 1;
-	para->ranks = 2;
-	if (mctl_core_init(para))
+	config->bus_full_width = 1;
+	config->ranks = 2;
+	if (mctl_core_init(para, config))
 		return;
 
 	debug("testing 32-bit width, rank = 1\n");
-	para->bus_full_width = 1;
-	para->ranks = 1;
-	if (mctl_core_init(para))
+	config->bus_full_width = 1;
+	config->ranks = 1;
+	if (mctl_core_init(para, config))
 		return;
 
 	debug("testing 16-bit width, rank = 2\n");
-	para->bus_full_width = 0;
-	para->ranks = 2;
-	if (mctl_core_init(para))
+	config->bus_full_width = 0;
+	config->ranks = 2;
+	if (mctl_core_init(para, config))
 		return;
 
 	debug("testing 16-bit width, rank = 1\n");
-	para->bus_full_width = 0;
-	para->ranks = 1;
-	if (mctl_core_init(para))
+	config->bus_full_width = 0;
+	config->ranks = 1;
+	if (mctl_core_init(para, config))
 		return;
 
 	panic("This DRAM setup is currently not supported.\n");
 }
 
-static void mctl_auto_detect_dram_size(struct dram_para *para)
+static void mctl_auto_detect_dram_size(const struct dram_para *para,
+				       struct dram_config *config)
 {
 	/* detect row address bits */
-	para->cols = 8;
-	para->rows = 18;
-	mctl_core_init(para);
+	config->cols = 8;
+	config->rows = 18;
+	mctl_core_init(para, config);
 
-	for (para->rows = 13; para->rows < 18; para->rows++) {
+	for (config->rows = 13; config->rows < 18; config->rows++) {
 		/* 8 banks, 8 bit per byte and 16/32 bit width */
-		if (mctl_mem_matches((1 << (para->rows + para->cols +
-					    4 + para->bus_full_width))))
+		if (mctl_mem_matches((1 << (config->rows + config->cols +
+					    4 + config->bus_full_width))))
 			break;
 	}
 
 	/* detect column address bits */
-	para->cols = 11;
-	mctl_core_init(para);
+	config->cols = 11;
+	mctl_core_init(para, config);
 
-	for (para->cols = 8; para->cols < 11; para->cols++) {
+	for (config->cols = 8; config->cols < 11; config->cols++) {
 		/* 8 bits per byte and 16/32 bit width */
-		if (mctl_mem_matches(1 << (para->cols + 1 +
-					   para->bus_full_width)))
+		if (mctl_mem_matches(1 << (config->cols + 1 +
+					   config->bus_full_width)))
 			break;
 	}
 }
 
-static unsigned long mctl_calc_size(struct dram_para *para)
+static unsigned long mctl_calc_size(const struct dram_config *config)
 {
-	u8 width = para->bus_full_width ? 4 : 2;
+	u8 width = config->bus_full_width ? 4 : 2;
 
 	/* 8 banks */
-	return (1ULL << (para->cols + para->rows + 3)) * width * para->ranks;
+	return (1ULL << (config->cols + config->rows + 3)) * width * config->ranks;
 }
 
+static const struct dram_para para = {
+	.clk = CONFIG_DRAM_CLK,
+#ifdef CONFIG_SUNXI_DRAM_H616_DDR3_1333
+	.type = SUNXI_DRAM_TYPE_DDR3,
+#elif defined(CONFIG_SUNXI_DRAM_H616_LPDDR3)
+	.type = SUNXI_DRAM_TYPE_LPDDR3,
+#elif defined(CONFIG_SUNXI_DRAM_H616_LPDDR4)
+	.type = SUNXI_DRAM_TYPE_LPDDR4,
+#endif
+	.dx_odt = CONFIG_DRAM_SUN50I_H616_DX_ODT,
+	.dx_dri = CONFIG_DRAM_SUN50I_H616_DX_DRI,
+	.ca_dri = CONFIG_DRAM_SUN50I_H616_CA_DRI,
+	.odt_en = CONFIG_DRAM_SUN50I_H616_ODT_EN,
+	.tpr0 = CONFIG_DRAM_SUN50I_H616_TPR0,
+	.tpr2 = CONFIG_DRAM_SUN50I_H616_TPR2,
+	.tpr6 = CONFIG_DRAM_SUN50I_H616_TPR6,
+	.tpr10 = CONFIG_DRAM_SUN50I_H616_TPR10,
+	.tpr11 = CONFIG_DRAM_SUN50I_H616_TPR11,
+	.tpr12 = CONFIG_DRAM_SUN50I_H616_TPR12,
+};
+
 unsigned long sunxi_dram_init(void)
 {
 	struct sunxi_prcm_reg *const prcm =
 		(struct sunxi_prcm_reg *)SUNXI_PRCM_BASE;
-	struct dram_para para = {
-		.clk = CONFIG_DRAM_CLK,
-#ifdef CONFIG_SUNXI_DRAM_H616_DDR3_1333
-		.type = SUNXI_DRAM_TYPE_DDR3,
-#elif defined(CONFIG_SUNXI_DRAM_H616_LPDDR3)
-		.type = SUNXI_DRAM_TYPE_LPDDR3,
-#endif
-		.dx_odt = CONFIG_DRAM_SUN50I_H616_DX_ODT,
-		.dx_dri = CONFIG_DRAM_SUN50I_H616_DX_DRI,
-		.ca_dri = CONFIG_DRAM_SUN50I_H616_CA_DRI,
-		.odt_en = CONFIG_DRAM_SUN50I_H616_ODT_EN,
-		.tpr0 = CONFIG_DRAM_SUN50I_H616_TPR0,
-		.tpr2 = CONFIG_DRAM_SUN50I_H616_TPR2,
-		.tpr10 = CONFIG_DRAM_SUN50I_H616_TPR10,
-		.tpr11 = CONFIG_DRAM_SUN50I_H616_TPR11,
-		.tpr12 = CONFIG_DRAM_SUN50I_H616_TPR12,
-	};
+	struct dram_config config;
 	unsigned long size;
 
 	setbits_le32(&prcm->res_cal_ctrl, BIT(8));
 	clrbits_le32(&prcm->ohms240, 0x3f);
 
-	mctl_auto_detect_rank_width(&para);
-	mctl_auto_detect_dram_size(&para);
+	mctl_auto_detect_rank_width(&para, &config);
+	mctl_auto_detect_dram_size(&para, &config);
 
-	mctl_core_init(&para);
+	mctl_core_init(&para, &config);
 
-	size = mctl_calc_size(&para);
+	size = mctl_calc_size(&config);
 
 	mctl_set_master_priority();
 
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c	2023-11-11 14:18:55.276684876 +0100
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c	2023-11-11 14:17:00.673351160 +0100
@@ -15,7 +15,7 @@
 #include <asm/arch/dram.h>
 #include <asm/arch/cpu.h>
 
-void mctl_set_timing_params(struct dram_para *para)
+void mctl_set_timing_params(const struct dram_para *para)
 {
 	struct sunxi_mctl_ctl_reg * const mctl_ctl =
 			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c	2023-11-11 14:18:54.976684875 +0100
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr3.c	2023-11-11 14:17:00.673351160 +0100
@@ -15,7 +15,7 @@
 #include <asm/arch/dram.h>
 #include <asm/arch/cpu.h>
 
-void mctl_set_timing_params(struct dram_para *para)
+void mctl_set_timing_params(const struct dram_para *para)
 {
 	struct sunxi_mctl_ctl_reg * const mctl_ctl =
 			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr4_2133.c u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr4_2133.c
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr4_2133.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h616_lpddr4_2133.c	2023-11-11 14:06:57.516682458 +0100
@@ -0,0 +1,95 @@
+/*
+ * sun50i H616 LPDDR4-2133 timings, as programmed by Allwinner's boot0
+ * for orangepi zero3 with the H618 and LPDDR4 memory.
+ *
+ * (C) Copyright 2023 Mikhail Kalashnikov <iuncuim@gmail.com>
+ *   Based on H6 DDR3 timings:
+ *   (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/cpu.h>
+
+void mctl_set_timing_params(const struct dram_para *para)
+{
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+
+	u8 tccd		= 4;
+	u8 tfaw		= ns_to_t(40);
+	u8 trrd		= max(ns_to_t(10), 2);
+	u8 trcd		= max(ns_to_t(18), 2);
+	u8 trc		= ns_to_t(65);
+	u8 txp		= max(ns_to_t(8), 2);
+	u8 trtp		= max(ns_to_t(8), 4);
+	u8 trp		= ns_to_t(21);
+	u8 tras		= ns_to_t(42);
+	u16 trefi	= ns_to_t(3904) / 32;
+	u16 trfc	= ns_to_t(280);
+	u16 txsr	= ns_to_t(190);
+
+	u8 tmrw		= max(ns_to_t(14), 5);
+	u8 tmrd		= tmrw;
+	u8 tmod		= 12;
+	u8 tcke		= max(ns_to_t(15), 2);
+	u8 tcksrx	= max(ns_to_t(2), 2);
+	u8 tcksre	= max(ns_to_t(5), 2);
+	u8 tckesr	= tcke;
+	u8 trasmax	= (trefi * 9) / 32;
+	u8 txs		= 4;
+	u8 txsdll	= 16;
+	u8 txsabort	= 4;
+	u8 txsfast	= 4;
+	u8 tcl		= 10;
+	u8 tcwl		= 5;
+	u8 t_rdata_en	= 17;
+	u8 tphy_wrlat	= 5;
+
+	u8 twtp		= 24;
+	u8 twr2rd	= max(trrd, (u8)4) + 14;
+	u8 trd2wr	= (ns_to_t(4) + 17) - ns_to_t(1);
+
+	/* set DRAM timing */
+	writel((twtp << 24) | (tfaw << 16) | (trasmax << 8) | tras,
+	       &mctl_ctl->dramtmg[0]);
+	writel((txp << 16) | (trtp << 8) | trc, &mctl_ctl->dramtmg[1]);
+	writel((tcwl << 24) | (tcl << 16) | (trd2wr << 8) | twr2rd,
+	       &mctl_ctl->dramtmg[2]);
+	writel((tmrw << 20) | (tmrd << 12) | tmod, &mctl_ctl->dramtmg[3]);
+	writel((trcd << 24) | (tccd << 16) | (trrd << 8) | trp,
+	       &mctl_ctl->dramtmg[4]);
+	writel((tcksrx << 24) | (tcksre << 16) | (tckesr << 8) | tcke,
+	       &mctl_ctl->dramtmg[5]);
+	/* Value suggested by ZynqMP manual and used by libdram */
+	writel((txp + 2) | 0x02020000, &mctl_ctl->dramtmg[6]);
+	writel((txsfast << 24) | (txsabort << 16) | (txsdll << 8) | txs,
+	       &mctl_ctl->dramtmg[8]);
+	writel(0x00020208, &mctl_ctl->dramtmg[9]);
+	writel(0xE0C05, &mctl_ctl->dramtmg[10]);
+	writel(0x440C021C, &mctl_ctl->dramtmg[11]);
+	writel(8, &mctl_ctl->dramtmg[12]);
+	writel(0xA100002, &mctl_ctl->dramtmg[13]);
+	writel(txsr, &mctl_ctl->dramtmg[14]);
+
+	clrsetbits_le32(&mctl_ctl->init[0], 0xC0000FFF, 0x3f0);
+	writel(0x01f20000, &mctl_ctl->init[1]);
+	writel(0x00000d05, &mctl_ctl->init[2]);
+	writel(0, &mctl_ctl->dfimisc);
+	writel(0x0034001b, &mctl_ctl->init[3]);
+	writel(0x00330000, &mctl_ctl->init[4]);
+	writel(0x00040072, &mctl_ctl->init[6]);
+	writel(0x00240009, &mctl_ctl->init[7]);
+
+	clrsetbits_le32(&mctl_ctl->rankctl, 0xff0, 0x660);
+
+	/* Configure DFI timing */
+	writel(tphy_wrlat | 0x2000000 | (t_rdata_en << 16) | 0x808000,
+	       &mctl_ctl->dfitmg0);
+	writel(0x100202, &mctl_ctl->dfitmg1);
+
+	/* set refresh timing */
+	writel((trefi << 16) | trfc, &mctl_ctl->rfshtmg);
+}
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_ddr3_1333.c u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_ddr3_1333.c
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_ddr3_1333.c	2021-07-05 17:11:28.000000000 +0200
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_ddr3_1333.c	2023-11-11 14:17:00.673351160 +0100
@@ -38,7 +38,7 @@
 };
 
 /* TODO: flexible timing */
-void mctl_set_timing_params(struct dram_para *para)
+void mctl_set_timing_params(const struct dram_para *para)
 {
 	struct sunxi_mctl_ctl_reg * const mctl_ctl =
 			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_lpddr3.c u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_lpddr3.c
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_lpddr3.c	2021-07-05 17:11:28.000000000 +0200
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/h6_lpddr3.c	2023-11-11 14:17:00.673351160 +0100
@@ -17,7 +17,7 @@
 };
 
 /* TODO: flexible timing */
-void mctl_set_timing_params(struct dram_para *para)
+void mctl_set_timing_params(const struct dram_para *para)
 {
 	struct sunxi_mctl_ctl_reg * const mctl_ctl =
 			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/Makefile u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/Makefile
--- u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/Makefile	2023-11-11 14:18:54.976684875 +0100
+++ u-boot-2021.07/arch/arm/mach-sunxi/dram_timings/Makefile	2023-11-11 14:17:00.673351160 +0100
@@ -3,6 +3,6 @@
 obj-$(CONFIG_SUNXI_DRAM_DDR2_V3S)	+= ddr2_v3s.o
 obj-$(CONFIG_SUNXI_DRAM_H6_LPDDR3)	+= h6_lpddr3.o
 obj-$(CONFIG_SUNXI_DRAM_H6_DDR3_1333)	+= h6_ddr3_1333.o
-# currently only DDR3 is supported on H616
 obj-$(CONFIG_SUNXI_DRAM_H616_DDR3_1333)	+= h616_ddr3_1333.o
-obj-$(CONFIG_SUNXI_DRAM_H616_LPDDR3)	+= h616_lpddr3.o
\ No newline at end of file
+obj-$(CONFIG_SUNXI_DRAM_H616_LPDDR3)	+= h616_lpddr3.o
+obj-$(CONFIG_SUNXI_DRAM_H616_LPDDR4)	+= h616_lpddr4_2133.o
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/Kconfig u-boot-2021.07/arch/arm/mach-sunxi/Kconfig
--- u-boot-2021.07/arch/arm/mach-sunxi/Kconfig	2023-11-11 14:18:55.276684876 +0100
+++ u-boot-2021.07/arch/arm/mach-sunxi/Kconfig	2023-11-11 14:17:00.673351160 +0100
@@ -88,6 +88,12 @@
 	help
 	  TPR2 value from vendor DRAM settings.
 
+config DRAM_SUN50I_H616_TPR6
+	hex "H616 DRAM TPR6 parameter"
+	default 0x3300c080
+	---help---
+	TPR6 value from vendor DRAM settings.
+
 config DRAM_SUN50I_H616_TPR10
 	hex "H616 DRAM TPR10 parameter"
 	help
@@ -455,6 +461,9 @@
 config SUNXI_DRAM_LPDDR3
 	bool
 
+config SUNXI_DRAM_LPDDR4
+	bool
+
 choice
 	prompt "DRAM Type and Timing"
 	default SUNXI_DRAM_DDR3_1333 if !MACH_SUN8I_V3S
@@ -498,6 +507,14 @@
 	This option is the LPDDR3 timing used by the stock boot0 by
 	Allwinner.
 
+config SUNXI_DRAM_H616_LPDDR4
+	bool "LPDDR4 DRAM chips on the H616 DRAM controller"
+	select SUNXI_DRAM_LPDDR4
+	depends on DRAM_SUN50I_H616
+	help
+	  This option is the LPDDR4 timing used by the stock boot0 by
+	  Allwinner.
+
 config SUNXI_DRAM_H616_DDR3_1333
 	bool "DDR3-1333 boot0 timings on the H616 DRAM controller"
 	select SUNXI_DRAM_DDR3
@@ -591,6 +608,7 @@
 	configuring this parameter increases reliability at high DRAM
 	clock speeds.
 
+
 config DRAM_DQS_GATING_DELAY
 	hex "sunxi dram dqs_gating_delay value"
 	default 0
