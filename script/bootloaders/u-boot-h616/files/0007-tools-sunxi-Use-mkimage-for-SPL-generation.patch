
To be able to easily share the Allwinner eGON BROM header structure
between the tools and the SPL code, move the struct definition into a
separate header file.

Signed-off-by: Andre Przywara <andre.przywara@arm.com>
---
 arch/arm/include/asm/arch-sunxi/spl.h | 65 +--------------------
 include/sunxi_image.h                 | 81 +++++++++++++++++++++++++++
 2 files changed, 82 insertions(+), 64 deletions(-)
 create mode 100644 include/sunxi_image.h

diff --git a/arch/arm/include/asm/arch-sunxi/spl.h b/arch/arm/include/asm/arch-sunxi/spl.h
index 8c916e8c752..7b99c1aa12d 100644
--- a/arch/arm/include/asm/arch-sunxi/spl.h
+++ b/arch/arm/include/asm/arch-sunxi/spl.h
@@ -7,19 +7,7 @@
 #ifndef	_ASM_ARCH_SPL_H_
 #define	_ASM_ARCH_SPL_H_
 
-#define BOOT0_MAGIC		"eGON.BT0"
-#define SPL_SIGNATURE		"SPL" /* marks "sunxi" SPL header */
-#define SPL_MAJOR_BITS		3
-#define SPL_MINOR_BITS		5
-#define SPL_VERSION(maj, min)						\
-	((((maj) & ((1U << SPL_MAJOR_BITS) - 1)) << SPL_MINOR_BITS) | \
-	((min) & ((1U << SPL_MINOR_BITS) - 1)))
-
-#define SPL_HEADER_VERSION	SPL_VERSION(0, 2)
-
-#define SPL_ENV_HEADER_VERSION	SPL_VERSION(0, 1)
-#define SPL_DT_HEADER_VERSION	SPL_VERSION(0, 2)
-#define SPL_DRAM_HEADER_VERSION	SPL_VERSION(0, 3)
+#include <sunxi_image.h>
 
 #define SPL_ADDR		CONFIG_SUNXI_SRAM_ADDRESS
 
@@ -31,57 +19,6 @@
 #define SUNXI_BOOTED_FROM_MMC0_HIGH	0x10
 #define SUNXI_BOOTED_FROM_MMC2_HIGH	0x12
 
-/* boot head definition from sun4i boot code */
-struct boot_file_head {
-	uint32_t b_instruction;	/* one intruction jumping to real code */
-	uint8_t magic[8];	/* ="eGON.BT0" or "eGON.BT1", not C-style str */
-	uint32_t check_sum;	/* generated by PC */
-	uint32_t length;	/* generated by PC */
-	/*
-	 * We use a simplified header, only filling in what is needed
-	 * by the boot ROM. To be compatible with Allwinner tools we
-	 * would need to implement the proper fields here instead of
-	 * padding.
-	 *
-	 * Actually we want the ability to recognize our "sunxi" variant
-	 * of the SPL. To do so, let's place a special signature into the
-	 * "pub_head_size" field. We can reasonably expect Allwinner's
-	 * boot0 to always have the upper 16 bits of this set to 0 (after
-	 * all the value shouldn't be larger than the limit imposed by
-	 * SRAM size).
-	 * If the signature is present (at 0x14), then we know it's safe
-	 * to use the remaining 8 bytes (at 0x18) for our own purposes.
-	 * (E.g. sunxi-tools "fel" utility can pass information there.)
-	 */
-	union {
-		uint32_t pub_head_size;
-		uint8_t spl_signature[4];
-	};
-	uint32_t fel_script_address;	/* since v0.1, set by sunxi-fel */
-	/*
-	 * If the fel_uEnv_length member below is set to a non-zero value,
-	 * it specifies the size (byte count) of data at fel_script_address.
-	 * At the same time this indicates that the data is in uEnv.txt
-	 * compatible format, ready to be imported via "env import -t".
-	 */
-	uint32_t fel_uEnv_length;	/* since v0.1, set by sunxi-fel */
-	/*
-	 * Offset of an ASCIIZ string (relative to the SPL header), which
-	 * contains the default device tree name (CONFIG_DEFAULT_DEVICE_TREE).
-	 * This is optional and may be set to NULL. Is intended to be used
-	 * by flash programming tools for providing nice informative messages
-	 * to the users.
-	 */
-	uint32_t dt_name_offset;	/* since v0.2, set by mksunxiboot */
-	uint32_t dram_size;		/* in MiB, since v0.3, set by SPL */
-	uint32_t boot_media;		/* written here by the boot ROM */
-	/* A padding area (may be used for storing text strings) */
-	uint32_t string_pool[13];	/* since v0.2, filled by mksunxiboot */
-	/* The header must be a multiple of 32 bytes (for VBAR alignment) */
-};
-
-/* Compile time check to assure proper alignment of structure */
-typedef char boot_file_head_not_multiple_of_32[1 - 2*(sizeof(struct boot_file_head) % 32)];
 
 #define is_boot0_magic(addr)	(memcmp((void *)addr, BOOT0_MAGIC, 8) == 0)
 
diff --git a/include/sunxi_image.h b/include/sunxi_image.h
new file mode 100644
index 00000000000..d0d1290eb72
--- /dev/null
+++ b/include/sunxi_image.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * Constants and data structures used in Allwinner "eGON" images, as
+ * parsed by the Boot-ROM.
+ *
+ * Shared between mkimage and the SPL.
+ */
+#ifndef	SUNXI_IMAGE_H
+#define	SUNXI_IMAGE_H
+
+#define BOOT0_MAGIC		"eGON.BT0"
+#define SPL_SIGNATURE		"SPL" /* marks "sunxi" SPL header */
+#define SPL_MAJOR_BITS		3
+#define SPL_MINOR_BITS		5
+#define SPL_VERSION(maj, min)						\
+	((((maj) & ((1U << SPL_MAJOR_BITS) - 1)) << SPL_MINOR_BITS) | \
+	((min) & ((1U << SPL_MINOR_BITS) - 1)))
+
+#define SPL_HEADER_VERSION	SPL_VERSION(0, 2)
+
+#define SPL_ENV_HEADER_VERSION	SPL_VERSION(0, 1)
+#define SPL_DT_HEADER_VERSION	SPL_VERSION(0, 2)
+#define SPL_DRAM_HEADER_VERSION	SPL_VERSION(0, 3)
+
+/* boot head definition from sun4i boot code */
+struct boot_file_head {
+	uint32_t b_instruction;	/* one intruction jumping to real code */
+	uint8_t magic[8];	/* ="eGON.BT0" or "eGON.BT1", not C-style str */
+	uint32_t check_sum;	/* generated by PC */
+	uint32_t length;	/* generated by PC */
+	/*
+	 * We use a simplified header, only filling in what is needed
+	 * by the boot ROM. To be compatible with Allwinner tools we
+	 * would need to implement the proper fields here instead of
+	 * padding.
+	 *
+	 * Actually we want the ability to recognize our "sunxi" variant
+	 * of the SPL. To do so, let's place a special signature into the
+	 * "pub_head_size" field. We can reasonably expect Allwinner's
+	 * boot0 to always have the upper 16 bits of this set to 0 (after
+	 * all the value shouldn't be larger than the limit imposed by
+	 * SRAM size).
+	 * If the signature is present (at 0x14), then we know it's safe
+	 * to use the remaining 8 bytes (at 0x18) for our own purposes.
+	 * (E.g. sunxi-tools "fel" utility can pass information there.)
+	 */
+	union {
+		uint32_t pub_head_size;
+		uint8_t spl_signature[4];
+	};
+	uint32_t fel_script_address;	/* since v0.1, set by sunxi-fel */
+	/*
+	 * If the fel_uEnv_length member below is set to a non-zero value,
+	 * it specifies the size (byte count) of data at fel_script_address.
+	 * At the same time this indicates that the data is in uEnv.txt
+	 * compatible format, ready to be imported via "env import -t".
+	 */
+	uint32_t fel_uEnv_length;	/* since v0.1, set by sunxi-fel */
+	/*
+	 * Offset of an ASCIIZ string (relative to the SPL header), which
+	 * contains the default device tree name (CONFIG_DEFAULT_DEVICE_TREE).
+	 * This is optional and may be set to NULL. Is intended to be used
+	 * by flash programming tools for providing nice informative messages
+	 * to the users.
+	 */
+	uint32_t dt_name_offset;	/* since v0.2, set by mksunxiboot */
+	uint32_t dram_size;		/* in MiB, since v0.3, set by SPL */
+	uint32_t boot_media;		/* written here by the boot ROM */
+	/* A padding area (may be used for storing text strings) */
+	uint32_t string_pool[13];	/* since v0.2, filled by mksunxiboot */
+	/* The header must be a multiple of 32 bytes (for VBAR alignment) */
+};
+
+/* Compile time check to assure proper alignment of structure */
+typedef char boot_file_head_not_multiple_of_32[1 - 2*(sizeof(struct boot_file_head) % 32)];
+
+#endif


So far we used the separate mksunxiboot tool for generating a bootable
image for Allwinner SPLs, probably just for historical reasons.

Use the mkimage framework to generate a so called eGON image the
Allwinner BROM expects.
The new image type is called "sunxi_egon", to differentiate it
from the (still to be implemented) secure boot TOC0 image.

Signed-off-by: Andre Przywara <andre.przywara@arm.com>
---
 common/image.c        |   1 +
 include/image.h       |   1 +
 include/sunxi_image.h |   1 +
 tools/Makefile        |   1 +
 tools/sunxi_egon.c    | 136 ++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 140 insertions(+)
 create mode 100644 tools/sunxi_egon.c

diff --git a/common/image.c b/common/image.c
index 451fc689a89..6923dac7c07 100644
--- a/common/image.c
+++ b/common/image.c
@@ -189,6 +189,7 @@ static const table_entry_t uimage_type[] = {
 	{	IH_TYPE_STM32IMAGE, "stm32image", "STMicroelectronics STM32 Image" },
 	{	IH_TYPE_MTKIMAGE,   "mtk_image",   "MediaTek BootROM loadable Image" },
 	{	IH_TYPE_COPRO, "copro", "Coprocessor Image"},
+	{	IH_TYPE_SUNXI_EGON, "sunxi_egon",  "Allwinner eGON Boot Image" },
 	{	-1,		    "",		  "",			},
 };
 
diff --git a/include/image.h b/include/image.h
index 00bc03bebec..89bfca2155a 100644
--- a/include/image.h
+++ b/include/image.h
@@ -308,6 +308,7 @@ enum {
 	IH_TYPE_IMX8MIMAGE,		/* Freescale IMX8MBoot Image	*/
 	IH_TYPE_IMX8IMAGE,		/* Freescale IMX8Boot Image	*/
 	IH_TYPE_COPRO,			/* Coprocessor Image for remoteproc*/
+	IH_TYPE_SUNXI_EGON,		/* Allwinner eGON Boot Image */
 
 	IH_TYPE_COUNT,			/* Number of image types */
 };
diff --git a/include/sunxi_image.h b/include/sunxi_image.h
index d0d1290eb72..5b2055c0af3 100644
--- a/include/sunxi_image.h
+++ b/include/sunxi_image.h
@@ -13,6 +13,7 @@
 #define	SUNXI_IMAGE_H
 
 #define BOOT0_MAGIC		"eGON.BT0"
+#define BROM_STAMP_VALUE	0x5f0a6c39
 #define SPL_SIGNATURE		"SPL" /* marks "sunxi" SPL header */
 #define SPL_MAJOR_BITS		3
 #define SPL_MINOR_BITS		5
diff --git a/tools/Makefile b/tools/Makefile
index 14fb0ed98f6..9b1aa51b10a 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -104,6 +104,7 @@ dumpimage-mkimage-objs := aisimage.o \
 			stm32image.o \
 			$(ROCKCHIP_OBS) \
 			socfpgaimage.o \
+			sunxi_egon.o \
 			lib/crc16.o \
 			lib/sha1.o \
 			lib/sha256.o \
diff --git a/tools/sunxi_egon.c b/tools/sunxi_egon.c
new file mode 100644
index 00000000000..a5299eb6a11
--- /dev/null
+++ b/tools/sunxi_egon.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2018 Arm Ltd.
+ */
+
+#include "imagetool.h"
+#include <image.h>
+
+#include <sunxi_image.h>
+
+/*
+ * NAND requires 8K padding. SD/eMMC gets away with 512 bytes,
+ * but let's use the larger padding to cover both.
+ */
+#define PAD_SIZE			8192
+
+static int egon_check_params(struct image_tool_params *params)
+{
+	/* We just need a binary image file. */
+	return !params->dflag;
+}
+
+static int egon_verify_header(unsigned char *ptr, int image_size,
+			      struct image_tool_params *params)
+{
+	const struct boot_file_head *header = (void *)ptr;
+	uint32_t length;
+
+	/* First 4 bytes must be an ARM branch instruction. */
+	if ((le32_to_cpu(header->b_instruction) & 0xff000000) != 0xea000000)
+		return EXIT_FAILURE;
+
+	if (memcmp(header->magic, BOOT0_MAGIC, sizeof(header->magic)))
+		return EXIT_FAILURE;
+
+	length = le32_to_cpu(header->length);
+	/* Must be at least 512 byte aligned. */
+	if (length & 511)
+		return EXIT_FAILURE;
+
+	/*
+	 * Image could also contain U-Boot proper, so could be bigger.
+	 * But it must not be shorter.
+	 */
+	if (image_size < length)
+		return EXIT_FAILURE;
+
+	return EXIT_SUCCESS;
+}
+
+static void egon_print_header(const void *buf)
+{
+	const struct boot_file_head *header = buf;
+
+	printf("Allwinner eGON image, size: %d bytes\n",
+	       le32_to_cpu(header->length));
+
+	if (memcmp(header->spl_signature, SPL_SIGNATURE, 3))
+		return;
+
+	printf("\tSPL header version %d.%d\n",
+	       header->spl_signature[3] >> SPL_MINOR_BITS,
+	       header->spl_signature[3] & ((1U << SPL_MINOR_BITS) - 1));
+	if (header->spl_signature[3] >= SPL_DT_HEADER_VERSION) {
+		uint32_t dt_name_offs = le32_to_cpu(header->dt_name_offset);
+
+		if (dt_name_offs > 0)
+			printf("\tDT name: %s\n", (char *)buf + dt_name_offs);
+	}
+}
+
+static void egon_set_header(void *buf, struct stat *sbuf, int infd,
+			    struct image_tool_params *params)
+{
+	struct boot_file_head *header = buf;
+	uint32_t *buf32 = buf;
+	uint32_t checksum = 0, value;
+	int i;
+
+	/* Generate an ARM branch instruction to jump over the header. */
+	value = 0xea000000 | (sizeof(struct boot_file_head) / 4 - 2);
+	header->b_instruction = cpu_to_le32(value);
+
+	memcpy(header->magic, BOOT0_MAGIC, sizeof(header->magic));
+	header->check_sum = cpu_to_le32(BROM_STAMP_VALUE);
+	header->length = cpu_to_le32(params->file_size);
+
+	memcpy(header->spl_signature, SPL_SIGNATURE, 3);
+	header->spl_signature[3] = SPL_ENV_HEADER_VERSION;
+
+	/* If an image name has been provided, use it as the DT name. */
+	if (params->imagename && params->imagename[0]) {
+		if (strlen(params->imagename) > sizeof(header->string_pool) - 1)
+			printf("WARNING: DT name too long for SPL header!\n");
+		else {
+			strcpy((char *)header->string_pool, params->imagename);
+			value = offsetof(struct boot_file_head, string_pool);
+			header->dt_name_offset = cpu_to_le32(value);
+			header->spl_signature[3] = SPL_DT_HEADER_VERSION;
+		}
+	}
+
+	/* Calculate the checksum. Yes, it's that simple. */
+	for (i = 0; i < sbuf->st_size / 4; i++)
+		checksum += le32_to_cpu(buf32[i]);
+	header->check_sum = cpu_to_le32(checksum);
+}
+
+static int egon_check_image_type(uint8_t type)
+{
+	return type == IH_TYPE_SUNXI_EGON ? 0 : 1;
+}
+
+static int egon_vrec_header(struct image_tool_params *params,
+			    struct image_type_params *tparams)
+{
+	tparams->hdr = calloc(sizeof(struct boot_file_head), 1);
+
+	/* Return padding to 8K blocks. */
+	return ALIGN(params->file_size, PAD_SIZE) - params->file_size;
+}
+
+U_BOOT_IMAGE_TYPE(
+	sunxi_egon,
+	"Allwinner eGON Boot Image support",
+	sizeof(struct boot_file_head),
+	NULL,
+	egon_check_params,
+	egon_verify_header,
+	egon_print_header,
+	egon_set_header,
+	NULL,
+	egon_check_image_type,
+	NULL,
+	egon_vrec_header
+);


Switch the SPL boot image generation from using mksunxiboot to the new
sunxi_egon format of mkimage.

Verified to create identical results for all 152 Allwinner boards.

Signed-off-by: Andre Przywara <andre.przywara@arm.com>
---
 scripts/Makefile.spl | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/scripts/Makefile.spl b/scripts/Makefile.spl
index 9f1f7445d71..db95bd998a8 100644
--- a/scripts/Makefile.spl
+++ b/scripts/Makefile.spl
@@ -382,11 +382,11 @@ endif
 $(obj)/$(SPL_BIN).sfp: $(obj)/$(SPL_BIN).bin FORCE
 	$(call if_changed,mkimage)
 
-quiet_cmd_mksunxiboot = MKSUNXI $@
-cmd_mksunxiboot = $(objtree)/tools/mksunxiboot \
-			--default-dt $(CONFIG_DEFAULT_DEVICE_TREE) $< $@
+MKIMAGEFLAGS_sunxi-spl.bin = -T sunxi_egon \
+	-n $(CONFIG_DEFAULT_DEVICE_TREE)
+
 $(obj)/sunxi-spl.bin: $(obj)/$(SPL_BIN).bin FORCE
-	$(call if_changed,mksunxiboot)
+	$(call if_changed,mkimage)
 
 quiet_cmd_sunxi_spl_image_builder = SUNXI_SPL_IMAGE_BUILDER $@
 cmd_sunxi_spl_image_builder = $(objtree)/tools/sunxi-spl-image-builder \
