From 54f08a53c97e6d4de19c57080449a9cf44cf50b1 Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@siol.net>
Date: Wed, 4 Nov 2020 22:24:45 +0100
Subject: [PATCH 03/13] h616 wip

---
 arch/arm/dts/Makefile                         |    2 +
 arch/arm/include/asm/arch-sunxi/boot0.h       |    2 +-
 arch/arm/include/asm/arch-sunxi/clock.h       |    2 +-
 .../include/asm/arch-sunxi/clock_sun50i_h6.h  |   28 +-
 arch/arm/include/asm/arch-sunxi/cpu.h         |    2 +-
 .../include/asm/arch-sunxi/cpu_sun50i_h6.h    |    7 +
 arch/arm/include/asm/arch-sunxi/dram.h        |    2 +
 .../include/asm/arch-sunxi/dram_sun50i_h616.h |  141 +++
 arch/arm/include/asm/arch-sunxi/gpio.h        |    2 +
 arch/arm/include/asm/arch-sunxi/prcm.h        |  247 +---
 arch/arm/include/asm/arch-sunxi/prcm_sun50i.h |   41 +
 arch/arm/include/asm/arch-sunxi/prcm_sun6i.h  |  247 ++++
 arch/arm/mach-sunxi/Kconfig                   |   30 +-
 arch/arm/mach-sunxi/Makefile                  |    3 +
 arch/arm/mach-sunxi/board.c                   |    6 +-
 arch/arm/mach-sunxi/clock.c                   |    4 +-
 arch/arm/mach-sunxi/clock_sun50i_h6.c         |   45 +-
 arch/arm/mach-sunxi/cpu_info.c                |    2 +
 arch/arm/mach-sunxi/dram_sun50i_h616.c        | 1014 +++++++++++++++++
 arch/arm/mach-sunxi/dram_timings/Makefile     |    2 +
 .../mach-sunxi/dram_timings/h616_ddr3_1333.c  |  105 ++
 arch/arm/mach-sunxi/pmic_bus.c                |    6 +
 arch/arm/mach-sunxi/rmr_switch.S              |    2 +-
 board/sunxi/board.c                           |   20 +-
 common/spl/Kconfig                            |    4 +-
 configs/tanix_tx6s_defconfig                  |   10 +
 drivers/clk/sunxi/Kconfig                     |    2 +-
 drivers/mmc/sunxi_mmc.c                       |   12 +-
 drivers/power/Kconfig                         |   19 +
 drivers/power/Makefile                        |    1 +
 drivers/power/axp305.c                        |   78 ++
 include/axp305.h                              |   17 +
 include/axp_pmic.h                            |    4 +
 include/configs/sun50i.h                      |    2 +-
 include/configs/sunxi-common.h                |    5 +
 35 files changed, 1850 insertions(+), 266 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/prcm_sun50i.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/prcm_sun6i.h
 create mode 100644 arch/arm/mach-sunxi/dram_sun50i_h616.c
 create mode 100644 arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c
 create mode 100644 configs/tanix_tx6s_defconfig
 create mode 100644 drivers/power/axp305.c
 create mode 100644 include/axp305.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index 7d1a3698..4bd1bbbd 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -605,6 +605,8 @@ dtb-$(CONFIG_MACH_SUN50I_H6) += \
 	sun50i-h6-orangepi-lite2.dtb \
 	sun50i-h6-orangepi-one-plus.dtb \
 	sun50i-h6-pine-h64.dtb
+dtb-$(CONFIG_MACH_SUN50I_H616) += \
+	sun50i-h6-orangepi-lite2.dtb
 dtb-$(CONFIG_MACH_SUN50I) += \
 	sun50i-a64-amarula-relic.dtb \
 	sun50i-a64-bananapi-m64.dtb \
diff --git a/arch/arm/include/asm/arch-sunxi/boot0.h b/arch/arm/include/asm/arch-sunxi/boot0.h
index 46d0f066..fa9fc9c5 100644
--- a/arch/arm/include/asm/arch-sunxi/boot0.h
+++ b/arch/arm/include/asm/arch-sunxi/boot0.h
@@ -39,7 +39,7 @@
 	.word	0xf57ff06f	// isb     sy
 	.word	0xe320f003	// wfi
 	.word	0xeafffffd	// b       @wfi
-#ifndef CONFIG_MACH_SUN50I_H6
+#if !defined(CONFIG_MACH_SUN50I_H6) && !defined(CONFIG_MACH_SUN50I_H616)
 	.word	0x017000a0	// writeable RVBAR mapping address
 #else
 	.word	0x09010040	// writeable RVBAR mapping address
diff --git a/arch/arm/include/asm/arch-sunxi/clock.h b/arch/arm/include/asm/arch-sunxi/clock.h
index 5994130e..9aa55fda 100644
--- a/arch/arm/include/asm/arch-sunxi/clock.h
+++ b/arch/arm/include/asm/arch-sunxi/clock.h
@@ -16,7 +16,7 @@
 /* clock control module regs definition */
 #if defined(CONFIG_MACH_SUN8I_A83T)
 #include <asm/arch/clock_sun8i_a83t.h>
-#elif defined(CONFIG_MACH_SUN50I_H6)
+#elif defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 #include <asm/arch/clock_sun50i_h6.h>
 #elif defined(CONFIG_MACH_SUN6I) || defined(CONFIG_MACH_SUN8I) || \
       defined(CONFIG_MACH_SUN50I)
diff --git a/arch/arm/include/asm/arch-sunxi/clock_sun50i_h6.h b/arch/arm/include/asm/arch-sunxi/clock_sun50i_h6.h
index 426069fc..8e4345f9 100644
--- a/arch/arm/include/asm/arch-sunxi/clock_sun50i_h6.h
+++ b/arch/arm/include/asm/arch-sunxi/clock_sun50i_h6.h
@@ -230,6 +230,7 @@ struct sunxi_ccm_reg {
 #define CCM_PLL1_CTRL_EN		BIT(31)
 #define CCM_PLL1_LOCK_EN		BIT(29)
 #define CCM_PLL1_LOCK			BIT(28)
+#define CCM_PLL1_OUT_EN			BIT(27)
 #define CCM_PLL1_CLOCK_TIME_2		(2 << 24)
 #define CCM_PLL1_CTRL_P(p)		((p) << 16)
 #define CCM_PLL1_CTRL_N(n)		((n) << 8)
@@ -238,6 +239,7 @@ struct sunxi_ccm_reg {
 #define CCM_PLL5_CTRL_EN		BIT(31)
 #define CCM_PLL5_LOCK_EN		BIT(29)
 #define CCM_PLL5_LOCK			BIT(28)
+#define CCM_PLL5_OUT_EN			BIT(27)
 #define CCM_PLL5_CTRL_N(n)		((n) << 8)
 #define CCM_PLL5_CTRL_DIV1(div1)	((div1) << 0)
 #define CCM_PLL5_CTRL_DIV2(div0)	((div0) << 1)
@@ -252,7 +254,6 @@ struct sunxi_ccm_reg {
 #define CCM_PLL6_CTRL_DIV1_MASK		(0x1 << CCM_PLL6_CTRL_DIV1_SHIFT)
 #define CCM_PLL6_CTRL_DIV2_SHIFT	1
 #define CCM_PLL6_CTRL_DIV2_MASK		(0x1 << CCM_PLL6_CTRL_DIV2_SHIFT)
-#define CCM_PLL6_DEFAULT		0xa0006300
 
 /* cpu_axi bit field*/
 #define CCM_CPU_AXI_MUX_MASK		(0x3 << 24)
@@ -262,6 +263,9 @@ struct sunxi_ccm_reg {
 #define CCM_CPU_AXI_AXI_MASK		0x3
 #define CCM_CPU_AXI_DEFAULT_FACTORS	0x301
 
+#ifdef CONFIG_MACH_SUN50I_H6
+#define CCM_PLL6_DEFAULT		0xa0006300
+
 /* psi_ahb1_ahb2 bit field */
 #define CCM_PSI_AHB1_AHB2_DEFAULT	0x03000102
 
@@ -270,6 +274,18 @@ struct sunxi_ccm_reg {
 
 /* apb1 bit field */
 #define CCM_APB1_DEFAULT		0x03000102
+#elif CONFIG_MACH_SUN50I_H616
+#define CCM_PLL6_DEFAULT		0xa8003100
+
+/* psi_ahb1_ahb2 bit field */
+#define CCM_PSI_AHB1_AHB2_DEFAULT	0x03000002
+
+/* ahb3 bit field */
+#define CCM_AHB3_DEFAULT		0x03000002
+
+/* apb1 bit field */
+#define CCM_APB1_DEFAULT		0x03000102
+#endif
 
 /* apb2 bit field */
 #define APB2_CLK_SRC_OSC24M		(0x0 << 24)
@@ -305,6 +321,10 @@ struct sunxi_ccm_reg {
 #define DRAM_CLK_SRC_PLL5		(0 << 24)
 #define DRAM_CLK_M(m)			(((m)-1) << 0)
 
+/* DRAM gate and reset bit field */
+#define DRAM_RESET			BIT(16)
+#define DRAM_ENABLE			BIT(0)
+
 /* MMC clock bit field */
 #define CCM_MMC_CTRL_M(x)		((x) - 1)
 #define CCM_MMC_CTRL_N(x)		((x) << 8)
@@ -312,10 +332,14 @@ struct sunxi_ccm_reg {
 #define CCM_MMC_CTRL_PLL6X2		(0x1 << 24)
 #define CCM_MMC_CTRL_PLL_PERIPH2X2	(0x2 << 24)
 #define CCM_MMC_CTRL_ENABLE		(0x1 << 31)
-/* H6 doesn't have these delays */
+/* H6 and H616 don't have these delays */
 #define CCM_MMC_CTRL_OCLK_DLY(a)	((void) (a), 0)
 #define CCM_MMC_CTRL_SCLK_DLY(a)	((void) (a), 0)
 
+/* TWI gate and reset fields */
+#define CCM_TWI_GATE_SHIFT		(0)
+#define CCM_TWI_RESET_SHIFT		(16)
+
 #ifndef __ASSEMBLY__
 void clock_set_pll1(unsigned int hz);
 unsigned int clock_get_pll6(void);
diff --git a/arch/arm/include/asm/arch-sunxi/cpu.h b/arch/arm/include/asm/arch-sunxi/cpu.h
index 8b57d24e..e909d502 100644
--- a/arch/arm/include/asm/arch-sunxi/cpu.h
+++ b/arch/arm/include/asm/arch-sunxi/cpu.h
@@ -8,7 +8,7 @@
 
 #if defined(CONFIG_MACH_SUN9I)
 #include <asm/arch/cpu_sun9i.h>
-#elif defined(CONFIG_MACH_SUN50I_H6)
+#elif defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 #include <asm/arch/cpu_sun50i_h6.h>
 #else
 #include <asm/arch/cpu_sun4i.h>
diff --git a/arch/arm/include/asm/arch-sunxi/cpu_sun50i_h6.h b/arch/arm/include/asm/arch-sunxi/cpu_sun50i_h6.h
index 6392cb07..d9cf8ae0 100644
--- a/arch/arm/include/asm/arch-sunxi/cpu_sun50i_h6.h
+++ b/arch/arm/include/asm/arch-sunxi/cpu_sun50i_h6.h
@@ -28,13 +28,20 @@
 #define SUNXI_GIC400_BASE		0x03020000
 #define SUNXI_IOMMU_BASE		0x030F0000
 
+#ifdef CONFIG_MACH_SUN50I_H6
 #define SUNXI_DRAM_COM_BASE		0x04002000
 #define SUNXI_DRAM_CTL0_BASE		0x04003000
 #define SUNXI_DRAM_PHY0_BASE		0x04005000
+#endif
 #define SUNXI_NFC_BASE			0x04011000
 #define SUNXI_MMC0_BASE			0x04020000
 #define SUNXI_MMC1_BASE			0x04021000
 #define SUNXI_MMC2_BASE			0x04022000
+#ifdef CONFIG_MACH_SUN50I_H616
+#define SUNXI_DRAM_COM_BASE		0x047FA000
+#define SUNXI_DRAM_CTL0_BASE		0x047FB000
+#define SUNXI_DRAM_PHY0_BASE		0x04800000
+#endif
 
 #define SUNXI_UART0_BASE		0x05000000
 #define SUNXI_UART1_BASE		0x05000400
diff --git a/arch/arm/include/asm/arch-sunxi/dram.h b/arch/arm/include/asm/arch-sunxi/dram.h
index 8002b7ef..c3b3e1f5 100644
--- a/arch/arm/include/asm/arch-sunxi/dram.h
+++ b/arch/arm/include/asm/arch-sunxi/dram.h
@@ -29,6 +29,8 @@
 #include <asm/arch/dram_sun9i.h>
 #elif defined(CONFIG_MACH_SUN50I_H6)
 #include <asm/arch/dram_sun50i_h6.h>
+#elif defined(CONFIG_MACH_SUN50I_H616)
+#include <asm/arch/dram_sun50i_h616.h>
 #else
 #include <asm/arch/dram_sun4i.h>
 #endif
diff --git a/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h b/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
new file mode 100644
index 00000000..3aeace5b
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/dram_sun50i_h616.h
@@ -0,0 +1,141 @@
+/*
+ * H616 dram controller register and constant defines
+ *
+ * (C) Copyright 2020  Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * Based on H6 one, which is:
+ * (C) Copyright 2017  Icenowy Zheng <icenowy@aosc.io>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_DRAM_SUN50I_H616_H
+#define _SUNXI_DRAM_SUN50I_H616_H
+
+#include <stdbool.h>
+#ifndef __ASSEMBLY__
+#include <linux/bitops.h>
+#endif
+
+enum sunxi_dram_type {
+	SUNXI_DRAM_TYPE_DDR3 = 3,
+	SUNXI_DRAM_TYPE_DDR4,
+	SUNXI_DRAM_TYPE_LPDDR3 = 7,
+	SUNXI_DRAM_TYPE_LPDDR4
+};
+
+/* MBUS part is largely the same as in H6, except for one special register */
+struct sunxi_mctl_com_reg {
+	u32 cr;			/* 0x000 control register */
+	u8 reserved_0x004[4];	/* 0x004 */
+	u32 unk_0x008;		/* 0x008 */
+	u32 tmr;		/* 0x00c timer register */
+	u8 reserved_0x010[4];	/* 0x010 */
+	u32 unk_0x014;		/* 0x014 */
+	u8 reserved_0x018[8];	/* 0x018 */
+	u32 maer0;		/* 0x020 master enable register 0 */
+	u32 maer1;		/* 0x024 master enable register 1 */
+	u32 maer2;		/* 0x028 master enable register 2 */
+	u8 reserved_0x02c[468];	/* 0x02c */
+	u32 bwcr;		/* 0x200 bandwidth control register */
+	u8 reserved_0x204[12];	/* 0x204 */
+	/*
+	 * The last master configured by BSP libdram is at 0x49x, so the
+	 * size of this struct array is set to 41 (0x29) now.
+	 */
+	struct {
+		u32 cfg0;		/* 0x0 */
+		u32 cfg1;		/* 0x4 */
+		u8 reserved_0x8[8];	/* 0x8 */
+	} master[41];		/* 0x210 + index * 0x10 */
+};
+check_member(sunxi_mctl_com_reg, master[40].reserved_0x8, 0x498);
+
+/* controller registers seems to be the same as in H6 */
+struct sunxi_mctl_ctl_reg {
+	u32 mstr;		/* 0x000 */
+	u32 statr;		/* 0x004 unused */
+	u32 mstr1;		/* 0x008 unused */
+	u32 unk_0x00c;		/* 0x00c */
+	u32 mrctrl0;		/* 0x010 unused */
+	u32 mrctrl1;		/* 0x014 unused */
+	u32 mrstatr;		/* 0x018 unused */
+	u32 mrctrl2;		/* 0x01c unused */
+	u32 derateen;		/* 0x020 unused */
+	u32 derateint;		/* 0x024 unused */
+	u8 reserved_0x028[8];	/* 0x028 */
+	u32 pwrctl;		/* 0x030 unused */
+	u32 pwrtmg;		/* 0x034 unused */
+	u32 hwlpctl;		/* 0x038 unused */
+	u8 reserved_0x03c[20];	/* 0x03c */
+	u32 rfshctl0;		/* 0x050 unused */
+	u32 rfshctl1;		/* 0x054 unused */
+	u8 reserved_0x058[8];	/* 0x05c */
+	u32 rfshctl3;		/* 0x060 */
+	u32 rfshtmg;		/* 0x064 */
+	u8 reserved_0x068[104];	/* 0x068 */
+	u32 init[8];		/* 0x0d0 */
+	u32 dimmctl;		/* 0x0f0 unused */
+	u32 rankctl;		/* 0x0f4 */
+	u8 reserved_0x0f8[8];	/* 0x0f8 */
+	u32 dramtmg[17];	/* 0x100 */
+	u8 reserved_0x144[60];	/* 0x144 */
+	u32 zqctl[3];		/* 0x180 */
+	u32 zqstat;		/* 0x18c unused */
+	u32 dfitmg0;		/* 0x190 */
+	u32 dfitmg1;		/* 0x194 */
+	u32 dfilpcfg[2];	/* 0x198 unused */
+	u32 dfiupd[3];		/* 0x1a0 */
+	u32 reserved_0x1ac;	/* 0x1ac */
+	u32 dfimisc;		/* 0x1b0 */
+	u32 dfitmg2;		/* 0x1b4 unused */
+	u32 dfitmg3;		/* 0x1b8 unused */
+	u32 dfistat;		/* 0x1bc */
+	u32 dbictl;		/* 0x1c0 */
+	u8 reserved_0x1c4[60];	/* 0x1c4 */
+	u32 addrmap[12];	/* 0x200 */
+	u8 reserved_0x230[16];	/* 0x230 */
+	u32 odtcfg;		/* 0x240 */
+	u32 odtmap;		/* 0x244 */
+	u8 reserved_0x248[8];	/* 0x248 */
+	u32 sched[2];		/* 0x250 */
+	u8 reserved_0x258[180];	/* 0x258 */
+	u32 dbgcmd;		/* 0x30c unused */
+	u32 dbgstat;		/* 0x310 unused */
+	u8 reserved_0x314[12];	/* 0x314 */
+	u32 swctl;		/* 0x320 */
+	u32 swstat;		/* 0x324 */
+};
+check_member(sunxi_mctl_ctl_reg, swstat, 0x324);
+
+#define MSTR_DEVICETYPE_DDR3	BIT(0)
+#define MSTR_DEVICETYPE_LPDDR2	BIT(2)
+#define MSTR_DEVICETYPE_LPDDR3	BIT(3)
+#define MSTR_DEVICETYPE_DDR4	BIT(4)
+#define MSTR_DEVICETYPE_MASK	GENMASK(5, 0)
+#define MSTR_2TMODE		BIT(10)
+#define MSTR_BUSWIDTH_FULL	(0 << 12)
+#define MSTR_BUSWIDTH_HALF	(1 << 12)
+#define MSTR_ACTIVE_RANKS(x)	(((x == 2) ? 3 : 1) << 24)
+#define MSTR_BURST_LENGTH(x)	(((x) >> 1) << 16)
+
+struct dram_para {
+	u32 clk;
+	enum sunxi_dram_type type;
+	u8 cols;
+	u8 rows;
+	u8 ranks;
+	u8 bus_full_width;
+};
+
+
+static inline int ns_to_t(int nanoseconds)
+{
+	const unsigned int ctrl_freq = CONFIG_DRAM_CLK / 2;
+
+	return DIV_ROUND_UP(ctrl_freq * nanoseconds, 1000);
+}
+
+void mctl_set_timing_params(struct dram_para *para);
+
+#endif /* _SUNXI_DRAM_SUN50I_H616_H */
diff --git a/arch/arm/include/asm/arch-sunxi/gpio.h b/arch/arm/include/asm/arch-sunxi/gpio.h
index f817d328..de77bf63 100644
--- a/arch/arm/include/asm/arch-sunxi/gpio.h
+++ b/arch/arm/include/asm/arch-sunxi/gpio.h
@@ -206,6 +206,7 @@ enum sunxi_gpio_number {
 #define SUN6I_GPH_UART0		2
 #define SUN9I_GPH_UART0		2
 #define SUN50I_H6_GPH_UART0	2
+#define SUN50I_H616_GPH_UART0	2
 
 #define SUNXI_GPI_SDC3		2
 #define SUN7I_GPI_TWI3		3
@@ -219,6 +220,7 @@ enum sunxi_gpio_number {
 #define SUN8I_A23_GPL_R_TWI	3
 #define SUN8I_GPL_R_UART	2
 #define SUN50I_GPL_R_TWI	2
+#define SUN50I_H616_GPL_R_TWI	3
 
 #define SUN9I_GPN_R_RSB		3
 
diff --git a/arch/arm/include/asm/arch-sunxi/prcm.h b/arch/arm/include/asm/arch-sunxi/prcm.h
index 767d1ff9..6c3bb30b 100644
--- a/arch/arm/include/asm/arch-sunxi/prcm.h
+++ b/arch/arm/include/asm/arch-sunxi/prcm.h
@@ -1,247 +1,18 @@
 /* SPDX-License-Identifier: GPL-2.0+ */
 /*
- * Sunxi A31 Power Management Unit register definition.
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
  *
- * (C) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
- * http://linux-sunxi.org
- * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
- * Berg Xing <bergxing@allwinnertech.com>
- * Tom Cubie <tangliang@allwinnertech.com>
+ * Sunxi platform prcm register definition.
  */
 
 #ifndef _SUNXI_PRCM_H
 #define _SUNXI_PRCM_H
 
-#define __PRCM_CPUS_CFG_PRE(n) (((n) & 0x3) << 4)
-#define PRCM_CPUS_CFG_PRE_MASK __PRCM_CPUS_CFG_PRE(0x3)
-#define __PRCM_CPUS_CFG_PRE_DIV(n) (((n) >> 1) - 1)
-#define PRCM_CPUS_CFG_PRE_DIV(n) \
-	__PRCM_CPUS_CFG_PRE(__PRCM_CPUS_CFG_CLK_PRE(n))
-#define __PRCM_CPUS_CFG_POST(n) (((n) & 0x1f) << 8)
-#define PRCM_CPUS_CFG_POST_MASK __PRCM_CPUS_CFG_POST(0x1f)
-#define __PRCM_CPUS_CFG_POST_DIV(n) ((n) - 1)
-#define PRCM_CPUS_CFG_POST_DIV(n) \
-	__PRCM_CPUS_CFG_POST_DIV(__PRCM_CPUS_CFG_POST_DIV(n))
-#define __PRCM_CPUS_CFG_CLK_SRC(n) (((n) & 0x3) << 16)
-#define PRCM_CPUS_CFG_CLK_SRC_MASK __PRCM_CPUS_CFG_CLK_SRC(0x3)
-#define __PRCM_CPUS_CFG_CLK_SRC_LOSC 0x0
-#define __PRCM_CPUS_CFG_CLK_SRC_HOSC 0x1
-#define __PRCM_CPUS_CFG_CLK_SRC_PLL6 0x2
-#define __PRCM_CPUS_CFG_CLK_SRC_PDIV 0x3
-#define PRCM_CPUS_CFG_CLK_SRC_LOSC \
-	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_LOSC)
-#define PRCM_CPUS_CFG_CLK_SRC_HOSC \
-	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_HOSC)
-#define PRCM_CPUS_CFG_CLK_SRC_PLL6 \
-	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_PLL6)
-#define PRCM_CPUS_CFG_CLK_SRC_PDIV \
-	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_PDIV)
+/* prcm regs definition */
+#if defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
+#include <asm/arch/prcm_sun50i.h>
+#else
+#include <asm/arch/prcm_sun6i.h>
+#endif
 
-#define __PRCM_APB0_RATIO(n) (((n) & 0x3) << 0)
-#define PRCM_APB0_RATIO_DIV_MASK __PRCM_APB0_RATIO_DIV(0x3)
-#define __PRCM_APB0_RATIO_DIV(n) (((n) >> 1) - 1)
-#define PRCM_APB0_RATIO_DIV(n) \
-	__PRCM_APB0_RATIO(__PRCM_APB0_RATIO_DIV(n))
-
-#define PRCM_CPU_CFG_NEON_CLK_EN (0x1 << 0)
-#define PRCM_CPU_CFG_CPU_CLK_EN (0x1 << 1)
-
-#define PRCM_APB0_GATE_PIO (0x1 << 0)
-#define PRCM_APB0_GATE_IR (0x1 << 1)
-#define PRCM_APB0_GATE_TIMER01 (0x1 << 2)
-#define PRCM_APB0_GATE_P2WI (0x1 << 3)		/* sun6i */
-#define PRCM_APB0_GATE_RSB (0x1 << 3)		/* sun8i */
-#define PRCM_APB0_GATE_UART (0x1 << 4)
-#define PRCM_APB0_GATE_1WIRE (0x1 << 5)
-#define PRCM_APB0_GATE_I2C (0x1 << 6)
-
-#define PRCM_APB0_RESET_PIO (0x1 << 0)
-#define PRCM_APB0_RESET_IR (0x1 << 1)
-#define PRCM_APB0_RESET_TIMER01 (0x1 << 2)
-#define PRCM_APB0_RESET_P2WI (0x1 << 3)
-#define PRCM_APB0_RESET_UART (0x1 << 4)
-#define PRCM_APB0_RESET_1WIRE (0x1 << 5)
-#define PRCM_APB0_RESET_I2C (0x1 << 6)
-
-#define PRCM_PLL_CTRL_PLL_BIAS (0x1 << 0)
-#define PRCM_PLL_CTRL_HOSC_GAIN_ENH (0x1 << 1)
-#define __PRCM_PLL_CTRL_USB_CLK_SRC(n) (((n) & 0x3) << 4)
-#define PRCM_PLL_CTRL_USB_CLK_SRC_MASK \
-	__PRCM_PLL_CTRL_USB_CLK_SRC(0x3)
-#define __PRCM_PLL_CTRL_USB_CLK_0 0x0
-#define __PRCM_PLL_CTRL_USB_CLK_1 0x1
-#define __PRCM_PLL_CTRL_USB_CLK_2 0x2
-#define __PRCM_PLL_CTRL_USB_CLK_3 0x3
-#define PRCM_PLL_CTRL_USB_CLK_0 \
-	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_0)
-#define PRCM_PLL_CTRL_USB_CLK_1 \
-	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_1)
-#define PRCM_PLL_CTRL_USB_CLK_2 \
-	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_2)
-#define PRCM_PLL_CTRL_USB_CLK_3 \
-	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_3)
-#define __PRCM_PLL_CTRL_INT_PLL_IN_SEL(n) (((n) & 0x3) << 12)
-#define PRCM_PLL_CTRL_INT_PLL_IN_SEL_MASK \
-	__PRCM_PLL_CTRL_INT_PLL_IN_SEL(0x3)
-#define PRCM_PLL_CTRL_INT_PLL_IN_SEL(n) \
-	__PRCM_PLL_CTRL_INT_PLL_IN_SEL(n)
-#define __PRCM_PLL_CTRL_HOSC_CLK_SEL(n) (((n) & 0x3) << 20)
-#define PRCM_PLL_CTRL_HOSC_CLK_SEL_MASK \
-	__PRCM_PLL_CTRL_HOSC_CLK_SEL(0x3)
-#define __PRCM_PLL_CTRL_HOSC_CLK_0 0x0
-#define __PRCM_PLL_CTRL_HOSC_CLK_1 0x1
-#define __PRCM_PLL_CTRL_HOSC_CLK_2 0x2
-#define __PRCM_PLL_CTRL_HOSC_CLK_3 0x3
-#define PRCM_PLL_CTRL_HOSC_CLK_0 \
-	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_0)
-#define PRCM_PLL_CTRL_HOSC_CLK_1 \
-	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_1)
-#define PRCM_PLL_CTRL_HOSC_CLK_2 \
-	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_2)
-#define PRCM_PLL_CTRL_HOSC_CLK_3 \
-	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_3)
-#define PRCM_PLL_CTRL_PLL_TST_SRC_EXT (0x1 << 24)
-#define PRCM_PLL_CTRL_LDO_DIGITAL_EN (0x1 << 0)
-#define PRCM_PLL_CTRL_LDO_ANALOG_EN (0x1 << 1)
-#define PRCM_PLL_CTRL_EXT_OSC_EN (0x1 << 2)
-#define PRCM_PLL_CTRL_CLK_TST_EN (0x1 << 3)
-#define PRCM_PLL_CTRL_IN_PWR_HIGH (0x1 << 15) /* 3.3 for hi 2.5 for lo */
-#define __PRCM_PLL_CTRL_VDD_LDO_OUT(n) (((n) & 0x7) << 16)
-#define PRCM_PLL_CTRL_LDO_OUT_MASK \
-	__PRCM_PLL_CTRL_LDO_OUT(0x7)
-/* When using the low voltage 20 mV steps, and high voltage 30 mV steps */
-#define PRCM_PLL_CTRL_LDO_OUT_L(n) \
-	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) - 1000) / 20) & 0x7)
-#define PRCM_PLL_CTRL_LDO_OUT_H(n) \
-	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) - 1160) / 30) & 0x7)
-#define PRCM_PLL_CTRL_LDO_OUT_LV(n) \
-	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) & 0x7) * 20) + 1000)
-#define PRCM_PLL_CTRL_LDO_OUT_HV(n) \
-	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) & 0x7) * 30) + 1160)
-#define PRCM_PLL_CTRL_LDO_KEY (0xa7 << 24)
-#define PRCM_PLL_CTRL_LDO_KEY_MASK (0xff << 24)
-
-#define PRCM_CLK_1WIRE_GATE (0x1 << 31)
-
-#define __PRCM_CLK_MOD0_M(n) (((n) & 0xf) << 0)
-#define PRCM_CLK_MOD0_M_MASK __PRCM_CLK_MOD0_M(0xf)
-#define __PRCM_CLK_MOD0_M_X(n) (n - 1)
-#define PRCM_CLK_MOD0_M(n) __PRCM_CLK_MOD0_M(__PRCM_CLK_MOD0_M_X(n))
-#define PRCM_CLK_MOD0_OUT_PHASE(n) (((n) & 0x7) << 8)
-#define PRCM_CLK_MOD0_OUT_PHASE_MASK(n) PRCM_CLK_MOD0_OUT_PHASE(0x7)
-#define _PRCM_CLK_MOD0_N(n) (((n) & 0x3) << 16)
-#define PRCM_CLK_MOD0_N_MASK __PRCM_CLK_MOD_N(0x3)
-#define __PRCM_CLK_MOD0_N_X(n) (((n) >> 1) - 1)
-#define PRCM_CLK_MOD0_N(n) __PRCM_CLK_MOD0_N(__PRCM_CLK_MOD0_N_X(n))
-#define PRCM_CLK_MOD0_SMPL_PHASE(n) (((n) & 0x7) << 20)
-#define PRCM_CLK_MOD0_SMPL_PHASE_MASK PRCM_CLK_MOD0_SMPL_PHASE(0x7)
-#define PRCM_CLK_MOD0_SRC_SEL(n) (((n) & 0x7) << 24)
-#define PRCM_CLK_MOD0_SRC_SEL_MASK PRCM_CLK_MOD0_SRC_SEL(0x7)
-#define PRCM_CLK_MOD0_GATE_EN (0x1 << 31)
-
-#define PRCM_APB0_RESET_PIO (0x1 << 0)
-#define PRCM_APB0_RESET_IR (0x1 << 1)
-#define PRCM_APB0_RESET_TIMER01 (0x1 << 2)
-#define PRCM_APB0_RESET_P2WI (0x1 << 3)
-#define PRCM_APB0_RESET_UART (0x1 << 4)
-#define PRCM_APB0_RESET_1WIRE (0x1 << 5)
-#define PRCM_APB0_RESET_I2C (0x1 << 6)
-
-#define __PRCM_CLK_OUTD_M(n) (((n) & 0x7) << 8)
-#define PRCM_CLK_OUTD_M_MASK __PRCM_CLK_OUTD_M(0x7)
-#define __PRCM_CLK_OUTD_M_X() ((n) - 1)
-#define PRCM_CLK_OUTD_M(n) __PRCM_CLK_OUTD_M(__PRCM_CLK_OUTD_M_X(n))
-#define __PRCM_CLK_OUTD_N(n) (((n) & 0x7) << 20)
-#define PRCM_CLK_OUTD_N_MASK __PRCM_CLK_OUTD_N(0x7)
-#define __PRCM_CLK_OUTD_N_X(n) (((n) >> 1) - 1)
-#define PRCM_CLK_OUTD_N(n) __PRCM_CLK_OUTD_N(__PRCM_CLK_OUTD_N_X(n)
-#define __PRCM_CLK_OUTD_SRC_SEL(n) (((n) & 0x3) << 24)
-#define PRCM_CLK_OUTD_SRC_SEL_MASK __PRCM_CLK_OUTD_SRC_SEL(0x3)
-#define __PRCM_CLK_OUTD_SRC_LOSC2 0x0
-#define __PRCM_CLK_OUTD_SRC_LOSC 0x1
-#define __PRCM_CLK_OUTD_SRC_HOSC 0x2
-#define __PRCM_CLK_OUTD_SRC_ERR 0x3
-#define PRCM_CLK_OUTD_SRC_LOSC2 \
-#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_LOSC2)
-#define PRCM_CLK_OUTD_SRC_LOSC \
-#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_LOSC)
-#define PRCM_CLK_OUTD_SRC_HOSC \
-#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_HOSC)
-#define PRCM_CLK_OUTD_SRC_ERR \
-#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_ERR)
-#define PRCM_CLK_OUTD_EN (0x1 << 31)
-
-#define PRCM_CPU0_PWROFF (0x1 << 0)
-#define PRCM_CPU1_PWROFF (0x1 << 1)
-#define PRCM_CPU2_PWROFF (0x1 << 2)
-#define PRCM_CPU3_PWROFF (0x1 << 3)
-#define PRCM_CPU_ALL_PWROFF (0xf << 0)
-
-#define PRCM_VDD_SYS_DRAM_CH0_PAD_HOLD_PWROFF (0x1 << 0)
-#define PRCM_VDD_SYS_DRAM_CH1_PAD_HOLD_PWROFF (0x1 << 1)
-#define PRCM_VDD_SYS_AVCC_A_PWROFF (0x1 << 2)
-#define PRCM_VDD_SYS_CPU0_VDD_PWROFF (0x1 << 3)
-
-#define PRCM_VDD_GPU_PWROFF (0x1 << 0)
-
-#define PRCM_VDD_SYS_RESET (0x1 << 0)
-
-#define PRCM_CPU1_PWR_CLAMP(n) (((n) & 0xff) << 0)
-#define PRCM_CPU1_PWR_CLAMP_MASK PRCM_CPU1_PWR_CLAMP(0xff)
-
-#define PRCM_CPU2_PWR_CLAMP(n) (((n) & 0xff) << 0)
-#define PRCM_CPU2_PWR_CLAMP_MASK PRCM_CPU2_PWR_CLAMP(0xff)
-
-#define PRCM_CPU3_PWR_CLAMP(n) (((n) & 0xff) << 0)
-#define PRCM_CPU3_PWR_CLAMP_MASK PRCM_CPU3_PWR_CLAMP(0xff)
-
-#define PRCM_SEC_SWITCH_APB0_CLK_NONSEC (0x1 << 0)
-#define PRCM_SEC_SWITCH_PLL_CFG_NONSEC (0x1 << 1)
-#define PRCM_SEC_SWITCH_PWR_GATE_NONSEC (0x1 << 2)
-
-#ifndef __ASSEMBLY__
-#include <linux/compiler.h>
-
-struct sunxi_prcm_reg {
-	u32 cpus_cfg;		/* 0x000 */
-	u8 res0[0x8];		/* 0x004 */
-	u32 apb0_ratio;		/* 0x00c */
-	u32 cpu0_cfg;		/* 0x010 */
-	u32 cpu1_cfg;		/* 0x014 */
-	u32 cpu2_cfg;		/* 0x018 */
-	u32 cpu3_cfg;		/* 0x01c */
-	u8 res1[0x8];		/* 0x020 */
-	u32 apb0_gate;		/* 0x028 */
-	u8 res2[0x14];		/* 0x02c */
-	u32 pll_ctrl0;		/* 0x040 */
-	u32 pll_ctrl1;		/* 0x044 */
-	u8 res3[0x8];		/* 0x048 */
-	u32 clk_1wire;		/* 0x050 */
-	u32 clk_ir;		/* 0x054 */
-	u8 res4[0x58];		/* 0x058 */
-	u32 apb0_reset;		/* 0x0b0 */
-	u8 res5[0x3c];		/* 0x0b4 */
-	u32 clk_outd;		/* 0x0f0 */
-	u8 res6[0xc];		/* 0x0f4 */
-	u32 cpu_pwroff;		/* 0x100 */
-	u8 res7[0xc];		/* 0x104 */
-	u32 vdd_sys_pwroff;	/* 0x110 */
-	u8 res8[0x4];		/* 0x114 */
-	u32 gpu_pwroff;		/* 0x118 */
-	u8 res9[0x4];		/* 0x11c */
-	u32 vdd_pwr_reset;	/* 0x120 */
-	u8 res10[0x1c];		/* 0x124 */
-	u32 cpu_pwr_clamp[4];	/* 0x140 but first one is actually unused */
-	u8 res11[0x30];		/* 0x150 */
-	u32 dram_pwr;		/* 0x180 */
-	u8 res12[0xc];		/* 0x184 */
-	u32 dram_tst;		/* 0x190 */
-	u8 res13[0x3c];		/* 0x194 */
-	u32 prcm_sec_switch;	/* 0x1d0 */
-};
-
-void prcm_apb0_enable(u32 flags);
-void prcm_apb0_disable(u32 flags);
-
-#endif /* __ASSEMBLY__ */
-#endif /* _PRCM_H */
+#endif /* _SUNXI_PRCM_H */
diff --git a/arch/arm/include/asm/arch-sunxi/prcm_sun50i.h b/arch/arm/include/asm/arch-sunxi/prcm_sun50i.h
new file mode 100644
index 00000000..68a78e50
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/prcm_sun50i.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Sunxi H6 Power Management Unit register definition.
+ *
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#ifndef _SUN50I_PRCM_H
+#define _SUN50I_PRCM_H
+
+#ifndef __ASSEMBLY__
+#include <linux/compiler.h>
+
+struct sunxi_prcm_reg {
+	u32 cpus_cfg;		/* 0x000 */
+	u8 res0[0x8];		/* 0x004 */
+	u32 apbs1_cfg;		/* 0x00c */
+	u32 apbs2_cfg;		/* 0x010 */
+	u8 res1[0x118];		/* 0x014 */
+	u32 wdg_gate_reset;	/* 0x12c */
+	u8 res2[0x6c];		/* 0x130 */
+	u32 twi_gate_reset;	/* 0x19c */
+	u8 res3[0x1c];		/* 0x1a0 */
+	u32 rsb_gate_reset;	/* 0x1bc */
+	u32 cir_cfg;		/* 0x1c0 */
+	u8 res4[0x8];		/* 0x1c4 */
+	u32 cir_gate_reset;	/* 0x1cc */
+	u8 res5[0x10];		/* 0x1d0 */
+	u32 w1_cfg;		/* 0x1e0 */
+	u8 res6[0x8];		/* 0x1e4 */
+	u32 w1_gate_reset;	/* 0x1ec */
+	u8 res7[0x1c];		/* 0x1f0 */
+	u32 rtc_gate_reset;	/* 0x20c */
+};
+check_member(sunxi_prcm_reg, rtc_gate_reset, 0x20c);
+
+#define PRCM_TWI_GATE		(1 << 0)
+#define PRCM_TWI_RESET		(1 << 16)
+
+#endif /* __ASSEMBLY__ */
+#endif /* _PRCM_H */
diff --git a/arch/arm/include/asm/arch-sunxi/prcm_sun6i.h b/arch/arm/include/asm/arch-sunxi/prcm_sun6i.h
new file mode 100644
index 00000000..ab664e80
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/prcm_sun6i.h
@@ -0,0 +1,247 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Sunxi A31 Power Management Unit register definition.
+ *
+ * (C) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
+ * http://linux-sunxi.org
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Berg Xing <bergxing@allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ */
+
+#ifndef _SUN6I_PRCM_H
+#define _SUN6I_PRCM_H
+
+#define __PRCM_CPUS_CFG_PRE(n) (((n) & 0x3) << 4)
+#define PRCM_CPUS_CFG_PRE_MASK __PRCM_CPUS_CFG_PRE(0x3)
+#define __PRCM_CPUS_CFG_PRE_DIV(n) (((n) >> 1) - 1)
+#define PRCM_CPUS_CFG_PRE_DIV(n) \
+	__PRCM_CPUS_CFG_PRE(__PRCM_CPUS_CFG_CLK_PRE(n))
+#define __PRCM_CPUS_CFG_POST(n) (((n) & 0x1f) << 8)
+#define PRCM_CPUS_CFG_POST_MASK __PRCM_CPUS_CFG_POST(0x1f)
+#define __PRCM_CPUS_CFG_POST_DIV(n) ((n) - 1)
+#define PRCM_CPUS_CFG_POST_DIV(n) \
+	__PRCM_CPUS_CFG_POST_DIV(__PRCM_CPUS_CFG_POST_DIV(n))
+#define __PRCM_CPUS_CFG_CLK_SRC(n) (((n) & 0x3) << 16)
+#define PRCM_CPUS_CFG_CLK_SRC_MASK __PRCM_CPUS_CFG_CLK_SRC(0x3)
+#define __PRCM_CPUS_CFG_CLK_SRC_LOSC 0x0
+#define __PRCM_CPUS_CFG_CLK_SRC_HOSC 0x1
+#define __PRCM_CPUS_CFG_CLK_SRC_PLL6 0x2
+#define __PRCM_CPUS_CFG_CLK_SRC_PDIV 0x3
+#define PRCM_CPUS_CFG_CLK_SRC_LOSC \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_LOSC)
+#define PRCM_CPUS_CFG_CLK_SRC_HOSC \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_HOSC)
+#define PRCM_CPUS_CFG_CLK_SRC_PLL6 \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_PLL6)
+#define PRCM_CPUS_CFG_CLK_SRC_PDIV \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_PDIV)
+
+#define __PRCM_APB0_RATIO(n) (((n) & 0x3) << 0)
+#define PRCM_APB0_RATIO_DIV_MASK __PRCM_APB0_RATIO_DIV(0x3)
+#define __PRCM_APB0_RATIO_DIV(n) (((n) >> 1) - 1)
+#define PRCM_APB0_RATIO_DIV(n) \
+	__PRCM_APB0_RATIO(__PRCM_APB0_RATIO_DIV(n))
+
+#define PRCM_CPU_CFG_NEON_CLK_EN (0x1 << 0)
+#define PRCM_CPU_CFG_CPU_CLK_EN (0x1 << 1)
+
+#define PRCM_APB0_GATE_PIO (0x1 << 0)
+#define PRCM_APB0_GATE_IR (0x1 << 1)
+#define PRCM_APB0_GATE_TIMER01 (0x1 << 2)
+#define PRCM_APB0_GATE_P2WI (0x1 << 3)		/* sun6i */
+#define PRCM_APB0_GATE_RSB (0x1 << 3)		/* sun8i */
+#define PRCM_APB0_GATE_UART (0x1 << 4)
+#define PRCM_APB0_GATE_1WIRE (0x1 << 5)
+#define PRCM_APB0_GATE_I2C (0x1 << 6)
+
+#define PRCM_APB0_RESET_PIO (0x1 << 0)
+#define PRCM_APB0_RESET_IR (0x1 << 1)
+#define PRCM_APB0_RESET_TIMER01 (0x1 << 2)
+#define PRCM_APB0_RESET_P2WI (0x1 << 3)
+#define PRCM_APB0_RESET_UART (0x1 << 4)
+#define PRCM_APB0_RESET_1WIRE (0x1 << 5)
+#define PRCM_APB0_RESET_I2C (0x1 << 6)
+
+#define PRCM_PLL_CTRL_PLL_BIAS (0x1 << 0)
+#define PRCM_PLL_CTRL_HOSC_GAIN_ENH (0x1 << 1)
+#define __PRCM_PLL_CTRL_USB_CLK_SRC(n) (((n) & 0x3) << 4)
+#define PRCM_PLL_CTRL_USB_CLK_SRC_MASK \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(0x3)
+#define __PRCM_PLL_CTRL_USB_CLK_0 0x0
+#define __PRCM_PLL_CTRL_USB_CLK_1 0x1
+#define __PRCM_PLL_CTRL_USB_CLK_2 0x2
+#define __PRCM_PLL_CTRL_USB_CLK_3 0x3
+#define PRCM_PLL_CTRL_USB_CLK_0 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_0)
+#define PRCM_PLL_CTRL_USB_CLK_1 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_1)
+#define PRCM_PLL_CTRL_USB_CLK_2 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_2)
+#define PRCM_PLL_CTRL_USB_CLK_3 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_3)
+#define __PRCM_PLL_CTRL_INT_PLL_IN_SEL(n) (((n) & 0x3) << 12)
+#define PRCM_PLL_CTRL_INT_PLL_IN_SEL_MASK \
+	__PRCM_PLL_CTRL_INT_PLL_IN_SEL(0x3)
+#define PRCM_PLL_CTRL_INT_PLL_IN_SEL(n) \
+	__PRCM_PLL_CTRL_INT_PLL_IN_SEL(n)
+#define __PRCM_PLL_CTRL_HOSC_CLK_SEL(n) (((n) & 0x3) << 20)
+#define PRCM_PLL_CTRL_HOSC_CLK_SEL_MASK \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(0x3)
+#define __PRCM_PLL_CTRL_HOSC_CLK_0 0x0
+#define __PRCM_PLL_CTRL_HOSC_CLK_1 0x1
+#define __PRCM_PLL_CTRL_HOSC_CLK_2 0x2
+#define __PRCM_PLL_CTRL_HOSC_CLK_3 0x3
+#define PRCM_PLL_CTRL_HOSC_CLK_0 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_0)
+#define PRCM_PLL_CTRL_HOSC_CLK_1 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_1)
+#define PRCM_PLL_CTRL_HOSC_CLK_2 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_2)
+#define PRCM_PLL_CTRL_HOSC_CLK_3 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_3)
+#define PRCM_PLL_CTRL_PLL_TST_SRC_EXT (0x1 << 24)
+#define PRCM_PLL_CTRL_LDO_DIGITAL_EN (0x1 << 0)
+#define PRCM_PLL_CTRL_LDO_ANALOG_EN (0x1 << 1)
+#define PRCM_PLL_CTRL_EXT_OSC_EN (0x1 << 2)
+#define PRCM_PLL_CTRL_CLK_TST_EN (0x1 << 3)
+#define PRCM_PLL_CTRL_IN_PWR_HIGH (0x1 << 15) /* 3.3 for hi 2.5 for lo */
+#define __PRCM_PLL_CTRL_VDD_LDO_OUT(n) (((n) & 0x7) << 16)
+#define PRCM_PLL_CTRL_LDO_OUT_MASK \
+	__PRCM_PLL_CTRL_LDO_OUT(0x7)
+/* When using the low voltage 20 mV steps, and high voltage 30 mV steps */
+#define PRCM_PLL_CTRL_LDO_OUT_L(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) - 1000) / 20) & 0x7)
+#define PRCM_PLL_CTRL_LDO_OUT_H(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) - 1160) / 30) & 0x7)
+#define PRCM_PLL_CTRL_LDO_OUT_LV(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) & 0x7) * 20) + 1000)
+#define PRCM_PLL_CTRL_LDO_OUT_HV(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) & 0x7) * 30) + 1160)
+#define PRCM_PLL_CTRL_LDO_KEY (0xa7 << 24)
+#define PRCM_PLL_CTRL_LDO_KEY_MASK (0xff << 24)
+
+#define PRCM_CLK_1WIRE_GATE (0x1 << 31)
+
+#define __PRCM_CLK_MOD0_M(n) (((n) & 0xf) << 0)
+#define PRCM_CLK_MOD0_M_MASK __PRCM_CLK_MOD0_M(0xf)
+#define __PRCM_CLK_MOD0_M_X(n) (n - 1)
+#define PRCM_CLK_MOD0_M(n) __PRCM_CLK_MOD0_M(__PRCM_CLK_MOD0_M_X(n))
+#define PRCM_CLK_MOD0_OUT_PHASE(n) (((n) & 0x7) << 8)
+#define PRCM_CLK_MOD0_OUT_PHASE_MASK(n) PRCM_CLK_MOD0_OUT_PHASE(0x7)
+#define _PRCM_CLK_MOD0_N(n) (((n) & 0x3) << 16)
+#define PRCM_CLK_MOD0_N_MASK __PRCM_CLK_MOD_N(0x3)
+#define __PRCM_CLK_MOD0_N_X(n) (((n) >> 1) - 1)
+#define PRCM_CLK_MOD0_N(n) __PRCM_CLK_MOD0_N(__PRCM_CLK_MOD0_N_X(n))
+#define PRCM_CLK_MOD0_SMPL_PHASE(n) (((n) & 0x7) << 20)
+#define PRCM_CLK_MOD0_SMPL_PHASE_MASK PRCM_CLK_MOD0_SMPL_PHASE(0x7)
+#define PRCM_CLK_MOD0_SRC_SEL(n) (((n) & 0x7) << 24)
+#define PRCM_CLK_MOD0_SRC_SEL_MASK PRCM_CLK_MOD0_SRC_SEL(0x7)
+#define PRCM_CLK_MOD0_GATE_EN (0x1 << 31)
+
+#define PRCM_APB0_RESET_PIO (0x1 << 0)
+#define PRCM_APB0_RESET_IR (0x1 << 1)
+#define PRCM_APB0_RESET_TIMER01 (0x1 << 2)
+#define PRCM_APB0_RESET_P2WI (0x1 << 3)
+#define PRCM_APB0_RESET_UART (0x1 << 4)
+#define PRCM_APB0_RESET_1WIRE (0x1 << 5)
+#define PRCM_APB0_RESET_I2C (0x1 << 6)
+
+#define __PRCM_CLK_OUTD_M(n) (((n) & 0x7) << 8)
+#define PRCM_CLK_OUTD_M_MASK __PRCM_CLK_OUTD_M(0x7)
+#define __PRCM_CLK_OUTD_M_X() ((n) - 1)
+#define PRCM_CLK_OUTD_M(n) __PRCM_CLK_OUTD_M(__PRCM_CLK_OUTD_M_X(n))
+#define __PRCM_CLK_OUTD_N(n) (((n) & 0x7) << 20)
+#define PRCM_CLK_OUTD_N_MASK __PRCM_CLK_OUTD_N(0x7)
+#define __PRCM_CLK_OUTD_N_X(n) (((n) >> 1) - 1)
+#define PRCM_CLK_OUTD_N(n) __PRCM_CLK_OUTD_N(__PRCM_CLK_OUTD_N_X(n)
+#define __PRCM_CLK_OUTD_SRC_SEL(n) (((n) & 0x3) << 24)
+#define PRCM_CLK_OUTD_SRC_SEL_MASK __PRCM_CLK_OUTD_SRC_SEL(0x3)
+#define __PRCM_CLK_OUTD_SRC_LOSC2 0x0
+#define __PRCM_CLK_OUTD_SRC_LOSC 0x1
+#define __PRCM_CLK_OUTD_SRC_HOSC 0x2
+#define __PRCM_CLK_OUTD_SRC_ERR 0x3
+#define PRCM_CLK_OUTD_SRC_LOSC2 \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_LOSC2)
+#define PRCM_CLK_OUTD_SRC_LOSC \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_LOSC)
+#define PRCM_CLK_OUTD_SRC_HOSC \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_HOSC)
+#define PRCM_CLK_OUTD_SRC_ERR \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_ERR)
+#define PRCM_CLK_OUTD_EN (0x1 << 31)
+
+#define PRCM_CPU0_PWROFF (0x1 << 0)
+#define PRCM_CPU1_PWROFF (0x1 << 1)
+#define PRCM_CPU2_PWROFF (0x1 << 2)
+#define PRCM_CPU3_PWROFF (0x1 << 3)
+#define PRCM_CPU_ALL_PWROFF (0xf << 0)
+
+#define PRCM_VDD_SYS_DRAM_CH0_PAD_HOLD_PWROFF (0x1 << 0)
+#define PRCM_VDD_SYS_DRAM_CH1_PAD_HOLD_PWROFF (0x1 << 1)
+#define PRCM_VDD_SYS_AVCC_A_PWROFF (0x1 << 2)
+#define PRCM_VDD_SYS_CPU0_VDD_PWROFF (0x1 << 3)
+
+#define PRCM_VDD_GPU_PWROFF (0x1 << 0)
+
+#define PRCM_VDD_SYS_RESET (0x1 << 0)
+
+#define PRCM_CPU1_PWR_CLAMP(n) (((n) & 0xff) << 0)
+#define PRCM_CPU1_PWR_CLAMP_MASK PRCM_CPU1_PWR_CLAMP(0xff)
+
+#define PRCM_CPU2_PWR_CLAMP(n) (((n) & 0xff) << 0)
+#define PRCM_CPU2_PWR_CLAMP_MASK PRCM_CPU2_PWR_CLAMP(0xff)
+
+#define PRCM_CPU3_PWR_CLAMP(n) (((n) & 0xff) << 0)
+#define PRCM_CPU3_PWR_CLAMP_MASK PRCM_CPU3_PWR_CLAMP(0xff)
+
+#define PRCM_SEC_SWITCH_APB0_CLK_NONSEC (0x1 << 0)
+#define PRCM_SEC_SWITCH_PLL_CFG_NONSEC (0x1 << 1)
+#define PRCM_SEC_SWITCH_PWR_GATE_NONSEC (0x1 << 2)
+
+#ifndef __ASSEMBLY__
+#include <linux/compiler.h>
+
+struct sunxi_prcm_reg {
+	u32 cpus_cfg;		/* 0x000 */
+	u8 res0[0x8];		/* 0x004 */
+	u32 apb0_ratio;		/* 0x00c */
+	u32 cpu0_cfg;		/* 0x010 */
+	u32 cpu1_cfg;		/* 0x014 */
+	u32 cpu2_cfg;		/* 0x018 */
+	u32 cpu3_cfg;		/* 0x01c */
+	u8 res1[0x8];		/* 0x020 */
+	u32 apb0_gate;		/* 0x028 */
+	u8 res2[0x14];		/* 0x02c */
+	u32 pll_ctrl0;		/* 0x040 */
+	u32 pll_ctrl1;		/* 0x044 */
+	u8 res3[0x8];		/* 0x048 */
+	u32 clk_1wire;		/* 0x050 */
+	u32 clk_ir;		/* 0x054 */
+	u8 res4[0x58];		/* 0x058 */
+	u32 apb0_reset;		/* 0x0b0 */
+	u8 res5[0x3c];		/* 0x0b4 */
+	u32 clk_outd;		/* 0x0f0 */
+	u8 res6[0xc];		/* 0x0f4 */
+	u32 cpu_pwroff;		/* 0x100 */
+	u8 res7[0xc];		/* 0x104 */
+	u32 vdd_sys_pwroff;	/* 0x110 */
+	u8 res8[0x4];		/* 0x114 */
+	u32 gpu_pwroff;		/* 0x118 */
+	u8 res9[0x4];		/* 0x11c */
+	u32 vdd_pwr_reset;	/* 0x120 */
+	u8 res10[0x1c];		/* 0x124 */
+	u32 cpu_pwr_clamp[4];	/* 0x140 but first one is actually unused */
+	u8 res11[0x30];		/* 0x150 */
+	u32 dram_pwr;		/* 0x180 */
+	u8 res12[0xc];		/* 0x184 */
+	u32 dram_tst;		/* 0x190 */
+	u8 res13[0x3c];		/* 0x194 */
+	u32 prcm_sec_switch;	/* 0x1d0 */
+};
+
+void prcm_apb0_enable(u32 flags);
+void prcm_apb0_disable(u32 flags);
+
+#endif /* __ASSEMBLY__ */
+#endif /* _PRCM_H */
diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index 49ef217f..0d11ba39 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -48,6 +48,12 @@ config DRAM_SUN50I_H6
 	  Select this dram controller driver for some sun50i platforms,
 	  like H6.
 
+config DRAM_SUN50I_H616
+	bool
+	help
+	  Select this dram controller driver for some sun50i platforms,
+	  like H616.
+
 config SUN6I_P2WI
 	bool "Allwinner sun6i internal P2WI controller"
 	help
@@ -82,7 +88,7 @@ config SUN8I_RSB
 config SUNXI_SRAM_ADDRESS
 	hex
 	default 0x10000 if MACH_SUN9I || MACH_SUN50I || MACH_SUN50I_H5
-	default 0x20000 if MACH_SUN50I_H6
+	default 0x20000 if MACH_SUN50I_H6 || MACH_SUN50I_H616
 	default 0x0
 	---help---
 	Older Allwinner SoCs have their mask boot ROM mapped just below 4GB,
@@ -141,9 +147,10 @@ config MACH_SUNXI_H3_H5
 	select SUPPORT_SPL
 
 # TODO: try out A80's 8GiB DRAM space
+# TODO: H616 supports 4 GiB DRAM space
 config SUNXI_DRAM_MAX_SIZE
 	hex
-	default 0xC0000000 if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN50I_H6
+	default 0xC0000000 if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN50I_H6 || MACH_SUN50I_H616
 	default 0x80000000
 
 choice
@@ -308,6 +315,15 @@ config MACH_SUN50I_H6
 	select SPL_LOAD_FIT
 	select DRAM_SUN50I_H6
 
+config MACH_SUN50I_H616
+	bool "sun50i (Allwinner H616)"
+	select ARM64
+	select DRAM_SUN50I_H616
+	select FIT
+	select SPL_LOAD_FIT
+	select SUNXI_GEN_SUN6I
+	select SUPPORT_SPL
+
 endchoice
 
 # The sun8i SoCs share a lot, this helps to avoid a lot of "if A23 || A33"
@@ -415,7 +431,7 @@ config DRAM_CLK
 	default 312 if MACH_SUN6I || MACH_SUN8I
 	default 360 if MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || \
 		       MACH_SUN8I_V3S
-	default 672 if MACH_SUN50I
+	default 672 if MACH_SUN50I || MACH_SUN50I_H616
 	default 744 if MACH_SUN50I_H6
 	---help---
 	Set the dram clock speed, valid range 240 - 480 (prior to sun9i),
@@ -433,6 +449,7 @@ endif
 
 config DRAM_ZQ
 	int "sunxi dram zq value"
+	depends on !MACH_SUN50I_H616
 	default 123 if MACH_SUN4I || MACH_SUN5I || MACH_SUN6I || \
 		       MACH_SUN8I_A23 || MACH_SUN8I_A33 || MACH_SUN8I_A83T
 	default 127 if MACH_SUN7I
@@ -450,6 +467,7 @@ config DRAM_ODT_EN
 	default y if MACH_SUN8I_R40
 	default y if MACH_SUN50I
 	default y if MACH_SUN50I_H6
+	default y if MACH_SUN50I_H616
 	---help---
 	Select this to enable dram odt (on die termination).
 
@@ -540,7 +558,7 @@ config SYS_CLK_FREQ
 	default 816000000 if MACH_SUN50I || MACH_SUN50I_H5
 	default 1008000000 if MACH_SUN8I
 	default 1008000000 if MACH_SUN9I
-	default 888000000 if MACH_SUN50I_H6
+	default 888000000 if MACH_SUN50I_H6 || MACH_SUN50I_H616
 
 config SYS_CONFIG_NAME
 	default "sun4i" if MACH_SUN4I
@@ -551,6 +569,7 @@ config SYS_CONFIG_NAME
 	default "sun9i" if MACH_SUN9I
 	default "sun50i" if MACH_SUN50I
 	default "sun50i" if MACH_SUN50I_H6
+	default "sun50i" if MACH_SUN50I_H616
 
 config SYS_BOARD
 	default "sunxi"
@@ -728,6 +747,7 @@ config R_I2C_ENABLE
 	bool "Enable the PRCM I2C/TWI controller"
 	# This is used for the pmic on H3
 	default y if SY8106A_POWER
+	default y if AXP305_POWER
 	select CMD_I2C
 	---help---
 	Set this to y to enable the I2C controller which is part of the PRCM.
@@ -757,6 +777,7 @@ config VIDEO_SUNXI
 	depends on !MACH_SUN9I
 	depends on !MACH_SUN50I
 	depends on !MACH_SUN50I_H6
+	depends on !MACH_SUN50I_H616
 	select VIDEO
 	imply VIDEO_DT_SIMPLEFB
 	default y
@@ -990,6 +1011,7 @@ config SPL_STACK_R_ADDR
 	default 0x2fe00000 if MACH_SUN9I
 	default 0x4fe00000 if MACH_SUN50I
 	default 0x4fe00000 if MACH_SUN50I_H6
+	default 0x4fe00000 if MACH_SUN50I_H616
 
 config SPL_SPI_SUNXI
 	bool "Support for SPI Flash on Allwinner SoCs in SPL"
diff --git a/arch/arm/mach-sunxi/Makefile b/arch/arm/mach-sunxi/Makefile
index d129f334..a504a33a 100644
--- a/arch/arm/mach-sunxi/Makefile
+++ b/arch/arm/mach-sunxi/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_MACH_SUN8I)	+= clock_sun6i.o
 endif
 obj-$(CONFIG_MACH_SUN9I)	+= clock_sun9i.o gtbus_sun9i.o
 obj-$(CONFIG_MACH_SUN50I_H6)	+= clock_sun50i_h6.o
+obj-$(CONFIG_MACH_SUN50I_H616)	+= clock_sun50i_h6.o
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_DRAM_SUN4I)	+= dram_sun4i.o
@@ -40,4 +41,6 @@ obj-$(CONFIG_SUNXI_DRAM_DW)	+= dram_sunxi_dw.o
 obj-$(CONFIG_SUNXI_DRAM_DW)	+= dram_timings/
 obj-$(CONFIG_DRAM_SUN50I_H6)	+= dram_sun50i_h6.o
 obj-$(CONFIG_DRAM_SUN50I_H6)	+= dram_timings/
+obj-$(CONFIG_DRAM_SUN50I_H616)	+= dram_sun50i_h616.o
+obj-$(CONFIG_DRAM_SUN50I_H616)	+= dram_timings/
 endif
diff --git a/arch/arm/mach-sunxi/board.c b/arch/arm/mach-sunxi/board.c
index f40fccd8..5cb8dca6 100644
--- a/arch/arm/mach-sunxi/board.c
+++ b/arch/arm/mach-sunxi/board.c
@@ -116,6 +116,10 @@ static int gpio_init(void)
 	sunxi_gpio_set_cfgpin(SUNXI_GPH(0), SUN50I_H6_GPH_UART0);
 	sunxi_gpio_set_cfgpin(SUNXI_GPH(1), SUN50I_H6_GPH_UART0);
 	sunxi_gpio_set_pull(SUNXI_GPH(1), SUNXI_GPIO_PULL_UP);
+#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN50I_H616)
+	sunxi_gpio_set_cfgpin(SUNXI_GPH(0), SUN50I_H616_GPH_UART0);
+	sunxi_gpio_set_cfgpin(SUNXI_GPH(1), SUN50I_H616_GPH_UART0);
+	sunxi_gpio_set_pull(SUNXI_GPH(1), SUNXI_GPIO_PULL_UP);
 #elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUN8I_A83T)
 	sunxi_gpio_set_cfgpin(SUNXI_GPB(9), SUN8I_A83T_GPB_UART0);
 	sunxi_gpio_set_cfgpin(SUNXI_GPB(10), SUN8I_A83T_GPB_UART0);
@@ -144,7 +148,7 @@ static int gpio_init(void)
 #error Unsupported console port number. Please fix pin mux settings in board.c
 #endif
 
-#ifdef CONFIG_MACH_SUN50I_H6
+#if defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 	/* Update PIO power bias configuration by copy hardware detected value */
 	val = readl(SUNXI_PIO_BASE + SUN50I_H6_GPIO_POW_MOD_VAL);
 	writel(val, SUNXI_PIO_BASE + SUN50I_H6_GPIO_POW_MOD_SEL);
diff --git a/arch/arm/mach-sunxi/clock.c b/arch/arm/mach-sunxi/clock.c
index f591affe..9b36fe50 100644
--- a/arch/arm/mach-sunxi/clock.c
+++ b/arch/arm/mach-sunxi/clock.c
@@ -35,8 +35,8 @@ int clock_init(void)
 	return 0;
 }
 
-/* These functions are shared between various SoCs so put them here. */
-#if defined CONFIG_SUNXI_GEN_SUN6I && !defined CONFIG_MACH_SUN9I
+#if defined(CONFIG_SUNXI_GEN_SUN6I) && !defined(CONFIG_MACH_SUN9I) && \
+	!defined(CONFIG_MACH_SUN50I_H616)
 int clock_twi_onoff(int port, int state)
 {
 	struct sunxi_ccm_reg *const ccm =
diff --git a/arch/arm/mach-sunxi/clock_sun50i_h6.c b/arch/arm/mach-sunxi/clock_sun50i_h6.c
index ba8a26eb..94e37514 100644
--- a/arch/arm/mach-sunxi/clock_sun50i_h6.c
+++ b/arch/arm/mach-sunxi/clock_sun50i_h6.c
@@ -2,6 +2,7 @@
 #include <asm/io.h>
 #include <asm/arch/cpu.h>
 #include <asm/arch/clock.h>
+#include <asm/arch/prcm.h>
 
 #ifdef CONFIG_SPL_BUILD
 void clock_init_safe(void)
@@ -67,6 +68,9 @@ void clock_set_pll1(unsigned int clk)
 
 	/* clk = 24*n/p, p is ignored if clock is >288MHz */
 	writel(CCM_PLL1_CTRL_EN | CCM_PLL1_LOCK_EN | CCM_PLL1_CLOCK_TIME_2 |
+#ifdef CONFIG_MACH_SUN50I_H616
+	       CCM_PLL1_OUT_EN |
+#endif
 	       CCM_PLL1_CTRL_N(clk / 24000000), &ccm->pll1_cfg);
 	while (!(readl(&ccm->pll1_cfg) & CCM_PLL1_LOCK)) {}
 
@@ -82,6 +86,11 @@ unsigned int clock_get_pll6(void)
 {
 	struct sunxi_ccm_reg *const ccm =
 		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+#ifdef CONFIG_MACH_SUN50I_H6
+	int m = 4;
+#else
+	int m = 2;
+#endif
 
 	uint32_t rval = readl(&ccm->pll6_cfg);
 	int n = ((rval & CCM_PLL6_CTRL_N_MASK) >> CCM_PLL6_CTRL_N_SHIFT);
@@ -90,5 +99,39 @@ unsigned int clock_get_pll6(void)
 	int div2 = ((rval & CCM_PLL6_CTRL_DIV2_MASK) >>
 			CCM_PLL6_CTRL_DIV2_SHIFT) + 1;
 	/* The register defines PLL6-4X, not plain PLL6 */
-	return 24000000 / 4 * n / div1 / div2;
+	return 24000000 / m * n / div1 / div2;
+}
+
+int clock_twi_onoff(int port, int state)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_prcm_reg *const prcm =
+		(struct sunxi_prcm_reg *)SUNXI_PRCM_BASE;
+
+	if (port == 5) {
+		if (state) {
+			setbits_le32(&prcm->twi_gate_reset, PRCM_TWI_GATE);
+			setbits_le32(&prcm->twi_gate_reset, PRCM_TWI_RESET);
+		} else {
+			clrbits_le32(&prcm->twi_gate_reset, PRCM_TWI_RESET);
+			clrbits_le32(&prcm->twi_gate_reset, PRCM_TWI_GATE);
+		}
+		return 0;
+	}
+
+	/* set the apb clock gate and reset for twi */
+	if (state) {
+		setbits_le32(&ccm->twi_gate_reset,
+			     1 << (CCM_TWI_GATE_SHIFT + port));
+		setbits_le32(&ccm->twi_gate_reset,
+			     1 << (CCM_TWI_RESET_SHIFT + port));
+	} else {
+		clrbits_le32(&ccm->twi_gate_reset,
+			     1 << (CCM_TWI_GATE_SHIFT + port));
+		clrbits_le32(&ccm->twi_gate_reset,
+			     1 << (CCM_TWI_RESET_SHIFT + port));
+	}
+
+	return 0;
 }
diff --git a/arch/arm/mach-sunxi/cpu_info.c b/arch/arm/mach-sunxi/cpu_info.c
index 875e5a1a..ba33ef24 100644
--- a/arch/arm/mach-sunxi/cpu_info.c
+++ b/arch/arm/mach-sunxi/cpu_info.c
@@ -99,6 +99,8 @@ int print_cpuinfo(void)
 	puts("CPU:   Allwinner H5 (SUN50I)\n");
 #elif defined CONFIG_MACH_SUN50I_H6
 	puts("CPU:   Allwinner H6 (SUN50I)\n");
+#elif defined CONFIG_MACH_SUN50I_H616
+	puts("CPU:   Allwinner H616 (SUN50I)\n");
 #else
 #warning Please update cpu_info.c with correct CPU information
 	puts("CPU:   SUNXI Family\n");
diff --git a/arch/arm/mach-sunxi/dram_sun50i_h616.c b/arch/arm/mach-sunxi/dram_sun50i_h616.c
new file mode 100644
index 00000000..eb4a8838
--- /dev/null
+++ b/arch/arm/mach-sunxi/dram_sun50i_h616.c
@@ -0,0 +1,1014 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * sun50i H616 platform dram controller init
+ *
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ */
+#include <common.h>
+#include <init.h>
+#include <log.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/cpu.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/kconfig.h>
+
+enum {
+	MBUS_QOS_LOWEST = 0,
+	MBUS_QOS_LOW,
+	MBUS_QOS_HIGH,
+	MBUS_QOS_HIGHEST
+};
+
+inline void mbus_configure_port(u8 port,
+				bool bwlimit,
+				bool priority,
+				u8 qos,
+				u8 waittime,
+				u8 acs,
+				u16 bwl0,
+				u16 bwl1,
+				u16 bwl2)
+{
+	struct sunxi_mctl_com_reg * const mctl_com =
+			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
+
+	const u32 cfg0 = ( (bwlimit ? (1 << 0) : 0)
+			   | (priority ? (1 << 1) : 0)
+			   | ((qos & 0x3) << 2)
+			   | ((waittime & 0xf) << 4)
+			   | ((acs & 0xff) << 8)
+			   | (bwl0 << 16) );
+	const u32 cfg1 = ((u32)bwl2 << 16) | (bwl1 & 0xffff);
+
+	debug("MBUS port %d cfg0 %08x cfg1 %08x\n", port, cfg0, cfg1);
+	writel(cfg0, &mctl_com->master[port].cfg0);
+	writel(cfg1, &mctl_com->master[port].cfg1);
+}
+
+#define MBUS_CONF(port, bwlimit, qos, acs, bwl0, bwl1, bwl2)	\
+	mbus_configure_port(port, bwlimit, false, \
+			    MBUS_QOS_ ## qos, 0, acs, bwl0, bwl1, bwl2)
+
+static void mctl_set_master_priority(void)
+{
+	struct sunxi_mctl_com_reg * const mctl_com =
+			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
+
+	/* enable bandwidth limit windows and set windows size 1us */
+	writel(399, &mctl_com->tmr);
+	writel(BIT(16), &mctl_com->bwcr);
+
+	MBUS_CONF( 0, true, HIGHEST, 0,  256,  128,  100);
+	MBUS_CONF( 1, true,    HIGH, 0, 1536, 1400,  256);
+	MBUS_CONF( 2, true, HIGHEST, 0,  512,  256,   96);
+	MBUS_CONF( 3, true,    HIGH, 0,  256,  100,   80);
+	MBUS_CONF( 4, true,    HIGH, 2, 8192, 5500, 5000);
+	MBUS_CONF( 5, true,    HIGH, 2,  100,   64,   32);
+	MBUS_CONF( 6, true,    HIGH, 2,  100,   64,   32);
+	MBUS_CONF( 8, true,    HIGH, 0,  256,  128,   64);
+	MBUS_CONF(11, true,    HIGH, 0,  256,  128,  100);
+	MBUS_CONF(14, true,    HIGH, 0, 1024,  256,   64);
+	MBUS_CONF(16, true, HIGHEST, 6, 8192, 2800, 2400);
+	MBUS_CONF(21, true, HIGHEST, 6, 2048,  768,  512);
+	MBUS_CONF(25, true, HIGHEST, 0,  100,   64,   32);
+	MBUS_CONF(26, true,    HIGH, 2, 8192, 5500, 5000);
+	MBUS_CONF(37, true,    HIGH, 0,  256,  128,   64);
+	MBUS_CONF(38, true,    HIGH, 2,  100,   64,   32);
+	MBUS_CONF(39, true,    HIGH, 2, 8192, 5500, 5000);
+	MBUS_CONF(40, true,    HIGH, 2,  100,   64,   32);
+}
+
+static void mctl_sys_init(struct dram_para *para)
+{
+	struct sunxi_ccm_reg * const ccm =
+			(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_mctl_com_reg * const mctl_com =
+			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+
+	/* Put all DRAM-related blocks to reset state */
+	clrbits_le32(&ccm->mbus_cfg, MBUS_ENABLE);
+	clrbits_le32(&ccm->mbus_cfg, MBUS_RESET);
+	clrbits_le32(&ccm->dram_gate_reset, DRAM_ENABLE);
+	udelay(5);
+	clrbits_le32(&ccm->dram_gate_reset, DRAM_RESET);
+	clrbits_le32(&ccm->pll5_cfg, CCM_PLL5_CTRL_EN);
+	clrbits_le32(&ccm->dram_clk_cfg, DRAM_MOD_RESET);
+
+	udelay(5);
+
+	/* Set PLL5 rate to doubled DRAM clock rate */
+	writel(CCM_PLL5_CTRL_EN | CCM_PLL5_LOCK_EN | CCM_PLL5_OUT_EN |
+	       CCM_PLL5_CTRL_N(para->clk * 2 / 24 - 1), &ccm->pll5_cfg);
+	mctl_await_completion(&ccm->pll5_cfg, CCM_PLL5_LOCK, CCM_PLL5_LOCK);
+
+	/* Configure DRAM mod clock */
+	writel(DRAM_CLK_SRC_PLL5, &ccm->dram_clk_cfg);
+	writel(DRAM_RESET, &ccm->dram_gate_reset);
+	udelay(5);
+	setbits_le32(&ccm->dram_gate_reset, DRAM_ENABLE);
+
+	/* Disable all channels */
+	writel(0, &mctl_com->maer0);
+	writel(0, &mctl_com->maer1);
+	writel(0, &mctl_com->maer2);
+
+	/* Configure MBUS and enable DRAM mod reset */
+	setbits_le32(&ccm->mbus_cfg, MBUS_RESET);
+	setbits_le32(&ccm->mbus_cfg, MBUS_ENABLE);
+
+	/* TODO: ??? */
+	clrbits_le32(0x47FA500, BIT(25));
+
+	setbits_le32(&ccm->dram_clk_cfg, DRAM_MOD_RESET);
+	udelay(5);
+
+	/* Unknown hack, which enables access of mctl_ctl regs */
+	writel(0x8000, &mctl_ctl->unk_0x00c);
+}
+
+static void mctl_set_addrmap(struct dram_para *para)
+{
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+	u8 cols = para->cols;
+	u8 rows = para->rows;
+	u8 ranks = para->ranks;
+
+	if (!para->bus_full_width)
+		cols -= 1;
+
+	/* Ranks */
+	if (ranks == 2)
+		mctl_ctl->addrmap[0] = rows + cols - 3;
+	else
+		mctl_ctl->addrmap[0] = 0x1F;
+
+	/* Banks, hardcoded to 8 banks now */
+	mctl_ctl->addrmap[1] = (cols - 2) | (cols - 2) << 8 | (cols - 2) << 16;
+
+	/* Columns */
+	mctl_ctl->addrmap[2] = 0;
+	switch (cols) {
+	case 7:
+		mctl_ctl->addrmap[3] = 0x1F1F1F00;
+		mctl_ctl->addrmap[4] = 0x1F1F;
+		break;
+	case 8:
+		mctl_ctl->addrmap[3] = 0x1F1F0000;
+		mctl_ctl->addrmap[4] = 0x1F1F;
+		break;
+	case 9:
+		mctl_ctl->addrmap[3] = 0x1F000000;
+		mctl_ctl->addrmap[4] = 0x1F1F;
+		break;
+	case 10:
+		mctl_ctl->addrmap[3] = 0;
+		mctl_ctl->addrmap[4] = 0x1F1F;
+		break;
+	case 11:
+		mctl_ctl->addrmap[3] = 0;
+		mctl_ctl->addrmap[4] = 0x1F00;
+		break;
+	case 12:
+		mctl_ctl->addrmap[3] = 0;
+		mctl_ctl->addrmap[4] = 0;
+		break;
+	default:
+		panic("Unsupported DRAM configuration: column number invalid\n");
+	}
+
+	/* Rows */
+	mctl_ctl->addrmap[5] = (cols - 3) | ((cols - 3) << 8) | ((cols - 3) << 16) | ((cols - 3) << 24);
+	switch (rows) {
+	case 13:
+		mctl_ctl->addrmap[6] = (cols - 3) | 0x0F0F0F00;
+		mctl_ctl->addrmap[7] = 0x0F0F;
+		break;
+	case 14:
+		mctl_ctl->addrmap[6] = (cols - 3) | ((cols - 3) << 8) | 0x0F0F0000;
+		mctl_ctl->addrmap[7] = 0x0F0F;
+		break;
+	case 15:
+		mctl_ctl->addrmap[6] = (cols - 3) | ((cols - 3) << 8) | ((cols - 3) << 16) | 0x0F000000;
+		mctl_ctl->addrmap[7] = 0x0F0F;
+		break;
+	case 16:
+		mctl_ctl->addrmap[6] = (cols - 3) | ((cols - 3) << 8) | ((cols - 3) << 16) | ((cols - 3) << 24);
+		mctl_ctl->addrmap[7] = 0x0F0F;
+		break;
+	case 17:
+		mctl_ctl->addrmap[6] = (cols - 3) | ((cols - 3) << 8) | ((cols - 3) << 16) | ((cols - 3) << 24);
+		mctl_ctl->addrmap[7] = (cols - 3) | 0x0F00;
+		break;
+	case 18:
+		mctl_ctl->addrmap[6] = (cols - 3) | ((cols - 3) << 8) | ((cols - 3) << 16) | ((cols - 3) << 24);
+		mctl_ctl->addrmap[7] = (cols - 3) | ((cols - 3) << 8);
+		break;
+	default:
+		panic("Unsupported DRAM configuration: row number invalid\n");
+	}
+
+	/* Bank groups, DDR4 only */
+	mctl_ctl->addrmap[8] = 0x3F3F;
+}
+
+static const u32 phy_init[] = {
+	0x00000007, 0x0000000b, 0x00000002, 0x00000016,
+	0x0000000d, 0x0000000e, 0x00000014, 0x00000019,
+	0x0000000a, 0x00000015, 0x00000003, 0x00000013,
+	0x00000004, 0x0000000c, 0x00000010, 0x00000006,
+	0x0000000f, 0x00000011, 0x0000001a, 0x00000001,
+	0x00000012, 0x00000017, 0x00000000, 0x00000008,
+	0x00000009, 0x00000005, 0x00000018
+};
+
+static void mctl_phy_odt(void)
+{
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x388);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x38c);
+
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x3c8);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x3cc);
+
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x408);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x40c);
+
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x448);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x44c);
+
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x340);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x344);
+
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x348);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x34c);
+
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x380);
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x384);
+
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x3c0);
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x3c4);
+
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x400);
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x404);
+
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x440);
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x444);
+}
+
+static bool mctl_phy_write_leveling(struct dram_para *para)
+{
+	bool result = true;
+	u32 val;
+
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0xc0, 0x80);
+	writel(4, SUNXI_DRAM_PHY0_BASE + 0xc);
+	writel(0x40, SUNXI_DRAM_PHY0_BASE + 0x10);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 4);
+
+	if (para->bus_full_width)
+		val = 0xf;
+	else
+		val = 3;
+
+	mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x188), val, val);
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 4);
+
+	val = readl(SUNXI_DRAM_PHY0_BASE + 0x258);
+	if (val == 0 || val == 0x3f)
+		result = false;
+	val = readl(SUNXI_DRAM_PHY0_BASE + 0x25c);
+	if (val == 0 || val == 0x3f)
+		result = false;
+	val = readl(SUNXI_DRAM_PHY0_BASE + 0x318);
+	if (val == 0 || val == 0x3f)
+		result = false;
+	val = readl(SUNXI_DRAM_PHY0_BASE + 0x31c);
+	if (val == 0 || val == 0x3f)
+		result = false;
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0xc0);
+
+	if (para->ranks == 2) {
+		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0xc0, 0x40);
+
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 4);
+
+		if (para->bus_full_width)
+			val = 0xf;
+		else
+			val = 3;
+
+		mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x188), val, val);
+
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 4);
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0xc0);
+
+	return result;
+}
+
+static bool mctl_phy_read_calibration(struct dram_para *para)
+{
+	bool result = true;
+	u32 val, tmp;
+
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30, 0x20);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
+
+	if (para->bus_full_width)
+		val = 0xf;
+	else
+		val = 3;
+
+	while ((readl(SUNXI_DRAM_PHY0_BASE + 0x184) & val) != val) {
+		if (readl(SUNXI_DRAM_PHY0_BASE + 0x184) & 0x20) {
+			result = false;
+			break;
+		}
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30);
+
+	if (para->ranks == 2) {
+		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30, 0x10);
+
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
+
+		while ((readl(SUNXI_DRAM_PHY0_BASE + 0x184) & val) != val) {
+			if (readl(SUNXI_DRAM_PHY0_BASE + 0x184) & 0x20) {
+				result = false;
+				break;
+			}
+		}
+
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 1);
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 0x30);
+
+	val = readl(SUNXI_DRAM_PHY0_BASE + 0x274) & 7;
+	tmp = readl(SUNXI_DRAM_PHY0_BASE + 0x26c) & 7;
+	if (val < tmp)
+		val = tmp;
+	tmp = readl(SUNXI_DRAM_PHY0_BASE + 0x32c) & 7;
+	if (val < tmp)
+		val = tmp;
+	tmp = readl(SUNXI_DRAM_PHY0_BASE + 0x334) & 7;
+	if (val < tmp)
+		val = tmp;
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x38, 0x7, (val + 2) & 7);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 0x20);
+
+	return result;
+}
+
+static bool mctl_phy_read_training(struct dram_para *para)
+{
+	u32 val1, val2, *ptr1, *ptr2;
+	bool result = true;
+	int i;
+
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 3, 2);
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x804, 0x3f, 0xf);
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x808, 0x3f, 0xf);
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0xa04, 0x3f, 0xf);
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0xa08, 0x3f, 0xf);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 6);
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 1);
+
+	mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x840), 0xc, 0xc);
+	if (readl(SUNXI_DRAM_PHY0_BASE + 0x840) & 3)
+		result = false;
+
+	if (para->bus_full_width) {
+		mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0xa40), 0xc, 0xc);
+		if (readl(SUNXI_DRAM_PHY0_BASE + 0xa40) & 3)
+			result = false;
+	}
+
+	ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x898);
+	ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x850);
+	for (i = 0; i < 9; i++) {
+		val1 = readl(&ptr1[i]);
+		val2 = readl(&ptr2[i]);
+		if (val1 - val2 <= 6)
+			result = false;
+	}
+	ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x8bc);
+	ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x874);
+	for (i = 0; i < 9; i++) {
+		val1 = readl(&ptr1[i]);
+		val2 = readl(&ptr2[i]);
+		if (val1 - val2 <= 6)
+			result = false;
+	}
+
+	if (para->bus_full_width) {
+		ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xa98);
+		ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xa50);
+		for (i = 0; i < 9; i++) {
+			val1 = readl(&ptr1[i]);
+			val2 = readl(&ptr2[i]);
+			if (val1 - val2 <= 6)
+				result = false;
+		}
+
+		ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xabc);
+		ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xa74);
+		for (i = 0; i < 9; i++) {
+			val1 = readl(&ptr1[i]);
+			val2 = readl(&ptr2[i]);
+			if (val1 - val2 <= 6)
+				result = false;
+		}
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 3);
+
+	if (para->ranks == 2) {
+		/* maybe last parameter should be 1? */
+		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 3, 2);
+
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 6);
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 1);
+
+		mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x840), 0xc, 0xc);
+		if (readl(SUNXI_DRAM_PHY0_BASE + 0x840) & 3)
+			result = false;
+
+		if (para->bus_full_width) {
+			mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0xa40), 0xc, 0xc);
+			if (readl(SUNXI_DRAM_PHY0_BASE + 0xa40) & 3)
+				result = false;
+		}
+
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 3);
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 3);
+
+	return result;
+}
+
+static bool mctl_phy_write_training(struct dram_para *para)
+{
+	u32 val1, val2, *ptr1, *ptr2;
+	bool result = true;
+	int i;
+
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x134);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x138);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x19c);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x1a0);
+
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 0xc, 8);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x10);
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x20);
+
+	mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x8e0), 3, 3);
+	if (readl(SUNXI_DRAM_PHY0_BASE + 0x8e0) & 0xc)
+		result = false;
+
+	if (para->bus_full_width) {
+		mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0xae0), 3, 3);
+		if (readl(SUNXI_DRAM_PHY0_BASE + 0xae0) & 0xc)
+			result = false;
+	}
+
+	ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x938);
+	ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x8f0);
+	for (i = 0; i < 9; i++) {
+		val1 = readl(&ptr1[i]);
+		val2 = readl(&ptr2[i]);
+		if (val1 - val2 <= 6)
+			result = false;
+	}
+	ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x95c);
+	ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x914);
+	for (i = 0; i < 9; i++) {
+		val1 = readl(&ptr1[i]);
+		val2 = readl(&ptr2[i]);
+		if (val1 - val2 <= 6)
+			result = false;
+	}
+
+	if (para->bus_full_width) {
+		ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xb38);
+		ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xaf0);
+		for (i = 0; i < 9; i++) {
+			val1 = readl(&ptr1[i]);
+			val2 = readl(&ptr2[i]);
+			if (val1 - val2 <= 6)
+				result = false;
+		}
+		ptr1 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xb5c);
+		ptr2 = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xb14);
+		for (i = 0; i < 9; i++) {
+			val1 = readl(&ptr1[i]);
+			val2 = readl(&ptr2[i]);
+			if (val1 - val2 <= 6)
+				result = false;
+		}
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x60);
+
+	if (para->ranks == 2) {
+		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 0xc, 4);
+
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x10);
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x20);
+
+		mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x8e0), 3, 3);
+		if (readl(SUNXI_DRAM_PHY0_BASE + 0x8e0) & 0xc)
+			result = false;
+
+		if (para->bus_full_width) {
+			mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0xae0), 3, 3);
+			if (readl(SUNXI_DRAM_PHY0_BASE + 0xae0) & 0xc)
+				result = false;
+		}
+
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x60);
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x198, 0xc);
+
+	return result;
+}
+
+static bool mctl_phy_bit_delay_compensation(struct dram_para *para)
+{
+	u32 *ptr;
+	int i;
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x60, 1);
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 8, 8);
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 0x10);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x484);
+	for (i = 0; i < 9; i++) {
+		writel(0x16, ptr);
+		writel(0x16, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x4d0);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x590);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x4cc);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x58c);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x4d8);
+	for (i = 0; i < 9; i++) {
+		writel(0x1a, ptr);
+		writel(0x1a, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x524);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x5e4);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x520);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x5e0);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x604);
+	for (i = 0; i < 9; i++) {
+		writel(0x1a, ptr);
+		writel(0x1a, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x650);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x710);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x64c);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x70c);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x658);
+	for (i = 0; i < 9; i++) {
+		writel(0x1a, ptr);
+		writel(0x1a, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x6a4);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x764);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x6a0);
+	writel(0x1e, SUNXI_DRAM_PHY0_BASE + 0x760);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x60, 1);
+
+	/* second part */
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x54, 0x80);
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x190, 4);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x480);
+	for (i = 0; i < 9; i++) {
+		writel(0x10, ptr);
+		writel(0x10, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x18, SUNXI_DRAM_PHY0_BASE + 0x528);
+	writel(0x18, SUNXI_DRAM_PHY0_BASE + 0x5e8);
+	writel(0x18, SUNXI_DRAM_PHY0_BASE + 0x4c8);
+	writel(0x18, SUNXI_DRAM_PHY0_BASE + 0x588);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x4d4);
+	for (i = 0; i < 9; i++) {
+		writel(0x12, ptr);
+		writel(0x12, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x52c);
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x5ec);
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x51c);
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x5dc);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x600);
+	for (i = 0; i < 9; i++) {
+		writel(0x12, ptr);
+		writel(0x12, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x6a8);
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x768);
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x648);
+	writel(0x1a, SUNXI_DRAM_PHY0_BASE + 0x708);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x654);
+	for (i = 0; i < 9; i++) {
+		writel(0x14, ptr);
+		writel(0x14, ptr + 0x30);
+		ptr += 2;
+	}
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x6ac);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x76c);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x69c);
+	writel(0x1c, SUNXI_DRAM_PHY0_BASE + 0x75c);
+
+	setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x54, 0x80);
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x60, 4);
+
+	return true;
+}
+
+static bool mctl_phy_init(struct dram_para *para)
+{
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+	u32 val, *ptr;
+	int i;
+
+	if (para->bus_full_width)
+		val = 0xf;
+	else
+		val = 3;
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x3c, 0xf, val);
+
+	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x14);
+	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x35c);
+	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x368);
+	writel(0xd, SUNXI_DRAM_PHY0_BASE + 0x374);
+
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x18);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x360);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x36c);
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x378);
+
+	writel(9, SUNXI_DRAM_PHY0_BASE + 0x1c);
+	writel(9, SUNXI_DRAM_PHY0_BASE + 0x364);
+	writel(9, SUNXI_DRAM_PHY0_BASE + 0x370);
+	writel(9, SUNXI_DRAM_PHY0_BASE + 0x37c);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0xc0);
+	for (i = 0; i < ARRAY_SIZE(phy_init); i++)
+		writel(phy_init[i], &ptr[i]);
+
+	ptr = (u32*)(SUNXI_DRAM_PHY0_BASE + 0x780);
+	for (i = 0; i < 32; i++)
+		writel(0x16, &ptr[i]);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x78c);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7a4);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7b8);
+	writel(0x8, SUNXI_DRAM_PHY0_BASE + 0x7d4);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7dc);
+	writel(0xe, SUNXI_DRAM_PHY0_BASE + 0x7e0);
+
+	writel(0x80, SUNXI_DRAM_PHY0_BASE + 0x3dc);
+	writel(0x80, SUNXI_DRAM_PHY0_BASE + 0x45c);
+
+	mctl_phy_odt();
+
+	clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 4, 7, 0xa);
+
+	if (para->clk <= 672)
+		writel(0xf, SUNXI_DRAM_PHY0_BASE + 0x20);
+	if (para->clk > 500) {
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x144, BIT(7));
+		clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x14c, 0xe0);
+	} else {
+		setbits_le32(SUNXI_DRAM_PHY0_BASE + 0x144, BIT(7));
+		clrsetbits_le32(SUNXI_DRAM_PHY0_BASE + 0x14c, 0xe0, 0x20);
+	}
+
+	clrbits_le32(SUNXI_DRAM_PHY0_BASE + 0x14c, 8);
+
+	mctl_await_completion((u32*)(SUNXI_DRAM_PHY0_BASE + 0x180), 4, 4);
+
+	writel(0x37, SUNXI_DRAM_PHY0_BASE + 0x58);
+	clrbits_le32(0x47FA500, 0x200);
+
+	writel(0, &mctl_ctl->swctl);
+	setbits_le32(&mctl_ctl->dfimisc, 1);
+
+	/* start DFI init */
+	setbits_le32(&mctl_ctl->dfimisc, 0x20);
+	writel(1, &mctl_ctl->swctl);
+	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
+	/* poll DFI init complete */
+	mctl_await_completion(&mctl_ctl->dfistat, 1, 1);
+	writel(0, &mctl_ctl->swctl);
+	clrbits_le32(&mctl_ctl->dfimisc, 0x20);
+
+	clrbits_le32(&mctl_ctl->pwrctl, 0x20);
+	writel(1, &mctl_ctl->swctl);
+	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
+	mctl_await_completion(&mctl_ctl->statr, 3, 1);
+
+	writel(0, &mctl_ctl->swctl);
+	clrbits_le32(&mctl_ctl->dfimisc, 1);
+
+	writel(1, &mctl_ctl->swctl);
+	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
+
+	writel(0x1f14, &mctl_ctl->mrctrl1);
+	writel(0x80000030, &mctl_ctl->mrctrl0);
+	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+	writel(4, &mctl_ctl->mrctrl1);
+	writel(0x80001030, &mctl_ctl->mrctrl0);
+	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+	writel(0x20, &mctl_ctl->mrctrl1);
+	writel(0x80002030, &mctl_ctl->mrctrl0);
+	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+	writel(0, &mctl_ctl->mrctrl1);
+	writel(0x80003030, &mctl_ctl->mrctrl0);
+	mctl_await_completion(&mctl_ctl->mrctrl0, BIT(31), 0);
+
+	writel(0, SUNXI_DRAM_PHY0_BASE + 0x54);
+
+	writel(0, &mctl_ctl->swctl);
+	clrbits_le32(&mctl_ctl->rfshctl3, 1);
+	writel(1, &mctl_ctl->swctl);
+
+	/*for (i = 0; i < 5; i++)
+		if (mctl_phy_write_leveling(para))
+			break;
+	if (i == 5) {
+		debug("write leveling failed!\n");
+		return false;
+	}
+	debug("write leveling finished\n");*/
+
+	for (i = 0; i < 5; i++)
+		if (mctl_phy_read_calibration(para))
+			break;
+	if (i == 5) {
+		debug("read calibration failed!\n");
+		return false;
+	}
+	debug("read calibration finished\n");
+
+	/*for (i = 0; i < 5; i++)
+		if (mctl_phy_read_training(para))
+			break;
+	if (i == 5) {
+		debug("read training failed!\n");
+		return false;
+	}
+	debug("read training finished\n");*/
+
+	/*for (i = 0; i < 5; i++)
+		if (mctl_phy_write_training(para))
+			break;
+	if (i == 5) {
+		debug("write training failed!\n");
+		return false;
+	}
+	debug("write training finished\n");*/
+
+	mctl_phy_bit_delay_compensation(para);
+
+	/*for (i = 0; i < 0x1000; i += 0x10)
+		printf("%08x: %08x %08x %08x %08x\n",
+		       SUNXI_DRAM_PHY0_BASE + i,
+		       readl(SUNXI_DRAM_PHY0_BASE + i),
+		       readl(SUNXI_DRAM_PHY0_BASE + i + 4),
+		       readl(SUNXI_DRAM_PHY0_BASE + i + 8),
+		       readl(SUNXI_DRAM_PHY0_BASE + i + 12));*/
+
+	return true;
+}
+
+static bool mctl_ctrl_init(struct dram_para *para)
+{
+	struct sunxi_mctl_com_reg * const mctl_com =
+			(struct sunxi_mctl_com_reg *)SUNXI_DRAM_COM_BASE;
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+	u32 reg_val;
+
+	clrsetbits_le32(0x47FA500, BIT(24), 0x200);
+	writel(0x8000, &mctl_ctl->unk_0x00c);
+
+	setbits_le32(&mctl_com->unk_0x008, 0xff00);
+
+	clrsetbits_le32(&mctl_ctl->sched[0], 0xff00, 0x3000);
+
+	writel(0, &mctl_ctl->hwlpctl);
+
+	setbits_le32(&mctl_com->unk_0x008, 0xff00);
+
+	reg_val = MSTR_BURST_LENGTH(8) | MSTR_ACTIVE_RANKS(para->ranks);
+	reg_val |= MSTR_DEVICETYPE_DDR3 | MSTR_2TMODE;
+	if (para->bus_full_width)
+		reg_val |= MSTR_BUSWIDTH_FULL;
+	else
+		reg_val |= MSTR_BUSWIDTH_HALF;
+	writel(BIT(31) | BIT(30) | reg_val, &mctl_ctl->mstr);
+
+	if (para->ranks == 2)
+		writel(0x0303, &mctl_ctl->odtmap);
+	else
+		writel(0x0201, &mctl_ctl->odtmap);
+
+	writel(0x06000400, &mctl_ctl->odtcfg);
+	writel(0x06000400, 0x47FD240);
+	writel(0x06000400, 0x47FE240);
+	writel(0x06000400, 0x47FF240);
+
+	setbits_le32(&mctl_com->cr, BIT(31));
+
+	mctl_set_addrmap(para);
+
+	mctl_set_timing_params(para);
+
+	writel(0, &mctl_ctl->pwrctl);
+
+	setbits_le32(&mctl_ctl->dfiupd[0], BIT(31) | BIT(30));
+	setbits_le32(&mctl_ctl->zqctl[0], BIT(31) | BIT(30));
+	setbits_le32(0x47FD180, BIT(31) | BIT(30));
+	setbits_le32(0x47FE180, BIT(31) | BIT(30));
+	setbits_le32(0x47FF180, BIT(31) | BIT(30));
+
+	setbits_le32(&mctl_ctl->rfshctl3, BIT(0));
+	clrbits_le32(&mctl_ctl->dfimisc, BIT(0));
+
+	writel(0, &mctl_com->maer0);
+	writel(0, &mctl_com->maer1);
+	writel(0, &mctl_com->maer2);
+
+	writel(0x20, &mctl_ctl->pwrctl);
+	setbits_le32(&mctl_ctl->unk_0x00c, BIT(8));
+
+	clrsetbits_le32(0x47FA500, BIT(24), 0x300);
+	/* this write seems to enable PHY MMIO region */
+	setbits_le32(0x47FA500, BIT(24));
+
+	if (!mctl_phy_init(para))
+		return false;
+
+	writel(0, &mctl_ctl->swctl);
+	clrbits_le32(&mctl_ctl->rfshctl3, BIT(0));
+
+	setbits_le32(&mctl_com->unk_0x014, BIT(31));
+	writel(0xffffffff, &mctl_com->maer0);
+	writel(0x7ff, &mctl_com->maer1);
+	writel(0xffff, &mctl_com->maer2);
+
+	writel(1, &mctl_ctl->swctl);
+	mctl_await_completion(&mctl_ctl->swstat, 1, 1);
+
+	return true;
+}
+
+static bool mctl_core_init(struct dram_para *para)
+{
+	mctl_sys_init(para);
+
+	return mctl_ctrl_init(para);
+}
+
+static void mctl_auto_detect_rank_width(struct dram_para *para)
+{
+	/* this is minimum size that it's supported */
+	para->cols = 8;
+	para->rows = 13;
+
+	/*
+	 * Strategy here is to test most demanding combination first and least
+	 * demanding last, otherwise HW might not be fully utilized. For
+	 * example, half bus width and rank = 1 combination would also work
+	 * on HW with full bus width and rank = 2, but only 1/4 RAM would be
+	 * visible.
+	 */
+
+	debug("testing 32-bit width, rank = 2\n");
+	para->bus_full_width = 1;
+	para->ranks = 2;
+	if (mctl_core_init(para))
+		return;
+
+	debug("testing 32-bit width, rank = 1\n");
+	para->bus_full_width = 1;
+	para->ranks = 1;
+	if (mctl_core_init(para))
+		return;
+
+	debug("testing 16-bit width, rank = 2\n");
+	para->bus_full_width = 0;
+	para->ranks = 2;
+	if (mctl_core_init(para))
+		return;
+
+	debug("testing 16-bit width, rank = 1\n");
+	para->bus_full_width = 0;
+	para->ranks = 1;
+	if (mctl_core_init(para))
+		return;
+
+	panic("This DRAM setup is currently not supported.\n");
+}
+
+static void mctl_auto_detect_dram_size(struct dram_para *para)
+{
+	/* detect row address bits */
+	para->cols = 8;
+	para->rows = 18;
+	mctl_core_init(para);
+
+	for (para->rows = 13; para->rows < 18; para->rows++) {
+		/* 8 banks, 8 bit per byte and 16/32 bit width */
+		if (mctl_mem_matches((1 << (para->rows + para->cols +
+					    4 + para->bus_full_width))))
+			break;
+	}
+
+	/* detect column address bits */
+	para->cols = 11;
+	mctl_core_init(para);
+
+	for (para->cols = 8; para->cols < 11; para->cols++) {
+		/* 8 bits per byte and 16/32 bit width */
+		if (mctl_mem_matches(1 << (para->cols + 1 +
+					   para->bus_full_width)))
+			break;
+	}
+}
+
+static unsigned long long mctl_calc_size(struct dram_para *para)
+{
+	u8 width = para->bus_full_width ? 4 : 2;
+
+	/* 8 banks */
+	return (1ULL << (para->cols + para->rows + 3)) * width * para->ranks;
+}
+
+unsigned long sunxi_dram_init(void)
+{
+	struct dram_para para = {
+		.clk = CONFIG_DRAM_CLK,
+		.type = SUNXI_DRAM_TYPE_DDR3,
+	};
+	unsigned long long size;
+
+	setbits_le32(0x7010310, BIT(8));
+	clrbits_le32(0x7010318, 0x3f);
+
+	mctl_auto_detect_rank_width(&para);
+	mctl_auto_detect_dram_size(&para);
+
+	mctl_core_init(&para);
+
+	size = mctl_calc_size(&para);
+
+	mctl_set_master_priority();
+
+	/* hack for 4 GiB RAM on 32-bit build */
+	if (size >= (1ULL << 32))
+		return 0xc0000000;
+
+	return size;
+};
diff --git a/arch/arm/mach-sunxi/dram_timings/Makefile b/arch/arm/mach-sunxi/dram_timings/Makefile
index 0deb9911..39a8756c 100644
--- a/arch/arm/mach-sunxi/dram_timings/Makefile
+++ b/arch/arm/mach-sunxi/dram_timings/Makefile
@@ -3,3 +3,5 @@ obj-$(CONFIG_SUNXI_DRAM_LPDDR3_STOCK)	+= lpddr3_stock.o
 obj-$(CONFIG_SUNXI_DRAM_DDR2_V3S)	+= ddr2_v3s.o
 obj-$(CONFIG_SUNXI_DRAM_H6_LPDDR3)	+= h6_lpddr3.o
 obj-$(CONFIG_SUNXI_DRAM_H6_DDR3_1333)	+= h6_ddr3_1333.o
+# currently only DDR3 is supported on H616
+obj-$(CONFIG_MACH_SUN50I_H616)		+= h616_ddr3_1333.o
diff --git a/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c b/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c
new file mode 100644
index 00000000..53135626
--- /dev/null
+++ b/arch/arm/mach-sunxi/dram_timings/h616_ddr3_1333.c
@@ -0,0 +1,105 @@
+/*
+ * sun50i H6 DDR3-1333 timings, as programmed by Allwinner's boot0
+ * for some TV boxes with the H6 and DDR3 memory.
+ *
+ * The chips are probably able to be driven by a faster clock, but boot0
+ * uses a more conservative timing (as usual).
+ *
+ * (C) Copyright 2018,2019 Arm Ltd.
+ *   based on previous work by:
+ *   (C) Copyright 2017      Icenowy Zheng <icenowy@aosc.io>
+ *
+ * References used:
+ * - JEDEC DDR3 SDRAM standard:	JESD79-3F.pdf
+ * - Samsung K4B2G0446D datasheet
+ * - ZynqMP UG1087 register DDRC/PHY documentation
+ *
+ * Many thanks to Jernej Skrabec for contributing some fixes!
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/cpu.h>
+
+void mctl_set_timing_params(struct dram_para *para)
+{
+	struct sunxi_mctl_ctl_reg * const mctl_ctl =
+			(struct sunxi_mctl_ctl_reg *)SUNXI_DRAM_CTL0_BASE;
+
+	u8 tccd		= 2;			/* JEDEC: 4nCK */
+	u8 tfaw		= ns_to_t(50);		/* JEDEC: 30 ns w/ 1K pages */
+	u8 trrd		= max(ns_to_t(6), 4);	/* JEDEC: max(6 ns, 4nCK) */
+	u8 trcd		= ns_to_t(15);		/* JEDEC: 13.5 ns */
+	u8 trc		= ns_to_t(53);		/* JEDEC: 49.5 ns */
+	u8 txp		= max(ns_to_t(6), 3);	/* JEDEC: max(6 ns, 3nCK) */
+	//u8 twtr		= max(ns_to_t(8), 2);	/* JEDEC: max(7.5 ns, 4nCK) */
+	u8 trtp		= max(ns_to_t(8), 2);	/* JEDEC: max(7.5 ns, 4nCK) */
+	//u8 twr		= ns_to_t(15);		/* JEDEC: 15 ns */
+	u8 trp		= ns_to_t(15);		/* JEDEC: >= 13.75 ns */
+	u8 tras		= ns_to_t(38);		/* JEDEC >= 36 ns, <= 9*trefi */
+	u16 trefi	= ns_to_t(7800) / 32;	/* JEDEC: 7.8us@Tcase <= 85C */
+	u16 trfc	= ns_to_t(350);		/* JEDEC: 160 ns for 2Gb */
+	u16 txsr	= 4;			/* ? */
+
+	u8 tmrw		= 0;			/* ? */
+	u8 tmrd		= 4;			/* JEDEC: 4nCK */
+	u8 tmod		= max(ns_to_t(15), 12);	/* JEDEC: max(15 ns, 12nCK) */
+	u8 tcke		= max(ns_to_t(6), 3);	/* JEDEC: max(5.625 ns, 3nCK) */
+	u8 tcksrx	= max(ns_to_t(10), 4);	/* JEDEC: max(10 ns, 5nCK) */
+	u8 tcksre	= max(ns_to_t(10), 4);	/* JEDEC: max(10 ns, 5nCK) */
+	u8 tckesr	= tcke + 1;		/* JEDEC: tCKE(min) + 1nCK */
+	u8 trasmax	= (para->clk / 2) / 15;	/* JEDEC: tREFI * 9 */
+	u8 txs		= ns_to_t(360) / 32;	/* JEDEC: max(5nCK,tRFC+10ns) */
+	u8 txsdll	= 16;			/* JEDEC: 512 nCK */
+	u8 txsabort	= 4;			/* ? */
+	u8 txsfast	= 4;			/* ? */
+	u8 tcl		= 7;			/* JEDEC: CL / 2 => 6 */
+	u8 tcwl		= 5;			/* JEDEC: 8 */
+	u8 t_rdata_en	= 9;			/* ? */
+
+	u8 twtp		= 14;			/* (WL + BL / 2 + tWR) / 2 */
+	u8 twr2rd	= trtp + 7;		/* (WL + BL / 2 + tWTR) / 2 */
+	u8 trd2wr	= 5;			/* (RL + BL / 2 + 2 - WL) / 2 */
+
+	/* set DRAM timing */
+	writel((twtp << 24) | (tfaw << 16) | (trasmax << 8) | tras,
+	       &mctl_ctl->dramtmg[0]);
+	writel((txp << 16) | (trtp << 8) | trc, &mctl_ctl->dramtmg[1]);
+	writel((tcwl << 24) | (tcl << 16) | (trd2wr << 8) | twr2rd,
+	       &mctl_ctl->dramtmg[2]);
+	writel((tmrw << 20) | (tmrd << 12) | tmod, &mctl_ctl->dramtmg[3]);
+	writel((trcd << 24) | (tccd << 16) | (trrd << 8) | trp,
+	       &mctl_ctl->dramtmg[4]);
+	writel((tcksrx << 24) | (tcksre << 16) | (tckesr << 8) | tcke,
+	       &mctl_ctl->dramtmg[5]);
+	/* Value suggested by ZynqMP manual and used by libdram */
+	writel((txp + 2) | 0x02020000, &mctl_ctl->dramtmg[6]);
+	writel((txsfast << 24) | (txsabort << 16) | (txsdll << 8) | txs,
+	       &mctl_ctl->dramtmg[8]);
+	writel(0x00020208, &mctl_ctl->dramtmg[9]);
+	writel(0xE0C05, &mctl_ctl->dramtmg[10]);
+	writel(0x440C021C, &mctl_ctl->dramtmg[11]);
+	writel(8, &mctl_ctl->dramtmg[12]);
+	writel(0xA100002, &mctl_ctl->dramtmg[13]);
+	writel(txsr, &mctl_ctl->dramtmg[14]);
+
+	//clrsetbits_le32(&mctl_ctl->init[0], (3 << 30), (1 << 30));
+	clrbits_le32(&mctl_ctl->init[0], 3 << 30);
+	writel(0x420000, &mctl_ctl->init[1]);
+	writel(5, &mctl_ctl->init[2]);
+	writel(0x1f140004, &mctl_ctl->init[3]);
+	writel(0x00200000, &mctl_ctl->init[4]);
+
+	writel(0, &mctl_ctl->dfimisc);
+	clrsetbits_le32(&mctl_ctl->rankctl, 0xff0, 0x660);
+
+	/* Configure DFI timing */
+	writel((tcl - 2) | 0x2000000 | (t_rdata_en << 16) | 0x808000,
+	       &mctl_ctl->dfitmg0);
+	writel(0x100202, &mctl_ctl->dfitmg1);
+
+	/* set refresh timing */
+	writel((trefi << 16) | trfc, &mctl_ctl->rfshtmg);
+}
diff --git a/arch/arm/mach-sunxi/pmic_bus.c b/arch/arm/mach-sunxi/pmic_bus.c
index dea42de8..0394ce85 100644
--- a/arch/arm/mach-sunxi/pmic_bus.c
+++ b/arch/arm/mach-sunxi/pmic_bus.c
@@ -18,6 +18,8 @@
 
 #define AXP209_I2C_ADDR			0x34
 
+#define AXP305_I2C_ADDR			0x36
+
 #define AXP221_CHIP_ADDR		0x68
 #define AXP221_CTRL_ADDR		0x3e
 #define AXP221_INIT_DATA		0x3e
@@ -64,6 +66,8 @@ int pmic_bus_read(u8 reg, u8 *data)
 	return i2c_read(AXP152_I2C_ADDR, reg, 1, data, 1);
 #elif defined CONFIG_AXP209_POWER
 	return i2c_read(AXP209_I2C_ADDR, reg, 1, data, 1);
+#elif defined CONFIG_AXP305_POWER
+	return i2c_read(AXP305_I2C_ADDR, reg, 1, data, 1);
 #elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 # ifdef CONFIG_MACH_SUN6I
 	return p2wi_read(reg, data);
@@ -81,6 +85,8 @@ int pmic_bus_write(u8 reg, u8 data)
 	return i2c_write(AXP152_I2C_ADDR, reg, 1, &data, 1);
 #elif defined CONFIG_AXP209_POWER
 	return i2c_write(AXP209_I2C_ADDR, reg, 1, &data, 1);
+#elif defined CONFIG_AXP305_POWER
+	return i2c_write(AXP305_I2C_ADDR, reg, 1, &data, 1);
 #elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 # ifdef CONFIG_MACH_SUN6I
 	return p2wi_write(reg, data);
diff --git a/arch/arm/mach-sunxi/rmr_switch.S b/arch/arm/mach-sunxi/rmr_switch.S
index fafd306f..bb30ee3d 100644
--- a/arch/arm/mach-sunxi/rmr_switch.S
+++ b/arch/arm/mach-sunxi/rmr_switch.S
@@ -30,7 +30,7 @@
 
 .text
 
-#ifndef CONFIG_MACH_SUN50I_H6
+#if !defined(CONFIG_MACH_SUN50I_H6) && !defined(CONFIG_MACH_SUN50I_H616)
 	ldr	r1, =0x017000a0		@ MMIO mapped RVBAR[0] register
 #else
 	ldr	r1, =0x09010040		@ MMIO mapped RVBAR[0] register
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 708a27ed..ee4047a4 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -196,6 +196,10 @@ void i2c_init_board(void)
 	clock_twi_onoff(5, 1);
 	sunxi_gpio_set_cfgpin(SUNXI_GPL(8), SUN50I_GPL_R_TWI);
 	sunxi_gpio_set_cfgpin(SUNXI_GPL(9), SUN50I_GPL_R_TWI);
+#elif CONFIG_MACH_SUN50I_H616
+	clock_twi_onoff(5, 1);
+	sunxi_gpio_set_cfgpin(SUNXI_GPL(0), SUN50I_H616_GPL_R_TWI);
+	sunxi_gpio_set_cfgpin(SUNXI_GPL(1), SUN50I_H616_GPL_R_TWI);
 #else
 	clock_twi_onoff(5, 1);
 	sunxi_gpio_set_cfgpin(SUNXI_GPL(0), SUN8I_H3_GPL_R_TWI);
@@ -634,30 +638,38 @@ void sunxi_board_init(void)
 #endif
 
 #if defined CONFIG_AXP152_POWER || defined CONFIG_AXP209_POWER || \
-	defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
-	defined CONFIG_AXP818_POWER
+	defined CONFIG_AXP221_POWER || defined CONFIG_AXP305_POWER || \
+	defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 	power_failed = axp_init();
 
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
 	defined CONFIG_AXP818_POWER
 	power_failed |= axp_set_dcdc1(CONFIG_AXP_DCDC1_VOLT);
 #endif
+#if !defined(CONFIG_AXP305_POWER)
 	power_failed |= axp_set_dcdc2(CONFIG_AXP_DCDC2_VOLT);
 	power_failed |= axp_set_dcdc3(CONFIG_AXP_DCDC3_VOLT);
-#if !defined(CONFIG_AXP209_POWER) && !defined(CONFIG_AXP818_POWER)
+#endif
+#if !defined(CONFIG_AXP209_POWER) && !defined(CONFIG_AXP818_POWER) && \
+	!defined(CONFIG_AXP305_POWER)
 	power_failed |= axp_set_dcdc4(CONFIG_AXP_DCDC4_VOLT);
 #endif
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
 	defined CONFIG_AXP818_POWER
 	power_failed |= axp_set_dcdc5(CONFIG_AXP_DCDC5_VOLT);
 #endif
+#if defined CONFIG_AXP305_POWER
+	power_failed |= axp_set_dcdcd(CONFIG_AXP_DCDCD_VOLT);
+#endif
 
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
 	defined CONFIG_AXP818_POWER
 	power_failed |= axp_set_aldo1(CONFIG_AXP_ALDO1_VOLT);
 #endif
+#if !defined(CONFIG_AXP305_POWER)
 	power_failed |= axp_set_aldo2(CONFIG_AXP_ALDO2_VOLT);
-#if !defined(CONFIG_AXP152_POWER)
+#endif
+#if !defined(CONFIG_AXP152_POWER) && !defined(CONFIG_AXP305_POWER)
 	power_failed |= axp_set_aldo3(CONFIG_AXP_ALDO3_VOLT);
 #endif
 #ifdef CONFIG_AXP209_POWER
diff --git a/common/spl/Kconfig b/common/spl/Kconfig
index d8086bd9..886914f0 100644
--- a/common/spl/Kconfig
+++ b/common/spl/Kconfig
@@ -150,7 +150,7 @@ config SPL_TEXT_BASE
 	hex "SPL Text Base"
 	default ISW_ENTRY_ADDR if AM43XX || AM33XX || OMAP54XX || ARCH_KEYSTONE
 	default 0x10060 if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN9I
-	default 0x20060 if MACH_SUN50I_H6
+	default 0x20060 if MACH_SUN50I_H6 || MACH_SUN50I_H616
 	default 0x00060 if ARCH_SUNXI
 	default 0xfffc0000 if ARCH_ZYNQMP
 	default 0x0
@@ -459,7 +459,7 @@ config SPL_SHA512_SUPPORT
 config SPL_FIT_IMAGE_TINY
 	bool "Remove functionality from SPL FIT loading to reduce size"
 	depends on SPL_FIT
-	default y if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN50I_H6
+	default y if MACH_SUN50I || MACH_SUN50I_H5 || MACH_SUN50I_H6 || MACH_SUN50I_H616
 	default y if ARCH_IMX8M
 	help
 	  Enable this to reduce the size of the FIT image loading code
diff --git a/configs/tanix_tx6s_defconfig b/configs/tanix_tx6s_defconfig
new file mode 100644
index 00000000..d3f295e9
--- /dev/null
+++ b/configs/tanix_tx6s_defconfig
@@ -0,0 +1,10 @@
+CONFIG_ARM=y
+CONFIG_ARCH_SUNXI=y
+CONFIG_SPL=y
+CONFIG_MACH_SUN50I_H616=y
+CONFIG_DRAM_CLK=696
+CONFIG_MMC0_CD_PIN="PF6"
+# CONFIG_PSCI_RESET is not set
+CONFIG_DEFAULT_DEVICE_TREE="sun50i-h6-orangepi-lite2"
+# CONFIG_SYS_MALLOC_CLEAR_ON_INIT is not set
+CONFIG_SPL_I2C_SUPPORT=y
diff --git a/drivers/clk/sunxi/Kconfig b/drivers/clk/sunxi/Kconfig
index 5ff101b9..716a8a39 100644
--- a/drivers/clk/sunxi/Kconfig
+++ b/drivers/clk/sunxi/Kconfig
@@ -74,7 +74,7 @@ config CLK_SUN8I_H3
 
 config CLK_SUN50I_H6
 	bool "Clock driver for Allwinner H6"
-	default MACH_SUN50I_H6
+	default MACH_SUN50I_H6 || MACH_SUN50I_H616
 	help
 	  This enables common clock driver support for platforms based
 	  on Allwinner H6 SoC.
diff --git a/drivers/mmc/sunxi_mmc.c b/drivers/mmc/sunxi_mmc.c
index 0e03b07c..5c68f497 100644
--- a/drivers/mmc/sunxi_mmc.c
+++ b/drivers/mmc/sunxi_mmc.c
@@ -122,7 +122,7 @@ static int mmc_set_mod_clk(struct sunxi_mmc_priv *priv, unsigned int hz)
 	if (IS_ENABLED(CONFIG_MACH_SUN8I_A83T) && priv->mmc_no != 2)
 		new_mode = false;
 
-#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN50I_H6)
+#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 	calibrate = true;
 #endif
 
@@ -133,7 +133,7 @@ static int mmc_set_mod_clk(struct sunxi_mmc_priv *priv, unsigned int hz)
 #ifdef CONFIG_MACH_SUN9I
 		pll = CCM_MMC_CTRL_PLL_PERIPH0;
 		pll_hz = clock_get_pll4_periph0();
-#elif defined(CONFIG_MACH_SUN50I_H6)
+#elif defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 		pll = CCM_MMC_CTRL_PLL6X2;
 		pll_hz = clock_get_pll6() * 2;
 #else
@@ -249,7 +249,7 @@ static int mmc_config_clock(struct sunxi_mmc_priv *priv, struct mmc *mmc)
 	rval &= ~SUNXI_MMC_CLK_DIVIDER_MASK;
 	writel(rval, &priv->reg->clkcr);
 
-#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN50I_H6)
+#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 	/* A64 supports calibration of delays on MMC controller and we
 	 * have to set delay of zero before starting calibration.
 	 * Allwinner BSP driver sets a delay only in the case of
@@ -530,7 +530,7 @@ struct mmc *sunxi_mmc_init(int sdc_no)
 
 	cfg->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
 	cfg->host_caps = MMC_MODE_4BIT;
-#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN8I) || defined(CONFIG_MACH_SUN50I_H6)
+#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUN8I) || defined(CONFIG_MACH_SUN50I_H6) || defined(CONFIG_MACH_SUN50I_H616)
 	if (sdc_no == 2)
 		cfg->host_caps = MMC_MODE_8BIT;
 #endif
@@ -545,7 +545,7 @@ struct mmc *sunxi_mmc_init(int sdc_no)
 
 	/* config ahb clock */
 	debug("init mmc %d clock and io\n", sdc_no);
-#if !defined(CONFIG_MACH_SUN50I_H6)
+#if !defined(CONFIG_MACH_SUN50I_H6) && !defined(CONFIG_MACH_SUN50I_H616)
 	setbits_le32(&ccm->ahb_gate0, 1 << AHB_GATE_OFFSET_MMC(sdc_no));
 
 #ifdef CONFIG_SUNXI_GEN_SUN6I
@@ -557,7 +557,7 @@ struct mmc *sunxi_mmc_init(int sdc_no)
 	writel(SUNXI_MMC_COMMON_CLK_GATE | SUNXI_MMC_COMMON_RESET,
 	       SUNXI_MMC_COMMON_BASE + 4 * sdc_no);
 #endif
-#else /* CONFIG_MACH_SUN50I_H6 */
+#else /* CONFIG_MACH_SUN50I_H6 || CONFIG_MACH_SUN50I_H616 */
 	setbits_le32(&ccm->sd_gate_reset, 1 << sdc_no);
 	/* unassert reset */
 	setbits_le32(&ccm->sd_gate_reset, 1 << (RESET_SHIFT + sdc_no));
diff --git a/drivers/power/Kconfig b/drivers/power/Kconfig
index 02050f6f..70018550 100644
--- a/drivers/power/Kconfig
+++ b/drivers/power/Kconfig
@@ -13,6 +13,7 @@ choice
 	depends on ARCH_SUNXI
 	default AXP209_POWER if MACH_SUN4I || MACH_SUN5I || MACH_SUN7I
 	default AXP221_POWER if MACH_SUN6I || MACH_SUN8I_A23 || MACH_SUN8I_A33 || MACH_SUN8I_R40
+	default AXP305_POWER if MACH_SUN50I_H616
 	default AXP818_POWER if MACH_SUN8I_A83T
 	default SUNXI_NO_PMIC if MACH_SUNXI_H3_H5 || MACH_SUN50I || MACH_SUN8I_V3S
 
@@ -48,6 +49,15 @@ config AXP221_POWER
 	Select this to enable support for the axp221/axp223 pmic found on most
 	A23 and A31 boards.
 
+config AXP305_POWER
+	bool "axp305 pmic support"
+	depends on MACH_SUN50I_H616
+	select AXP_PMIC_BUS
+	select CMD_POWEROFF
+	---help---
+	Select this to enable support for the axp305 pmic found on most
+	H616 boards.
+
 config AXP809_POWER
 	bool "axp809 pmic support"
 	depends on MACH_SUN9I
@@ -151,6 +161,15 @@ config AXP_DCDC5_VOLT
 	On A23 / A31 / A33 / A80 / A83T / R40 boards dcdc5 is VCC-DRAM and
 	should be 1.5V, 1.35V if DDR3L is used.
 
+config AXP_DCDCD_VOLT
+	int "axp pmic dcdcd voltage"
+	depends on AXP305_POWER
+	default 1500
+	---help---
+	Set the voltage (mV) to program the axp pmic dcdcd at, set to 0 to
+	disable dcdcd.
+	On H616 boards with an axp305 dcdcd is VCC-DRAM and should be 1.5V.
+
 config AXP_ALDO1_VOLT
 	int "axp pmic (a)ldo1 voltage"
 	depends on AXP221_POWER || AXP809_POWER || AXP818_POWER
diff --git a/drivers/power/Makefile b/drivers/power/Makefile
index 2dcc7bb9..0bef0692 100644
--- a/drivers/power/Makefile
+++ b/drivers/power/Makefile
@@ -6,6 +6,7 @@
 obj-$(CONFIG_AXP152_POWER)	+= axp152.o
 obj-$(CONFIG_AXP209_POWER)	+= axp209.o
 obj-$(CONFIG_AXP221_POWER)	+= axp221.o
+obj-$(CONFIG_AXP305_POWER)	+= axp305.o
 obj-$(CONFIG_AXP809_POWER)	+= axp809.o
 obj-$(CONFIG_AXP818_POWER)	+= axp818.o
 obj-$(CONFIG_EXYNOS_TMU)	+= exynos-tmu.o
diff --git a/drivers/power/axp305.c b/drivers/power/axp305.c
new file mode 100644
index 00000000..53d4d3f2
--- /dev/null
+++ b/drivers/power/axp305.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * AXP305 driver
+ *
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * Based on axp221.c
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ * (C) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <asm/arch/pmic_bus.h>
+#include <axp_pmic.h>
+
+static u8 axp305_mvolt_to_cfg(int mvolt, int min, int max, int div)
+{
+	if (mvolt < min)
+		mvolt = min;
+	else if (mvolt > max)
+		mvolt = max;
+
+	return  (mvolt - min) / div;
+}
+
+int axp_set_dcdcd(unsigned int mvolt)
+{
+	int ret;
+	u8 cfg;
+
+	if (mvolt >= 1600)
+		cfg = 46 + axp305_mvolt_to_cfg(mvolt, 1600, 3300, 100);
+	else
+		cfg = axp305_mvolt_to_cfg(mvolt, 600, 1500, 20);
+
+	if (mvolt == 0)
+		return pmic_bus_clrbits(AXP305_OUTPUT_CTRL1,
+					AXP305_OUTPUT_CTRL1_DCDCD_EN);
+
+	ret = pmic_bus_write(AXP305_DCDCD_VOLTAGE, cfg);
+	if (ret)
+		return ret;
+
+	return pmic_bus_setbits(AXP305_OUTPUT_CTRL1,
+				AXP305_OUTPUT_CTRL1_DCDCD_EN);
+}
+
+int axp_init(void)
+{
+	u8 axp_chip_id;
+	int ret;
+
+	ret = pmic_bus_init();
+	if (ret)
+		return ret;
+
+	ret = pmic_bus_read(AXP305_CHIP_VERSION, &axp_chip_id);
+	if (ret)
+		return ret;
+
+	if ((axp_chip_id & AXP305_CHIP_VERSION_MASK) != 0x40)
+		return -ENODEV;
+
+	return ret;
+}
+
+int do_poweroff(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	pmic_bus_write(AXP305_SHUTDOWN, AXP305_POWEROFF);
+
+	/* infinite loop during shutdown */
+	while (1) {}
+
+	/* not reached */
+	return 0;
+}
diff --git a/include/axp305.h b/include/axp305.h
new file mode 100644
index 00000000..225c5040
--- /dev/null
+++ b/include/axp305.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+enum axp305_reg {
+	AXP305_CHIP_VERSION = 0x3,
+	AXP305_OUTPUT_CTRL1 = 0x10,
+	AXP305_DCDCD_VOLTAGE = 0x15,
+	AXP305_SHUTDOWN = 0x32,
+};
+
+#define AXP305_CHIP_VERSION_MASK	0xcf
+
+#define AXP305_OUTPUT_CTRL1_DCDCD_EN	(1 << 3)
+
+#define AXP305_POWEROFF			(1 << 7)
diff --git a/include/axp_pmic.h b/include/axp_pmic.h
index 10091d0b..371c834c 100644
--- a/include/axp_pmic.h
+++ b/include/axp_pmic.h
@@ -15,6 +15,9 @@
 #ifdef CONFIG_AXP221_POWER
 #include <axp221.h>
 #endif
+#ifdef CONFIG_AXP305_POWER
+#include <axp305.h>
+#endif
 #ifdef CONFIG_AXP809_POWER
 #include <axp809.h>
 #endif
@@ -27,6 +30,7 @@ int axp_set_dcdc2(unsigned int mvolt);
 int axp_set_dcdc3(unsigned int mvolt);
 int axp_set_dcdc4(unsigned int mvolt);
 int axp_set_dcdc5(unsigned int mvolt);
+int axp_set_dcdcd(unsigned int mvolt);
 int axp_set_aldo1(unsigned int mvolt);
 int axp_set_aldo2(unsigned int mvolt);
 int axp_set_aldo3(unsigned int mvolt);
diff --git a/include/configs/sun50i.h b/include/configs/sun50i.h
index e050a529..c511b5e0 100644
--- a/include/configs/sun50i.h
+++ b/include/configs/sun50i.h
@@ -10,7 +10,7 @@
  * A64 specific configuration
  */
 
-#ifndef CONFIG_MACH_SUN50I_H6
+#if !defined(CONFIG_MACH_SUN50I_H6) && !defined(CONFIG_MACH_SUN50I_H616)
 #define GICD_BASE		0x1c81000
 #define GICC_BASE		0x1c82000
 #else
diff --git a/include/configs/sunxi-common.h b/include/configs/sunxi-common.h
index 203cb10f..0de815a0 100644
--- a/include/configs/sunxi-common.h
+++ b/include/configs/sunxi-common.h
@@ -179,8 +179,13 @@
 #endif /* !CONFIG_ARM64 */
 #elif CONFIG_SUNXI_SRAM_ADDRESS == 0x20000
 #define CONFIG_SPL_MAX_SIZE		0x7fa0		/* 32 KiB */
+#ifdef CONFIG_MACH_SUN50I_H6
 /* end of SRAM A2 on H6 for now */
 #define LOW_LEVEL_SRAM_STACK		0x00118000
+#elif CONFIG_MACH_SUN50I_H616
+/* end of SRAM C on H616 for now */
+#define LOW_LEVEL_SRAM_STACK		0x58000
+#endif
 #else
 #define CONFIG_SPL_MAX_SIZE		0x5fa0		/* 24KB on sun4i/sun7i */
 #define LOW_LEVEL_SRAM_STACK		0x00008000	/* End of sram */
-- 
2.29.2

