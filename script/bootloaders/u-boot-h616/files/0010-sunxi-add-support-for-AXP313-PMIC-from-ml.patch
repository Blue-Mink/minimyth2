
Code i based on https://lore.kernel.org/linux-sunxi/20231018155014.383566-1-andre.przywara@arm.com/T/#t


diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/arch/arm/mach-sunxi/pmic_bus.c u-boot-2021.07/arch/arm/mach-sunxi/pmic_bus.c
--- u-boot-2021.07/arch/arm/mach-sunxi/pmic_bus.c	2021-07-05 17:11:28.000000000 +0200
+++ u-boot-2021.07/arch/arm/mach-sunxi/pmic_bus.c	2023-10-18 20:52:00.166809124 +0200
@@ -19,6 +19,7 @@
 #define AXP209_I2C_ADDR			0x34
 
 #define AXP305_I2C_ADDR			0x36
+#define AXP313_I2C_ADDR			0x36
 
 #define AXP221_CHIP_ADDR		0x68
 #define AXP221_CTRL_ADDR		0x3e
@@ -66,7 +67,7 @@
 	return i2c_read(AXP152_I2C_ADDR, reg, 1, data, 1);
 #elif defined CONFIG_AXP209_POWER
 	return i2c_read(AXP209_I2C_ADDR, reg, 1, data, 1);
-#elif defined CONFIG_AXP305_POWER
+#elif (IS_ENABLED(CONFIG_AXP305_POWER) || IS_ENABLED(CONFIG_AXP313_POWER))
 	return i2c_read(AXP305_I2C_ADDR, reg, 1, data, 1);
 #elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 # ifdef CONFIG_MACH_SUN6I
@@ -85,7 +86,7 @@
 	return i2c_write(AXP152_I2C_ADDR, reg, 1, &data, 1);
 #elif defined CONFIG_AXP209_POWER
 	return i2c_write(AXP209_I2C_ADDR, reg, 1, &data, 1);
-#elif defined CONFIG_AXP305_POWER
+#elif (IS_ENABLED(CONFIG_AXP305_POWER) || IS_ENABLED(CONFIG_AXP313_POWER))
 	return i2c_write(AXP305_I2C_ADDR, reg, 1, &data, 1);
 #elif defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
 # ifdef CONFIG_MACH_SUN6I
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/board/sunxi/board.c u-boot-2021.07/board/sunxi/board.c
--- u-boot-2021.07/board/sunxi/board.c	2023-10-18 21:11:50.176813052 +0200
+++ u-boot-2021.07/board/sunxi/board.c	2023-10-18 20:45:53.313474542 +0200
@@ -663,7 +663,8 @@
 
 #if defined CONFIG_AXP152_POWER || defined CONFIG_AXP209_POWER || \
 	defined CONFIG_AXP221_POWER || defined CONFIG_AXP305_POWER || \
-	defined CONFIG_AXP809_POWER || defined CONFIG_AXP818_POWER
+	defined CONFIG_AXP313_POWER || defined CONFIG_AXP809_POWER || \
+	defined CONFIG_AXP818_POWER
 	power_failed = axp_init();
 
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
@@ -671,10 +672,12 @@
 	power_failed |= axp_set_dcdc1(CONFIG_AXP_DCDC1_VOLT);
 #endif
 #if !defined(CONFIG_AXP305_POWER)
+#if !defined CONFIG_AXP313_POWER
 	power_failed |= axp_set_dcdc2(CONFIG_AXP_DCDC2_VOLT);
+#endif
 	power_failed |= axp_set_dcdc3(CONFIG_AXP_DCDC3_VOLT);
 #endif
-#if !defined(CONFIG_AXP209_POWER) && !defined(CONFIG_AXP818_POWER)
+#if !defined(CONFIG_AXP209_POWER) && !defined(CONFIG_AXP818_POWER) && !defined(CONFIG_AXP313_POWER)
 	power_failed |= axp_set_dcdc4(CONFIG_AXP_DCDC4_VOLT);
 #endif
 #if defined CONFIG_AXP221_POWER || defined CONFIG_AXP809_POWER || \
@@ -686,10 +689,10 @@
 	defined CONFIG_AXP818_POWER
 	power_failed |= axp_set_aldo1(CONFIG_AXP_ALDO1_VOLT);
 #endif
-#if !defined(CONFIG_AXP305_POWER)
+#if !defined(CONFIG_AXP305_POWER) && !defined(CONFIG_AXP313_POWER)
 	power_failed |= axp_set_aldo2(CONFIG_AXP_ALDO2_VOLT);
 #endif
-#if !defined(CONFIG_AXP152_POWER) && !defined(CONFIG_AXP305_POWER)
+#if !defined(CONFIG_AXP152_POWER) && !defined(CONFIG_AXP305_POWER) && !defined(CONFIG_AXP313_POWER)
 	power_failed |= axp_set_aldo3(CONFIG_AXP_ALDO3_VOLT);
 #endif
 #ifdef CONFIG_AXP209_POWER
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/drivers/power/axp313.c u-boot-2021.07/drivers/power/axp313.c
--- u-boot-2021.07/drivers/power/axp313.c	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2021.07/drivers/power/axp313.c	2023-10-18 20:39:41.856806597 +0200
@@ -0,0 +1,134 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * AXP313(a) driver
+ *
+ * (C) Copyright 2023 Arm Ltd.
+ *
+ * Based on axp305.c
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ * (C) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
+ */
+
+#include <common.h>
+#include <command.h>
+#include <errno.h>
+#include <asm/arch/pmic_bus.h>
+#include <axp_pmic.h>
+
+enum axp313_reg {
+	AXP313_CHIP_VERSION	= 0x03,
+	AXP313_OUTPUT_CTRL	= 0x10,
+	AXP313_DCDC1_CTRL	= 0x13,
+	AXP313_SHUTDOWN		= 0x1a,
+};
+
+#define AXP313_CHIP_VERSION_MASK	0xcf
+#define AXP313_CHIP_VERSION_AXP1530	0x48
+#define AXP313_CHIP_VERSION_AXP313A	0x4b
+#define AXP313_CHIP_VERSION_AXP313B	0x4c
+
+#define AXP313_DCDC_SPLIT_OFFSET	71
+#define AXP313_DCDC_SPLIT_MVOLT		1200
+
+#define AXP313_POWEROFF			BIT(7)
+
+static u8 mvolt_to_cfg(int mvolt, int min, int max, int div)
+{
+	if (mvolt < min)
+		mvolt = min;
+	else if (mvolt > max)
+		mvolt = max;
+
+	return (mvolt - min) / div;
+}
+
+static int axp_set_dcdc(int dcdc_num, unsigned int mvolt)
+{
+	int ret;
+	u8 cfg, enable_mask = 1U << (dcdc_num - 1);
+	int volt_reg = AXP313_DCDC1_CTRL + dcdc_num - 1;
+	int max_mV;
+
+	switch (dcdc_num) {
+	case 1:
+	case 2:
+		max_mV	= 1540;
+		break;
+	case 3:
+		/*
+		 * The manual defines a different split point, but tests
+		 * show that it's the same 1200mV as for DCDC1/2.
+		 */
+		max_mV	= 1840;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (mvolt > AXP313_DCDC_SPLIT_MVOLT)
+		cfg = AXP313_DCDC_SPLIT_OFFSET + mvolt_to_cfg(mvolt,
+				AXP313_DCDC_SPLIT_MVOLT + 20, max_mV, 20);
+	else
+		cfg = mvolt_to_cfg(mvolt, 500, AXP313_DCDC_SPLIT_MVOLT, 10);
+
+	if (mvolt == 0)
+		return pmic_bus_clrbits(AXP313_OUTPUT_CTRL, enable_mask);
+
+	debug("DCDC%d: writing 0x%x to reg 0x%x\n", dcdc_num, cfg, volt_reg);
+	ret = pmic_bus_write(volt_reg, cfg);
+	if (ret)
+		return ret;
+
+	return pmic_bus_setbits(AXP313_OUTPUT_CTRL, enable_mask);
+}
+
+int axp_set_dcdc2(unsigned int mvolt)
+{
+	return axp_set_dcdc(2, mvolt);
+}
+
+int axp_set_dcdc3(unsigned int mvolt)
+{
+	return axp_set_dcdc(3, mvolt);
+}
+
+int axp_init(void)
+{
+	u8 axp_chip_id;
+	int ret;
+
+	ret = pmic_bus_init();
+	if (ret)
+		return ret;
+
+	ret = pmic_bus_read(AXP313_CHIP_VERSION, &axp_chip_id);
+	if (ret)
+		return ret;
+
+	axp_chip_id &= AXP313_CHIP_VERSION_MASK;
+	switch (axp_chip_id) {
+	case AXP313_CHIP_VERSION_AXP1530:
+	case AXP313_CHIP_VERSION_AXP313A:
+	case AXP313_CHIP_VERSION_AXP313B:
+		break;
+	default:
+		debug("unknown PMIC: 0x%x\n", axp_chip_id);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+#if !CONFIG_IS_ENABLED(ARM_PSCI_FW) && !IS_ENABLED(CONFIG_SYSRESET_CMD_POWEROFF)
+int do_poweroff(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
+{
+	pmic_bus_write(AXP313_SHUTDOWN, AXP313_POWEROFF);
+
+	/* infinite loop during shutdown */
+	while (1) {}
+
+	/* not reached */
+	return 0;
+}
+#endif
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/drivers/power/Kconfig u-boot-2021.07/drivers/power/Kconfig
--- u-boot-2021.07/drivers/power/Kconfig	2021-07-05 17:11:28.000000000 +0200
+++ u-boot-2021.07/drivers/power/Kconfig	2023-10-18 20:55:49.090143209 +0200
@@ -58,6 +58,15 @@
 	Select this to enable support for the axp305 pmic found on most
 	H616 boards.
 
+config AXP313_POWER
+	bool "axp313 pmic support"
+	depends on MACH_SUN50I_H616
+	select AXP_PMIC_BUS
+	select CMD_POWEROFF
+	---help---
+	Select this to enable support for the axp313 pmic found on most
+	H616 boards.
+
 config AXP809_POWER
 	bool "axp809 pmic support"
 	depends on MACH_SUN9I
@@ -103,6 +112,7 @@
 	depends on AXP152_POWER || AXP209_POWER || AXP221_POWER || AXP809_POWER || AXP818_POWER
 	default 900 if AXP818_POWER
 	default 1400 if AXP152_POWER || AXP209_POWER
+	default 1000 if AXP313_POWER
 	default 1200 if MACH_SUN6I
 	default 1100 if MACH_SUN8I
 	default 0 if MACH_SUN9I
@@ -118,10 +128,11 @@
 
 config AXP_DCDC3_VOLT
 	int "axp pmic dcdc3 voltage"
-	depends on AXP152_POWER || AXP209_POWER || AXP221_POWER || AXP809_POWER || AXP818_POWER
+	depends on AXP152_POWER || AXP209_POWER || AXP221_POWER || AXP313_POWER || AXP809_POWER || AXP818_POWER
 	default 900 if AXP809_POWER || AXP818_POWER
 	default 1500 if AXP152_POWER
 	default 1250 if AXP209_POWER
+	default 1100 if AXP313_POWER
 	default 1100 if MACH_SUN8I_R40
 	default 1200 if MACH_SUN6I || MACH_SUN8I
 	---help---
@@ -134,6 +145,7 @@
 	On A80 boards dcdc3 is used for VDD-CPUA(cluster 0) and should be 0.9V.
 	On A83T boards dcdc3 is used for VDD-CPUB(cluster 1) and should be 0.9V.
 	On R40 boards dcdc3 is VDD-SYS and VDD-GPU and should be 1.1V.
+	On H616 boards dcdc3 is VDD-DRAM and for LPDDR3 should be 1.2V.
 
 config AXP_DCDC4_VOLT
 	int "axp pmic dcdc4 voltage"
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/drivers/power/Makefile u-boot-2021.07/drivers/power/Makefile
--- u-boot-2021.07/drivers/power/Makefile	2021-07-05 17:11:28.000000000 +0200
+++ u-boot-2021.07/drivers/power/Makefile	2023-10-18 20:45:53.313474542 +0200
@@ -7,6 +7,7 @@
 obj-$(CONFIG_AXP209_POWER)	+= axp209.o
 obj-$(CONFIG_AXP221_POWER)	+= axp221.o
 obj-$(CONFIG_AXP305_POWER)	+= axp305.o
+obj-$(CONFIG_AXP313_POWER)	+= axp313.o
 obj-$(CONFIG_AXP809_POWER)	+= axp809.o
 obj-$(CONFIG_AXP818_POWER)	+= axp818.o
 obj-$(CONFIG_EXYNOS_TMU)	+= exynos-tmu.o
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/include/axp313.h u-boot-2021.07/include/axp313.h
--- u-boot-2021.07/include/axp313.h	1970-01-01 01:00:00.000000000 +0100
+++ u-boot-2021.07/include/axp313.h	2023-10-18 21:17:46.883480887 +0200
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#define AXP_PMIC_MODE_REG	0x3e
+#define AXP_PMIC_MODE_I2C	0x00
+#define AXP_PMIC_MODE_P2WI	0x3e
+#define AXP_PMIC_MODE_RSB	0x7c
+
+#define AXP_PMIC_PRI_DEVICE_ADDR	0x3a3
+#define AXP_PMIC_PRI_RUNTIME_ADDR	0x2d
+#define AXP_PMIC_SEC_DEVICE_ADDR	0x745
+#define AXP_PMIC_SEC_RUNTIME_ADDR	0x3a
+
diff --speed-large-files --no-dereference --minimal -Naur u-boot-2021.07/include/axp_pmic.h u-boot-2021.07/include/axp_pmic.h
--- u-boot-2021.07/include/axp_pmic.h	2021-07-05 17:11:28.000000000 +0200
+++ u-boot-2021.07/include/axp_pmic.h	2023-10-18 21:10:14.093479408 +0200
@@ -24,6 +24,22 @@
 #ifdef CONFIG_AXP818_POWER
 #include <axp818.h>
 #endif
+#ifdef CONFIG_AXP313_POWER
+#include <axp313.h>
+#endif
+
+enum {
+ AXP152_ID,
+ AXP202_ID,
+ AXP209_ID,
+ AXP221_ID,
+ AXP223_ID,
+ AXP313_ID,
+ AXP803_ID,
+ AXP806_ID,
+ AXP809_ID,
+ AXP813_ID,
+};
 
 int axp_set_dcdc1(unsigned int mvolt);
 int axp_set_dcdc2(unsigned int mvolt);
