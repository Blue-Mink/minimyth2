From 80e7cbad682252cd731fb59f8d425365b027a7f0 Mon Sep 17 00:00:00 2001
From: Maxime Jourdan <mjourdan@baylibre.com>
Date: Fri, 1 Mar 2019 12:41:03 +0100
Subject: [PATCH 199/199] media: meson: vp9: add IOMMU support

Starting with GXL (S905X), the HEVC/VP9 decoder hardware supports an
IOMMU to access the decoded frames. This IOMMU is controlled by writing
the buffer's page IDs to the firmware, which then does the actual work.

This commit adds support for using the IOMMU with VP9/HEVC on G12A, the
first SoC on which it becomes mandatory.

Signed-off-by: Maxime Jourdan <mjourdan@baylibre.com>
---
 drivers/staging/media/meson/vdec/codec_vp9.c | 67 ++++++++++++++++++++--------
 1 file changed, 48 insertions(+), 19 deletions(-)

diff --git a/drivers/staging/media/meson/vdec/codec_vp9.c b/drivers/staging/media/meson/vdec/codec_vp9.c
index 73de400..7a18d5a 100644
--- a/drivers/staging/media/meson/vdec/codec_vp9.c
+++ b/drivers/staging/media/meson/vdec/codec_vp9.c
@@ -218,6 +218,9 @@ struct vp9_frame {
 struct codec_vp9 {
 	struct mutex lock;
 
+	/* Common part with the HEVC decoder */
+	struct codec_hevc_common common;
+
 	/* Buffer for the VP9 Workspace */
 	void      *workspace_vaddr;
 	dma_addr_t workspace_paddr;
@@ -437,27 +440,26 @@ static u32 codec_vp9_num_pending_bufs(struct amvdec_session *sess)
 	return vp9->frames_num;
 }
 
-static int
-codec_vp9_setup_workspace(struct amvdec_core *core, struct codec_vp9 *vp9)
+static int codec_vp9_alloc_workspace(struct amvdec_core *core,
+				     struct codec_vp9 *vp9)
 {
-	dma_addr_t wkaddr;
-
 	/* Allocate some memory for the VP9 decoder's state */
 	vp9->workspace_vaddr = dma_alloc_coherent(core->dev, SIZE_WORKSPACE,
-						   &wkaddr, GFP_KERNEL);
+					    &vp9->workspace_paddr, GFP_KERNEL);
 	if (!vp9->workspace_vaddr) {
 		dev_err(core->dev, "Failed to allocate VP9 Workspace\n");
 		return -ENOMEM;
 	}
 
-	memset(vp9->workspace_vaddr + DBLK_PARA_OFFSET, 0, DBLK_PARA_SIZE);
-	memset(vp9->workspace_vaddr + COUNT_OFFSET, 0, COUNT_SIZE);
-	memset(vp9->workspace_vaddr + PROB_OFFSET, 0, PROB_SIZE);
-
-	dev_dbg(core->dev, "Workspace: %08X-%08X\n", wkaddr, wkaddr + SIZE_WORKSPACE);
-	dev_dbg(core->dev, "DBLK_PARA: %08X\n", wkaddr + DBLK_PARA_OFFSET);
+	return 0;
+}
 
-	vp9->workspace_paddr = wkaddr;
+static void codec_vp9_setup_workspace(struct amvdec_session *sess,
+				      struct codec_vp9 *vp9)
+{
+	struct amvdec_core *core = sess->core;
+	u32 revision = core->platform->revision;
+	dma_addr_t wkaddr = vp9->workspace_paddr;
 
 	amvdec_write_dos(core, HEVCD_IPP_LINEBUFF_BASE, wkaddr + IPP_OFFSET);
 	amvdec_write_dos(core, VP9_RPM_BUFFER, wkaddr + RPM_OFFSET);
@@ -465,7 +467,6 @@ codec_vp9_setup_workspace(struct amvdec_core *core, struct codec_vp9 *vp9)
 	amvdec_write_dos(core, VP9_PPS_BUFFER, wkaddr + PPS_OFFSET);
 	amvdec_write_dos(core, VP9_SAO_UP, wkaddr + SAO_UP_OFFSET);
 
-	/* No MMU */
 	amvdec_write_dos(core, VP9_STREAM_SWAP_BUFFER,
 			 wkaddr + SWAP_BUF_OFFSET);
 	amvdec_write_dos(core, VP9_STREAM_SWAP_BUFFER2,
@@ -483,7 +484,19 @@ codec_vp9_setup_workspace(struct amvdec_core *core, struct codec_vp9 *vp9)
 	amvdec_write_dos(core, VP9_COUNT_SWAP_BUFFER, wkaddr + COUNT_OFFSET);
 	amvdec_write_dos(core, LMEM_DUMP_ADR, wkaddr + LMEM_OFFSET);
 
-	return 0;
+	if (codec_hevc_use_mmu(revision, sess->pixfmt_cap, vp9->is_10bit)) {
+		amvdec_write_dos(core, HEVC_SAO_MMU_VH0_ADDR,
+				 wkaddr + MMU_VBH_OFFSET);
+		amvdec_write_dos(core, HEVC_SAO_MMU_VH1_ADDR,
+				 wkaddr + MMU_VBH_OFFSET + (MMU_VBH_SIZE / 2));
+
+		if (revision >= VDEC_REVISION_G12A)
+			amvdec_write_dos(core, HEVC_ASSIST_MMU_MAP_ADDR,
+					 vp9->common.mmu_map_paddr);
+		else
+			amvdec_write_dos(core, VP9_MMU_MAP_BUFFER,
+					 vp9->common.mmu_map_paddr);
+	}
 }
 
 static int codec_vp9_start(struct amvdec_session *sess)
@@ -498,10 +511,11 @@ static int codec_vp9_start(struct amvdec_session *sess)
 	if (!vp9)
 		return -ENOMEM;
 
-	ret = codec_vp9_setup_workspace(core, vp9);
+	ret = codec_vp9_alloc_workspace(core, vp9);
 	if (ret)
 		goto free_vp9;
 
+	codec_vp9_setup_workspace(sess, vp9);
 	amvdec_write_dos_bits(core, HEVC_STREAM_CONTROL, BIT(0));
 	// stream_fifo_hole
 	if (core->platform->revision >= VDEC_REVISION_G12A)
@@ -575,7 +589,7 @@ static int codec_vp9_stop(struct amvdec_session *sess)
 				  vp9->workspace_vaddr,
 				  vp9->workspace_paddr);
 
-	codec_hevc_free_fbc_buffers(sess);
+	codec_hevc_free_fbc_buffers(sess, &vp9->common);
 	return 0;
 }
 
@@ -590,7 +604,7 @@ static void codec_vp9_set_sao(struct amvdec_session *sess, struct vb2_buffer *vb
 
 	if (codec_hevc_use_downsample(sess->pixfmt_cap, vp9->is_10bit))
 		buf_y_paddr =
-			sess->fbc_buffer_paddr[vb->index];
+			vp9->common.fbc_buffer_paddr[vb->index];
 	else
 		buf_y_paddr =
 		       vb2_dma_contig_plane_dma_addr(vb, 0);
@@ -612,13 +626,22 @@ static void codec_vp9_set_sao(struct amvdec_session *sess, struct vb2_buffer *vb
 		amvdec_write_dos(core, HEVC_SAO_C_WPTR, buf_u_v_paddr);
 	}
 
+	if (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
+			       vp9->is_10bit)) {
+		amvdec_write_dos(core, HEVC_CM_HEADER_START_ADDR,
+				 vp9->common.mmu_header_paddr[vb->index]);
+		/*  use HEVC_CM_HEADER_START_ADDR */
+		amvdec_write_dos_bits(core, HEVC_SAO_CTRL5, BIT(10));
+	 }
+
 	amvdec_write_dos(core, HEVC_SAO_Y_LENGTH,
 			 amvdec_get_output_size(sess));
 	amvdec_write_dos(core, HEVC_SAO_C_LENGTH,
 			 (amvdec_get_output_size(sess) / 2));
 
 	if (core->platform->revision >= VDEC_REVISION_G12A) {
-		amvdec_clear_dos_bits(core, HEVC_DBLK_CFGB, BIT(4) | BIT(5) | BIT(8) | BIT(9));
+		amvdec_clear_dos_bits(core, HEVC_DBLK_CFGB,
+				      BIT(4) | BIT(5) | BIT(8) | BIT(9));
 		/* enable first, compressed write */
 		if (codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit))
 			amvdec_write_dos_bits(core, HEVC_DBLK_CFGB, BIT(8));
@@ -919,6 +942,11 @@ static void codec_vp9_process_frame(struct amvdec_session *sess)
 	codec_vp9_update_next_ref(vp9);
 	codec_vp9_show_existing_frame(vp9);
 
+	if (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
+			       vp9->is_10bit))
+		codec_hevc_fill_mmu_map(sess, &vp9->common,
+					&vp9->cur_frame->vbuf->vb2_buf);
+
 	intra_only = param->p.show_frame ? 0 : param->p.intra_only;
 	/* clear mpred (for keyframe only) */
 	if (param->p.frame_type != KEY_FRAME && !intra_only) {
@@ -971,11 +999,12 @@ static void codec_vp9_resume(struct amvdec_session *sess)
 {
 	struct codec_vp9 *vp9 = sess->priv;
 
-	if (codec_hevc_setup_buffers(sess, vp9->is_10bit)) {
+	if (codec_hevc_setup_buffers(sess, &vp9->common, vp9->is_10bit)) {
 		amvdec_abort(sess);
 		return;
 	}
 
+	codec_vp9_setup_workspace(sess, vp9);
 	codec_hevc_setup_decode_head(sess, vp9->is_10bit);
 	codec_vp9_process_lf(vp9);
 	codec_vp9_process_frame(sess);
-- 
2.7.1

