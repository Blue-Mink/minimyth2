From 6a1472b6b9900dfa3fa07641c7d94b6118cbcc9e Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@siol.net>
Date: Sun, 3 May 2020 21:32:25 +0200
Subject: [PATCH] media: Add VC-1 parsed slice

Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
---
 drivers/media/v4l2-core/v4l2-ctrls.c |  19 +++
 drivers/media/v4l2-core/v4l2-ioctl.c |   1 +
 include/media/v4l2-ctrls.h           |   1 +
 include/media/vc1-ctrls.h            | 165 +++++++++++++++++++++++++++
 4 files changed, 186 insertions(+)
 create mode 100644 include/media/vc1-ctrls.h

diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c
index de038b341bbdf..96da50881e907 100644
--- a/drivers/media/v4l2-core/v4l2-ctrls.c
+++ b/drivers/media/v4l2-core/v4l2-ctrls.c
@@ -914,6 +914,8 @@ const char *v4l2_ctrl_get_name(u32 id)
 	case V4L2_CID_MPEG_VIDEO_FWHT_PARAMS:			return "FWHT Stateless Parameters";
 	case V4L2_CID_FWHT_I_FRAME_QP:				return "FWHT I-Frame QP Value";
 	case V4L2_CID_FWHT_P_FRAME_QP:				return "FWHT P-Frame QP Value";
+	case V4L2_CID_MPEG_VIDEO_VC1_SLICE_PARAMS:		return "VC1 Slice Parameters";
+	case V4L2_CID_MPEG_VIDEO_VC1_BITPLANES:			return "VC1 Bitplanes";
 
 	/* VPX controls */
 	case V4L2_CID_MPEG_VIDEO_VPX_NUM_PARTITIONS:		return "VPX Number of Partitions";
@@ -1420,6 +1422,12 @@ void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,
 		*type = V4L2_CTRL_TYPE_AREA;
 		*flags |= V4L2_CTRL_FLAG_READ_ONLY;
 		break;
+	case V4L2_CID_MPEG_VIDEO_VC1_SLICE_PARAMS:
+		*type = V4L2_CTRL_TYPE_VC1_SLICE_PARAMS;
+		break;
+	case V4L2_CID_MPEG_VIDEO_VC1_BITPLANES:
+		*type = V4L2_CTRL_TYPE_VC1_BITPLANES;
+		break;
 	default:
 		*type = V4L2_CTRL_TYPE_INTEGER;
 		break;
@@ -1875,6 +1883,11 @@ static int std_validate_compound(const struct v4l2_ctrl *ctrl, u32 idx,
 			return -EINVAL;
 		break;
 
+	case V4L2_CTRL_TYPE_VC1_SLICE_PARAMS:
+	case V4L2_CTRL_TYPE_VC1_BITPLANES:
+		/* TODO */
+		break;
+
 	default:
 		return -EINVAL;
 	}
@@ -2564,6 +2577,12 @@ static struct v4l2_ctrl *v4l2_ctrl_new(struct v4l2_ctrl_handler *hdl,
 	case V4L2_CTRL_TYPE_AREA:
 		elem_size = sizeof(struct v4l2_area);
 		break;
+	case V4L2_CTRL_TYPE_VC1_SLICE_PARAMS:
+		elem_size = sizeof(struct v4l2_ctrl_vc1_slice_params);
+		break;
+	case V4L2_CTRL_TYPE_VC1_BITPLANES:
+		elem_size = sizeof(struct v4l2_ctrl_vc1_bitplanes);
+		break;
 	default:
 		if (type < V4L2_CTRL_COMPOUND_TYPES)
 			elem_size = sizeof(s32);
diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
index 833e79a2cb98d..4bcd8eb685541 100644
--- a/drivers/media/v4l2-core/v4l2-ioctl.c
+++ b/drivers/media/v4l2-core/v4l2-ioctl.c
@@ -1395,6 +1395,7 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
 		case V4L2_PIX_FMT_S5C_UYVY_JPG:	descr = "S5C73MX interleaved UYVY/JPEG"; break;
 		case V4L2_PIX_FMT_MT21C:	descr = "Mediatek Compressed Format"; break;
 		case V4L2_PIX_FMT_SUNXI_TILED_NV12: descr = "Sunxi Tiled NV12 Format"; break;
+		case V4L2_PIX_FMT_VC1_SLICE:	descr = "VC-1 Parsed Data"; break;
 		default:
 			if (fmt->description[0])
 				return;
diff --git a/include/media/v4l2-ctrls.h b/include/media/v4l2-ctrls.h
index 757a713bad412..4f1024bc55ceb 100644
--- a/include/media/v4l2-ctrls.h
+++ b/include/media/v4l2-ctrls.h
@@ -22,6 +22,7 @@
 #include <media/h264-ctrls.h>
 #include <media/vp8-ctrls.h>
 #include <media/hevc-ctrls.h>
+#include <media/vc1-ctrls.h>
 
 /* forward references */
 struct file;
diff --git a/include/media/vc1-ctrls.h b/include/media/vc1-ctrls.h
new file mode 100644
index 0000000000000..e1d0748f479ef
--- /dev/null
+++ b/include/media/vc1-ctrls.h
@@ -0,0 +1,165 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * These are the VC1 state controls for use with stateless VC1 codec drivers.
+ *
+ * It turns out that these structs are not stable yet and will undergo
+ * more changes. So keep them private until they are stable and ready to
+ * become part of the official public API.
+ */
+
+#ifndef _VC1_CTRLS_H_
+#define _VC1_CTRLS_H_
+
+/* Our pixel format isn't stable at the moment */
+#define V4L2_PIX_FMT_VC1_SLICE v4l2_fourcc('S', 'V', 'C', '1') /* VC1 parsed slices */
+
+#define V4L2_CID_MPEG_VIDEO_VC1_SLICE_PARAMS	(V4L2_CID_MPEG_BASE + 254)
+#define V4L2_CID_MPEG_VIDEO_VC1_BITPLANES	(V4L2_CID_MPEG_BASE + 255)
+
+/* enum v4l2_ctrl_type type values */
+#define V4L2_CTRL_TYPE_VC1_SLICE_PARAMS			0x0109
+#define	V4L2_CTRL_TYPE_VC1_BITPLANES			0x010a
+
+#define V4L2_VC1_SEQUENCE_FLAG_PULLDOWN			0x01
+#define V4L2_VC1_SEQUENCE_FLAG_INTERLACE		0x02
+#define V4L2_VC1_SEQUENCE_FLAG_TFCNTRFLAG		0x04
+#define V4L2_VC1_SEQUENCE_FLAG_FINTERPFLAG		0x08
+#define V4L2_VC1_SEQUENCE_FLAG_PSF			0x10
+
+struct v4l2_vc1_sequence {
+	__u8	profile;
+	__u8	level;
+	__u8	colordiff_format;
+	__u32	flags;
+};
+
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_BROKEN_LINK	0x001
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_CLOSED_ENTRY	0x002
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_PANSCAN		0x004
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_REFDIST		0x008
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_LOOPFILTER	0x010
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_FASTUVMC	0x020
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_MV	0x040
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_VSTRANSFORM	0x080
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_OVERLAP		0x100
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_DMV	0x200
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_RANGE_MAPY	0x400
+#define V4L2_VC1_ENTRYPOINT_HEADER_FLAG_RANGE_MAPUV	0x800
+
+struct v4l2_vc1_entrypoint_header {
+	__u8	dquant;
+	__u8	quantizer;
+	__u16	coded_width;
+	__u16	coded_height;
+	__u8	range_mapy;
+	__u8	range_mapuv;
+	__u32	flags;
+};
+
+#define V4L2_VC1_PICTURE_LAYER_FLAG_RANGEREDFRM		0x0001
+#define V4L2_VC1_PICTURE_LAYER_FLAG_HALFQP		0x0002
+#define V4L2_VC1_PICTURE_LAYER_FLAG_PQUANTIZER		0x0004
+#define V4L2_VC1_PICTURE_LAYER_FLAG_TRANSDCTAB		0x0008
+#define V4L2_VC1_PICTURE_LAYER_FLAG_TFF			0x0010
+#define V4L2_VC1_PICTURE_LAYER_FLAG_RNDCTRL		0x0020
+#define V4L2_VC1_PICTURE_LAYER_FLAG_TTMBF		0x0040
+#define V4L2_VC1_PICTURE_LAYER_FLAG_4MVSWITCH		0x0080
+#define V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP		0x0100
+#define V4L2_VC1_PICTURE_LAYER_FLAG_NUMREF		0x0200
+#define V4L2_VC1_PICTURE_LAYER_FLAG_REFFIELD		0x0400
+#define V4L2_VC1_PICTURE_LAYER_FLAG_SECOND_FIELD	0x0800
+
+struct v4l2_vc1_picture_layer {
+	__u8	ptype;
+	__u8	pqindex;
+	__u8	mvrange;
+	__u8	respic;
+	__u8	transacfrm;
+	__u8	transacfrm2;
+	__u8	bfraction;
+	__u8	fcm;
+	__u8	mvmode;
+	__u8	mvmode2;
+	__u8	lumscale;
+	__u8	lumshift;
+	__u8	lumscale2;
+	__u8	lumshift2;
+	__u8	mvtab;
+	__u8	cbptab;
+	__u8	intcompfield;
+	__u8	dmvrange;
+	__u8	mbmodetab;
+	__u8	twomvbptab;
+	__u8	fourmvbptab;
+	__u8	ttfrm;
+	__u8	refdist;
+	__u8	condover;
+	__u8	imvtab;
+	__u8	icbptab;
+	__u32	flags;
+};
+
+#define V4L2_VC1_VOPDQUANT_FLAG_DQUANTFRM		0x1
+#define V4L2_VC1_VOPDQUANT_FLAG_DQBILEVEL		0x2
+
+struct v4l2_vc1_vopdquant {
+	__u8	altpquant;
+	__u8	dqprofile;
+	__u8	dqsbedge;
+	__u8	dqdbedge;
+	__u8	flags;
+};
+
+#define V4L2_VC1_METADATA_FLAG_MULTIRES		0x1
+#define V4L2_VC1_METADATA_FLAG_SYNCMARKER	0x2
+#define V4L2_VC1_METADATA_FLAG_RANGERED		0x4
+
+struct v4l2_vc1_metadata {
+	__u8	maxbframes;
+	__u8	flags;
+};
+
+#define V4L2_VC1_RAW_CODING_FLAG_MVTYPEMB	0x01
+#define V4L2_VC1_RAW_CODING_FLAG_DIRECTMB	0x02
+#define V4L2_VC1_RAW_CODING_FLAG_SKIPMB		0x04
+#define V4L2_VC1_RAW_CODING_FLAG_FIELDTX	0x08
+#define V4L2_VC1_RAW_CODING_FLAG_FORWARDMB	0x10
+#define V4L2_VC1_RAW_CODING_FLAG_ACPRED		0x20
+#define V4L2_VC1_RAW_CODING_FLAG_OVERFLAGS	0x40
+
+struct v4l2_ctrl_vc1_slice_params {
+	__u32	bit_size;
+	__u32	data_bit_offset;
+	__u64	backward_ref_ts;
+	__u64	forward_ref_ts;
+
+	struct v4l2_vc1_sequence sequence;
+	struct v4l2_vc1_entrypoint_header entrypoint_header;
+	struct v4l2_vc1_picture_layer picture_layer;
+	struct v4l2_vc1_vopdquant vopdquant;
+	struct v4l2_vc1_metadata metadata;
+
+	__u8	raw_coding_flags;
+};
+
+#define V4L2_VC1_BITPLANE_FLAG_MVTYPEMB		0x01
+#define V4L2_VC1_BITPLANE_FLAG_DIRECTMB		0x02
+#define V4L2_VC1_BITPLANE_FLAG_SKIPMB		0x04
+#define V4L2_VC1_BITPLANE_FLAG_FIELDTX		0x08
+#define V4L2_VC1_BITPLANE_FLAG_FORWARDMB	0x10
+#define V4L2_VC1_BITPLANE_FLAG_ACPRED		0x20
+#define V4L2_VC1_BITPLANE_FLAG_OVERFLAGS	0x40
+
+struct v4l2_ctrl_vc1_bitplanes {
+	__u8	bitplane_flags;
+
+	__u8	mvtypemb[1024];
+	__u8	directmb[1024];
+	__u8	skipmb[1024];
+	__u8	fieldtx[1024];
+	__u8	forwardmb[1024];
+	__u8	acpred[1024];
+	__u8	overflags[1024];
+};
+
+#endif
From 93ce77477438917b5941fde4bb7adbe5ce9814b3 Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@siol.net>
Date: Wed, 6 May 2020 17:57:42 +0200
Subject: [PATCH] media: cedrus: Add VC-1 support

Signed-off-by: Jernej Skrabec <jernej.skrabec@siol.net>
---
 drivers/staging/media/sunxi/cedrus/Makefile   |   2 +-
 drivers/staging/media/sunxi/cedrus/cedrus.c   |  15 +
 drivers/staging/media/sunxi/cedrus/cedrus.h   |  23 +
 .../staging/media/sunxi/cedrus/cedrus_dec.c   |   7 +
 .../staging/media/sunxi/cedrus/cedrus_hw.c    |   4 +
 .../staging/media/sunxi/cedrus/cedrus_regs.h  | 154 +++++
 .../staging/media/sunxi/cedrus/cedrus_vc1.c   | 568 ++++++++++++++++++
 .../staging/media/sunxi/cedrus/cedrus_video.c |   9 +
 8 files changed, 781 insertions(+), 1 deletion(-)
 create mode 100644 drivers/staging/media/sunxi/cedrus/cedrus_vc1.c

diff --git a/drivers/staging/media/sunxi/cedrus/cedrus.c b/drivers/staging/media/sunxi/cedrus/cedrus.c
index e92d55331d083..69dcae773d948 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus.c
@@ -141,6 +141,20 @@ static const struct cedrus_control cedrus_controls[] = {
 		.codec		= CEDRUS_CODEC_H265,
 		.required	= false,
 	},
+	{
+		.cfg = {
+			.id	= V4L2_CID_MPEG_VIDEO_VC1_SLICE_PARAMS,
+		},
+		.codec		= CEDRUS_CODEC_VC1,
+		.required	= true,
+	},
+	{
+		.cfg = {
+			.id	= V4L2_CID_MPEG_VIDEO_VC1_BITPLANES,
+		},
+		.codec		= CEDRUS_CODEC_VC1,
+		.required	= false,
+	},
 };
 
 #define CEDRUS_CONTROLS_COUNT	ARRAY_SIZE(cedrus_controls)
@@ -387,6 +401,7 @@ static int cedrus_probe(struct platform_device *pdev)
 	dev->dec_ops[CEDRUS_CODEC_H264] = &cedrus_dec_ops_h264;
 	dev->dec_ops[CEDRUS_CODEC_H265] = &cedrus_dec_ops_h265;
 	dev->dec_ops[CEDRUS_CODEC_VP8] = &cedrus_dec_ops_vp8;
+	dev->dec_ops[CEDRUS_CODEC_VC1] = &cedrus_dec_ops_vc1;
 
 	mutex_init(&dev->dev_mutex);
 
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus.h b/drivers/staging/media/sunxi/cedrus/cedrus.h
index f8264953dd040..12e3da0c9c340 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus.h
+++ b/drivers/staging/media/sunxi/cedrus/cedrus.h
@@ -35,6 +35,7 @@ enum cedrus_codec {
 	CEDRUS_CODEC_H264,
 	CEDRUS_CODEC_H265,
 	CEDRUS_CODEC_VP8,
+	CEDRUS_CODEC_VC1,
 	CEDRUS_CODEC_LAST,
 };
 
@@ -76,6 +77,11 @@ struct cedrus_vp8_run {
 	const struct v4l2_ctrl_vp8_frame_header>	*frame_params;
 };
 
+struct cedrus_vc1_run {
+	const struct v4l2_ctrl_vc1_slice_params		*slice_params;
+	const struct v4l2_ctrl_vc1_bitplanes		*bitplanes;
+};
+
 struct cedrus_run {
 	struct vb2_v4l2_buffer	*src;
 	struct vb2_v4l2_buffer	*dst;
@@ -84,6 +90,7 @@ struct cedrus_run {
 		struct cedrus_mpeg2_run	mpeg2;
 		struct cedrus_h265_run	h265;
 		struct cedrus_vp8_run	vp8;
+		struct cedrus_vc1_run	vc1;
 	};
 };
 
@@ -103,6 +110,11 @@ struct cedrus_buffer {
 			dma_addr_t	mv_col_buf_dma;
 			ssize_t		mv_col_buf_size;
 		} h265;
+		struct {
+			int		interlaced;
+			int		rangeredfrm;
+			unsigned int	ptype;
+		} vc1;
 	} codec;
 };
 
@@ -141,6 +153,15 @@ struct cedrus_ctx {
 			void		*entry_points_buf;
 			dma_addr_t	entry_points_buf_addr;
 		} h265;
+		struct {
+			void		*mv_buf;
+			dma_addr_t	mv_buf_addr;
+			void		*acdc_buf;
+			dma_addr_t	acdc_buf_addr;
+			u8		*bitplanes_buf;
+			dma_addr_t	bitplanes_buf_addr;
+			int		compen;
+		} vc1;
 		struct {
 			unsigned int<-->last_frame_p_type;
 			unsigned int<-->last_filter_type;
 
@@ -188,9 +209,11 @@ struct cedrus_dev {
 extern struct cedrus_dec_ops cedrus_dec_ops_h264;
 extern struct cedrus_dec_ops cedrus_dec_ops_h265;
 extern struct cedrus_dec_ops cedrus_dec_ops_vp8;
+extern struct cedrus_dec_ops cedrus_dec_ops_vc1;
 
 static inline void cedrus_write(struct cedrus_dev *dev, u32 reg, u32 val)
 {
+	printk("%.3x: %.8x\n", reg, val);
 	writel(val, dev->base + reg);
 }
 
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus_dec.c b/drivers/staging/media/sunxi/cedrus/cedrus_dec.c
index 327ed6c264dc8..2c3746451af92 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus_dec.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus_dec.c
@@ -70,6 +70,13 @@ void cedrus_device_run(void *priv)
 			V4L2_CID_MPEG_VIDEO_VP8_FRAME_HEADER);
 		break;
 
+	case V4L2_PIX_FMT_VC1_SLICE:
+		run.vc1.slice_params = cedrus_find_control_data(ctx,
+			V4L2_CID_MPEG_VIDEO_VC1_SLICE_PARAMS);
+		run.vc1.bitplanes = cedrus_find_control_data(ctx,
+			V4L2_CID_MPEG_VIDEO_VC1_BITPLANES);
+		break;
+
 	default:
 		break;
 	}
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus_hw.c b/drivers/staging/media/sunxi/cedrus/cedrus_hw.c
index d8271a108d849..2518171908aa7 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus_hw.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus_hw.c
@@ -54,6 +54,10 @@ int cedrus_engine_enable(struct cedrus_ctx *ctx, enum cedrus_codec codec)
 		reg |= VE_MODE_DEC_H265;
 		break;
 
+	case CEDRUS_CODEC_VC1:
+		reg |= VE_MODE_DEC_VC1;
+		break;
+
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus_regs.h b/drivers/staging/media/sunxi/cedrus/cedrus_regs.h
index 150eae2d92d2f..8276d9313a9a1 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus_regs.h
+++ b/drivers/staging/media/sunxi/cedrus/cedrus_regs.h
@@ -31,6 +31,7 @@
 
 #define VE_ENGINE_DEC_MPEG			0x100
 #define VE_ENGINE_DEC_H264			0x200
+#define VE_ENGINE_DEC_VC1			0x300
 #define VE_ENGINE_DEC_H265			0x500
 
 #define VE_MODE					0x00
@@ -43,6 +44,7 @@
 #define VE_MODE_DDR_MODE_BW_256			(0x02 << 16)
 #define VE_MODE_DISABLED			(0x07 << 0)
 #define VE_MODE_DEC_H265			(0x04 << 0)
+#define VE_MODE_DEC_VC1				(0x02 << 0)
 #define VE_MODE_DEC_H264			(0x01 << 0)
 #define VE_MODE_DEC_MPEG			(0x00 << 0)
 
@@ -526,6 +528,158 @@
 #define VE_DEC_H265_SRAM_DATA_ADDR_BASE(a)	((a) >> 8)
 #define VE_DEC_H265_SRAM_REF_PIC_LIST_LT_REF	BIT(7)
 
+#define VE_DEC_VC1_EPHS				(VE_ENGINE_DEC_VC1 + 0x00)
+#define VE_DEC_VC1_EPHS_STARTCODE_DET_EN	BIT(16)
+#define VE_DEC_VC1_EPHS_EPTB_DET_BYPASS		BIT(15)
+#define VE_DEC_VC1_EPHS_SYNCMARKER		BIT(14)
+#define VE_DEC_VC1_EPHS_FINTERPFLAG		BIT(13)
+#define VE_DEC_VC1_EPHS_RANGERED		BIT(12)
+#define VE_DEC_VC1_EPHS_QUANTIZER(x)		SHIFT_AND_MASK_BITS(x, 11, 10)
+#define VE_DEC_VC1_EPHS_OVERLAP			BIT(9)
+#define VE_DEC_VC1_EPHS_VSTRANSFORM		BIT(8)
+#define VE_DEC_VC1_EPHS_DQUANT(x)		SHIFT_AND_MASK_BITS(x, 7, 6)
+#define VE_DEC_VC1_EPHS_EXTENDEDMV		BIT(5)
+#define VE_DEC_VC1_EPHS_FASTUVMC		BIT(4)
+#define VE_DEC_VC1_EPHS_MULTIRES		BIT(3)
+#define VE_DEC_VC1_EPHS_LOOPFILTER		BIT(2)
+#define VE_DEC_VC1_EPHS_PROFILE(x)		SHIFT_AND_MASK_BITS(x, 1, 0)
+
+#define VE_DEC_VC1_PICCTRL			(VE_ENGINE_DEC_VC1 + 0x04)
+#define VE_DEC_VC1_PICCTRL_BITPL_CODING		BIT(31)
+#define VE_DEC_VC1_PICCTRL_DIRECT_REF_INTRA	BIT(29)
+#define VE_DEC_VC1_PICCTRL_DIRECTMB_RAW		BIT(28)
+#define VE_DEC_VC1_PICCTRL_TTFRM(x)		SHIFT_AND_MASK_BITS(x, 27, 26)
+#define VE_DEC_VC1_PICCTRL_TTMBF		BIT(25)
+#define VE_DEC_VC1_PICCTRL_SKIPMB_RAW		BIT(24)
+#define VE_DEC_VC1_PICCTRL_CBPTAB(x)		SHIFT_AND_MASK_BITS(x, 23, 22)
+#define VE_DEC_VC1_PICCTRL_OVERFLAGS_RAW	BIT(21)
+#define VE_DEC_VC1_PICCTRL_ACPRED_RAW		BIT(20)
+#define VE_DEC_VC1_PICCTRL_CONDOVER(x)		SHIFT_AND_MASK_BITS(x, 19, 18)
+#define VE_DEC_VC1_PICCTRL_RNDCTRL		BIT(17)
+#define VE_DEC_VC1_PICCTRL_TRANSDCTAB		BIT(16)
+#define VE_DEC_VC1_PICCTRL_TRANSACFRM2(x)	SHIFT_AND_MASK_BITS(x, 15, 14)
+#define VE_DEC_VC1_PICCTRL_TRANSACFRM(x)	SHIFT_AND_MASK_BITS(x, 13, 12)
+#define VE_DEC_VC1_PICCTRL_BWD_RANGEREDFRM	BIT(10)
+#define VE_DEC_VC1_PICCTRL_FWD_RANGEREDFRM	BIT(9)
+#define VE_DEC_VC1_PICCTRL_RANGEREDFRM		BIT(8)
+#define VE_DEC_VC1_PICCTRL_SECOND_FIELD		BIT(7)
+#define VE_DEC_VC1_PICCTRL_BOTTOM_FIELD		BIT(6)
+#define VE_DEC_VC1_PICCTRL_FCM(x)		SHIFT_AND_MASK_BITS(x, 5, 4)
+#define VE_DEC_VC1_PICCTRL_PTYPE(x)		SHIFT_AND_MASK_BITS(x, 2, 0)
+
+#define VE_DEC_VC1_PICQP			(VE_ENGINE_DEC_VC1 + 0x08)
+#define VE_DEC_VC1_PICQP_DQBILEVEL		BIT(25)
+#define VE_DEC_VC1_PICQP_DQUANTFRM		BIT(24)
+#define VE_DEC_VC1_PICQP_ALTPQUANT(x)		SHIFT_AND_MASK_BITS(x, 20, 16)
+#define VE_DEC_VC1_PICQP_DQDBEDGE(x)		SHIFT_AND_MASK_BITS(x, 15, 13)
+#define VE_DEC_VC1_PICQP_DQSBEDGE(x)		SHIFT_AND_MASK_BITS(x, 13, 12)
+#define VE_DEC_VC1_PICQP_DQPPROFILE(x)		SHIFT_AND_MASK_BITS(x, 11, 10)
+#define VE_DEC_VC1_PICQP_PQUANTIZER		BIT(9)
+#define VE_DEC_VC1_PICQP_HALFQP			BIT(8)
+#define VE_DEC_VC1_PICQP_PQINDEX(x)		SHIFT_AND_MASK_BITS(x, 4, 0)
+
+#define VE_DEC_VC1_PICMV			(VE_ENGINE_DEC_VC1 + 0x0c)
+#define VE_DEC_VC1_PICMV_MVTYPEMB_RAW		BIT(20)
+#define VE_DEC_VC1_PICMV_MVTAB(x)		SHIFT_AND_MASK_BITS(x, 17, 16)
+#define VE_DEC_VC1_PICMV_INTENSITY_COMP_EN	BIT(14)
+#define VE_DEC_VC1_PICMV_MVMODE(x)		SHIFT_AND_MASK_BITS(x, 13, 12)
+#define VE_DEC_VC1_PICMV_MVRANGE(x)		SHIFT_AND_MASK_BITS(x, 11, 10)
+#define VE_DEC_VC1_PICMV_BFRAC_LESS_THAN_HALF	BIT(9)
+#define VE_DEC_VC1_PICMV_BFRACTION(x)		SHIFT_AND_MASK_BITS(x, 7, 0)
+
+#define VE_DEC_VC1_PICINTENCOMP			(VE_ENGINE_DEC_VC1 + 0x10)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASHIFT2(x)	SHIFT_AND_MASK_BITS(x, 29, 24)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASCALE2(x)	SHIFT_AND_MASK_BITS(x, 21, 16)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASHIFT1(x)	SHIFT_AND_MASK_BITS(x, 13, 8)
+#define VE_DEC_VC1_PICINTENCOMP_LUMASCALE1(x)	SHIFT_AND_MASK_BITS(x, 5, 0)
+
+#define VE_DEC_VC1_PICINTERLACE			(VE_ENGINE_DEC_VC1 + 0x14)
+#define VE_DEC_VC1_PICINTERLACE_NUMREF		BIT(31)
+#define VE_DEC_VC1_PICINTERLACE_BWD_INTERLACE	BIT(30)
+#define VE_DEC_VC1_PICINTERLACE_FWD_INTERLACE	BIT(29)
+#define VE_DEC_VC1_PICINTERLACE_FORWARD_RAW	BIT(28)
+#define VE_DEC_VC1_PICINTERLACE_INTENCOMPFLD(x)	SHIFT_AND_MASK_BITS(x, 27, 26)
+#define VE_DEC_VC1_PICINTERLACE_REFFIELD	BIT(25)
+#define VE_DEC_VC1_PICINTERLACE_BRFD(x)		SHIFT_AND_MASK_BITS(x, 23, 22)
+#define VE_DEC_VC1_PICINTERLACE_FRFD(x)		SHIFT_AND_MASK_BITS(x, 21, 20)
+#define VE_DEC_VC1_PICINTERLACE_4MVBPTAB(x)	SHIFT_AND_MASK_BITS(x, 19, 18)
+#define VE_DEC_VC1_PICINTERLACE_2MVBPTAB(x)	SHIFT_AND_MASK_BITS(x, 17, 16)
+#define VE_DEC_VC1_PICINTERLACE_INTENCOMP	BIT(15)
+#define VE_DEC_VC1_PICINTERLACE_ICBPTAB(x)	SHIFT_AND_MASK_BITS(x, 14, 12)
+#define VE_DEC_VC1_PICINTERLACE_IMVTAB(x)	SHIFT_AND_MASK_BITS(x, 10, 8)
+#define VE_DEC_VC1_PICINTERLACE_MBMODETAB(x)	SHIFT_AND_MASK_BITS(x, 6, 4)
+#define VE_DEC_VC1_PICINTERLACE_4MVSWITCH	BIT(3)
+#define VE_DEC_VC1_PICINTERLACE_DMVRANGE(x)	SHIFT_AND_MASK_BITS(x, 2, 1)
+#define VE_DEC_VC1_PICINTERLACE_FIELDTX_RAW	BIT(0)
+
+#define VE_DEC_VC1_PICHDRLEN			(VE_ENGINE_DEC_VC1 + 0x18)
+#define VE_DEC_VC1_PICHDRLEN_LENGTH(l)		SHIFT_AND_MASK_BITS(l, 15, 0)
+
+#define VE_DEC_VC1_FSIZE			(VE_ENGINE_DEC_VC1 + 0x1c)
+#define VE_DEC_VC1_FSIZE_WIDTH(w) \
+	SHIFT_AND_MASK_BITS(DIV_ROUND_UP(w, 16), 15, 8)
+#define VE_DEC_VC1_FSIZE_HEIGHT(h) \
+	SHIFT_AND_MASK_BITS(DIV_ROUND_UP(h, 16), 7, 0)
+
+#define VE_DEC_VC1_PICSIZE			(VE_ENGINE_DEC_VC1 + 0x20)
+#define VE_DEC_VC1_PICSIZE_WIDTH(w)		SHIFT_AND_MASK_BITS(w, 27, 16)
+#define VE_DEC_VC1_PICSIZE_HEIGHT(h)		SHIFT_AND_MASK_BITS(h, 11, 0)
+
+#define VE_DEC_VC1_CTRL				(VE_ENGINE_DEC_VC1 + 0x24)
+#define VE_DEC_VC1_CTRL_EPTB_DET_BYPASS		BIT(24)
+#define VE_DEC_VC1_CTRL_MCRI_CACHE_EN		BIT(10)
+#define VE_DEC_VC1_CTRL_WRITE_ROTATE_PIC	BIT(9)
+#define VE_DEC_VC1_CTRL_NO_RECONSTRUCT_PIC	BIT(8)
+#define VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN	BIT(2)
+#define VE_DEC_VC1_CTRL_ERROR_IRQ_EN		BIT(1)
+#define VE_DEC_VC1_CTRL_FINISH_IRQ_EN		BIT(0)
+#define VE_DEC_VC1_CTRL_IRQ_MASK \
+	(VE_DEC_VC1_CTRL_FINISH_IRQ_EN | VE_DEC_VC1_CTRL_ERROR_IRQ_EN | \
+	 VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN)
+
+#define VE_DEC_VC1_TRIGGER_TYPE			(VE_ENGINE_DEC_VC1 + 0x28)
+#define VE_DEC_VC1_TRIGGER_TYPE_N_BITS(n)	SHIFT_AND_MASK_BITS(n, 13, 8)
+#define VE_DEC_VC1_TRIGGER_TYPE_DECODE		(8 << 0)
+#define VE_DEC_VC1_TRIGGER_TYPE_INIT_SWDEC	(7 << 0)
+#define VE_DEC_VC1_TRIGGER_TYPE_FLUSH_BITS	(3 << 0)
+
+#define VE_DEC_VC1_STATUS			(VE_ENGINE_DEC_VC1 + 0x2c)
+#define VE_DEC_VC1_STATUS_BITS_BUSY		BIT(8)
+#define VE_DEC_VC1_STATUS_VLD_DATA_REQ		BIT(2)
+#define VE_DEC_VC1_STATUS_ERROR			BIT(1)
+#define VE_DEC_VC1_STATUS_SUCCESS		BIT(0)
+#define VE_DEC_VC1_STATUS_INT_MASK		VE_DEC_VC1_CTRL_IRQ_MASK
+
+#define VE_DEC_VC1_BITS_ADDR			(VE_ENGINE_DEC_VC1 + 0x30)
+#define VE_DEC_VC1_BITS_ADDR_FIRST_SLICE_DATA	BIT(30)
+#define VE_DEC_VC1_BITS_ADDR_LAST_SLICE_DATA	BIT(29)
+#define VE_DEC_VC1_BITS_ADDR_VALID_SLICE_DATA	BIT(28)
+#define VE_DEC_VC1_BITS_ADDR_BASE(a) 					\
+	({								\
+		u32 _tmp = (a);						\
+		u32 _lo = _tmp & GENMASK(27, 4);			\
+		u32 _hi = (_tmp >> 28) & GENMASK(3, 0);			\
+		(_lo | _hi);						\
+	})
+
+#define VE_DEC_VC1_BITS_OFFSET			(VE_ENGINE_DEC_VC1 + 0x34)
+#define VE_DEC_VC1_BITS_LEN			(VE_ENGINE_DEC_VC1 + 0x38)
+#define VE_DEC_VC1_BITS_END_ADDR		(VE_ENGINE_DEC_VC1 + 0x3c)
+#define VE_DEC_VC1_REC_LUMA			(VE_ENGINE_DEC_VC1 + 0x40)
+#define VE_DEC_VC1_REC_CHROMA			(VE_ENGINE_DEC_VC1 + 0x44)
+#define VE_DEC_VC1_FWD_REF_LUMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x48)
+#define VE_DEC_VC1_FWD_REF_CHROMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x4c)
+#define VE_DEC_VC1_BWD_REF_LUMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x50)
+#define VE_DEC_VC1_BWD_REF_CHROMA_ADDR		(VE_ENGINE_DEC_VC1 + 0x54)
+
+#define VE_DEC_VC1_DCACPRED_ADDR		(VE_ENGINE_DEC_VC1 + 0x5c)
+#define VE_DEC_VC1_BITPLANE_ADDR		(VE_ENGINE_DEC_VC1 + 0x60)
+#define VE_DEC_VC1_MVINFO_ADDR			(VE_ENGINE_DEC_VC1 + 0x64)
+
+#define VE_DEC_VC1_ROT_CTRL			(VE_ENGINE_DEC_VC1 + 0xc0)
+#define VE_DEC_VC1_ROT_LUMA_ADDR		(VE_ENGINE_DEC_VC1 + 0xc4)
+#define VE_DEC_VC1_ROT_CHROMA_ADDR		(VE_ENGINE_DEC_VC1 + 0xc8)
+
 #define VE_H264_SPS			0x200
 #define VE_H264_SPS_MBS_ONLY			BIT(18)
 #define VE_H264_SPS_MB_ADAPTIVE_FRAME_FIELD	BIT(17)
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c b/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c
new file mode 100644
index 0000000000000..91a6ef0d96628
--- /dev/null
+++ b/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c
@@ -0,0 +1,568 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Cedrus VPU driver
+ *
+ * Copyright (c) 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+
+#include <media/videobuf2-dma-contig.h>
+
+#include "cedrus.h"
+#include "cedrus_hw.h"
+#include "cedrus_regs.h"
+
+#define MV_BUF_SIZE			(64 * SZ_1K)
+#define ACDC_BUF_SIZE			(16 * SZ_1K)
+#define BITPLANES_BUF_SIZE		(16 * SZ_1K)
+
+#define VC1_PROFILE_SIMPLE		0
+#define VC1_PROFILE_MAIN		1
+#define VC1_PROFILE_COMPLEX		2
+#define VC1_PROFILE_ADVANCED		3
+
+#define VC1_PICTURE_TYPE_I		0
+#define VC1_PICTURE_TYPE_P		1
+#define VC1_PICTURE_TYPE_B		2
+#define VC1_PICTURE_TYPE_BI		3
+#define VC1_PICTURE_TYPE_SKIPPED	4
+
+#define VC1_FCM_PROGRESSIVE		0
+#define VC1_FCM_INTERLACED_FRAME	1
+#define VC1_FCM_INTERLACED_FIELD	2
+
+#define VC1_MVMODE_1MV_HPEL_BILIN	0
+#define VC1_MVMODE_1MV			1
+#define VC1_MVMODE_1MV_HPEL		2
+#define VC1_MVMODE_MIXED_MV		3
+#define VC1_MVMODE_INTENSITY_COMP	4
+
+#define VC1_BITPLANE_OFFSET_ACPRED	0x0000
+#define VC1_BITPLANE_OFFSET_OVERFLAGS	0x0400
+#define VC1_BITPLANE_OFFSET_MVTYPEMB	0x0800
+#define VC1_BITPLANE_OFFSET_SKIPMB	0x0C00
+#define VC1_BITPLANE_OFFSET_DIRECTMB	0x1000
+#define VC1_BITPLANE_OFFSET_FIELDTX	0x1400
+#define VC1_BITPLANE_OFFSET_FORWARDMB	0x1800
+
+#define FRACTION(num, denom) (((num) * 256) / (denom))
+
+static const unsigned int vc1_fractions[] = {
+	FRACTION(1, 2),
+	FRACTION(1, 3),
+	FRACTION(2, 3),
+	FRACTION(1, 4),
+	FRACTION(3, 4),
+	FRACTION(1, 5),
+	FRACTION(2, 5),
+	FRACTION(3, 5),
+	FRACTION(4, 5),
+	FRACTION(1, 6),
+	FRACTION(5, 6),
+	FRACTION(1, 7),
+	FRACTION(2, 7),
+	FRACTION(3, 7),
+	FRACTION(4, 7),
+	FRACTION(5, 7),
+	FRACTION(6, 7),
+	FRACTION(1, 8),
+	FRACTION(3, 8),
+	FRACTION(5, 8),
+	FRACTION(7, 8),
+	0xff,
+	0
+};
+
+static const unsigned int vc1_mvmode_map[] = {3, 2, 0, 1};
+
+static unsigned int cedrus_vc1_get_fraction(unsigned int index)
+{
+	if (index >= ARRAY_SIZE(vc1_fractions))
+		return 0;
+
+	return vc1_fractions[index];
+}
+
+static void cedrus_vc1_bitplanes_setup(struct cedrus_ctx *ctx,
+				       struct cedrus_run *run)
+{
+	const struct v4l2_vc1_entrypoint_header *entrypoint;
+	const struct v4l2_ctrl_vc1_bitplanes *bitplanes;
+	unsigned int mb_num, plane_size;
+
+	entrypoint = &run->vc1.slice_params->entrypoint_header;
+	bitplanes = run->vc1.bitplanes;
+
+	/*
+	 * FIXME: Not sure if max coded size or current code
+	 * size is correct.
+	 */
+	/*mb_num = DIV_ROUND_UP(entrypoint->coded_width, 16) *
+		 DIV_ROUND_UP(entrypoint->coded_height, 16);
+	plane_size = DIV_ROUND_UP(mb_num, 8);
+
+	if (plane_size > 1024) {
+		printk("VC-1: Warning, bitplane size too big!\n");
+		plane_size = 1024;
+	}*/
+
+	plane_size = 1024;
+
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_MVTYPEMB)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_MVTYPEMB,
+		       bitplanes->mvtypemb, plane_size);
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_DIRECTMB)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_DIRECTMB,
+		       bitplanes->directmb, plane_size);
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_SKIPMB)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_SKIPMB,
+		       bitplanes->skipmb, plane_size);
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_FIELDTX)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_FIELDTX,
+		       bitplanes->fieldtx, plane_size);
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_FORWARDMB)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_FORWARDMB,
+		       bitplanes->forwardmb, plane_size);
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_ACPRED)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_ACPRED,
+		       bitplanes->acpred, plane_size);
+	if (bitplanes->bitplane_flags & V4L2_VC1_BITPLANE_FLAG_OVERFLAGS)
+		memcpy(ctx->codec.vc1.bitplanes_buf + VC1_BITPLANE_OFFSET_OVERFLAGS,
+		       bitplanes->overflags, plane_size);
+}
+
+static enum cedrus_irq_status
+cedrus_vc1_irq_status(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	u32 reg = cedrus_read(dev, VE_DEC_VC1_STATUS);
+
+	if (reg & (VE_DEC_VC1_STATUS_ERROR |
+		   VE_DEC_VC1_STATUS_VLD_DATA_REQ))
+		return CEDRUS_IRQ_ERROR;
+
+	if (reg & VE_DEC_VC1_STATUS_SUCCESS)
+		return CEDRUS_IRQ_OK;
+
+	return CEDRUS_IRQ_NONE;
+}
+
+static void cedrus_vc1_irq_clear(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+
+	cedrus_write(dev, VE_DEC_VC1_STATUS,
+		     VE_DEC_VC1_STATUS_INT_MASK);
+}
+
+static void cedrus_vc1_irq_disable(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	u32 reg = cedrus_read(dev, VE_DEC_VC1_CTRL);
+
+	cedrus_write(dev, VE_DEC_VC1_CTRL,
+		     reg & ~VE_DEC_VC1_CTRL_IRQ_MASK);
+}
+
+static void cedrus_vc1_skip_bits(struct cedrus_dev *dev, int num)
+{
+	int count = 0;
+
+	while (count < num) {
+		int tmp = min(num - count, 32);
+
+		cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
+			     VE_DEC_VC1_TRIGGER_TYPE_FLUSH_BITS |
+			     VE_DEC_VC1_TRIGGER_TYPE_N_BITS(tmp));
+		while (cedrus_read(dev, VE_DEC_VC1_STATUS) & VE_DEC_VC1_STATUS_BITS_BUSY)
+			udelay(1);
+
+		count += tmp;
+	}
+}
+
+static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
+{
+	const struct v4l2_ctrl_vc1_slice_params *slice = run->vc1.slice_params;
+	const struct v4l2_ctrl_vc1_bitplanes *bitplanes = run->vc1.bitplanes;
+	bool progressive, top_field_first, second_field, ref_field;
+	const struct v4l2_vc1_entrypoint_header *entrypoint;
+	struct cedrus_buffer *fwd_buf, *bwd_buf, *out_buf;
+	struct vb2_buffer *src_buf = &run->src->vb2_buf;
+	const struct v4l2_vc1_picture_layer *picture;
+	const struct v4l2_vc1_vopdquant *vopdquant;
+	dma_addr_t dst_luma_addr, dst_chroma_addr;
+	dma_addr_t fwd_luma_addr, fwd_chroma_addr;
+	dma_addr_t bwd_luma_addr, bwd_chroma_addr;
+	const struct v4l2_vc1_sequence *sequence;
+	const struct v4l2_vc1_metadata *metadata;
+	struct cedrus_dev *dev = ctx->dev;
+	unsigned int bfraction, frfd;
+	dma_addr_t src_buf_addr;
+	struct vb2_queue *vq;
+	int backward_idx;
+	int forward_idx;
+	int brfd;
+	u32 reg;
+
+	unsigned int raw_coding = slice->raw_coding_flags;
+	//if (bitplanes && bitplanes->bitplane_flags)
+	//	raw_coding = ~bitplanes->bitplane_flags;
+	printk("raw coding: %.2x, flags: %.2x\n", slice->raw_coding_flags, bitplanes->bitplane_flags);
+
+	sequence = &slice->sequence;
+	entrypoint = &slice->entrypoint_header;
+	picture = &slice->picture_layer;
+	vopdquant = &slice->vopdquant;
+	metadata = &slice->metadata;
+
+	second_field = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_SECOND_FIELD);
+	top_field_first = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_TFF);
+	progressive = picture->fcm == VC1_FCM_PROGRESSIVE;
+	ref_field = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_REFFIELD);
+
+	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+
+	forward_idx = vb2_find_timestamp(vq, slice->forward_ref_ts, 0);
+	fwd_buf = NULL;
+	if (forward_idx >= 0)
+		fwd_buf = vb2_to_cedrus_buffer(vq->bufs[forward_idx]);
+
+	backward_idx = vb2_find_timestamp(vq, slice->backward_ref_ts, 0);
+	bwd_buf = NULL;
+	if (backward_idx >= 0)
+		bwd_buf = vb2_to_cedrus_buffer(vq->bufs[backward_idx]);
+
+	out_buf = vb2_to_cedrus_buffer(&run->dst->vb2_buf);
+	out_buf->codec.vc1.rangeredfrm =
+		picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_RANGEREDFRM;
+	out_buf->codec.vc1.interlaced = !progressive;
+	out_buf->codec.vc1.ptype = picture->ptype;
+
+	cedrus_engine_enable(ctx, CEDRUS_CODEC_VC1);
+
+	/* Set auxiliary buffers */
+
+	cedrus_write(dev, VE_DEC_VC1_DCACPRED_ADDR,
+		     ctx->codec.vc1.acdc_buf_addr);
+	cedrus_write(dev, VE_DEC_VC1_BITPLANE_ADDR,
+		     ctx->codec.vc1.bitplanes_buf_addr);
+	cedrus_write(dev, VE_DEC_VC1_MVINFO_ADDR,
+		     ctx->codec.vc1.mv_buf_addr);
+
+	/* Set bitstream source */
+
+	src_buf_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);
+	cedrus_write(dev, VE_DEC_VC1_BITS_OFFSET, slice->data_bit_offset);
+	cedrus_write(dev, VE_DEC_VC1_BITS_LEN, slice->bit_size - slice->data_bit_offset);
+	cedrus_write(dev, VE_DEC_VC1_BITS_ADDR,
+		     VE_DEC_VC1_BITS_ADDR_BASE(src_buf_addr) |
+		     VE_DEC_VC1_BITS_ADDR_VALID_SLICE_DATA |
+		     VE_DEC_VC1_BITS_ADDR_LAST_SLICE_DATA |
+		     VE_DEC_VC1_BITS_ADDR_FIRST_SLICE_DATA);
+	cedrus_write(dev, VE_DEC_VC1_BITS_END_ADDR,
+		     src_buf_addr + vb2_get_plane_payload(src_buf, 0));
+
+	cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
+		     VE_DEC_VC1_TRIGGER_TYPE_INIT_SWDEC);
+
+	//cedrus_vc1_skip_bits(dev, slice->data_bit_offset);
+
+	cedrus_write(dev, VE_DEC_VC1_ROT_CTRL, 0);
+
+
+	cedrus_write(dev, VE_DEC_VC1_PICHDRLEN,
+		     VE_DEC_VC1_PICHDRLEN_LENGTH(0));
+
+	reg = VE_DEC_VC1_EPHS_PROFILE(sequence->profile);
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_LOOPFILTER)
+		reg |= VE_DEC_VC1_EPHS_LOOPFILTER;
+	if (metadata->flags & V4L2_VC1_METADATA_FLAG_MULTIRES)
+		reg |= VE_DEC_VC1_EPHS_MULTIRES;
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_FASTUVMC)
+		reg |= VE_DEC_VC1_EPHS_FASTUVMC;
+	//if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_MV)
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_DMV)
+		reg |= VE_DEC_VC1_EPHS_EXTENDEDMV;
+	reg |= VE_DEC_VC1_EPHS_DQUANT(entrypoint->dquant);
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_VSTRANSFORM)
+		reg |= VE_DEC_VC1_EPHS_VSTRANSFORM;
+	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_OVERLAP)
+		reg |= VE_DEC_VC1_EPHS_OVERLAP;
+	reg |= VE_DEC_VC1_EPHS_QUANTIZER(entrypoint->quantizer);
+	if (metadata->flags & V4L2_VC1_METADATA_FLAG_RANGERED)
+		reg |= VE_DEC_VC1_EPHS_RANGERED;
+	if (sequence->flags & V4L2_VC1_SEQUENCE_FLAG_FINTERPFLAG)
+		reg |= VE_DEC_VC1_EPHS_FINTERPFLAG;
+	if (metadata->flags & V4L2_VC1_METADATA_FLAG_SYNCMARKER)
+		reg |= VE_DEC_VC1_EPHS_SYNCMARKER;
+	/*if (sequence->profile == VC1_PROFILE_ADVANCED)
+		reg |= VE_DEC_VC1_EPHS_STARTCODE_DET_EN;
+	else
+		reg |= VE_DEC_VC1_EPHS_EPTB_DET_BYPASS;*/
+	cedrus_write(dev, VE_DEC_VC1_EPHS, reg);
+
+	reg = VE_DEC_VC1_PICCTRL_PTYPE(picture->ptype);
+        reg |= VE_DEC_VC1_PICCTRL_FCM(picture->fcm ? picture->fcm + 1 : 0);
+	if (!progressive && !(top_field_first ^ second_field))
+		reg |= VE_DEC_VC1_PICCTRL_BOTTOM_FIELD;
+	if (second_field)
+		reg |= VE_DEC_VC1_PICCTRL_SECOND_FIELD;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_RANGEREDFRM)
+		reg |= VE_DEC_VC1_PICCTRL_RANGEREDFRM;
+	if (fwd_buf && fwd_buf->codec.vc1.rangeredfrm)
+		reg |= VE_DEC_VC1_PICCTRL_FWD_RANGEREDFRM;
+	if (bwd_buf && bwd_buf->codec.vc1.rangeredfrm)
+		reg |= VE_DEC_VC1_PICCTRL_BWD_RANGEREDFRM;
+	reg |= VE_DEC_VC1_PICCTRL_TRANSACFRM(picture->transacfrm);
+	reg |= VE_DEC_VC1_PICCTRL_TRANSACFRM2(picture->transacfrm2);
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_TRANSDCTAB)
+		reg |= VE_DEC_VC1_PICCTRL_TRANSDCTAB;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_RNDCTRL)
+		reg |= VE_DEC_VC1_PICCTRL_RNDCTRL;
+	reg |= VE_DEC_VC1_PICCTRL_CONDOVER(picture->condover ? picture->condover + 1 : 0);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_ACPRED)
+		reg |= VE_DEC_VC1_PICCTRL_ACPRED_RAW;
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_OVERFLAGS)
+		reg |= VE_DEC_VC1_PICCTRL_OVERFLAGS_RAW;
+	reg |= VE_DEC_VC1_PICCTRL_CBPTAB(picture->cbptab);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_SKIPMB)
+		reg |= VE_DEC_VC1_PICCTRL_SKIPMB_RAW;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_TTMBF)
+		reg |= VE_DEC_VC1_PICCTRL_TTMBF;
+	reg |= VE_DEC_VC1_PICCTRL_TTFRM(picture->ttfrm);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_DIRECTMB)
+		reg |= VE_DEC_VC1_PICCTRL_DIRECTMB_RAW;
+	if (bwd_buf && bwd_buf->codec.vc1.ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
+	//if (picture->ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
+		reg |= VE_DEC_VC1_PICCTRL_DIRECT_REF_INTRA;
+	if (bitplanes && bitplanes->bitplane_flags)
+		reg |= VE_DEC_VC1_PICCTRL_BITPL_CODING;
+	cedrus_write(dev, VE_DEC_VC1_PICCTRL, reg);
+
+	reg = VE_DEC_VC1_PICQP_PQINDEX(picture->pqindex);
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_HALFQP)
+		reg |= VE_DEC_VC1_PICQP_HALFQP;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_PQUANTIZER)
+		reg |= VE_DEC_VC1_PICQP_PQUANTIZER;
+	reg |= VE_DEC_VC1_PICQP_DQPPROFILE(vopdquant->dqprofile);
+	reg |= VE_DEC_VC1_PICQP_DQSBEDGE(vopdquant->dqsbedge);
+	reg |= VE_DEC_VC1_PICQP_DQDBEDGE(vopdquant->dqdbedge);
+	reg |= VE_DEC_VC1_PICQP_ALTPQUANT(vopdquant->altpquant);
+	if (vopdquant->flags & V4L2_VC1_VOPDQUANT_FLAG_DQUANTFRM)
+		reg |= VE_DEC_VC1_PICQP_DQUANTFRM;
+	if (vopdquant->flags & V4L2_VC1_VOPDQUANT_FLAG_DQBILEVEL)
+		reg |= VE_DEC_VC1_PICQP_DQBILEVEL;
+	cedrus_write(dev, VE_DEC_VC1_PICQP, reg);
+
+	bfraction = cedrus_vc1_get_fraction(picture->bfraction);
+	reg = VE_DEC_VC1_PICMV_BFRACTION(bfraction);
+	if (bfraction < FRACTION(1, 2))
+		reg |= VE_DEC_VC1_PICMV_BFRAC_LESS_THAN_HALF;
+	reg |= VE_DEC_VC1_PICMV_MVRANGE(picture->mvrange);
+	/* FIXME: is this ok? */
+	if (picture->ptype == VC1_PICTURE_TYPE_P &&
+	    picture->mvmode == VC1_MVMODE_INTENSITY_COMP)
+		reg |= VE_DEC_VC1_PICMV_MVMODE(vc1_mvmode_map[picture->mvmode2 & 3]);
+	else
+		reg |= VE_DEC_VC1_PICMV_MVMODE(vc1_mvmode_map[picture->mvmode & 3]);
+	if ((picture->ptype == VC1_PICTURE_TYPE_B && ctx->codec.vc1.compen) ||
+	    (picture->ptype != VC1_PICTURE_TYPE_B && picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP))
+		reg |= VE_DEC_VC1_PICMV_INTENSITY_COMP_EN;
+	if (picture->ptype == VC1_PICTURE_TYPE_P)
+		ctx->codec.vc1.compen = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP);
+	else if (picture->ptype == VC1_PICTURE_TYPE_I)
+		ctx->codec.vc1.compen = 0;
+	reg |= VE_DEC_VC1_PICMV_MVTAB(picture->mvtab);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_MVTYPEMB)
+		reg |= VE_DEC_VC1_PICMV_MVTYPEMB_RAW;
+	cedrus_write(dev, VE_DEC_VC1_PICMV, reg);
+
+	reg = VE_DEC_VC1_PICINTENCOMP_LUMASCALE1(picture->lumscale);
+	reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT1(picture->lumshift);
+	reg |= VE_DEC_VC1_PICINTENCOMP_LUMASCALE2(picture->lumscale2);
+	reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT2(picture->lumshift2);
+	cedrus_write(dev, VE_DEC_VC1_PICINTENCOMP, reg);
+
+	frfd = (bfraction * picture->refdist) >> 8;
+	brfd = picture->refdist - frfd - 1;
+
+	if (frfd > 3)
+		frfd = 3;
+	if (brfd < 0)
+		brfd = 0;
+	else if (brfd > 3)
+		brfd = 3;
+
+	reg = 0;
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_FIELDTX)
+		reg |= VE_DEC_VC1_PICINTERLACE_FIELDTX_RAW;
+	reg |= VE_DEC_VC1_PICINTERLACE_DMVRANGE(picture->dmvrange);
+	//if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_4MVSWITCH)
+	if (picture->mvmode == VC1_MVMODE_MIXED_MV)
+		reg |= VE_DEC_VC1_PICINTERLACE_4MVSWITCH;
+	reg |= VE_DEC_VC1_PICINTERLACE_MBMODETAB(picture->mbmodetab);
+	reg |= VE_DEC_VC1_PICINTERLACE_IMVTAB(picture->imvtab);
+	reg |= VE_DEC_VC1_PICINTERLACE_ICBPTAB(picture->icbptab);
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP)
+		reg |= VE_DEC_VC1_PICINTERLACE_INTENCOMP;
+	reg |= VE_DEC_VC1_PICINTERLACE_2MVBPTAB(picture->twomvbptab);
+	reg |= VE_DEC_VC1_PICINTERLACE_4MVBPTAB(picture->fourmvbptab);
+	reg |= VE_DEC_VC1_PICINTERLACE_FRFD(frfd);
+	reg |= VE_DEC_VC1_PICINTERLACE_BRFD(brfd);
+	if (!(second_field ^ ref_field))
+		reg |= VE_DEC_VC1_PICINTERLACE_REFFIELD;
+	reg |= VE_DEC_VC1_PICINTERLACE_INTENCOMPFLD(picture->intcompfield);
+	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_FORWARDMB)
+		reg |= VE_DEC_VC1_PICINTERLACE_FORWARD_RAW;
+	if ((fwd_buf && fwd_buf->codec.vc1.interlaced) ||
+	    (!fwd_buf && !progressive))
+		reg |= VE_DEC_VC1_PICINTERLACE_FWD_INTERLACE;
+	if ((bwd_buf && bwd_buf->codec.vc1.interlaced) ||
+	    (!bwd_buf && !progressive))
+		reg |= VE_DEC_VC1_PICINTERLACE_BWD_INTERLACE;
+	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_NUMREF)
+		reg |= VE_DEC_VC1_PICINTERLACE_NUMREF;
+	cedrus_write(dev, VE_DEC_VC1_PICINTERLACE, reg);
+
+	/* Set frame dimensions. */
+
+	/* FIXME: not sure if max coded size or current code size is correct */
+	reg = VE_DEC_VC1_FSIZE_WIDTH(ctx->src_fmt.width);
+	reg |= VE_DEC_VC1_FSIZE_HEIGHT(ctx->src_fmt.width);
+	cedrus_write(dev, VE_DEC_VC1_FSIZE, reg);
+
+	reg = VE_DEC_VC1_PICSIZE_WIDTH(ctx->src_fmt.width);
+	reg |= VE_DEC_VC1_PICSIZE_HEIGHT(ctx->src_fmt.width);
+	cedrus_write(dev, VE_DEC_VC1_PICSIZE, reg);
+
+	/* Destination luma and chroma buffers. */
+
+	dst_luma_addr = cedrus_dst_buf_addr(ctx, run->dst->vb2_buf.index, 0);
+	dst_chroma_addr = cedrus_dst_buf_addr(ctx, run->dst->vb2_buf.index, 1);
+
+	cedrus_write(dev, VE_DEC_VC1_REC_LUMA, dst_luma_addr);
+	cedrus_write(dev, VE_DEC_VC1_REC_CHROMA, dst_chroma_addr);
+	cedrus_write(dev, VE_DEC_VC1_ROT_LUMA_ADDR, dst_luma_addr);
+	cedrus_write(dev, VE_DEC_VC1_ROT_CHROMA_ADDR, dst_chroma_addr);
+
+	/* Forward and backward prediction reference buffers. */
+
+        if (forward_idx >= 0) {
+            fwd_luma_addr = cedrus_dst_buf_addr(ctx, forward_idx, 0);
+            fwd_chroma_addr = cedrus_dst_buf_addr(ctx, forward_idx, 1);
+        } else {
+            fwd_luma_addr = dst_luma_addr;
+            fwd_chroma_addr = dst_chroma_addr;
+        }
+
+	cedrus_write(dev, VE_DEC_VC1_FWD_REF_LUMA_ADDR, fwd_luma_addr);
+	cedrus_write(dev, VE_DEC_VC1_FWD_REF_CHROMA_ADDR, fwd_chroma_addr);
+
+        if (backward_idx >= 0) {
+            bwd_luma_addr = cedrus_dst_buf_addr(ctx, backward_idx, 0);
+            bwd_chroma_addr = cedrus_dst_buf_addr(ctx, backward_idx, 1);
+        } else {
+            bwd_luma_addr = dst_luma_addr;
+            bwd_chroma_addr = dst_chroma_addr;
+        }
+
+	cedrus_write(dev, VE_DEC_VC1_BWD_REF_LUMA_ADDR, bwd_luma_addr);
+	cedrus_write(dev, VE_DEC_VC1_BWD_REF_CHROMA_ADDR, bwd_chroma_addr);
+
+	/* Setup bitplanes */
+
+	if (bitplanes && bitplanes->bitplane_flags)
+		cedrus_vc1_bitplanes_setup(ctx, run);
+
+	/* clear status flags */
+	//cedrus_write(dev, VE_DEC_VC1_STATUS,
+	//	     cedrus_read(dev, VE_DEC_VC1_STATUS));
+
+	cedrus_write(dev, VE_DEC_VC1_CTRL,
+		     VE_DEC_VC1_CTRL_FINISH_IRQ_EN |
+		     VE_DEC_VC1_CTRL_ERROR_IRQ_EN |
+		     VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN);
+}
+
+static int cedrus_vc1_start(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+	int ret;
+
+	ctx->codec.vc1.mv_buf =
+		dma_alloc_coherent(dev->dev, MV_BUF_SIZE,
+				   &ctx->codec.vc1.mv_buf_addr,
+				   GFP_KERNEL);
+	if (!ctx->codec.vc1.mv_buf)
+		return -ENOMEM;
+
+	ctx->codec.vc1.acdc_buf =
+		dma_alloc_coherent(dev->dev, ACDC_BUF_SIZE,
+				   &ctx->codec.vc1.acdc_buf_addr,
+				   GFP_KERNEL);
+	if (!ctx->codec.vc1.acdc_buf) {
+		ret = -ENOMEM;
+		goto err_mv_buf;
+	}
+
+	ctx->codec.vc1.bitplanes_buf =
+		dma_alloc_coherent(dev->dev, BITPLANES_BUF_SIZE,
+				   &ctx->codec.vc1.bitplanes_buf_addr,
+				   GFP_KERNEL);
+	if (!ctx->codec.vc1.bitplanes_buf) {
+		ret = -ENOMEM;
+		goto err_acdc_buf;
+	}
+
+	return 0;
+
+err_acdc_buf:
+	dma_free_coherent(dev->dev, ACDC_BUF_SIZE,
+			  ctx->codec.vc1.acdc_buf,
+			  ctx->codec.vc1.acdc_buf_addr);
+
+err_mv_buf:
+	dma_free_coherent(dev->dev, MV_BUF_SIZE,
+			  ctx->codec.vc1.mv_buf,
+			  ctx->codec.vc1.mv_buf_addr);
+
+	return ret;
+}
+
+static void cedrus_vc1_stop(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+
+	dma_free_coherent(dev->dev, MV_BUF_SIZE,
+			  ctx->codec.vc1.mv_buf,
+			  ctx->codec.vc1.mv_buf_addr);
+	dma_free_coherent(dev->dev, ACDC_BUF_SIZE,
+			  ctx->codec.vc1.acdc_buf,
+			  ctx->codec.vc1.acdc_buf_addr);
+	dma_free_coherent(dev->dev, BITPLANES_BUF_SIZE,
+			  ctx->codec.vc1.bitplanes_buf,
+			  ctx->codec.vc1.bitplanes_buf_addr);
+}
+
+static void cedrus_vc1_trigger(struct cedrus_ctx *ctx)
+{
+	struct cedrus_dev *dev = ctx->dev;
+
+	cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
+		     VE_DEC_VC1_TRIGGER_TYPE_DECODE);
+
+	printk("---trigger---\n");
+}
+
+struct cedrus_dec_ops cedrus_dec_ops_vc1 = {
+	.irq_clear	= cedrus_vc1_irq_clear,
+	.irq_disable	= cedrus_vc1_irq_disable,
+	.irq_status	= cedrus_vc1_irq_status,
+	.setup		= cedrus_vc1_setup,
+	.start		= cedrus_vc1_start,
+	.stop		= cedrus_vc1_stop,
+	.trigger	= cedrus_vc1_trigger,
+};
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus_video.c b/drivers/staging/media/sunxi/cedrus/cedrus_video.c
index e97bc24ace6c8..bd14768b855ce 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus_video.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus_video.c
@@ -46,6 +46,10 @@ static struct cedrus_format cedrus_formats[] = {
 		.directions	= CEDRUS_DECODE_SRC,
 		.capabilities	= CEDRUS_CAPABILITY_VP8_DEC,
 	},
+	{
+		.pixelformat	= V4L2_PIX_FMT_VC1_SLICE,
+		.directions	= CEDRUS_DECODE_SRC,
+	},
 	{
 		.pixelformat	= V4L2_PIX_FMT_SUNXI_TILED_NV12,
 		.directions	= CEDRUS_DECODE_DST,
@@ -123,6 +127,7 @@ void cedrus_prepare_format(struct v4l2_pix_format *pix_fmt, int extended)
 	case V4L2_PIX_FMT_H264_SLICE:
 	case V4L2_PIX_FMT_HEVC_SLICE:
 	case V4L2_PIX_FMT_VP8_FRAME:
+	case V4L2_PIX_FMT_VC1_SLICE:
 		/* Zero bytes per line for encoded source. */
 		bytesperline = 0;
 		/* Choose some minimum size since this can't be 0 */
@@ -513,6 +518,10 @@ static int cedrus_start_streaming(struct vb2_queue *vq, unsigned int count)
 		ctx->current_codec = CEDRUS_CODEC_VP8;
 		break;
 
+	case V4L2_PIX_FMT_VC1_SLICE:
+		ctx->current_codec = CEDRUS_CODEC_VC1;
+		break;
+
 	default:
 		return -EINVAL;
 	}
From 6c18e3df4478ce3956eaf203aa052922d96f87a2 Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@siol.net>
Date: Sun, 2 Aug 2020 17:58:01 +0200
Subject: [PATCH] vc1 fixes

---
 drivers/staging/media/sunxi/cedrus/cedrus.h   |   4 +-
 .../staging/media/sunxi/cedrus/cedrus_vc1.c   | 111 +++++++++---------
 2 files changed, 56 insertions(+), 59 deletions(-)

diff --git a/drivers/staging/media/sunxi/cedrus/cedrus.h b/drivers/staging/media/sunxi/cedrus/cedrus.h
index 12e3da0c9c340..8284c64f31543 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus.h
+++ b/drivers/staging/media/sunxi/cedrus/cedrus.h
@@ -114,6 +114,7 @@ struct cedrus_buffer {
 			int		interlaced;
 			int		rangeredfrm;
 			unsigned int	ptype;
+			int		compen;
 		} vc1;
 	} codec;
 };
@@ -160,7 +161,6 @@ struct cedrus_ctx {
 			dma_addr_t	acdc_buf_addr;
 			u8		*bitplanes_buf;
 			dma_addr_t	bitplanes_buf_addr;
-			int		compen;
 		} vc1;
 	} codec;
 };
diff --git a/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c b/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c
index 91a6ef0d96628..db0f75c1c0568 100644
--- a/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c
+++ b/drivers/staging/media/sunxi/cedrus/cedrus_vc1.c
@@ -75,7 +75,7 @@ static const unsigned int vc1_fractions[] = {
 	0
 };
 
-static const unsigned int vc1_mvmode_map[] = {3, 2, 0, 1};
+static const unsigned int vc1_mvmode_map[] = {3, 0, 2, 1};
 
 static unsigned int cedrus_vc1_get_fraction(unsigned int index)
 {
@@ -99,14 +99,14 @@ static void cedrus_vc1_bitplanes_setup(struct cedrus_ctx *ctx,
 	 * FIXME: Not sure if max coded size or current code
 	 * size is correct.
 	 */
-	/*mb_num = DIV_ROUND_UP(entrypoint->coded_width, 16) *
+	mb_num = DIV_ROUND_UP(entrypoint->coded_width, 16) *
 		 DIV_ROUND_UP(entrypoint->coded_height, 16);
 	plane_size = DIV_ROUND_UP(mb_num, 8);
 
 	if (plane_size > 1024) {
 		printk("VC-1: Warning, bitplane size too big!\n");
 		plane_size = 1024;
-	}*/
+	}
 
 	plane_size = 1024;
 
@@ -166,23 +166,6 @@ static void cedrus_vc1_irq_disable(struct cedrus_ctx *ctx)
 		     reg & ~VE_DEC_VC1_CTRL_IRQ_MASK);
 }
 
-static void cedrus_vc1_skip_bits(struct cedrus_dev *dev, int num)
-{
-	int count = 0;
-
-	while (count < num) {
-		int tmp = min(num - count, 32);
-
-		cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
-			     VE_DEC_VC1_TRIGGER_TYPE_FLUSH_BITS |
-			     VE_DEC_VC1_TRIGGER_TYPE_N_BITS(tmp));
-		while (cedrus_read(dev, VE_DEC_VC1_STATUS) & VE_DEC_VC1_STATUS_BITS_BUSY)
-			udelay(1);
-
-		count += tmp;
-	}
-}
-
 static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 {
 	const struct v4l2_ctrl_vc1_slice_params *slice = run->vc1.slice_params;
@@ -194,12 +177,12 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	const struct v4l2_vc1_picture_layer *picture;
 	const struct v4l2_vc1_vopdquant *vopdquant;
 	dma_addr_t dst_luma_addr, dst_chroma_addr;
-	dma_addr_t fwd_luma_addr, fwd_chroma_addr;
-	dma_addr_t bwd_luma_addr, bwd_chroma_addr;
+	dma_addr_t fwd_luma_addr = 0, fwd_chroma_addr = 0;
+	dma_addr_t bwd_luma_addr = 0, bwd_chroma_addr = 0;
 	const struct v4l2_vc1_sequence *sequence;
 	const struct v4l2_vc1_metadata *metadata;
+	unsigned int bfraction, frfd, mvmode;
 	struct cedrus_dev *dev = ctx->dev;
-	unsigned int bfraction, frfd;
 	dma_addr_t src_buf_addr;
 	struct vb2_queue *vq;
 	int backward_idx;
@@ -208,9 +191,9 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	u32 reg;
 
 	unsigned int raw_coding = slice->raw_coding_flags;
-	//if (bitplanes && bitplanes->bitplane_flags)
+	//if (bitplanes)
 	//	raw_coding = ~bitplanes->bitplane_flags;
-	printk("raw coding: %.2x, flags: %.2x\n", slice->raw_coding_flags, bitplanes->bitplane_flags);
+	//printk("raw coding: %.2x, flags: %.2x\n", slice->raw_coding_flags, bitplanes->bitplane_flags);
 
 	sequence = &slice->sequence;
 	entrypoint = &slice->entrypoint_header;
@@ -255,21 +238,25 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	/* Set bitstream source */
 
 	src_buf_addr = vb2_dma_contig_plane_dma_addr(src_buf, 0);
+	cedrus_write(dev, VE_DEC_VC1_BITS_ADDR,
+		     VE_DEC_VC1_BITS_ADDR_BASE(src_buf_addr));
+	cedrus_write(dev, VE_DEC_VC1_BITS_END_ADDR,
+		     src_buf_addr + vb2_get_plane_payload(src_buf, 0));
 	cedrus_write(dev, VE_DEC_VC1_BITS_OFFSET, slice->data_bit_offset);
-	cedrus_write(dev, VE_DEC_VC1_BITS_LEN, slice->bit_size - slice->data_bit_offset);
+	cedrus_write(dev, VE_DEC_VC1_BITS_LEN, vb2_get_plane_payload(src_buf, 0) * 8 /*- slice->data_bit_offset*/);
+
 	cedrus_write(dev, VE_DEC_VC1_BITS_ADDR,
 		     VE_DEC_VC1_BITS_ADDR_BASE(src_buf_addr) |
 		     VE_DEC_VC1_BITS_ADDR_VALID_SLICE_DATA |
 		     VE_DEC_VC1_BITS_ADDR_LAST_SLICE_DATA |
 		     VE_DEC_VC1_BITS_ADDR_FIRST_SLICE_DATA);
-	cedrus_write(dev, VE_DEC_VC1_BITS_END_ADDR,
-		     src_buf_addr + vb2_get_plane_payload(src_buf, 0));
+
+	cedrus_write(dev, VE_DEC_VC1_STATUS,
+		     VE_DEC_VC1_STATUS_INT_MASK);
 
 	cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
 		     VE_DEC_VC1_TRIGGER_TYPE_INIT_SWDEC);
 
-	//cedrus_vc1_skip_bits(dev, slice->data_bit_offset);
-
 	cedrus_write(dev, VE_DEC_VC1_ROT_CTRL, 0);
 
 
@@ -283,7 +270,6 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 		reg |= VE_DEC_VC1_EPHS_MULTIRES;
 	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_FASTUVMC)
 		reg |= VE_DEC_VC1_EPHS_FASTUVMC;
-	//if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_MV)
 	if (entrypoint->flags & V4L2_VC1_ENTRYPOINT_HEADER_FLAG_EXTENDED_DMV)
 		reg |= VE_DEC_VC1_EPHS_EXTENDEDMV;
 	reg |= VE_DEC_VC1_EPHS_DQUANT(entrypoint->dquant);
@@ -298,10 +284,10 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 		reg |= VE_DEC_VC1_EPHS_FINTERPFLAG;
 	if (metadata->flags & V4L2_VC1_METADATA_FLAG_SYNCMARKER)
 		reg |= VE_DEC_VC1_EPHS_SYNCMARKER;
-	/*if (sequence->profile == VC1_PROFILE_ADVANCED)
+	if (sequence->profile == VC1_PROFILE_ADVANCED)
 		reg |= VE_DEC_VC1_EPHS_STARTCODE_DET_EN;
 	else
-		reg |= VE_DEC_VC1_EPHS_EPTB_DET_BYPASS;*/
+		reg |= VE_DEC_VC1_EPHS_EPTB_DET_BYPASS;
 	cedrus_write(dev, VE_DEC_VC1_EPHS, reg);
 
 	reg = VE_DEC_VC1_PICCTRL_PTYPE(picture->ptype);
@@ -323,8 +309,8 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_RNDCTRL)
 		reg |= VE_DEC_VC1_PICCTRL_RNDCTRL;
 	reg |= VE_DEC_VC1_PICCTRL_CONDOVER(picture->condover ? picture->condover + 1 : 0);
-	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_ACPRED)
-		reg |= VE_DEC_VC1_PICCTRL_ACPRED_RAW;
+	//if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_ACPRED)
+	//	reg |= VE_DEC_VC1_PICCTRL_ACPRED_RAW;
 	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_OVERFLAGS)
 		reg |= VE_DEC_VC1_PICCTRL_OVERFLAGS_RAW;
 	reg |= VE_DEC_VC1_PICCTRL_CBPTAB(picture->cbptab);
@@ -335,8 +321,9 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	reg |= VE_DEC_VC1_PICCTRL_TTFRM(picture->ttfrm);
 	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_DIRECTMB)
 		reg |= VE_DEC_VC1_PICCTRL_DIRECTMB_RAW;
-	if (bwd_buf && bwd_buf->codec.vc1.ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
-	//if (picture->ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
+	//if (bwd_buf && bwd_buf->codec.vc1.ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
+	//if (fwd_buf && fwd_buf->codec.vc1.ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
+	if (picture->ptype != VC1_PICTURE_TYPE_P) /* FIXME: should it be == VC1_PICTURE_TYPE_I ? */
 		reg |= VE_DEC_VC1_PICCTRL_DIRECT_REF_INTRA;
 	if (bitplanes && bitplanes->bitplane_flags)
 		reg |= VE_DEC_VC1_PICCTRL_BITPL_CODING;
@@ -365,19 +352,21 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	/* FIXME: is this ok? */
 	if (picture->ptype == VC1_PICTURE_TYPE_P &&
 	    picture->mvmode == VC1_MVMODE_INTENSITY_COMP)
-		reg |= VE_DEC_VC1_PICMV_MVMODE(vc1_mvmode_map[picture->mvmode2 & 3]);
+		mvmode = picture->mvmode2;
 	else
-		reg |= VE_DEC_VC1_PICMV_MVMODE(vc1_mvmode_map[picture->mvmode & 3]);
-	if ((picture->ptype == VC1_PICTURE_TYPE_B && ctx->codec.vc1.compen) ||
+		mvmode = picture->mvmode;
+	reg |= VE_DEC_VC1_PICMV_MVMODE(vc1_mvmode_map[mvmode & 3]);
+	if ((picture->ptype == VC1_PICTURE_TYPE_B && fwd_buf && fwd_buf->codec.vc1.compen) ||
 	    (picture->ptype != VC1_PICTURE_TYPE_B && picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP))
+	//if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP)
 		reg |= VE_DEC_VC1_PICMV_INTENSITY_COMP_EN;
 	if (picture->ptype == VC1_PICTURE_TYPE_P)
-		ctx->codec.vc1.compen = !!(picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_INTCOMP);
+		out_buf->codec.vc1.compen = !!(reg & VE_DEC_VC1_PICMV_INTENSITY_COMP_EN);
 	else if (picture->ptype == VC1_PICTURE_TYPE_I)
-		ctx->codec.vc1.compen = 0;
+		out_buf->codec.vc1.compen = 0;
 	reg |= VE_DEC_VC1_PICMV_MVTAB(picture->mvtab);
-	if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_MVTYPEMB)
-		reg |= VE_DEC_VC1_PICMV_MVTYPEMB_RAW;
+	//if (raw_coding & V4L2_VC1_RAW_CODING_FLAG_MVTYPEMB)
+	//	reg |= VE_DEC_VC1_PICMV_MVTYPEMB_RAW;
 	cedrus_write(dev, VE_DEC_VC1_PICMV, reg);
 
 	reg = VE_DEC_VC1_PICINTENCOMP_LUMASCALE1(picture->lumscale);
@@ -386,7 +375,10 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	reg |= VE_DEC_VC1_PICINTENCOMP_LUMASHIFT2(picture->lumshift2);
 	cedrus_write(dev, VE_DEC_VC1_PICINTENCOMP, reg);
 
-	frfd = (bfraction * picture->refdist) >> 8;
+	if (picture->ptype == VC1_PICTURE_TYPE_B)
+		frfd = (bfraction * picture->refdist) >> 8;
+	else
+		frfd = picture->refdist;
 	brfd = picture->refdist - frfd - 1;
 
 	if (frfd > 3)
@@ -401,7 +393,8 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 		reg |= VE_DEC_VC1_PICINTERLACE_FIELDTX_RAW;
 	reg |= VE_DEC_VC1_PICINTERLACE_DMVRANGE(picture->dmvrange);
 	//if (picture->flags & V4L2_VC1_PICTURE_LAYER_FLAG_4MVSWITCH)
-	if (picture->mvmode == VC1_MVMODE_MIXED_MV)
+	if (mvmode == VC1_MVMODE_MIXED_MV)
+	//if (mvmode == VC1_MVMODE_1MV)
 		reg |= VE_DEC_VC1_PICINTERLACE_4MVSWITCH;
 	reg |= VE_DEC_VC1_PICINTERLACE_MBMODETAB(picture->mbmodetab);
 	reg |= VE_DEC_VC1_PICINTERLACE_IMVTAB(picture->imvtab);
@@ -431,11 +424,11 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 
 	/* FIXME: not sure if max coded size or current code size is correct */
 	reg = VE_DEC_VC1_FSIZE_WIDTH(ctx->src_fmt.width);
-	reg |= VE_DEC_VC1_FSIZE_HEIGHT(ctx->src_fmt.width);
+	reg |= VE_DEC_VC1_FSIZE_HEIGHT(ctx->src_fmt.height);
 	cedrus_write(dev, VE_DEC_VC1_FSIZE, reg);
 
 	reg = VE_DEC_VC1_PICSIZE_WIDTH(ctx->src_fmt.width);
-	reg |= VE_DEC_VC1_PICSIZE_HEIGHT(ctx->src_fmt.width);
+	reg |= VE_DEC_VC1_PICSIZE_HEIGHT(ctx->src_fmt.height);
 	cedrus_write(dev, VE_DEC_VC1_PICSIZE, reg);
 
 	/* Destination luma and chroma buffers. */
@@ -453,7 +446,9 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
         if (forward_idx >= 0) {
             fwd_luma_addr = cedrus_dst_buf_addr(ctx, forward_idx, 0);
             fwd_chroma_addr = cedrus_dst_buf_addr(ctx, forward_idx, 1);
-        } else {
+        }
+
+        if (!fwd_luma_addr || !fwd_chroma_addr) {
             fwd_luma_addr = dst_luma_addr;
             fwd_chroma_addr = dst_chroma_addr;
         }
@@ -464,7 +459,9 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
         if (backward_idx >= 0) {
             bwd_luma_addr = cedrus_dst_buf_addr(ctx, backward_idx, 0);
             bwd_chroma_addr = cedrus_dst_buf_addr(ctx, backward_idx, 1);
-        } else {
+        }
+
+        if (!bwd_luma_addr || !bwd_chroma_addr) {
             bwd_luma_addr = dst_luma_addr;
             bwd_chroma_addr = dst_chroma_addr;
         }
@@ -477,14 +474,11 @@ static void cedrus_vc1_setup(struct cedrus_ctx *ctx, struct cedrus_run *run)
 	if (bitplanes && bitplanes->bitplane_flags)
 		cedrus_vc1_bitplanes_setup(ctx, run);
 
-	/* clear status flags */
-	//cedrus_write(dev, VE_DEC_VC1_STATUS,
-	//	     cedrus_read(dev, VE_DEC_VC1_STATUS));
-
 	cedrus_write(dev, VE_DEC_VC1_CTRL,
 		     VE_DEC_VC1_CTRL_FINISH_IRQ_EN |
 		     VE_DEC_VC1_CTRL_ERROR_IRQ_EN |
-		     VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN);
+		     VE_DEC_VC1_CTRL_VLD_DATA_REQ_IRQ_EN |
+		     VE_DEC_VC1_CTRL_MCRI_CACHE_EN);
 }
 
 static int cedrus_vc1_start(struct cedrus_ctx *ctx)
@@ -550,11 +544,14 @@ static void cedrus_vc1_stop(struct cedrus_ctx *ctx)
 static void cedrus_vc1_trigger(struct cedrus_ctx *ctx)
 {
 	struct cedrus_dev *dev = ctx->dev;
+	int i;
+
+	for (i = 0x300; i <= 0x324; i+=4)
+		printk("%.3x: %.8x\n", i, cedrus_read(dev, i));
+	printk("--eof--\n");
 
 	cedrus_write(dev, VE_DEC_VC1_TRIGGER_TYPE,
 		     VE_DEC_VC1_TRIGGER_TYPE_DECODE);
-
-	printk("---trigger---\n");
 }
 
 struct cedrus_dec_ops cedrus_dec_ops_vc1 = {
diff -Naur linux-5.11.7-old/drivers/staging/media/sunxi/cedrus/Makefile linux-5.11.7-new/drivers/staging/media/sunxi/cedrus/Makefile
--- linux-5.11.7-old/drivers/staging/media/sunxi/cedrus/Makefile	2021-03-17 17:11:47.000000000 +0100
+++ linux-5.11.7-new/drivers/staging/media/sunxi/cedrus/Makefile	2021-03-18 13:43:53.686665896 +0100
@@ -3,4 +3,4 @@
 
 sunxi-cedrus-y = cedrus.o cedrus_video.o cedrus_hw.o cedrus_dec.o \
 		 cedrus_mpeg2.o cedrus_h264.o cedrus_h265.o \
-		 cedrus_vp8.o
+		 cedrus_vp8.o cedrus_vc1.o
