From eb05c4bd9a6cbf18a19b4307bb7f4d9040c1d251 Mon Sep 17 00:00:00 2001
From: Qiang Yu <yuq825@gmail.com>
Date: Mon, 11 Feb 2019 10:56:12 +0800
Subject: [PATCH 06/20] drm/lima: move bo GPU va map into kernel

Signed-off-by: Qiang Yu <yuq825@gmail.com>
---
 drivers/gpu/drm/lima/lima_drv.c   |  21 +----
 drivers/gpu/drm/lima/lima_gem.c   | 173 +++++++++++++-------------------------
 drivers/gpu/drm/lima/lima_gem.h   |   4 +-
 drivers/gpu/drm/lima/lima_sched.c | 103 +++++++++--------------
 drivers/gpu/drm/lima/lima_sched.h |   8 +-
 drivers/gpu/drm/lima/lima_vm.c    | 156 ++++++++--------------------------
 drivers/gpu/drm/lima/lima_vm.h    |  10 +--
 include/uapi/drm/lima_drm.h       |  26 ++----
 8 files changed, 147 insertions(+), 354 deletions(-)

diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index e13d0cd..04dbcdd 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -41,8 +41,6 @@ static int lima_ioctl_info(struct drm_device *dev, void *data, struct drm_file *
 		return -ENODEV;
 	}
 	info->num_pp = ldev->pipe[lima_pipe_pp].num_processor;
-	info->va_start = ldev->va_start;
-	info->va_end = ldev->va_end;
 	return 0;
 }
 
@@ -63,21 +61,7 @@ static int lima_ioctl_gem_info(struct drm_device *dev, void *data, struct drm_fi
 {
 	struct drm_lima_gem_info *args = data;
 
-	return lima_gem_mmap_offset(file, args->handle, &args->offset);
-}
-
-static int lima_ioctl_gem_va(struct drm_device *dev, void *data, struct drm_file *file)
-{
-	struct drm_lima_gem_va *args = data;
-
-	switch (args->op) {
-	case LIMA_VA_OP_MAP:
-		return lima_gem_va_map(file, args->handle, args->flags, args->va);
-	case LIMA_VA_OP_UNMAP:
-		return lima_gem_va_unmap(file, args->handle, args->va);
-	default:
-		return -EINVAL;
-	}
+	return lima_gem_get_info(file, args->handle, &args->va, &args->offset);
 }
 
 static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_file *file)
@@ -154,8 +138,6 @@ static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_
 	submit.out_sync = args->out_sync;
 
 	err = lima_gem_submit(file, &submit);
-	if (!err)
-		args->done = submit.done;
 
 	lima_ctx_put(ctx);
 out2:
@@ -243,7 +225,6 @@ static const struct drm_ioctl_desc lima_drm_driver_ioctls[] = {
 	DRM_IOCTL_DEF_DRV(LIMA_INFO, lima_ioctl_info, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_CREATE, lima_ioctl_gem_create, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_INFO, lima_ioctl_gem_info, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(LIMA_GEM_VA, lima_ioctl_gem_va, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_SUBMIT, lima_ioctl_gem_submit, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_WAIT, lima_ioctl_gem_wait, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_CTX, lima_ioctl_ctx, DRM_AUTH|DRM_RENDER_ALLOW),
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index eca63fe..9f01773 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -49,15 +49,27 @@ int lima_gem_object_open(struct drm_gem_object *obj, struct drm_file *file)
 	struct lima_bo *bo = to_lima_bo(obj);
 	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 	struct lima_vm *vm = priv->vm;
+
+	LIST_HEAD(list);
+	struct ttm_validate_buffer tv_bo, tv_pd;
+	struct ww_acquire_ctx ticket;
 	int err;
 
-	err = lima_bo_reserve(bo, true);
+	tv_bo.bo = &bo->tbo;
+	tv_bo.num_shared = 0;
+	list_add(&tv_bo.head, &list);
+
+	tv_pd.bo = &vm->pd->tbo;
+	tv_pd.num_shared = 0;
+	list_add(&tv_pd.head, &list);
+
+	err = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
 	if (err)
 		return err;
 
 	err = lima_vm_bo_add(vm, bo);
 
-	lima_bo_unreserve(bo);
+	ttm_eu_backoff_reservation(&ticket, &list);
 	return err;
 }
 
@@ -74,11 +86,11 @@ void lima_gem_object_close(struct drm_gem_object *obj, struct drm_file *file)
 	int r;
 
 	tv_bo.bo = &bo->tbo;
-	tv_bo.num_shared = 1;
+	tv_bo.num_shared = 0;
 	list_add(&tv_bo.head, &list);
 
 	tv_pd.bo = &vm->pd->tbo;
-	tv_pd.num_shared = 1;
+	tv_pd.num_shared = 0;
 	list_add(&tv_pd.head, &list);
 
 	r = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
@@ -93,20 +105,33 @@ void lima_gem_object_close(struct drm_gem_object *obj, struct drm_file *file)
 	ttm_eu_backoff_reservation(&ticket, &list);
 }
 
-int lima_gem_mmap_offset(struct drm_file *file, u32 handle, u64 *offset)
+int lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset)
 {
 	struct drm_gem_object *obj;
 	struct lima_bo *bo;
+	struct lima_drm_priv *priv = to_lima_drm_priv(file);
+	struct lima_vm *vm = priv->vm;
+	int err = 0;
 
 	obj = drm_gem_object_lookup(file, handle);
 	if (!obj)
 		return -ENOENT;
 
 	bo = to_lima_bo(obj);
+
+	err = lima_bo_reserve(bo, true);
+	if (err)
+	        goto out;
+
+	*va = lima_vm_get_va(vm, bo);
+
+	lima_bo_unreserve(bo);
+
 	*offset = drm_vma_node_offset_addr(&bo->tbo.vma_node);
 
+out:
 	drm_gem_object_put_unlocked(obj);
-	return 0;
+	return err;
 }
 
 int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma)
@@ -128,96 +153,6 @@ int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma)
 	return ttm_bo_mmap(filp, vma, &dev->mman.bdev);
 }
 
-int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va)
-{
-	struct lima_drm_priv *priv = to_lima_drm_priv(file);
-	struct lima_vm *vm = priv->vm;
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-	struct lima_device *dev;
-	int err;
-
-	LIST_HEAD(list);
-	struct ttm_validate_buffer tv_bo, tv_pd;
-	struct ww_acquire_ctx ticket;
-
-	if (!PAGE_ALIGNED(va))
-		return -EINVAL;
-
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
-
-	bo = to_lima_bo(obj);
-	dev = to_lima_dev(obj->dev);
-
-	/* carefully handle overflow when calculate range */
-	if (va < dev->va_start || dev->va_end - obj->size < va) {
-		err = -EINVAL;
-		goto out;
-	}
-
-	tv_bo.bo = &bo->tbo;
-	tv_bo.num_shared = 1;
-	list_add(&tv_bo.head, &list);
-
-	tv_pd.bo = &vm->pd->tbo;
-	tv_pd.num_shared = 1;
-	list_add(&tv_pd.head, &list);
-
-	err = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
-	if (err)
-		goto out;
-
-	err = lima_vm_bo_map(vm, bo, va);
-
-	ttm_eu_backoff_reservation(&ticket, &list);
-out:
-	drm_gem_object_put_unlocked(obj);
-	return err;
-}
-
-int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va)
-{
-	struct lima_drm_priv *priv = to_lima_drm_priv(file);
-	struct lima_vm *vm = priv->vm;
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-	int err;
-
-	LIST_HEAD(list);
-	struct ttm_validate_buffer tv_bo, tv_pd;
-	struct ww_acquire_ctx ticket;
-
-	if (!PAGE_ALIGNED(va))
-		return -EINVAL;
-
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
-
-	bo = to_lima_bo(obj);
-
-	tv_bo.bo = &bo->tbo;
-	tv_bo.num_shared = 1;
-	list_add(&tv_bo.head, &list);
-
-	tv_pd.bo = &vm->pd->tbo;
-	tv_pd.num_shared = 1;
-	list_add(&tv_pd.head, &list);
-
-	err = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
-	if (err)
-		goto out;
-
-	err = lima_vm_bo_unmap(vm, bo, va);
-
-	ttm_eu_backoff_reservation(&ticket, &list);
-out:
-	drm_gem_object_put_unlocked(obj);
-	return err;
-}
-
 static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,
 			    bool write, bool explicit)
 {
@@ -301,6 +236,11 @@ int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 	struct lima_vm *vm = priv->vm;
 	struct drm_syncobj *out_sync = NULL;
 	struct dma_fence *fence;
+	struct lima_bo **bos;
+
+	bos = kzalloc(sizeof(*bos) * submit->nr_bos, GFP_KERNEL);
+	if (!bos)
+		return -ENOMEM;
 
 	INIT_LIST_HEAD(&submit->validated);
 	INIT_LIST_HEAD(&submit->duplicates);
@@ -316,7 +256,8 @@ int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 			goto out0;
 		}
 
-		vb->bo = &to_lima_bo(obj)->tbo;
+		bos[i] = to_lima_bo(obj);
+		vb->bo = &bos[i]->tbo;
 		if (bo->flags & LIMA_SUBMIT_BO_WRITE)
 			vb->num_shared = 0;
 		else
@@ -342,14 +283,6 @@ int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 	if (err)
 		goto out2;
 
-	if (submit->out_sync) {
-		out_sync = drm_syncobj_find(file, submit->out_sync);
-		if (!out_sync) {
-			err = -ENOENT;
-			goto out2;
-		}
-	}
-
 	for (i = 0; i < submit->nr_bos; i++) {
 		struct ttm_validate_buffer *vb = submit->vbs + i;
 		struct lima_bo *bo = ttm_to_lima_bo(vb->bo);
@@ -357,11 +290,20 @@ int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 			submit->task, bo, vb->num_shared == 0,
 			submit->flags & LIMA_SUBMIT_FLAG_EXPLICIT_FENCE);
 		if (err)
-			goto out3;
+			goto out2;
+	}
+
+	if (submit->out_sync) {
+		out_sync = drm_syncobj_find(file, submit->out_sync);
+		if (!out_sync) {
+			err = -ENOENT;
+			goto out2;
+		}
 	}
 
 	fence = lima_sched_context_queue_task(
-		submit->ctx->context + submit->pipe, submit->task, &submit->done);
+		submit->ctx->context + submit->pipe, submit->task,
+		bos, submit->nr_bos);
 
 	ttm_eu_fence_buffer_objects(&submit->ticket, &submit->validated, fence);
 
@@ -369,22 +311,23 @@ int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 		drm_syncobj_replace_fence(out_sync, fence);
 
 	dma_fence_put(fence);
-out3:
+
 	if (out_sync)
 		drm_syncobj_put(out_sync);
+
+	return 0;
+
 out2:
-	if (err)
-		lima_sched_task_fini(submit->task);
+	lima_sched_task_fini(submit->task);
 out1:
-        if (err)
-		ttm_eu_backoff_reservation(&submit->ticket, &submit->validated);
+	ttm_eu_backoff_reservation(&submit->ticket, &submit->validated);
 out0:
 	for (i = 0; i < submit->nr_bos; i++) {
-		struct ttm_validate_buffer *vb = submit->vbs + i;
-		if (!vb->bo)
+		if (!bos[i])
 			break;
-		drm_gem_object_put_unlocked(&ttm_to_lima_bo(vb->bo)->gem);
+		drm_gem_object_put_unlocked(&bos[i]->gem);
 	}
+	kfree(bos);
 	return err;
 }
 
diff --git a/drivers/gpu/drm/lima/lima_gem.h b/drivers/gpu/drm/lima/lima_gem.h
index da6968f..ed30413 100644
--- a/drivers/gpu/drm/lima/lima_gem.h
+++ b/drivers/gpu/drm/lima/lima_gem.h
@@ -13,10 +13,8 @@ int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 void lima_gem_free_object(struct drm_gem_object *obj);
 int lima_gem_object_open(struct drm_gem_object *obj, struct drm_file *file);
 void lima_gem_object_close(struct drm_gem_object *obj, struct drm_file *file);
-int lima_gem_mmap_offset(struct drm_file *file, u32 handle, u64 *offset);
+int lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset);
 int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma);
-int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va);
-int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va);
 int lima_gem_submit(struct drm_file *file, struct lima_submit *submit);
 int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns);
 int lima_gem_get_modifier(struct drm_file *file, u32 handle, u64 *modifier);
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index 58fb274..3a1b25f 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -9,6 +9,7 @@
 #include "lima_vm.h"
 #include "lima_mmu.h"
 #include "lima_l2_cache.h"
+#include "lima_object.h"
 
 struct lima_fence {
 	struct dma_fence base;
@@ -120,6 +121,7 @@ int lima_sched_task_init(struct lima_sched_task *task,
 
 void lima_sched_task_fini(struct lima_sched_task *task)
 {
+	lima_vm_put(task->vm);
 	drm_sched_job_cleanup(&task->base);
 }
 
@@ -162,82 +164,28 @@ int lima_sched_context_init(struct lima_sched_pipe *pipe,
 			    atomic_t *guilty)
 {
 	struct drm_sched_rq *rq = pipe->base.sched_rq + DRM_SCHED_PRIORITY_NORMAL;
-	int err;
 
-	context->fences =
-		kzalloc(sizeof(*context->fences) * lima_sched_max_tasks, GFP_KERNEL);
-	if (!context->fences)
-		return -ENOMEM;
-
-	mutex_init(&context->lock);
-	err = drm_sched_entity_init(&context->base, &rq, 1, guilty);
-	if (err) {
-		kfree(context->fences);
-		context->fences = NULL;
-		return err;
-	}
-
-	return 0;
+	return drm_sched_entity_init(&context->base, &rq, 1, guilty);
 }
 
 void lima_sched_context_fini(struct lima_sched_pipe *pipe,
 			     struct lima_sched_context *context)
 {
 	drm_sched_entity_fini(&context->base);
-
-	mutex_destroy(&context->lock);
-
-	if (context->fences) {
-		int i;
-		for (i = 0; i < lima_sched_max_tasks; i++)
-			dma_fence_put(context->fences[i]);
-		kfree(context->fences);
-	}
-}
-
-static uint32_t lima_sched_context_add_fence(struct lima_sched_context *context,
-					     struct dma_fence *fence)
-{
-	uint32_t seq, idx, i;
-	struct dma_fence *other;
-
-	mutex_lock(&context->lock);
-
-	seq = context->sequence;
-	idx = seq & (lima_sched_max_tasks - 1);
-	other = context->fences[idx];
-
-	if (other) {
-		int err = dma_fence_wait(other, false);
-		if (err)
-			DRM_ERROR("Error %d waiting context fence\n", err);
-	}
-
-	context->fences[idx] = dma_fence_get(fence);
-	context->sequence++;
-
-	/* get finished fence offset from seq */
-	for (i = 1; i < lima_sched_max_tasks; i++) {
-		idx = (seq - i) & (lima_sched_max_tasks - 1);
-		if (!context->fences[idx] ||
-		    dma_fence_is_signaled(context->fences[idx]))
-			break;
-	}
-
-	mutex_unlock(&context->lock);
-
-	dma_fence_put(other);
-
-	return i;
 }
 
 struct dma_fence *lima_sched_context_queue_task(struct lima_sched_context *context,
 						struct lima_sched_task *task,
-						uint32_t *done)
+						struct lima_bo **bos, int nr_bos)
 {
 	struct dma_fence *fence = dma_fence_get(&task->base.s_fence->finished);
+	int i;
+
+	task->bos = bos;
+	task->num_bos = nr_bos;
 
-	*done = lima_sched_context_add_fence(context, fence);
+	for (i = 0; i < nr_bos; i++)
+		lima_vm_bo_add(task->vm, bos[i]);
 
 	drm_sched_entity_push_job(&task->base, &context->base);
 	return fence;
@@ -370,8 +318,15 @@ static void lima_sched_free_job(struct drm_sched_job *job)
 {
 	struct lima_sched_task *task = to_lima_task(job);
 	struct lima_sched_pipe *pipe = to_lima_pipe(job->sched);
+	struct lima_vm *vm = task->vm;
+	struct lima_bo **bos = task->bos;
 	int i;
 
+	LIST_HEAD(list);
+	struct ttm_validate_buffer tv_bo, tv_pd;
+	struct ww_acquire_ctx ticket;
+	int err;
+
 	drm_sched_job_cleanup(job);
 
 	dma_fence_put(task->fence);
@@ -384,7 +339,29 @@ static void lima_sched_free_job(struct drm_sched_job *job)
 	if (task->dep)
 		kfree(task->dep);
 
-	lima_vm_put(task->vm);
+	tv_pd.bo = &vm->pd->tbo;
+	tv_pd.num_shared = 0;
+	list_add(&tv_pd.head, &list);
+	list_add(&tv_bo.head, &list);
+
+	for (i = 0; i < task->num_bos; i++) {
+		tv_bo.bo = &bos[i]->tbo;
+		tv_bo.num_shared = 0;
+
+		err = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
+		if (!err) {
+			lima_vm_bo_del(vm, bos[i]);
+			ttm_eu_backoff_reservation(&ticket, &list);
+		}
+		else
+			dev_err(vm->dev->dev, "leeking bo va because we "
+				"fail to reserve bo (%d)\n", err);
+
+		drm_gem_object_put_unlocked(&bos[i]->gem);
+	}
+
+	kfree(bos);
+	lima_vm_put(vm);
 	kmem_cache_free(pipe->task_slab, task);
 }
 
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index 533dbfb..fe4250c 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -18,15 +18,15 @@ struct lima_sched_task {
 	int num_dep;
 	int max_dep;
 
+	struct lima_bo **bos;
+	int num_bos;
+
 	/* pipe fence */
 	struct dma_fence *fence;
 };
 
 struct lima_sched_context {
 	struct drm_sched_entity base;
-	struct mutex lock;
-	struct dma_fence **fences;
-	uint32_t sequence;
 };
 
 #define LIMA_SCHED_PIPE_MAX_MMU       8
@@ -86,7 +86,7 @@ void lima_sched_context_fini(struct lima_sched_pipe *pipe,
 			     struct lima_sched_context *context);
 struct dma_fence *lima_sched_context_queue_task(struct lima_sched_context *context,
 						struct lima_sched_task *task,
-						uint32_t *done);
+						struct lima_bo **bos, int nr_bos);
 
 int lima_sched_pipe_init(struct lima_sched_pipe *pipe, const char *name);
 void lima_sched_pipe_fini(struct lima_sched_pipe *pipe);
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
index a264f3a..1710409 100644
--- a/drivers/gpu/drm/lima/lima_vm.c
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -3,26 +3,17 @@
 
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
-#include <linux/interval_tree_generic.h>
 
 #include "lima_device.h"
 #include "lima_vm.h"
 #include "lima_object.h"
 #include "lima_regs.h"
 
-struct lima_bo_va_mapping {
-	struct list_head list;
-	struct rb_node rb;
-	uint32_t start;
-	uint32_t last;
-	uint32_t __subtree_last;
-};
-
 struct lima_bo_va {
 	struct list_head list;
 	unsigned ref_count;
 
-	struct list_head mapping;
+	struct drm_mm_node node;
 
 	struct lima_vm *vm;
 };
@@ -40,14 +31,6 @@ struct lima_bo_va {
 #define LIMA_PBE(va) (va >> LIMA_VM_PB_SHIFT)
 #define LIMA_BTE(va) ((va & LIMA_VM_BT_MASK) >> LIMA_VM_BT_SHIFT)
 
-#define START(node) ((node)->start)
-#define LAST(node) ((node)->last)
-
-INTERVAL_TREE_DEFINE(struct lima_bo_va_mapping, rb, uint32_t, __subtree_last,
-		     START, LAST, static, lima_vm_it)
-
-#undef START
-#undef LAST
 
 static void lima_vm_unmap_page_table(struct lima_vm *vm, u32 start, u32 end)
 {
@@ -133,71 +116,11 @@ lima_vm_bo_find(struct lima_vm *vm, struct lima_bo *bo)
 	return ret;
 }
 
-int lima_vm_bo_map(struct lima_vm *vm, struct lima_bo *bo, u32 start)
-{
-	int err;
-	struct lima_bo_va_mapping *it, *mapping;
-	u32 end = start + bo->gem.size - 1;
-	dma_addr_t *pages_dma = lima_bo_get_pages(bo);
-	struct lima_bo_va *bo_va;
-
-	it = lima_vm_it_iter_first(&vm->va, start, end);
-	if (it) {
-		dev_dbg(bo->gem.dev->dev, "lima vm map va overlap %x-%x %x-%x\n",
-			start, end, it->start, it->last);
-		return -EINVAL;
-	}
-
-	mapping = kmalloc(sizeof(*mapping), GFP_KERNEL);
-	if (!mapping)
-		return -ENOMEM;
-	mapping->start = start;
-	mapping->last = end;
-
-	err = lima_vm_map_page_table(vm, pages_dma, start, end);
-	if (err) {
-		kfree(mapping);
-		return err;
-	}
-
-	lima_vm_it_insert(mapping, &vm->va);
-
-	bo_va = lima_vm_bo_find(vm, bo);
-	list_add_tail(&mapping->list, &bo_va->mapping);
-
-	return 0;
-}
-
-static void lima_vm_unmap(struct lima_vm *vm,
-			  struct lima_bo_va_mapping *mapping)
-{
-	lima_vm_it_remove(mapping, &vm->va);
-
-	lima_vm_unmap_page_table(vm, mapping->start, mapping->last);
-
-	list_del(&mapping->list);
-	kfree(mapping);
-}
-
-int lima_vm_bo_unmap(struct lima_vm *vm, struct lima_bo *bo, u32 start)
-{
-	struct lima_bo_va *bo_va;
-	struct lima_bo_va_mapping *mapping;
-
-	bo_va = lima_vm_bo_find(vm, bo);
-	list_for_each_entry(mapping, &bo_va->mapping, list) {
-		if (mapping->start == start) {
-		        lima_vm_unmap(vm, mapping);
-			break;
-		}
-	}
-
-	return 0;
-}
-
 int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo)
 {
 	struct lima_bo_va *bo_va;
+	dma_addr_t *pages_dma;
+	int err;
 
 	bo_va = lima_vm_bo_find(vm, bo);
 	if (bo_va) {
@@ -205,66 +128,60 @@ int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo)
 		return 0;
 	}
 
-	bo_va = kmalloc(sizeof(*bo_va), GFP_KERNEL);
+	bo_va = kzalloc(sizeof(*bo_va), GFP_KERNEL);
 	if (!bo_va)
 		return -ENOMEM;
 
 	bo_va->vm = vm;
 	bo_va->ref_count = 1;
-	INIT_LIST_HEAD(&bo_va->mapping);
-	list_add_tail(&bo_va->list, &bo->va);
-	return 0;
-}
 
-/* wait only fence of resv from task using vm */
-static int lima_vm_wait_resv(struct lima_vm *vm,
-			     struct reservation_object *resv)
-{
-	unsigned nr_fences;
-	struct dma_fence **fences;
-	int i;
-	long err;
+	err = drm_mm_insert_node(&vm->mm, &bo_va->node, bo->gem.size);
+	if (err)
+		goto err_out0;
 
-	err = reservation_object_get_fences_rcu(resv, NULL, &nr_fences, &fences);
-	if (err || !nr_fences)
-		return err;
+	pages_dma = lima_bo_get_pages(bo);
+	err = lima_vm_map_page_table(vm, pages_dma, bo_va->node.start,
+				     bo_va->node.start + bo_va->node.size - 1);
+	if (err)
+	        goto err_out1;
 
-	for (i = 0; i < nr_fences; i++) {
-		struct drm_sched_fence *sf = to_drm_sched_fence(fences[i]);
-		if (sf && sf->owner == vm)
-			err |= dma_fence_wait(fences[i], false);
-		dma_fence_put(fences[i]);
-	}
+	list_add_tail(&bo_va->list, &bo->va);
+	return 0;
 
-	kfree(fences);
+err_out1:
+	drm_mm_remove_node(&bo_va->node);
+err_out0:
+	kfree(bo_va);
 	return err;
 }
 
 int lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo)
 {
 	struct lima_bo_va *bo_va;
-	struct lima_bo_va_mapping *mapping, *tmp;
-	int err;
 
 	bo_va = lima_vm_bo_find(vm, bo);
 	if (--bo_va->ref_count > 0)
 		return 0;
 
-	/* wait bo idle before unmap it from vm in case user
-	 * space application is terminated when bo is busy.
-	 */
-	err = lima_vm_wait_resv(vm, bo->tbo.resv);
-	if (err)
-		dev_err(vm->dev->dev, "bo del fail to wait (%d)\n", err);
+	lima_vm_unmap_page_table(vm, bo_va->node.start,
+				 bo_va->node.start + bo_va->node.size - 1);
+
+        drm_mm_remove_node(&bo_va->node);
 
-	list_for_each_entry_safe(mapping, tmp, &bo_va->mapping, list) {
-	        lima_vm_unmap(vm, mapping);
-	}
 	list_del(&bo_va->list);
 	kfree(bo_va);
 	return 0;
 }
 
+u32 lima_vm_get_va(struct lima_vm *vm, struct lima_bo *bo)
+{
+	struct lima_bo_va *bo_va;
+
+	bo_va = lima_vm_bo_find(vm, bo);
+	BUG_ON(!bo_va);
+	return bo_va->node.start;
+}
+
 struct lima_vm *lima_vm_create(struct lima_device *dev)
 {
 	struct lima_vm *vm;
@@ -275,7 +192,6 @@ struct lima_vm *lima_vm_create(struct lima_device *dev)
 		return NULL;
 
 	vm->dev = dev;
-	vm->va = RB_ROOT_CACHED;
 	kref_init(&vm->refcount);
 
 	vm->pd = lima_bo_create(dev, LIMA_PAGE_SIZE, 0,
@@ -296,6 +212,8 @@ struct lima_vm *lima_vm_create(struct lima_device *dev)
 			goto err_out1;
 	}
 
+	drm_mm_init(&vm->mm, dev->va_start, dev->va_end - dev->va_start);
+
 	return vm;
 
 err_out1:
@@ -308,12 +226,9 @@ struct lima_vm *lima_vm_create(struct lima_device *dev)
 void lima_vm_release(struct kref *kref)
 {
 	struct lima_vm *vm = container_of(kref, struct lima_vm, refcount);
-	struct lima_device *dev = vm->dev;
 	int i;
 
-	if (!RB_EMPTY_ROOT(&vm->va.rb_root)) {
-		dev_err(dev->dev, "still active bo inside vm\n");
-	}
+	drm_mm_takedown(&vm->mm);
 
 	for (i = 0; i < LIMA_VM_NUM_BT; i++) {
 		if (vm->bts[i])
@@ -331,9 +246,6 @@ void lima_vm_print(struct lima_vm *vm)
 	int i, j, k;
 	u32 *pd, *pt;
 
-	/* to avoid the defined by not used warning */
-	(void)&lima_vm_it_iter_next;
-
 	pd = lima_bo_kmap(vm->pd);
 	for (i = 0; i < LIMA_VM_NUM_BT; i++) {
 		if (!vm->bts[i])
diff --git a/drivers/gpu/drm/lima/lima_vm.h b/drivers/gpu/drm/lima/lima_vm.h
index f615f8d..93650bd 100644
--- a/drivers/gpu/drm/lima/lima_vm.h
+++ b/drivers/gpu/drm/lima/lima_vm.h
@@ -4,7 +4,7 @@
 #ifndef __LIMA_VM_H__
 #define __LIMA_VM_H__
 
-#include <linux/rbtree.h>
+#include <drm/drm_mm.h>
 #include <linux/kref.h>
 
 #define LIMA_PAGE_SIZE    4096
@@ -25,8 +25,7 @@ struct lima_device;
 struct lima_vm {
 	struct kref refcount;
 
-	/* tree of virtual addresses mapped */
-	struct rb_root_cached va;
+	struct drm_mm mm;
 
 	struct lima_device *dev;
 
@@ -34,12 +33,11 @@ struct lima_vm {
 	struct lima_bo *bts[LIMA_VM_NUM_BT];
 };
 
-int lima_vm_bo_map(struct lima_vm *vm, struct lima_bo *bo, u32 start);
-int lima_vm_bo_unmap(struct lima_vm *vm, struct lima_bo *bo, u32 start);
-
 int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo);
 int lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo);
 
+u32 lima_vm_get_va(struct lima_vm *vm, struct lima_bo *bo);
+
 struct lima_vm *lima_vm_create(struct lima_device *dev);
 void lima_vm_release(struct kref *kref);
 
diff --git a/include/uapi/drm/lima_drm.h b/include/uapi/drm/lima_drm.h
index b5f02dd..94704d4 100644
--- a/include/uapi/drm/lima_drm.h
+++ b/include/uapi/drm/lima_drm.h
@@ -16,8 +16,6 @@ extern "C" {
 struct drm_lima_info {
 	__u32 gpu_id;   /* out */
 	__u32 num_pp;   /* out */
-	__u64 va_start; /* out */
-	__u64 va_end;   /* out */
 };
 
 struct drm_lima_gem_create {
@@ -29,20 +27,10 @@ struct drm_lima_gem_create {
 
 struct drm_lima_gem_info {
 	__u32 handle;  /* in */
-	__u32 pad;
+	__u32 va;      /* out */
 	__u64 offset;  /* out */
 };
 
-#define LIMA_VA_OP_MAP    1
-#define LIMA_VA_OP_UNMAP  2
-
-struct drm_lima_gem_va {
-	__u32 handle;  /* in */
-	__u32 op;      /* in */
-	__u32 flags;   /* in */
-	__u32 va;      /* in */
-};
-
 #define LIMA_SUBMIT_BO_READ   0x01
 #define LIMA_SUBMIT_BO_WRITE  0x02
 
@@ -96,8 +84,6 @@ struct drm_lima_gem_submit {
 	__u32 flags;       /* in */
 	__u32 out_sync;    /* in */
 	__u32 in_sync[2];  /* in */
-	__u32 done;        /* out */
-	__u32 _pad;
 };
 
 #define LIMA_GEM_WAIT_READ   0x01
@@ -129,16 +115,14 @@ struct drm_lima_gem_mod {
 #define DRM_LIMA_INFO        0x00
 #define DRM_LIMA_GEM_CREATE  0x01
 #define DRM_LIMA_GEM_INFO    0x02
-#define DRM_LIMA_GEM_VA      0x03
-#define DRM_LIMA_GEM_SUBMIT  0x04
-#define DRM_LIMA_GEM_WAIT    0x05
-#define DRM_LIMA_CTX         0x06
-#define DRM_LIMA_GEM_MOD     0x07
+#define DRM_LIMA_GEM_SUBMIT  0x03
+#define DRM_LIMA_GEM_WAIT    0x04
+#define DRM_LIMA_CTX         0x05
+#define DRM_LIMA_GEM_MOD     0x06
 
 #define DRM_IOCTL_LIMA_INFO DRM_IOR(DRM_COMMAND_BASE + DRM_LIMA_INFO, struct drm_lima_info)
 #define DRM_IOCTL_LIMA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_CREATE, struct drm_lima_gem_create)
 #define DRM_IOCTL_LIMA_GEM_INFO DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_INFO, struct drm_lima_gem_info)
-#define DRM_IOCTL_LIMA_GEM_VA DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_GEM_VA, struct drm_lima_gem_va)
 #define DRM_IOCTL_LIMA_GEM_SUBMIT DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_SUBMIT, struct drm_lima_gem_submit)
 #define DRM_IOCTL_LIMA_GEM_WAIT DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_GEM_WAIT, struct drm_lima_gem_wait)
 #define DRM_IOCTL_LIMA_CTX DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_CTX, struct drm_lima_ctx)
-- 
2.7.1

