
Move the extra bytes calculation that are needed for H264
motion vector to a helper. This is just a cosmetic cleanup.

Signed-off-by: Ezequiel Garcia <ezequiel@collabora.com>
---
 drivers/staging/media/hantro/hantro.h      |  4 ---
 drivers/staging/media/hantro/hantro_hw.h   | 31 ++++++++++++++++++++++
 drivers/staging/media/hantro/hantro_v4l2.c | 25 ++---------------
 3 files changed, 33 insertions(+), 27 deletions(-)

diff -Naur linux-5.6-rc5-old/drivers/staging/media/hantro/hantro.h linux-5.6-rc5-new/drivers/staging/media/hantro/hantro.h
--- linux-5.6-rc5-old/drivers/staging/media/hantro/hantro.h	2020-03-09 01:44:44.000000000 +0100
+++ linux-5.6-rc5-new/drivers/staging/media/hantro/hantro.h	2020-03-13 18:44:20.483333301 +0100
@@ -26,10 +26,6 @@
 
 #include "hantro_hw.h"
 
-#define MB_DIM			16
-#define MB_WIDTH(w)		DIV_ROUND_UP(w, MB_DIM)
-#define MB_HEIGHT(h)		DIV_ROUND_UP(h, MB_DIM)
-
 struct hantro_ctx;
 struct hantro_codec_ops;
 
diff -Naur linux-5.6-rc5-old/drivers/staging/media/hantro/hantro_hw.h linux-5.6-rc5-new/drivers/staging/media/hantro/hantro_hw.h
--- linux-5.6-rc5-old/drivers/staging/media/hantro/hantro_hw.h	2020-03-09 01:44:44.000000000 +0100
+++ linux-5.6-rc5-new/drivers/staging/media/hantro/hantro_hw.h	2020-03-13 18:44:20.486666634 +0100
@@ -18,6 +18,10 @@
 
 #define DEC_8190_ALIGN_MASK	0x07U
 
+#define MB_DIM			16
+#define MB_WIDTH(w)		DIV_ROUND_UP(w, MB_DIM)
+#define MB_HEIGHT(h)		DIV_ROUND_UP(h, MB_DIM)
+
 struct hantro_dev;
 struct hantro_ctx;
 struct hantro_buf;
@@ -175,6 +179,33 @@
 int hantro_h264_dec_init(struct hantro_ctx *ctx);
 void hantro_h264_dec_exit(struct hantro_ctx *ctx);
 
+static inline size_t
+hantro_h264_mv_size(unsigned int width, unsigned int height)
+{
+	/*
+	 * A decoded 8-bit 4:2:0 NV12 frame may need memory for up to
+	 * 448 bytes per macroblock with additional 32 bytes on
+	 * multi-core variants.
+	 *
+	 * The H264 decoder needs extra space on the output buffers
+	 * to store motion vectors. This is needed for reference
+	 * frames and only if the format is non-post-processed NV12.
+	 *
+	 * Memory layout is as follow:
+	 *
+	 * +---------------------------+
+	 * | Y-plane   256 bytes x MBs |
+	 * +---------------------------+
+	 * | UV-plane  128 bytes x MBs |
+	 * +---------------------------+
+	 * | MV buffer  64 bytes x MBs |
+	 * +---------------------------+
+	 * | MC sync          32 bytes |
+	 * +---------------------------+
+	 */
+	return 64 * MB_WIDTH(width) * MB_WIDTH(height) + 32;
+}
+
 void hantro_g1_mpeg2_dec_run(struct hantro_ctx *ctx);
 void rk3399_vpu_mpeg2_dec_run(struct hantro_ctx *ctx);
 void hantro_mpeg2_dec_copy_qtable(u8 *qtable,
diff -Naur linux-5.6-rc5-old/drivers/staging/media/hantro/hantro_v4l2.c linux-5.6-rc5-new/drivers/staging/media/hantro/hantro_v4l2.c
--- linux-5.6-rc5-old/drivers/staging/media/hantro/hantro_v4l2.c	2020-03-13 18:43:14.250000000 +0100
+++ linux-5.6-rc5-new/drivers/staging/media/hantro/hantro_v4l2.c	2020-03-13 18:45:44.289999997 +0100
@@ -297,8 +297,8 @@
 		if (ctx->vpu_src_fmt->fourcc == V4L2_PIX_FMT_H264_SLICE &&
 		    !hantro_needs_postproc(ctx, ctx->vpu_dst_fmt))
 			pix_mp->plane_fmt[0].sizeimage +=
-				64 * MB_WIDTH(pix_mp->width) *
-				     MB_WIDTH(pix_mp->height) + 32;
+				hantro_h264_mv_size(pix_mp->width,
+						    pix_mp->height);
 	} else if (!pix_mp->plane_fmt[0].sizeimage) {
 		/*
 		 * For coded formats the application can specify
