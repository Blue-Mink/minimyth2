From 1dfdf0d5ec43775ecf0dd3d413656d503906d868 Mon Sep 17 00:00:00 2001
From: Ondrej Jirman <megous@megous.com>
Date: Tue, 25 Jun 2019 05:54:37 +0200
Subject: [PATCH 23/39] Fix reboot issue with ethernet on Orange Pi 3

We disable phy regulators before reboot, so that they are in a
known state on the next boot.

Signed-off-by: Ondrej Jirman <megous@megous.com>
---
 .../boot/dts/allwinner/sun50i-h6-orangepi-3.dts    |  5 +-
 drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c  | 61 ++++++++++++++++++++--
 2 files changed, 61 insertions(+), 5 deletions(-)

diff --git a/arch/arm64/boot/dts/allwinner/sun50i-h6-orangepi-3.dts b/arch/arm64/boot/dts/allwinner/sun50i-h6-orangepi-3.dts
index 7b5c03a..c9eff34 100644
--- a/arch/arm64/boot/dts/allwinner/sun50i-h6-orangepi-3.dts
+++ b/arch/arm64/boot/dts/allwinner/sun50i-h6-orangepi-3.dts
@@ -89,7 +89,7 @@
 		regulator-name = "gmac-2v5";
 		regulator-min-microvolt = <2500000>;
 		regulator-max-microvolt = <2500000>;
-		startup-delay-us = <100000>;
+		//startup-delay-us = <100000>;
 		enable-active-high;
 		gpio = <&pio 3 6 GPIO_ACTIVE_HIGH>; /* PD6 */
 
@@ -97,7 +97,7 @@
 		 * enable two regulators to power the phy. This is one way
 		 * to achieve that.
 		 */
-		vin-supply = <&reg_aldo2>; /* GMAC-3V */
+		//vin-supply = <&reg_aldo2>; /* GMAC-3V */
 	};
 
 	wifi_pwrseq: wifi_pwrseq {
@@ -135,6 +135,7 @@
 	phy-mode = "rgmii";
 	phy-handle = <&ext_rgmii_phy>;
 	phy-supply = <&reg_gmac_2v5>;
+	phy2-supply = <&reg_aldo2>;
 	allwinner,rx-delay-ps = <1500>;
 	allwinner,tx-delay-ps = <700>;
 	status = "okay";
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
index 4083019..7cb4092 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
@@ -17,6 +17,7 @@
 #include <linux/phy.h>
 #include <linux/platform_device.h>
 #include <linux/regulator/consumer.h>
+#include <linux/reboot.h>
 #include <linux/regmap.h>
 #include <linux/stmmac.h>
 
@@ -60,6 +61,7 @@ struct emac_variant {
  * @tx_clk:	reference to MAC TX clock
  * @ephy_clk:	reference to the optional EPHY clock for the internal PHY
  * @regulator:	reference to the optional regulator
+ * @regulator2:	reference to the optional regulator2
  * @rst_ephy:	reference to the optional EPHY reset for the internal PHY
  * @variant:	reference to the current board variant
  * @regmap:	regmap for using the syscon
@@ -70,11 +72,13 @@ struct sunxi_priv_data {
 	struct clk *tx_clk;
 	struct clk *ephy_clk;
 	struct regulator *regulator;
+	struct regulator *regulator2;
 	struct reset_control *rst_ephy;
 	const struct emac_variant *variant;
 	struct regmap_field *regmap_field;
 	bool internal_phy_powered;
 	void *mux_handle;
+	struct notifier_block reboot_nb;
 };
 
 /* EMAC clock register @ 0x30 in the "system control" address range */
@@ -536,15 +540,33 @@ static int sun8i_dwmac_init(struct platform_device *pdev, void *priv)
 		}
 	}
 
+	if (gmac->regulator2) {
+		ret = regulator_enable(gmac->regulator2);
+		if (ret) {
+			dev_err(&pdev->dev, "Fail to enable regulator2\n");
+			goto err_disable_regulator;
+		}
+	}
+
 	ret = clk_prepare_enable(gmac->tx_clk);
 	if (ret) {
-		if (gmac->regulator)
-			regulator_disable(gmac->regulator);
 		dev_err(&pdev->dev, "Could not enable AHB clock\n");
-		return ret;
+		goto err_disable_regulator2;
 	}
 
+	msleep(100);
+
 	return 0;
+
+err_disable_regulator:
+	if (gmac->regulator)
+		regulator_disable(gmac->regulator);
+
+err_disable_regulator2:
+	if (gmac->regulator2)
+		regulator_disable(gmac->regulator2);
+
+	return ret;
 }
 
 static void sun8i_dwmac_core_init(struct mac_device_info *hw,
@@ -994,6 +1016,9 @@ static void sun8i_dwmac_exit(struct platform_device *pdev, void *priv)
 
 	if (gmac->regulator)
 		regulator_disable(gmac->regulator);
+
+	if (gmac->regulator2)
+		regulator_disable(gmac->regulator2);
 }
 
 static void sun8i_dwmac_set_mac_loopback(void __iomem *ioaddr, bool enable)
@@ -1093,6 +1118,20 @@ static struct regmap *sun8i_dwmac_get_syscon_from_dev(struct device_node *node)
 	return regmap;
 }
 
+
+static int sun8i_dwmac_reboot_notifier(struct notifier_block *nb, unsigned long action, void *data)
+{
+	struct sunxi_priv_data *gmac = container_of(nb, struct sunxi_priv_data, reboot_nb);
+
+	if (gmac->regulator)
+		regulator_disable(gmac->regulator);
+
+	if (gmac->regulator2)
+		regulator_disable(gmac->regulator2);
+	
+	return NOTIFY_DONE;
+}
+
 static int sun8i_dwmac_probe(struct platform_device *pdev)
 {
 	struct plat_stmmacenet_data *plat_dat;
@@ -1137,6 +1176,22 @@ static int sun8i_dwmac_probe(struct platform_device *pdev)
 		gmac->regulator = NULL;
 	}
 
+	/* Optional regulator2 for PHY */
+	gmac->regulator2 = devm_regulator_get_optional(dev, "phy2");
+	if (IS_ERR(gmac->regulator2)) {
+		if (PTR_ERR(gmac->regulator2) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+		dev_info(dev, "No regulator2 found\n");
+		gmac->regulator2 = NULL;
+	}
+
+	gmac->reboot_nb.notifier_call = sun8i_dwmac_reboot_notifier;
+	ret = devm_register_reboot_notifier(dev, &gmac->reboot_nb);
+	if (ret) {
+		dev_err(dev, "Failed to register reboot notifier (%d)\n", ret);
+		return ret;
+	}
+
 	/* The "GMAC clock control" register might be located in the
 	 * CCU address range (on the R40), or the system control address
 	 * range (on most other sun8i and later SoCs).
-- 
2.7.1

