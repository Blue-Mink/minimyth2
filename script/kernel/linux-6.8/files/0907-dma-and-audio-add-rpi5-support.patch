From 02d22724cb938dc17403116e6b16488a78aa25c5 Mon Sep 17 00:00:00 2001
From: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date: Mon, 26 Feb 2024 19:01:25 +0000
Subject: [PATCH] Revert "Revert "drm/vc4: Use phys addresses for slave DMA
 config""

This reverts commit 83336df375180dc05c395271a336ba3ed131a72b.
---
 drivers/gpu/drm/vc4/vc4_hdmi.c | 13 ++++---------
 1 file changed, 4 insertions(+), 9 deletions(-)

diff --git a/drivers/gpu/drm/vc4/vc4_hdmi.c b/drivers/gpu/drm/vc4/vc4_hdmi.c
index d05598ac9a6b6..2f2e194e7e8ee 100644
--- a/drivers/gpu/drm/vc4/vc4_hdmi.c
+++ b/drivers/gpu/drm/vc4/vc4_hdmi.c
@@ -2716,7 +2716,7 @@ static int vc4_hdmi_audio_init(struct vc4_hdmi *vc4_hdmi)
 	struct snd_soc_card *card = &vc4_hdmi->audio.card;
 	struct device *dev = &vc4_hdmi->pdev->dev;
 	struct platform_device *codec_pdev;
-	const __be32 *addr;
+	struct resource *iomem;
 	int index, len;
 	int ret;
 
@@ -2752,20 +2752,15 @@ static int vc4_hdmi_audio_init(struct vc4_hdmi *vc4_hdmi)
 	}
 
 	/*
-	 * Get the physical address of VC4_HD_MAI_DATA. We need to retrieve
-	 * the bus address specified in the DT, because the physical address
-	 * (the one returned by platform_get_resource()) is not appropriate
-	 * for DMA transfers.
-	 * This VC/MMU should probably be exposed to avoid this kind of hacks.
+	 * Get the physical address of VC4_HD_MAI_DATA.
 	 */
 	index = of_property_match_string(dev->of_node, "reg-names", "hd");
 	/* Before BCM2711, we don't have a named register range */
 	if (index < 0)
 		index = 1;
+	iomem = platform_get_resource(vc4_hdmi->pdev, IORESOURCE_MEM, index);
 
-	addr = of_get_address(dev->of_node, index, NULL, NULL);
-
-	vc4_hdmi->audio.dma_data.addr = be32_to_cpup(addr) + mai_data->offset;
+	vc4_hdmi->audio.dma_data.addr = iomem->start + mai_data->offset;
 	vc4_hdmi->audio.dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
 	vc4_hdmi->audio.dma_data.maxburst = 2;
 
From d4636a0f172ee033842e2f7af54e65e68df7695a Mon Sep 17 00:00:00 2001
From: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date: Tue, 27 Feb 2024 12:31:31 +0000
Subject: [PATCH] HACK: bcm2835-dma: Use phys_to_dma to get addresses

Requires the relevant DT updates
---
 drivers/dma/bcm2835-dma.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/drivers/dma/bcm2835-dma.c b/drivers/dma/bcm2835-dma.c
index aa59126d8423c..e03662454a6b9 100644
--- a/drivers/dma/bcm2835-dma.c
+++ b/drivers/dma/bcm2835-dma.c
@@ -18,6 +18,7 @@
  *	Copyright 2012 Marvell International Ltd.
  */
 #include <linux/dmaengine.h>
+#include <linux/dma-direct.h>
 #include <linux/dma-mapping.h>
 #include <linux/dmapool.h>
 #include <linux/err.h>
@@ -1131,11 +1132,11 @@ static struct dma_async_tx_descriptor *bcm2835_dma_prep_slave_sg(
 	if (direction == DMA_DEV_TO_MEM) {
 		if (c->cfg.src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		src = cfg->addr_offset + c->cfg.src_addr;
+		src = phys_to_dma(chan->device->dev, c->cfg.src_addr);
 	} else {
 		if (c->cfg.dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		dst = cfg->addr_offset + c->cfg.dst_addr;
+		dst = phys_to_dma(chan->device->dev, c->cfg.dst_addr);
 	}
 
 	/* count frames in sg list */
@@ -1193,12 +1194,12 @@ static struct dma_async_tx_descriptor *bcm2835_dma_prep_dma_cyclic(
 	if (direction == DMA_DEV_TO_MEM) {
 		if (c->cfg.src_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		src = cfg->addr_offset + c->cfg.src_addr;
+		src = phys_to_dma(chan->device->dev, c->cfg.src_addr);
 		dst = buf_addr;
 	} else {
 		if (c->cfg.dst_addr_width != DMA_SLAVE_BUSWIDTH_4_BYTES)
 			return NULL;
-		dst = cfg->addr_offset + c->cfg.dst_addr;
+		dst = phys_to_dma(chan->device->dev, c->cfg.dst_addr);
 		src = buf_addr;
 	}
 
From 604622b302d1a2ef0fdeac6811d209439a678cfc Mon Sep 17 00:00:00 2001
From: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date: Tue, 27 Feb 2024 12:45:00 +0000
Subject: [PATCH] Fixup 2711 40 bit DMA support

---
 drivers/dma/bcm2835-dma.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/drivers/dma/bcm2835-dma.c b/drivers/dma/bcm2835-dma.c
index e03662454a6b9..3aab49c0c40fb 100644
--- a/drivers/dma/bcm2835-dma.c
+++ b/drivers/dma/bcm2835-dma.c
@@ -524,6 +524,8 @@ static dma_addr_t bcm2835_dma_read_addr(struct bcm2835_chan *c,
 	return 0;
 }
 
+/* BCM2711 and BCM2712 DMA4 channels */
+
 static inline u32 bcm2711_dma_cb_get_length(void *data)
 {
 	struct bcm2711_dma40_scb *scb = data;
@@ -1358,7 +1360,7 @@ static const struct bcm2835_dma_cfg bcm2711_data = {
 	.chan_plat_init = bcm2711_dma_chan_plat_init,
 	.read_addr = bcm2711_dma_read_addr,
 
-	.dma_mask = DMA_BIT_MASK(36),
+	.dma_mask = DMA_BIT_MASK(40),
 };
 
 static const struct of_device_id bcm2835_dma_of_match[] = {
From a1060f8b707e10f61dd11406ac98e96394a69b9a Mon Sep 17 00:00:00 2001
From: Dave Stevenson <dave.stevenson@raspberrypi.com>
Date: Tue, 27 Feb 2024 12:46:09 +0000
Subject: [PATCH] WIP: dma: Add support for the 2712 DMA lite controllers

---
 drivers/dma/bcm2835-dma.c | 70 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 70 insertions(+)

diff --git a/drivers/dma/bcm2835-dma.c b/drivers/dma/bcm2835-dma.c
index 3aab49c0c40fb..f98afc1c4ec65 100644
--- a/drivers/dma/bcm2835-dma.c
+++ b/drivers/dma/bcm2835-dma.c
@@ -78,6 +78,16 @@ struct bcm2711_dma40_scb {
 	u32 pad;
 };
 
+struct bcm2712_lite_scb {
+	u32 info;
+	u32 src;
+	u32 dst;
+	u32 length;
+	u32 addr_high;
+	u32 next;
+	u32 pad[2];
+};
+
 struct bcm2835_cb_entry {
 	struct bcm_dma_cb *cb;
 	dma_addr_t paddr;
@@ -675,6 +685,65 @@ static void bcm2711_dma_cb_abort(struct dma_chan *chan)
 	       chan_base + BCM2711_DMA40_DEBUG);
 }
 
+/* BCM2712 Lite channels */
+
+static dma_addr_t
+bcm2712_lite_dma_cb_get_addr(void *data, enum dma_transfer_direction direction)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	if (direction == DMA_DEV_TO_MEM)
+		return (((dma_addr_t)cb->addr_high & 0xff00) << 24ULL) + cb->dst;
+
+	return (((dma_addr_t)cb->addr_high & 0xff) << 32ULL) + cb->src;
+}
+
+static void
+bcm2712_lite_dma_cb_init(void *data, struct bcm2835_chan *c,
+			 enum dma_transfer_direction direction, dma_addr_t src,
+			 dma_addr_t dst, bool zero_page)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->info = bcm2835_dma_prepare_cb_info(c, direction, zero_page);
+	cb->src = lower_32_bits(src);
+	cb->dst = lower_32_bits(dst);
+	cb->addr_high = (upper_32_bits(src) & 0xff) |
+			((upper_32_bits(dst) & 0xff) << 8);
+	cb->next = 0;
+}
+
+static void
+bcm2712_lite_dma_cb_set_src(void *data, enum dma_transfer_direction direction,
+			    dma_addr_t src)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->src = src;
+	cb->addr_high &= 0xff;
+	cb->addr_high |= upper_32_bits(src);
+}
+
+static void
+bcm2712_lite_dma_cb_set_dst(void *data, enum dma_transfer_direction direction,
+			    dma_addr_t dst)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->dst = dst;
+	cb->addr_high &= 0xff00;
+	cb->addr_high |= (upper_32_bits(dst) << 8);
+}
+
+static void bcm2712_lite_dma_cb_set_next(void *data, dma_addr_t next)
+{
+	struct bcm2712_lite_scb *cb = data;
+
+	cb->next = next;
+}
+
+/* Common functions */
+
 static void bcm2835_dma_free_cb_chain(struct bcm2835_desc *desc)
 {
 	size_t i;
@@ -1366,6 +1435,7 @@ static const struct bcm2835_dma_cfg bcm2711_data = {
 static const struct of_device_id bcm2835_dma_of_match[] = {
 	{ .compatible = "brcm,bcm2835-dma", .data = &bcm2835_data },
 	{ .compatible = "brcm,bcm2711-dma", .data = &bcm2711_data },
+	{ .compatible = "brcm,bcm2712-dma", .data = &bcm2711_data },
 	{},
 };
 MODULE_DEVICE_TABLE(of, bcm2835_dma_of_match);
