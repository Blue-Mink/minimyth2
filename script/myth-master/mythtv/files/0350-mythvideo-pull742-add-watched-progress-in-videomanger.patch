From 4b2abb7d5c6783e0f012097af87bc68e23e2d1d6 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Tue, 4 Apr 2023 16:20:05 +0200
Subject: [PATCH] Add support for MARK_TOTAL_FRAMES for videos

Extend ProgramInfo to load, delete and insert
MARK_TOTAL_FRAMES entries in filemarkup table.
This markup type can now be written by mythcommflag
when rebuilding the seektable for a video file.
This is in preparation to support displaying watched
progress within the video manager.
---
 mythtv/libs/libmythbase/programinfo.cpp | 216 +++++++++++++++++-------
 1 file changed, 158 insertions(+), 58 deletions(-)

diff --git a/mythtv/libs/libmythbase/programinfo.cpp b/mythtv/libs/libmythbase/programinfo.cpp
index 4d46b9d9f64..2fddcbe9ff5 100644
--- a/mythtv/libs/libmythbase/programinfo.cpp
+++ b/mythtv/libs/libmythbase/programinfo.cpp
@@ -4311,68 +4311,106 @@ void ProgramInfo::SaveVideoScanType(uint64_t frame, bool progressive)
 }
 
 
-/// \brief Store the Total Duration at frame 0 in the recordedmarkup table
-void ProgramInfo::SaveTotalDuration(std::chrono::milliseconds duration)
+static void delete_markup_datum(
+    MarkTypes type, uint chanid, const QDateTime &recstartts)
 {
-    if (!IsRecording())
-        return;
-
     MSqlQuery query(MSqlQuery::InitCon());
 
     query.prepare("DELETE FROM recordedmarkup "
-                  " WHERE chanid=:CHANID "
-                  " AND starttime=:STARTTIME "
-                  " AND type=:TYPE");
-    query.bindValue(":CHANID", m_chanId);
-    query.bindValue(":STARTTIME", m_recStartTs);
-    query.bindValue(":TYPE", MARK_DURATION_MS);
+                " WHERE chanid=:CHANID "
+                " AND starttime=:STARTTIME "
+                " AND type=:TYPE");
+    query.bindValue(":CHANID", chanid);
+    query.bindValue(":STARTTIME", recstartts);
+    query.bindValue(":TYPE", type);
 
     if (!query.exec())
-        MythDB::DBError("Duration delete", query);
+        MythDB::DBError("delete_markup_datum", query);
+}
 
-    query.prepare("INSERT INTO recordedmarkup"
-                  "    (chanid, starttime, mark, type, data)"
-                  "    VALUES"
-                  " ( :CHANID, :STARTTIME, 0, :TYPE, :DATA);");
-    query.bindValue(":CHANID", m_chanId);
-    query.bindValue(":STARTTIME", m_recStartTs);
-    query.bindValue(":TYPE", MARK_DURATION_MS);
-    query.bindValue(":DATA", (uint)(duration.count()));
+static void delete_markup_datum(
+    MarkTypes type, const QString &videoPath)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    query.prepare("DELETE FROM filemarkup"
+                " WHERE filename = :PATH "
+                " AND type = :TYPE ;");
+    query.bindValue(":PATH", videoPath);
+    query.bindValue(":TYPE", type);
 
     if (!query.exec())
-        MythDB::DBError("Duration insert", query);
+        MythDB::DBError("delete_markup_datum", query);
 }
 
-/// \brief Store the Total Frames at frame 0 in the recordedmarkup table
-void ProgramInfo::SaveTotalFrames(int64_t frames)
+static void insert_markup_datum(
+    MarkTypes type, uint mark, uint offset, const QString &videoPath)
 {
-    if (!IsRecording())
-        return;
-
     MSqlQuery query(MSqlQuery::InitCon());
 
-    query.prepare("DELETE FROM recordedmarkup "
-                  " WHERE chanid=:CHANID "
-                  " AND starttime=:STARTTIME "
-                  " AND type=:TYPE");
-    query.bindValue(":CHANID", m_chanId);
-    query.bindValue(":STARTTIME", m_recStartTs);
-    query.bindValue(":TYPE", MARK_TOTAL_FRAMES);
+    query.prepare("INSERT INTO filemarkup"
+                "   (filename, mark, type, `offset`)"
+                " VALUES"
+                "   ( :PATH , :MARK , :TYPE, :OFFSET );");
+    query.bindValue(":PATH", videoPath);
+    query.bindValue(":OFFSET", offset);
+    query.bindValue(":TYPE", type);
+    query.bindValue(":MARK", mark);
 
     if (!query.exec())
-        MythDB::DBError("Frames delete", query);
+        MythDB::DBError("insert_markup_datum", query);
+}
+
+static void insert_markup_datum(
+    MarkTypes type, uint mark, uint data, uint chanid, const QDateTime &recstartts)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
 
     query.prepare("INSERT INTO recordedmarkup"
-                  "    (chanid, starttime, mark, type, data)"
-                  "    VALUES"
-                  " ( :CHANID, :STARTTIME, 0, :TYPE, :DATA);");
-    query.bindValue(":CHANID", m_chanId);
-    query.bindValue(":STARTTIME", m_recStartTs);
-    query.bindValue(":TYPE", MARK_TOTAL_FRAMES);
-    query.bindValue(":DATA", (uint)(frames));
+                "    (chanid, starttime, mark, type, data)"
+                "    VALUES"
+                " ( :CHANID, :STARTTIME, :MARK, :TYPE, :DATA);");
+    query.bindValue(":CHANID", chanid);
+    query.bindValue(":STARTTIME", recstartts);
+    query.bindValue(":DATA", data);
+    query.bindValue(":TYPE", type);
+    query.bindValue(":MARK", mark);
 
     if (!query.exec())
-        MythDB::DBError("Total Frames insert", query);
+        MythDB::DBError("insert_markup_datum", query);
+}
+
+
+/// \brief Store the Total Duration at frame 0 in the recordedmarkup table
+void ProgramInfo::SaveTotalDuration(std::chrono::milliseconds duration)
+{
+    if (IsVideo())
+    {
+        auto videoPath = StorageGroup::GetRelativePathname(m_pathname);
+        delete_markup_datum(MARK_DURATION_MS, videoPath);
+        insert_markup_datum(MARK_DURATION_MS, 0, duration.count(), videoPath);
+    }
+    else if (IsRecording())
+    {
+        delete_markup_datum(MARK_DURATION_MS, m_chanId, m_recStartTs);
+        insert_markup_datum(MARK_DURATION_MS, 0, duration.count(), m_chanId, m_recStartTs);
+    }
+}
+
+/// \brief Store the Total Frames at frame 0 in the recordedmarkup table
+void ProgramInfo::SaveTotalFrames(int64_t frames)
+{
+    if (IsVideo())
+    {
+        auto videoPath = StorageGroup::GetRelativePathname(m_pathname);
+        delete_markup_datum(MARK_TOTAL_FRAMES, videoPath);
+        insert_markup_datum(MARK_TOTAL_FRAMES, 0, frames, videoPath);
+    }
+    else if (IsRecording())
+    {
+        delete_markup_datum(MARK_TOTAL_FRAMES, m_chanId, m_recStartTs);
+        insert_markup_datum(MARK_TOTAL_FRAMES, 0, frames, m_chanId, m_recStartTs);
+    }
 }
 
 /// \brief Store the Resolution at frame in the recordedmarkup table
@@ -4448,6 +4486,40 @@ static uint load_markup_datum(
     return (query.next()) ? query.value(0).toUInt() : 0;
 }
 
+static uint load_markup_datum(
+    MarkTypes type, const QString &videoPath)
+{
+    QString qstr = QString(
+        "SELECT filemarkup.`offset` "
+        "FROM filemarkup "
+        "WHERE filemarkup.filename  = :PATH    AND "
+        "      filemarkup.type      = :TYPE "
+        "GROUP BY filemarkup.`offset` "
+        "ORDER BY SUM( ( SELECT IFNULL(fm.mark, filemarkup.mark)"
+        "                FROM filemarkup AS fm "
+        "                WHERE fm.filename  = filemarkup.filename  AND "
+        "                      fm.type      = filemarkup.type      AND "
+        "                      fm.mark      > filemarkup.mark "
+        "                ORDER BY fm.mark ASC LIMIT 1 "
+        "              ) - filemarkup.mark "
+        "            ) DESC "
+        "LIMIT 1");
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(qstr);
+    query.bindValue(":TYPE", (int)type);
+    query.bindValue(":PATH", videoPath);
+
+    if (!query.exec())
+    {
+        MythDB::DBError("load_markup_datum", query);
+        return 0;
+    }
+
+    return (query.next()) ? query.value(0).toUInt() : 0;
+}
+
+
 /** \brief If present in recording this loads average height of the
  *         main video stream from database's stream markup table.
  *  \note Saves loaded value for future reference by GetHeight().
@@ -4555,8 +4627,20 @@ std::chrono::milliseconds ProgramInfo::QueryTotalDuration(void) const
  */
 int64_t ProgramInfo::QueryTotalFrames(void) const
 {
-    int64_t frames = load_markup_datum(MARK_TOTAL_FRAMES, m_chanId, m_recStartTs);
-    return frames;
+    if (IsVideo())
+    {
+        int64_t frames = load_markup_datum(MARK_TOTAL_FRAMES, StorageGroup::GetRelativePathname(m_pathname));
+        return frames;
+    }
+    else if (IsRecording())
+    {
+        int64_t frames = load_markup_datum(MARK_TOTAL_FRAMES, m_chanId, m_recStartTs);
+        return frames;
+    }
+    else
+    {
+        return 0;
+    }
 }
 
 void ProgramInfo::QueryMarkup(QVector<MarkupEntry> &mapMark,
@@ -6405,28 +6489,44 @@ void ProgramInfo::CalculateWatchedProgress(uint64_t pos)
     }
 
     uint64_t total = 0;
-    switch (m_recStatus)
+    if (IsVideo())
     {
-      case RecStatus::Recorded:
         total = std::max((int64_t)0, QueryTotalFrames());
-        break;
-      case RecStatus::Recording:
+    }
+    else if (IsRecording())
+    {
+        switch (m_recStatus)
         {
-            // Compute expected total frames based on frame rate.
-            int64_t rate1000 = QueryAverageFrameRate();
-            int64_t duration = m_recStartTs.secsTo(m_recEndTs);
-            total = rate1000 * duration / 1000;
+        case RecStatus::Recorded:
+            total = std::max((int64_t)0, QueryTotalFrames());
+            break;
+        case RecStatus::Recording:
+            {
+                // Compute expected total frames based on frame rate.
+                int64_t rate1000 = QueryAverageFrameRate();
+                int64_t duration = m_recStartTs.secsTo(m_recEndTs);
+                total = rate1000 * duration / 1000;
+            }
+            break;
+        default:
+            break;
         }
-        break;
-      default:
-        break;
     }
 
     if (total == 0)
     {
-        LOG(VB_GUI, LOG_DEBUG,
-            QString("%1 %2 no frame count. Please rebuild seek table for this recording.")
-            .arg(m_recordedId).arg(m_title));
+        if (IsVideo())
+        {
+            LOG(VB_GUI, LOG_DEBUG,
+                QString("%1 %2 no frame count. Please rebuild seek table for this video.")
+                .arg(m_pathname).arg(m_title));
+        }
+        else if (IsRecording())
+        {
+            LOG(VB_GUI, LOG_DEBUG,
+                QString("%1 %2 no frame count. Please rebuild seek table for this recording.")
+                .arg(m_recordedId).arg(m_title));
+        }
         m_watchedPercent = 0;
         return;
     }
From fa5a52d5920ce1dbaa41469954ad98f0072f742c Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Sun, 8 Oct 2023 13:57:23 +0200
Subject: [PATCH] Save total frame count for video files

When exiting the media player, check if the current
video file alreadey has a total frame count saved
within the filemarkup table. If it is not yet present,
then save the total frame count from the player.
This way the watched progress does not need extra
tooling to provide the total frame count of a video file.
---
 mythtv/libs/libmythtv/tv_play.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index 0e3e2a8ae73..28ab9292024 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -2724,6 +2724,17 @@ void TV::PrepareToExitPlayer(int Line)
             at_end = true;
         }
 
+        // Save total frames for video file if not already present
+        if (m_playerContext.m_playingInfo->IsVideoFile())
+        {
+            auto totalFrames = m_playerContext.m_playingInfo->QueryTotalFrames();
+            if (!totalFrames)
+            {
+                totalFrames = m_playerContext.m_player->GetCurrentFrameCount();
+                m_playerContext.m_playingInfo->SaveTotalFrames(totalFrames);
+            }
+        }
+
         // Clear/Save play position without notification
         // The change must be broadcast when file is no longer in use
         // to update previews, ie. with the MarkNotInUse notification
From 905777f0fb9873f17b23d1d7a6f8b9fdb4887d58 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Tue, 23 Jan 2024 23:05:41 +0100
Subject: [PATCH] Pull playback state for all videos from database

Query and cache playback state related data from
database so the watched progress can be shown for
multiple video list items.
---
 mythtv/programs/mythfrontend/mythfrontend.pro |   3 +
 .../programs/mythfrontend/playbackstate.cpp   | 118 ++++++++++++++++++
 mythtv/programs/mythfrontend/playbackstate.h  |  45 +++++++
 3 files changed, 166 insertions(+)
 create mode 100644 mythtv/programs/mythfrontend/playbackstate.cpp
 create mode 100644 mythtv/programs/mythfrontend/playbackstate.h

diff --git a/mythtv/programs/mythfrontend/mythfrontend.pro b/mythtv/programs/mythfrontend/mythfrontend.pro
index 4b9913f9d93..af86498d614 100644
--- a/mythtv/programs/mythfrontend/mythfrontend.pro
+++ b/mythtv/programs/mythfrontend/mythfrontend.pro
@@ -90,6 +90,9 @@ SOURCES += services/mythfrontendservice.cpp
 HEADERS += progdetails.h proginfolist.h
 SOURCES += progdetails.cpp proginfolist.cpp
 
+HEADERS += playbackstate.h
+SOURCES += playbackstate.cpp
+
 macx {
     mac_bundle {
         CONFIG -= console  # Force behaviour of producing .app bundle
diff --git a/mythtv/programs/mythfrontend/playbackstate.cpp b/mythtv/programs/mythfrontend/playbackstate.cpp
new file mode 100644
index 00000000000..40a20a5e312
--- /dev/null
+++ b/mythtv/programs/mythfrontend/playbackstate.cpp
@@ -0,0 +1,118 @@
+#include "playbackstate.h"
+#include "libmythbase/mythdb.h"
+#include "libmythbase/mythdbcon.h"
+#include "libmythbase/mythlogging.h"
+#include "libmythbase/programtypes.h"
+#include "libmythmetadata/videometadata.h"
+
+void PlaybackState::Initialize()
+{
+    LOG(VB_GENERAL, LOG_INFO, "Query playback state for all videos from database");
+
+    m_fileMarkup.clear();
+
+    QueryData();
+
+    LOG(VB_GENERAL, LOG_INFO, QString("Collected playbackstate for %1 videos").arg(m_fileMarkup.count()));
+}
+
+void PlaybackState::Update(const QString &filename)
+{
+    if (!filename.isEmpty())
+    {
+        QueryData(filename);
+    }
+}
+
+void PlaybackState::QueryData(const QString &filterFilename)
+{
+    MSqlQuery query(MSqlQuery::InitCon());
+
+    if (filterFilename.isEmpty())
+    {
+        query.prepare("SELECT filename, type, mark, `offset` "
+                    "FROM filemarkup "
+                    "WHERE type IN (:BOOKMARK, :FRAMES, :PLAYPOS) "
+                    "ORDER BY filename");
+    }
+    else
+    {
+        query.prepare("SELECT filename, type, mark, `offset` "
+                    "FROM filemarkup "
+                    "WHERE type IN (:BOOKMARK, :FRAMES, :PLAYPOS) "
+                    "AND filename = :FILENAME "
+                    "ORDER BY filename");
+        query.bindValue(":FILENAME", filterFilename);
+    }
+    query.bindValue(":BOOKMARK", MARK_BOOKMARK);
+    query.bindValue(":FRAMES", MARK_TOTAL_FRAMES);
+    query.bindValue(":PLAYPOS", MARK_UTIL_LASTPLAYPOS);
+
+    if (!query.exec())
+    {
+        MythDB::DBError("PlaybackState", query);
+        return;
+    }
+
+    QString lastFilename;
+    Markup currMarks;
+    while (query.next())
+    {
+        const QString filename = query.value(0).toString();
+        if (!lastFilename.isEmpty() && filename != lastFilename)
+        {
+            m_fileMarkup[lastFilename] = currMarks;
+            currMarks = Markup();
+        }
+        switch(query.value(1).toInt())
+        {
+            case MARK_BOOKMARK:
+                currMarks.bookmarkPos = query.value(2).toLongLong();
+                break;
+            case MARK_TOTAL_FRAMES:
+                currMarks.totalFrames = query.value(3).toLongLong();
+                break;
+            case MARK_UTIL_LASTPLAYPOS:
+                currMarks.lastPlayPos = query.value(2).toLongLong();
+                break;
+        }
+        lastFilename = filename;
+    }
+    m_fileMarkup[lastFilename] = currMarks;
+}
+
+bool PlaybackState::HasBookmark(const QString &filename) const
+{
+    auto it = m_fileMarkup.constFind(filename);
+    if (it == m_fileMarkup.constEnd())
+    {
+        return false;
+    }
+    return (it.value().bookmarkPos > 0) ? true : false;
+}
+
+uint64_t PlaybackState::GetLastPlayPos(const QString &filename) const
+{
+    auto it = m_fileMarkup.constFind(filename);
+    if (it == m_fileMarkup.constEnd())
+    {
+        return 0;
+    }
+    return it.value().lastPlayPos;
+}
+
+uint PlaybackState::GetWatchedPercent(const QString &filename) const
+{
+    auto it = m_fileMarkup.constFind(filename);
+    if (it == m_fileMarkup.constEnd())
+    {
+        return 0;
+    }
+    const auto pos = it.value().lastPlayPos;
+    const auto total = it.value().totalFrames;
+    if (0 == total)
+    {
+        return 0;
+    }
+    return std::clamp(100 * pos / total, (uint64_t)0, (uint64_t)100);
+}
diff --git a/mythtv/programs/mythfrontend/playbackstate.h b/mythtv/programs/mythfrontend/playbackstate.h
new file mode 100644
index 00000000000..9613111cbf1
--- /dev/null
+++ b/mythtv/programs/mythfrontend/playbackstate.h
@@ -0,0 +1,45 @@
+#ifndef PLAYBACKSTATE_H_
+#define PLAYBACKSTATE_H_
+
+// POSIX headers
+#include <cstdint> // for [u]int[32,64]_t
+
+#include <QMap>
+#include <QString>
+
+/// Utility class to query playback state from database
+class PlaybackState
+{
+public:
+    PlaybackState() = default;
+
+    /// Initializes playback state from database
+    void Initialize();
+
+    /// Updates playback state of video with specified filename
+    void Update(const QString &filename);
+
+    /// Query bookmark of video with the specified filename
+    bool HasBookmark(const QString &filename) const;
+
+    /// Query last playback position of video with the specified filename
+    uint64_t GetLastPlayPos(const QString &filename) const;
+
+    /// Query watched percent of video with the specified filename
+    uint GetWatchedPercent(const QString &filename) const;
+
+private:
+    /// Query playback state from database, only for single video if a filename is specified
+    void QueryData(const QString &filterFilename = QString());
+
+    /// Markup for a video file
+    struct Markup {
+        uint64_t totalFrames = 0;   ///< total frames
+        uint64_t lastPlayPos = 0;   ///< last playing position
+        uint64_t bookmarkPos = 0;   ///< bookmark position
+    };
+
+    QMap<QString, Markup> m_fileMarkup; ///< maps filename to markup
+};
+
+#endif // PLAYBACKSTATE_H_
From 395d1bd2301add93fcff274af2c2e31e7454516a Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Sun, 9 Apr 2023 13:10:43 +0200
Subject: [PATCH] Add bookmark and watched percent support to videos

Add support for displaying a bookmark state within
the video manager. This uses the playback state class
for caching the playback state for all videos.
Also adds support for displaying watched progress
state to video manager. This needs the last playing
position (already supported) as well as a total
frames markup datum within the filemarkup table.
The watched progress is then calculated and can be
displayed via a progress in the currently selected list
item.
---
 mythtv/programs/mythfrontend/videodlg.cpp | 82 +++++++++++++++++++++--
 mythtv/programs/mythfrontend/videodlg.h   |  3 +
 2 files changed, 81 insertions(+), 4 deletions(-)

diff --git a/mythtv/programs/mythfrontend/videodlg.cpp b/mythtv/programs/mythfrontend/videodlg.cpp
index 044cb250e62..d086e5b3918 100644
--- a/mythtv/programs/mythfrontend/videodlg.cpp
+++ b/mythtv/programs/mythfrontend/videodlg.cpp
@@ -40,11 +40,13 @@
 #include "libmythui/mythuibuttontree.h"
 #include "libmythui/mythuihelper.h"
 #include "libmythui/mythuiimage.h"
+#include "libmythui/mythuiprogressbar.h"
 #include "libmythui/mythuistatetype.h"
 #include "libmythui/mythuitext.h"
 
 // MythFrontend
 #include "editvideometadata.h"
+#include "playbackstate.h"
 #include "videodlg.h"
 #include "videofileassoc.h"
 #include "videofilter.h"
@@ -560,8 +562,37 @@ namespace
         h.handleState("watchedstate");
         h.handleState("videolevel");
     }
+
+    void CopyPlaybackStateToUI(const PlaybackState &playbackState,
+            const VideoMetadata *metadata,
+            MythUIButtonListItem *item = nullptr,
+            MythScreenType *screen = nullptr)
+    {
+        if (!metadata || (!item && !screen))
+        {
+            return;
+        }
+
+        const auto bookmarkState = playbackState.HasBookmark(metadata->GetFilename()) ? "yes" : "no";
+        const auto watchedPercent = playbackState.GetWatchedPercent(metadata->GetFilename());
+        if (item)
+        {
+            item->DisplayState(bookmarkState, "bookmarkstate");
+            item->SetProgress1(0, watchedPercent ? 100 : 0, watchedPercent);
+        }
+        if (screen)
+        {
+            CheckedSet(screen, "bookmarkstate", bookmarkState);
+            auto watchedProgress = dynamic_cast<MythUIProgressBar *>(screen->GetChild("watchedprogressbar"));
+            if (watchedProgress)
+            {
+                watchedProgress->Set(0, 100, watchedPercent);
+            }
+        }
+    }
 }
 
+
 class ItemDetailPopup : public MythScreenType
 {
     Q_OBJECT
@@ -575,9 +606,9 @@ class ItemDetailPopup : public MythScreenType
 
   public:
     ItemDetailPopup(MythScreenStack *lparent, VideoMetadata *metadata,
-            const VideoMetadataListManager &listManager) :
+            const VideoMetadataListManager &listManager, PlaybackState &playbackState) :
         MythScreenType(lparent, kWindowName), m_metadata(metadata),
-        m_listManager(listManager)
+        m_listManager(listManager), m_playbackState(playbackState)
     {
     }
 
@@ -606,6 +637,7 @@ class ItemDetailPopup : public MythScreenType
 
         ScreenCopyDest dest(this);
         CopyMetadataToUI(m_metadata, dest);
+        CopyPlaybackStateToUI(m_playbackState, m_metadata, nullptr, this);
 
         return true;
     }
@@ -661,6 +693,7 @@ class ItemDetailPopup : public MythScreenType
     static const char * const kWindowName;
     VideoMetadata *m_metadata   {nullptr};
     const VideoMetadataListManager &m_listManager;
+    PlaybackState &m_playbackState;
 
     MythUIButton  *m_playButton {nullptr};
     MythUIButton  *m_doneButton {nullptr};
@@ -794,6 +827,8 @@ class VideoDialogPrivate
     QString m_lastTreeNodePath;
     QMap<QString, int> m_notifications;
 
+    PlaybackState m_playbackState;
+
   private:
     parental_level_map m_ratingToPl;
 };
@@ -861,6 +896,20 @@ VideoDialog::VideoDialog(MythScreenStack *lparent, const QString& lname,
 
     StorageGroup::ClearGroupToUseCache();
     MythCoreContext::ClearBackendServerPortCache();
+    // Get notified when playback stopped, so we can update watched progress
+    connect(gCoreContext, &MythCoreContext::TVPlaybackStopped, this, &VideoDialog::OnPlaybackStopped);
+    connect(gCoreContext, &MythCoreContext::TVPlaybackAborted, this, &VideoDialog::OnPlaybackStopped);
+}
+
+void VideoDialog::OnPlaybackStopped()
+{
+    auto *item = GetItemCurrent();
+    const auto *metadata = GetMetadata(item);
+    if (metadata)
+    {
+        m_d->m_playbackState.Update(metadata->GetFilename());
+    }
+    UpdateText(item);
 }
 
 VideoDialog::~VideoDialog()
@@ -1000,6 +1049,7 @@ bool VideoDialog::Create()
     UIUtilW::Assign(this, m_parentalLevelState, "parentallevel");
     UIUtilW::Assign(this, m_watchedState, "watchedstate");
     UIUtilW::Assign(this, m_studioState, "studiostate");
+    UIUtilW::Assign(this, m_bookmarkState, "bookmarkstate");
 
     if (err)
     {
@@ -1011,6 +1061,7 @@ bool VideoDialog::Create()
     CheckedSet(m_parentalLevelState, "None");
     CheckedSet(m_watchedState, "None");
     CheckedSet(m_studioState, "None");
+    CheckedSet(m_bookmarkState, "None");
 
     BuildFocusList();
 
@@ -1024,6 +1075,8 @@ bool VideoDialog::Create()
                 this, &VideoDialog::UpdateText);
         connect(m_videoButtonTree, &MythUIButtonTree::nodeChanged,
                 this, &VideoDialog::SetCurrentNode);
+        connect(m_videoButtonTree, &MythUIButtonTree::itemVisible,
+                this, &VideoDialog::UpdateVisible);
     }
     else
     {
@@ -1033,6 +1086,8 @@ bool VideoDialog::Create()
                 this, &VideoDialog::handleSelect);
         connect(m_videoButtonList, &MythUIButtonList::itemSelected,
                 this, &VideoDialog::UpdateText);
+        connect(m_videoButtonList, &MythUIButtonList::itemVisible,
+                this, &VideoDialog::UpdateVisible);
     }
 
     return true;
@@ -1234,6 +1289,7 @@ void VideoDialog::UpdateItem(MythUIButtonListItem *item)
 
     MythUIButtonListItemCopyDest dest(item);
     CopyMetadataToUI(metadata, dest);
+    CopyPlaybackStateToUI(m_d->m_playbackState, metadata, item, nullptr);
 
     MythGenericTree *parent = node->getParent();
 
@@ -1311,6 +1367,7 @@ void VideoDialog::UpdateItem(MythUIButtonListItem *item)
  */
 void VideoDialog::fetchVideos()
 {
+    m_d->m_playbackState.Initialize();
     MythGenericTree *oldroot = m_d->m_rootNode;
     if (!m_d->m_treeLoaded)
     {
@@ -2185,13 +2242,29 @@ void VideoDialog::UpdatePosition()
                                     .arg(currentList->GetCount()));
 }
 
+/** \fn VideoDialog::UpdateVisible(MythUIButtonListItem *item)
+ *  \brief Update playback state for for a given visible ButtonListItem
+ *  \return void.
+ */
+void VideoDialog::UpdateVisible(MythUIButtonListItem *item)
+{
+    if (!item)
+        return;
+
+    VideoMetadata *metadata = GetMetadata(item);
+    if (!metadata)
+        return;
+
+    CopyPlaybackStateToUI(m_d->m_playbackState, metadata, item, nullptr);
+}
+
 /** \fn VideoDialog::UpdateText(MythUIButtonListItem *item)
  *  \brief Update the visible text values for a given ButtonListItem.
  *  \return void.
  */
 void VideoDialog::UpdateText(MythUIButtonListItem *item)
 {
-    if (!item)
+    if (!item || !item->isVisible())
         return;
 
     MythUIButtonList *currentList = item->parent();
@@ -2221,6 +2294,7 @@ void VideoDialog::UpdateText(MythUIButtonListItem *item)
 
     ScreenCopyDest dest(this);
     CopyMetadataToUI(metadata, dest);
+    CopyPlaybackStateToUI(m_d->m_playbackState, metadata, item, m_d->m_currentNode ? this : nullptr);
 
     if (node->getInt() == kSubFolder && !metadata)
     {
@@ -2862,7 +2936,7 @@ bool VideoDialog::DoItemDetailShow()
     {
         MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
         auto *idp = new ItemDetailPopup(mainStack, metadata,
-                m_d->m_videoList->getListCache());
+                m_d->m_videoList->getListCache(), m_d->m_playbackState);
 
         if (idp->Create())
         {
diff --git a/mythtv/programs/mythfrontend/videodlg.h b/mythtv/programs/mythfrontend/videodlg.h
index d4000536244..050811bbad8 100644
--- a/mythtv/programs/mythfrontend/videodlg.h
+++ b/mythtv/programs/mythfrontend/videodlg.h
@@ -68,6 +68,7 @@ class VideoDialog : public MythScreenType
 
   private slots:
     void UpdatePosition();
+    void UpdateVisible(MythUIButtonListItem *item);
     void UpdateText(MythUIButtonListItem *item);
     void handleSelect(MythUIButtonListItem *item);
     void SetCurrentNode(MythGenericTree *node);
@@ -184,6 +185,7 @@ class VideoDialog : public MythScreenType
 
     void OnVideoImageSetDone(VideoMetadata *metadata);
     void OnVideoSearchDone(MetadataLookup *lookup);
+    void OnPlaybackStopped();
 
   private:
     MythDialogBox    *m_menuPopup          {nullptr};
@@ -211,6 +213,7 @@ class VideoDialog : public MythScreenType
     MythUIStateType  *m_userRatingState    {nullptr};
     MythUIStateType  *m_watchedState       {nullptr};
     MythUIStateType  *m_studioState        {nullptr};
+    MythUIStateType  *m_bookmarkState      {nullptr};
 
     MetadataFactory *m_metadataFactory     {nullptr};
 
From 9faa88cbcd571049f45577856a0e6c3f7221be42 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Wed, 31 Jan 2024 23:05:15 +0100
Subject: [PATCH] Signal changed playback state

Signal removal of last played position and bookmark
to video dialog, so it can update the respective
button list item.
---
 mythtv/programs/mythfrontend/mythfrontend.cpp | 14 ++++++++++++++
 mythtv/programs/mythfrontend/videodlg.cpp     | 11 +++++++++++
 mythtv/programs/mythfrontend/videodlg.h       |  1 +
 3 files changed, 26 insertions(+)

diff --git a/mythtv/programs/mythfrontend/mythfrontend.cpp b/mythtv/programs/mythfrontend/mythfrontend.cpp
index 3cb38f5aed1..c3c59523ab1 100644
--- a/mythtv/programs/mythfrontend/mythfrontend.cpp
+++ b/mythtv/programs/mythfrontend/mythfrontend.cpp
@@ -243,6 +243,7 @@ namespace
         {
             QString msg = tr("DVD/Video contains a bookmark");
 
+            m_videoDlg = dynamic_cast<VideoDialog*>(GetScreenStack()->GetTopScreen());
             auto *popup = new MythDialogBox(msg, GetScreenStack(), "bookmarkdialog");
             if (!popup->Create())
             {
@@ -283,9 +284,21 @@ namespace
             else if (buttonText == m_btnPlayBegin)
                 TV::StartTV(m_pgi, kStartTVIgnoreLastPlayPos | kStartTVIgnoreBookmark);
             else if (buttonText == m_btnClearBookmark)
+            {
                 m_pgi->SaveBookmark(0);
+                if (m_videoDlg)
+                {
+                    m_videoDlg->playbackStateChanged(m_pgi->GetBasename());
+                }
+            }
             else if (buttonText == m_btnClearLast)
+            {
                 m_pgi->SaveLastPlayPos(0);
+                if (m_videoDlg)
+                {
+                    m_videoDlg->playbackStateChanged(m_pgi->GetBasename());
+                }
+            }
             delete m_pgi;
         }
 
@@ -298,6 +311,7 @@ namespace
         QString      m_btnPlayBegin;
         QString      m_btnPlayLast;
         QString      m_btnClearLast;
+        VideoDialog  *m_videoDlg        {nullptr};
     };
 
     void cleanup()
diff --git a/mythtv/programs/mythfrontend/videodlg.cpp b/mythtv/programs/mythfrontend/videodlg.cpp
index d086e5b3918..7146307c943 100644
--- a/mythtv/programs/mythfrontend/videodlg.cpp
+++ b/mythtv/programs/mythfrontend/videodlg.cpp
@@ -901,6 +901,17 @@ VideoDialog::VideoDialog(MythScreenStack *lparent, const QString& lname,
     connect(gCoreContext, &MythCoreContext::TVPlaybackAborted, this, &VideoDialog::OnPlaybackStopped);
 }
 
+void VideoDialog::playbackStateChanged(const QString &filename)
+{
+    m_d->m_playbackState.Update(filename);
+    auto *item = GetItemCurrent();
+    const auto *metadata = GetMetadata(item);
+    if (metadata && metadata->GetFilename() == filename)
+    {
+        UpdateText(item);
+    }
+}
+
 void VideoDialog::OnPlaybackStopped()
 {
     auto *item = GetItemCurrent();
diff --git a/mythtv/programs/mythfrontend/videodlg.h b/mythtv/programs/mythfrontend/videodlg.h
index 050811bbad8..49122bd5874 100644
--- a/mythtv/programs/mythfrontend/videodlg.h
+++ b/mythtv/programs/mythfrontend/videodlg.h
@@ -61,6 +61,7 @@ class VideoDialog : public MythScreenType
 
   public slots:
     void searchComplete(const QString& string);
+    void playbackStateChanged(const QString &filename);
 
   protected slots:
     void Init() override; /// Called after the screen is created by MythScreenStack
From 95235af1d5f6385978bebec6883fdb689c55a3a6 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Tue, 30 Jan 2024 22:47:30 +0100
Subject: [PATCH] Fix displaying watched state after playback

When watching a video to the end, the player can mark
(if enabled by a setting) the video as watched. This
was not reflected in the GUI state until now.
So after receiving the playback stopped event, we load
the video metadata of the current video and sync it with
the metadata from the cache.
---
 mythtv/programs/mythfrontend/videodlg.cpp | 30 +++++++++++++++++++++++
 mythtv/programs/mythfrontend/videodlg.h   |  1 +
 2 files changed, 31 insertions(+)

diff --git a/mythtv/programs/mythfrontend/videodlg.cpp b/mythtv/programs/mythfrontend/videodlg.cpp
index 7146307c943..8236425b23f 100644
--- a/mythtv/programs/mythfrontend/videodlg.cpp
+++ b/mythtv/programs/mythfrontend/videodlg.cpp
@@ -921,8 +921,10 @@ void VideoDialog::OnPlaybackStopped()
         m_d->m_playbackState.Update(metadata->GetFilename());
     }
     UpdateText(item);
+    UpdateWatchedState(item);
 }
 
+
 VideoDialog::~VideoDialog()
 {
     if (!m_d->m_switchingLayout)
@@ -2337,6 +2339,34 @@ void VideoDialog::UpdateText(MythUIButtonListItem *item)
         node->becomeSelectedChild();
 }
 
+/** \fn VideoDialog::UpdateWatchedState(MythUIButtonListItem *item)
+ *  \brief Update the watched state for a given ButtonListItem from the database.
+ *  \return void.
+ * 
+ *  The player could have updated the watched state of a video after watching.
+ *  We load the metadata of the current item from the database and sync the
+ *  watched state of the current item if it was changed by the player.
+ */
+void VideoDialog::UpdateWatchedState(MythUIButtonListItem *item)
+{
+    if (!gCoreContext->GetBoolSetting("AutomaticSetWatched", false))
+        return;
+
+    if (!item)
+        return;
+
+    VideoMetadata *metadata = GetMetadata(item);
+    if (!metadata)
+        return;
+
+    auto metadataNew = m_d->m_videoList->getListCache().loadOneFromDatabase(metadata->GetID());
+    if (metadata->GetWatched() != metadataNew->GetWatched())
+    {
+        metadata->SetWatched(metadataNew->GetWatched());
+        item->DisplayState(WatchedToState(metadata->GetWatched()), "watchedstate");
+    }
+}
+
 /** \fn VideoDialog::VideoMenu()
  *  \brief Pop up a MythUI "Playback Menu" for MythVideo.  Bound to INFO.
  *  \return void.
diff --git a/mythtv/programs/mythfrontend/videodlg.h b/mythtv/programs/mythfrontend/videodlg.h
index 49122bd5874..493c27ee4c0 100644
--- a/mythtv/programs/mythfrontend/videodlg.h
+++ b/mythtv/programs/mythfrontend/videodlg.h
@@ -70,6 +70,7 @@ class VideoDialog : public MythScreenType
   private slots:
     void UpdatePosition();
     void UpdateVisible(MythUIButtonListItem *item);
+    void UpdateWatchedState(MythUIButtonListItem *item);
     void UpdateText(MythUIButtonListItem *item);
     void handleSelect(MythUIButtonListItem *item);
     void SetCurrentNode(MythGenericTree *node);
From 21dd2aa896b03d7433f7da8d22efbcdb5745dc99 Mon Sep 17 00:00:00 2001
From: Jan Hambrecht <jaham@gmx.net>
Date: Wed, 31 Jan 2024 00:04:27 +0100
Subject: [PATCH] Add setting to always show watched progress

Adds a setting to always show watched progress even
if the recording or video is marked as watched.
Make behaviour of displaying the watched progress
the same in recordings and video lists.
---
 mythtv/programs/mythfrontend/globalsettings.cpp | 17 +++++++++++++++++
 mythtv/programs/mythfrontend/playbackbox.cpp    |  7 +++++--
 mythtv/programs/mythfrontend/playbackbox.h      |  1 +
 mythtv/programs/mythfrontend/playbackstate.cpp  | 13 +++++++++++++
 mythtv/programs/mythfrontend/playbackstate.h    |  6 +++++-
 mythtv/programs/mythfrontend/videodlg.cpp       |  5 +++--
 6 files changed, 44 insertions(+), 5 deletions(-)

diff --git a/mythtv/programs/mythfrontend/globalsettings.cpp b/mythtv/programs/mythfrontend/globalsettings.cpp
index 531bdfb8a3e..67f5a2ad793 100644
--- a/mythtv/programs/mythfrontend/globalsettings.cpp
+++ b/mythtv/programs/mythfrontend/globalsettings.cpp
@@ -1881,6 +1881,22 @@ static HostCheckBoxSetting *AutomaticSetWatched()
     return gc;
 }
 
+static HostCheckBoxSetting *AlwaysShowWatchedProgress()
+{
+    auto *gc = new HostCheckBoxSetting("AlwaysShowWatchedProgress");
+
+    gc->setLabel(PlaybackSettings::tr("Always show watched percent progress bar"));
+
+    gc->setValue(false);
+
+    gc->setHelpText(PlaybackSettings::tr("If enabled, shows the watched percent "
+                                         "progress bar even if the recording or "
+                                         "video is marked as watched. "
+                                         "Having a watched percent progress bar at "
+                                         "all depends on the currently used theme."));
+    return gc;
+}
+
 static HostSpinBoxSetting *LiveTVIdleTimeout()
 {
     auto *gs = new HostSpinBoxSetting("LiveTVIdleTimeout", 0, 3600, 1);
@@ -4407,6 +4423,7 @@ void PlaybackSettings::Load(void)
     general->addChild(JumpToProgramOSD());
     general->addChild(UseProgStartMark());
     general->addChild(AutomaticSetWatched());
+    general->addChild(AlwaysShowWatchedProgress());
     general->addChild(ContinueEmbeddedTVPlay());
     general->addChild(LiveTVIdleTimeout());
 
diff --git a/mythtv/programs/mythfrontend/playbackbox.cpp b/mythtv/programs/mythfrontend/playbackbox.cpp
index d588602f02f..7ca0e8d1edf 100644
--- a/mythtv/programs/mythfrontend/playbackbox.cpp
+++ b/mythtv/programs/mythfrontend/playbackbox.cpp
@@ -465,6 +465,8 @@ PlaybackBox::PlaybackBox(MythScreenStack *parent, const QString& name,
 
     fillRecGroupPasswordCache();
 
+    m_alwaysShowWatchedProgress = gCoreContext->GetBoolSetting("AlwaysShowWatchedProgress", false);
+
     // misc setup
     gCoreContext->addListener(this);
 
@@ -1039,8 +1041,9 @@ void PlaybackBox::ItemVisible(MythUIButtonListItem *item)
     // Flagging status (queued, running, no, yes)
     item->DisplayState(extract_commflag_state(*pginfo), "commflagged");
 
-    item->SetProgress1(0, pginfo->IsWatched() ? 0 : 100,
-                       pginfo->GetWatchedPercent());
+    const auto watchedPercent = pginfo->GetWatchedPercent();
+    const bool showProgress = watchedPercent && (m_alwaysShowWatchedProgress || !pginfo->IsWatched());
+    item->SetProgress1(0, showProgress ? 100 : 0, watchedPercent);
     item->SetProgress2(0, 100, pginfo->GetRecordedPercent());
 
     MythUIButtonListItem *sel_item = item->parent()->GetItemCurrent();
diff --git a/mythtv/programs/mythfrontend/playbackbox.h b/mythtv/programs/mythfrontend/playbackbox.h
index 5cf146c46f5..053fd620da3 100644
--- a/mythtv/programs/mythfrontend/playbackbox.h
+++ b/mythtv/programs/mythfrontend/playbackbox.h
@@ -466,6 +466,7 @@ class PlaybackBox : public ScheduleCommon
     bool                m_groupSelected       {false};
     bool                m_passwordEntered     {false};
 
+    bool                m_alwaysShowWatchedProgress {false};
     // This class caches the contents of the jobqueue table to avoid excessive
     // DB queries each time the PBB selection changes (currently 4 queries per
     // displayed item).  The cache remains valid for 15 seconds
diff --git a/mythtv/programs/mythfrontend/playbackstate.cpp b/mythtv/programs/mythfrontend/playbackstate.cpp
index 40a20a5e312..b22fb154651 100644
--- a/mythtv/programs/mythfrontend/playbackstate.cpp
+++ b/mythtv/programs/mythfrontend/playbackstate.cpp
@@ -1,10 +1,18 @@
 #include "playbackstate.h"
+
+// MythTV
+#include "libmyth/mythcontext.h"
 #include "libmythbase/mythdb.h"
 #include "libmythbase/mythdbcon.h"
 #include "libmythbase/mythlogging.h"
 #include "libmythbase/programtypes.h"
 #include "libmythmetadata/videometadata.h"
 
+PlaybackState::PlaybackState()
+{
+    m_alwaysShowWatchedProgress = gCoreContext->GetBoolSetting("AlwaysShowWatchedProgress", false);
+}
+
 void PlaybackState::Initialize()
 {
     LOG(VB_GENERAL, LOG_INFO, "Query playback state for all videos from database");
@@ -116,3 +124,8 @@ uint PlaybackState::GetWatchedPercent(const QString &filename) const
     }
     return std::clamp(100 * pos / total, (uint64_t)0, (uint64_t)100);
 }
+
+bool PlaybackState::AlwaysShowWatchedProgress() const
+{
+    return m_alwaysShowWatchedProgress;
+}
diff --git a/mythtv/programs/mythfrontend/playbackstate.h b/mythtv/programs/mythfrontend/playbackstate.h
index 9613111cbf1..d06ee6942b8 100644
--- a/mythtv/programs/mythfrontend/playbackstate.h
+++ b/mythtv/programs/mythfrontend/playbackstate.h
@@ -11,7 +11,7 @@
 class PlaybackState
 {
 public:
-    PlaybackState() = default;
+    PlaybackState();
 
     /// Initializes playback state from database
     void Initialize();
@@ -28,6 +28,9 @@ class PlaybackState
     /// Query watched percent of video with the specified filename
     uint GetWatchedPercent(const QString &filename) const;
 
+    /// Returns cached setting "AlwaysShowWatchedProgress"
+    bool AlwaysShowWatchedProgress() const;
+
 private:
     /// Query playback state from database, only for single video if a filename is specified
     void QueryData(const QString &filterFilename = QString());
@@ -40,6 +43,7 @@ class PlaybackState
     };
 
     QMap<QString, Markup> m_fileMarkup; ///< maps filename to markup
+    bool m_alwaysShowWatchedProgress {false};
 };
 
 #endif // PLAYBACKSTATE_H_
diff --git a/mythtv/programs/mythfrontend/videodlg.cpp b/mythtv/programs/mythfrontend/videodlg.cpp
index 8236425b23f..2a60099104b 100644
--- a/mythtv/programs/mythfrontend/videodlg.cpp
+++ b/mythtv/programs/mythfrontend/videodlg.cpp
@@ -575,10 +575,11 @@ namespace
 
         const auto bookmarkState = playbackState.HasBookmark(metadata->GetFilename()) ? "yes" : "no";
         const auto watchedPercent = playbackState.GetWatchedPercent(metadata->GetFilename());
+        const bool showProgress = watchedPercent && (playbackState.AlwaysShowWatchedProgress() || !metadata->GetWatched());
         if (item)
         {
             item->DisplayState(bookmarkState, "bookmarkstate");
-            item->SetProgress1(0, watchedPercent ? 100 : 0, watchedPercent);
+            item->SetProgress1(0, showProgress ? 100 : 0, watchedPercent);
         }
         if (screen)
         {
@@ -586,7 +587,7 @@ namespace
             auto watchedProgress = dynamic_cast<MythUIProgressBar *>(screen->GetChild("watchedprogressbar"));
             if (watchedProgress)
             {
-                watchedProgress->Set(0, 100, watchedPercent);
+                watchedProgress->Set(0, showProgress ? 100 : 0, watchedPercent);
             }
         }
     }
