From 49d95223721998638ed1e9b6837d7e590751f163 Mon Sep 17 00:00:00 2001
From: Timothy D Witham <twitham@sbcglobal.net>
Date: Fri, 12 Jan 2024 00:39:49 -0600
Subject: [PATCH] MythMusic: add CU LRC scrapers verbatim

from https://gitlab.com/ronie/script.cu.lrclyrics
---
 .../scripts/metadata/Music/lyrics/LICENSE.txt | 282 +++++++
 .../scripts/metadata/Music/lyrics/README.txt  |  28 +
 .../scripts/metadata/Music/lyrics/addon.xml   |  85 ++
 .../metadata/Music/lyrics/changelog.txt       | 488 +++++++++++
 .../scripts/metadata/Music/lyrics/default.py  |  29 +
 .../metadata/Music/lyrics/lib/audiofile.py    | 127 +++
 .../lib/broken-scrapers/alsong/__init__.py    |   1 +
 .../broken-scrapers/alsong/lyricsScraper.py   |  65 ++
 .../lib/broken-scrapers/baidu/__init__.py     |   1 +
 .../broken-scrapers/baidu/lyricsScraper.py    |  51 ++
 .../lib/broken-scrapers/gomaudio/__init__.py  |   1 +
 .../broken-scrapers/gomaudio/lyricsScraper.py | 101 +++
 .../lib/broken-scrapers/lyricwiki/__init__.py |   1 +
 .../lyricwiki/lyricsScraper.py                |  67 ++
 .../broken-scrapers/minilyrics/__init__.py    |   1 +
 .../minilyrics/lyricsScraper.py               | 161 ++++
 .../lib/broken-scrapers/ttplayer/__init__.py  |   1 +
 .../broken-scrapers/ttplayer/lyricsScraper.py | 207 +++++
 .../lib/broken-scrapers/xiami/__init__.py     |   1 +
 .../broken-scrapers/xiami/lyricsScraper.py    |  96 +++
 .../lyrics/lib/culrcscrapers/__init__.py      |   1 +
 .../lib/culrcscrapers/azlyrics/__init__.py    |   1 +
 .../culrcscrapers/azlyrics/lyricsScraper.py   |  42 +
 .../lib/culrcscrapers/darklyrics/__init__.py  |   1 +
 .../culrcscrapers/darklyrics/lyricsScraper.py | 124 +++
 .../lib/culrcscrapers/genius/__init__.py      |   1 +
 .../lib/culrcscrapers/genius/lyricsScraper.py |  68 ++
 .../lib/culrcscrapers/lrclib/__init__.py      |   1 +
 .../lib/culrcscrapers/lrclib/lyricsScraper.py |  66 ++
 .../lib/culrcscrapers/lyricscom/__init__.py   |   1 +
 .../culrcscrapers/lyricscom/lyricsScraper.py  |  61 ++
 .../culrcscrapers/lyricsify/lyricsScraper.py  |  75 ++
 .../lib/culrcscrapers/lyricsmode/__init__.py  |   1 +
 .../culrcscrapers/lyricsmode/lyricsScraper.py |  59 ++
 .../lib/culrcscrapers/megalobiz/__init__.py   |   1 +
 .../culrcscrapers/megalobiz/lyricsScraper.py  |  69 ++
 .../lib/culrcscrapers/music163/__init__.py    |   1 +
 .../culrcscrapers/music163/lyricsScraper.py   |  71 ++
 .../lib/culrcscrapers/musixmatch/__init__.py  |   1 +
 .../culrcscrapers/musixmatch/lyricsScraper.py |  86 ++
 .../culrcscrapers/musixmatchlrc/__init__.py   |   1 +
 .../musixmatchlrc/lyricsScraper.py            | 117 +++
 .../lib/culrcscrapers/supermusic/__init__.py  |   1 +
 .../culrcscrapers/supermusic/lyricsScraper.py |  64 ++
 .../metadata/Music/lyrics/lib/embedlrc.py     | 183 ++++
 .../scripts/metadata/Music/lyrics/lib/gui.py  | 796 ++++++++++++++++++
 .../metadata/Music/lyrics/lib/scrapertest.py  | 268 ++++++
 .../scripts/metadata/Music/lyrics/lib/sync.py |  48 ++
 .../metadata/Music/lyrics/lib/utils.py        | 187 ++++
 49 files changed, 4190 insertions(+)
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/LICENSE.txt
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/README.txt
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/addon.xml
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/changelog.txt
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/default.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/audiofile.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsify/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/__init__.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/lyricsScraper.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/embedlrc.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/gui.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/scrapertest.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/sync.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lib/utils.py

diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/LICENSE.txt b/mythtv/programs/scripts/metadata/Music/lyrics/LICENSE.txt
new file mode 100644
index 00000000000..4f8e8eb30cc
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/LICENSE.txt
@@ -0,0 +1,282 @@
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+-------------------------------------------------------------------------
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/README.txt b/mythtv/programs/scripts/metadata/Music/lyrics/README.txt
new file mode 100644
index 00000000000..ce5fb3ff115
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/README.txt
@@ -0,0 +1,28 @@
+ INFO FOR SKINNERS & ADDON DEVS
+================================
+
+control id's:
+110 - list (lyrics text)
+200 - label (used lyrics scraper)
+
+
+listitem properties:
+Container(110).ListItem.Property(part1)    - first word of the current line
+Container(110).ListItem.Property(part2)    - second word of the current line
+Container(110).ListItem.Property(part3)    - third word of the current line
+Container(110).ListItem.Property(part4)    - rest of the current line
+Container(110).ListItem.Property(duration) - time the current line will be shown
+
+
+window properties:
+Window(Home).Property(culrc.lyrics)   - shows the current lyrics, including timing info in case of lrc lyrics.
+Window(Home).Property(culrc.source)   - source or scraper that was used to find the current lyrics.
+Window(Home).Property(culrc.haslist)  - will be 'true' if multiple lyrics are available, empty if not.
+Window(Home).Property(culrc.islrc)    - returns 'true' when the lyrics are lrc based, empty if not.
+Window(Home).Property(culrc.running)  - returns 'true' when the lyrics script is running, empty if not.
+
+
+music addons can add lyrics to their items this way:
+https://codedocs.xyz/xbmc/xbmc/group__python__xbmcgui__listitem.html
+listitem.setInfo('music', {'lyrics': 'lyrics here'})
+listitem.setProperty('culrc.source', 'addon name here')
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/addon.xml b/mythtv/programs/scripts/metadata/Music/lyrics/addon.xml
new file mode 100644
index 00000000000..8133be3e8f6
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/addon.xml
@@ -0,0 +1,85 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<addon id="script.cu.lrclyrics" name="CU LRC Lyrics" version="6.6.2" provider-name="Taxigps, ronie">
+	<requires>
+		<import addon="xbmc.python" version="3.0.0"/>
+		<import addon="script.module.beautifulsoup4" version="4.8.2+matrix.1"/>
+		<import addon="script.module.chardet" version="3.0.4+matrix.1"/>
+		<import addon="script.module.mutagen" version="1.44.0+matrix.1"/>
+		<import addon="script.module.requests" version="2.22.0+matrix.1"/>
+	</requires>
+	<extension point="xbmc.python.lyrics" library="default.py"/>
+	<extension point="xbmc.service" library="default.py"/>
+	<extension point="xbmc.addon.metadata">
+		<summary lang="be_BY">CU LRC Lyrics</summary>
+		<summary lang="bg_BG">CU LRC Лирики</summary>
+		<summary lang="ca_ES">CU LRC Lyrics</summary>
+		<summary lang="da_DK">CU LRC Lyrics</summary>
+		<summary lang="de_DE">CU LRC-Songtext</summary>
+		<summary lang="el_GR">Στίχοι CU LRC</summary>
+		<summary lang="en_GB">CU LRC Lyrics</summary>
+		<summary lang="en_NZ">CU LRC Lyrics</summary>
+		<summary lang="en_US">CU LRC Lyrics</summary>
+		<summary lang="es_ES">CU LRC Lyrics</summary>
+		<summary lang="fr_FR">CU LRC Lyrics</summary>
+		<summary lang="fr_CA">Paroles CU LRC</summary>
+		<summary lang="gl_ES">Letras de CU LRC</summary>
+		<summary lang="he_IL">CU LRC Lyrics</summary>
+		<summary lang="hr_HR">CU LRC tekstovi pjesama</summary>
+		<summary lang="hu_HU">CU LRC Dalszöveg</summary>
+		<summary lang="id_ID">Lirik CU LRC</summary>
+		<summary lang="it_IT">CU LRC Lyrics</summary>
+		<summary lang="ja_JP">CU LRC Lyrics</summary>
+		<summary lang="ko_KR">CU LRC Lyrics</summary>
+		<summary lang="lt_LT">CU LRC dainų žodžiai</summary>
+		<summary lang="nl_NL">CU LRC songteksten</summary>
+		<summary lang="nb_NO">CU LRC sangtekster</summary>
+		<summary lang="pl_PL">CU LRC Lyrics</summary>
+		<summary lang="pt_PT">CU LRC Lyrics</summary>
+		<summary lang="pt_BR">CU LRC Letras</summary>
+		<summary lang="ro_RO">Versuri CU LRC</summary>
+		<summary lang="sk_SK">CU LRC Lyrics</summary>
+		<summary lang="sl_SI">CU LRC Lyrics</summary>
+		<summary lang="sv_SE">CU LRC Lyrics</summary>
+		<summary lang="zh_CN">CU LRC Lyrics 歌词插件</summary>
+		<summary lang="zh_TW">CU LRC Lyrics 歌詞腳本</summary>
+		<description lang="be_BY">CU LRC Lyrics is a lyrics script for Kodi. It supports regular as well as LRC Lyrics. The script can search synchronized/unsynchronized lyrics embedded, from file or by scrapers. It can read .lrc/.txt lyrics file saved at the same path by same file name with .mp3(or other type of music).</description>
+		<description lang="bg_BG">CU LRC Лирики е добавка за лирики. Поддържа обикновени текстови файлове и .lrc файлове. Може да търси за синхронизирани/несинхронизирани лирики вградени в аудиофайловете или да ги извлича от различни източници. Може да прочита .lrc и .txt файлове съхраняващи лирики, които се намират в папката на дадения аудио файл (с разширение .mp3 например) и носят неговото име.</description>
+		<description lang="ca_ES">CU LRC Lyrics es un script de lletres de cançons per a Kodi. Suporta lletres normal tan com LRC Lyrics. El script busca lletres sincronitzades o no, incrustades al fitxer d'àudio, des de un altre fitxer o per scrapers. Pot llegir fitxers .lrc/.txt guardats al mateix directori i nom de fitxer amb .mp3(o un altre tipus de música).</description>
+		<description lang="da_DK">CU LRC Lyrics er et script til sangtekster til Kodi. Det understøtter almindelige såvel som LRC sangtekster. Script'et kan søge i synkroniserede/usynkroniserede sangtekster som er inkodede i filer eller ved hjælp af scrapere. Det kan læse .lrc/.txt sangtekstfiler som er gemt i den samme mappe og med samme filnavn som mp3'en (eller andre typer af musikfiler).</description>
+		<description lang="de_DE">CU LRC-Songtext ist ein Songtextskript für Kodi, das sowohl normale als auch LRC-Songtexte unterstützt. Das Skript kann nach synchronisierten/unsynchronisierten eingebetteten Songtexten von Datei oder Scraper suchen. Es kann .lrc/.txt-Songtextdateien lesen, die im gleichen Pfad und mit dem gleichen Dateinamen mit .mp3 (oder eine anderen Musikart) gespeichert wurden.</description>
+		<description lang="el_GR">Οι Στίχοι CU LRC είναι ένα script στίχων για το Kodi. Υποστηρίζει συνηθισμένους στίχους καθώς και Στίχους LRC. Το script μπορεί να αναζητήσει συγχρονισμένους και μη στίχους, ενσωματωμένους, από αρχεία ή από scraper. Μπορεί να διαβάσει αρχεία στίχων τύπου .lrc/.txt που βρίσκονται στον ίδιο φάκελο και έχουν το ίδιο όνομα με το .mp3 (ή άλλης κατάληξης μουσική).</description>
+		<description lang="en_GB">CU LRC Lyrics is a lyrics script for Kodi. It supports regular as well as LRC Lyrics. The script can search synchronized/unsynchronized lyrics embedded, from file or by scrapers. It can read .lrc/.txt lyrics file saved at the same path by same file name with .mp3(or other type of music).</description>
+		<description lang="en_NZ">CU LRC Lyrics is a lyrics script for Kodi. It supports regular as well as LRC Lyrics. The script can search synchronised/unsynchronised lyrics embedded, from file or by scrapers. It can read .lrc/.txt lyrics file saved at the same path by same file name with .mp3(or other type of music).</description>
+		<description lang="en_US">CU LRC Lyrics is a lyrics script for Kodi. It supports regular as well as LRC Lyrics. The script can search synchronized/unsynchronized lyrics embedded, from file or by scrapers. It can read .lrc/.txt lyrics file saved at the same path by same file name with .mp3(or other type of music).</description>
+		<description lang="es_ES">CU LRC Lyrics es un script de letras para Kodi. Es compatible tanto con letra regular como LRC Lyrics. El script puede buscar desde archivo o a través de scrapers letras incrustadas sincronizadas o no sincronizadas. Puede leer archivos .lrc/.txt guardados en la misma carpeta con el mismo nombre del archivo *.mp3 (u otro tipo de archivo de audio).</description>
+		<description lang="fr_FR">CU LRC Lyrics est un script pour gérer les paroles dans Kodi. Il supporte les formats de paroles habituels aussi bien que LRC. Le script peut chercher des paroles synchronisées/désynchronisées intégrées dans les fichier ou par collecteurs. Il peut lire les fichiers paroles .lrc/.txt stockés dans le même dossier et avec le même nom que le fichier .mp3 (ou autre type de format musical).</description>
+		<description lang="fr_CA">Paroles CU LRC est un script de paroles pour Kodi. Il prend en charge les paroles régulières et LRC. Le script peut rechercher des paroles synchronisées/désynchronisées intégrées, d'un fichier ou de récupérateurs. Il peut lire les fichiers de paroles .lrc/.txt enregistrés dans le même chemin et avec le me nom que le .mp3 (ou autres types de musique).</description>
+		<description lang="gl_ES">Letras CU LRC é un script de letras para Kodi. Soporta letras normais como as LRC. O script pode buscar letras sincronizadas/non sincronizadas incrustadas, ou buscar a partir dun ficheiro ou de scrapers. Pode ler letras de ficheiros .lrc/.txt gardados na mesma ruta do ficheiro .mp3 (ou outro tipo de música).</description>
+		<description lang="he_IL">CU LRC Lyrics הינו סקריפט מילות שירים עבור Kodi התומך בפורמט LRC והן בטקסט רגיל. הסקריפט מסוגל לחפש מילות שיר מסונכרות/לא מסונכרות המוטמעות בשיר, מקובץ מקומי או בעזרת סקרייפר. הסקריפט מסוגל לקרוא קובץ מילות שיר txt/lrc השמור באותו נתיב עם שם זהה לקובץ ה-mp3 (או סוג אחר של קובץ מוזיקה).</description>
+		<description lang="hr_HR">CU LRC tekstovi pjesama je skripta za Kodi. Podržavna redovne i LRC tekstove pjesama. Skripta može pretraživati usklađivati/uklanjati ugrađene tekstove pjesama, iz datoteke ili sakupljača. Može čitati .lrc/.txt datoteke tekstova pjesama spremljene u istu putanju s istim nazivom datoteke sa .mp3 (ili drugim vrstama glazbe).</description>
+		<description lang="hu_HU">A CU LRC Dalszöveg egy kiegészítő az Kodi-hez, ami támogatja  a hagyományos és az LRC dalszövegek keresését, megjelenítését. A dalszöveg lehet szinkronizált, vagy szinkronizálatlan, a zenefájlba beágyazott, vagy leolvasókkal letöltött, vagy akár származhat a zene könyvtárában található .lrc vagy .txt fájlokból is.</description>
+		<description lang="id_ID">Lirik CU LRC adalah script lirik untuk Kodi. Mendukung lirik regular maupun LRC. Script ini mampu mencari lirik dengan singkronisasi maupun tidak yang tercantum pada berkas atau melalui alat penyalin. Script dapat membaca berkas lirik .lrc/.txt yang disimpan di lokasi dan nama berkas yang sama dengan .mp3 (atau format musik lainnya).</description>
+		<description lang="it_IT">CU LRC Lyrics è uno script per i testi per Kodi. Supporta testi come LRC. Lo script può cercare testi incorporati sincronizzati e non, da file o tramite scapers. Legge file .lrc/.txt salvati nello stesso percorso e con lo stesso nome dell'.mp3 (o altri tipi di musica)</description>
+		<description lang="ja_JP">CU LRC LyricsはKodiのための歌詞表示スクリプトです。[CR]このスクリプトは、シンクロ歌詞、テキスト歌詞、埋め込み歌詞を、ファイルまたはWebから検索することができます。[CR]MP3（またはその他の音楽ファイル形式）と同じ場所、同じ名前で保存されたlrc / txt形式の歌詞を読み込むことができます。</description>
+		<description lang="ko_KR">CU LRC Lyrics는 Kodi를 위한 가사 수집기입니다. 일반 가사와 LRC 가사를 지원하며, 내장 가동기/비동기 가사를 검색하거나 파일 내장 가사를 찾습니다. mp3(또는 다른 형식의 음악 파일)와 같은 경로에 저장되어 있는 .lrc/.txt 형식의 가사를 읽어옵니다.</description>
+		<description lang="lt_LT">CU LRC Lyrics yra dainų žodžių atsiuntimo skriptas, skirtas Kodi. Palaikomi tiek įprasti, tiek LRC dainų žodžiai. Skriptas gali ieškoti sinchronizuotų / nesinchronizuotų dainų žodžių, integruotų failuose arba naudojant skreperius. Jis gali nuskaityti .lrc/.txt dainų žodžių failus, išsaugotus toje pačioje vietoje ir tokiu pačiu pavadinimu kaip ir .mp3 failas (ar kitokio muzikinio failo tipo).</description>
+		<description lang="nl_NL">CU LRC Lyrics is een script voor songteksten in Kodi. Het ondersteunt zowel reguliere als LRC songteksten. Het script ondersteunt gesynchroniseerde of ongesynchroniseerde songteksten die ingebed zijn in een bestand, in een los bestand staan of van een scraper. Het kan .lrc/.txt songtekst-bestanden lezen die opgeslagen zijn op hetzelfde pad en dezelfde bestandsnaam hebben als de .mp3 (of ander type bestand).</description>
+		<description lang="nb_NO">CU LRC Lyrics er et skript for å vise sangtekster i Kodi. Den støtter vanlige samt LRC sangtekster. Skriptet kan søke synkroniserte / usynkroniserte sangtekster innebygd, fra en fil eller via skrapere. Den kan lese .lrc / .txt filer som er lagret på den samme banen og med samme filnavn (.mp3 eller annen type musikk).</description>
+		<description lang="pl_PL">CU LRC Lyrics jest dodatkiem obsługującym teksty utworów dla Kodi. Obsługuje teksty utworów zarówno zwykłe jak i zsynchronizowane. Dodatek potrafi wyszukać teksty zapisane lokalnie, wbudowane w pliki utworów, a także pobierać je z Internetu. Potrafi wczytać teksty w formatach .lrc/.txt zapisane w tym samym folderze co pliku utworu .mp3 (lub innym wspierany formacie).</description>
+		<description lang="pt_PT">CU LRC Lyrics é um script de letras para o Kodi. Suporta letras normais e LRC. O script pode encontrar letras sincronizadas/dessincronizadas embutidas, ou procurar a partir de ficheiro ou de colectores. Pode ler letras de ficheiros .lrc/.txt guardados na mesma localização do ficheiro .mp3 (ou outro tipo de música).</description>
+		<description lang="pt_BR">CU LRC Lyrics é script de letras de músicas para Kodi. Ele suporta regular bem como Letras LRC. O script pode procurar por letras embutidas sincronizadas/dessincronizadas, de arquivos ou usando scrapers. Ele pode ler arquivos de letras .lrc/txt salvos no mesmo caminho com o mesmo nome do arquivo .mp3 (ou outro formato de música).</description>
+		<description lang="sk_SK">CU LRC Lyrics je doplnok poskytujúci texty skladieb pre Kodi. Podporuje bežné ako aj LRC formáty. Doplnok môže vyhľadávať synchronizované/nesynchronizované Texty skladieb vložené, v samostatnom súbore alebo cez sťahovače. Dokáže čítať .lrc/.txt súbory v rovnakom priečinku a s rovnakým názvom ako .mp3 súbor (alebo iný hudobný súbor).</description>
+		<description lang="sl_SI">CU LRC Lyrics je skripta za besedila pesmi za Kodi. Podpira redne kot tudi LRC besedila pesmi. Skripta lahko išče sinhronizirana/nesinhronizirana besedila pesmi, vgrajena, iz datoteke ali od ponudnikov. Bere lahko .lrc/.txt formate zapisa datotek iz iste mape kot je istoimenska datoteka .mp3 (ali drigi format zapisa glasbe).</description>
+		<description lang="sv_SE">CU LRC Lyrics är ett skript för Kodi. Det stödjer såväl vanliga som LRC texter. Skriptet kan söka synkroniserade/osynkroniserade texter inbäddade från fil eller från skraport. Det kan läsa .lrc/.txt filer sparade med samma sökväg och filnamn som .mp3 (eller annan typ av musik).</description>
+		<description lang="zh_CN">CU LRC Lyrics 是 Kodi 的歌词插件。它支持原 LRC Lyrics 歌词插件的功能。这个插件会搜索内嵌的、本地文件或通过刮削器获取同步/非同步歌词。它可以读取以相同文件名与歌曲文件保存在相同目录的 .lrc/.txt 歌词文件。</description>
+		<description lang="zh_TW">CU LRC Lyrics 是為 Kodi 而設的歌詞腳本。它支援一般格式的歌詞以及 LRC 格式的歌詞。此腳本能夠搜尋歌曲檔案內嵌歌詞的同步及非同步歌詞，同時也能使用刮削器在線搜尋、本地文件或通过刮削器获取同步/非同步歌词。它可以讀取放在同一個資料夾內，而又與歌曲相同命名的 .lrc/.txt 歌詞檔。</description>
+		<platform>all</platform>
+		<license>GPL-2.0-only</license>
+		<forum>https://forum.kodi.tv/showthread.php?tid=147340</forum>
+		<source>https://gitlab.com/ronie/script.cu.lrclyrics/</source>
+		<assets>
+			<icon>resources/icon.png</icon>
+		</assets>
+		<news>- fixed broken scrapers and added new ones</news>
+	</extension>
+</addon>
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/changelog.txt b/mythtv/programs/scripts/metadata/Music/lyrics/changelog.txt
new file mode 100644
index 00000000000..50c2e60ade1
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/changelog.txt
@@ -0,0 +1,488 @@
+v6.6.1
+- add supermusic scraper
+
+v6.6.0
+- removed minilyrics
+- removed gomaudio
+- fixed lyricsify
+- fixed lyricscom
+- fixed azlyrics
+- added lrclib
+- added megalobiz
+- added musixmatch lrc
+
+v6.5.2
+- remove invalid characters from filenames
+
+v6.5.1
+- fix crash if ctypes are not supported
+
+v6.5.0
+- add musixmatch scraper
+
+v6.4.1
+- fix genius scraper
+- fix darklyrics scraper
+
+v6.4.0
+- replace syair by lyricsify
+
+v6.3.14
+- fix Genius scraper
+
+v6.3.13
+- add separate options for writing lrc and txt lyrics
+
+v6.3.12
+- add separate options for reading .lrc and .txt files
+
+v6.3.11
+- fix syair scraper
+
+v6.3.10
+- remove quotes from filename
+
+v6.3.9
+- fix embedded lyrics
+
+v6.3.8
+- update japanese language file
+
+v6.3.7
+- python 3.9 compatibility
+
+v6.3.6
+- display artist name and track title in the lyrics dialog
+- add option to hide the lyrics background
+- before searching for lyrics, check if the song hasn't changed
+
+v6.3.5
+- don't search for next lyrics if we've already skipped to another track
+
+v6.3.4
+- fix potential crash in minlyrics scraper
+
+v6.3.3
+- fix clear lyric list when next song starts
+
+v6.3.2
+- fix lyric selection
+
+v6.3.1
+- skin cosmetics
+- move all scrapers to python requests
+- fix bug with monitor class
+
+v6.3.0
+- remove the need for list control 120
+- remove support for manually searching for lyrics
+- don't use window properties for inter-thread communication
+- remove thread locking
+
+v6.2.4
+- fix darklyrics scraper
+- really really fix reading embedded lyrics from remote files
+
+v6.2.3
+- add support for MusicPlayer.Lyrics infolabel
+- support lyrics from .ogg files
+- support lyrics from .ape files
+- really fix reading embedded lyrics from remote files
+- fix getting lyrics from memory
+
+v6.2.2
+- fix reading embedded lyrics from remote files
+
+v6.2.1
+- remove broken ttplayer scraper
+- fix genius scraper
+- fix manual sync
+- fix potential crash in minilyrics
+
+v6.2.0
+- refactor
+- update mutagen
+
+v6.1.0
+- really add syair scraper
+
+v6.0.10
+- Player.IsInternetStream bug workaround
+
+v6.0.9
+- don't fetch lyrics twice on windowopen and simultanious avstarted call
+
+v6.0.8
+- add syair scraper
+
+v6.0.7
+- fix osd would interfere with getting page lines
+
+v6.0.6
+- break from loop
+
+v6.0.5
+- fix music163 error
+
+v6.0.4
+- handle dialog.close()
+- create listitems offscreen
+
+v6.0.3
+- use threading lock
+
+v6.0.2
+- don't display/focus the first line from the start of the song
+
+v6.0.1
+- bump
+
+v5.5.14
+- stop searching for lyrics when exiting the visualization screen
+
+v5.5.13
+- fix negative offset
+
+v6.0.0
+- changes for python 3
+
+v5.5.10
+- delete lyrics from memory as well
+- re-search for lyrics if it was not found previously
+- fix lyrics from memory
+- fix lyricwiki scraper
+- more accurate results from ttplayer scraper
+- genius scraper strip blank lines
+- change manual sync range to +/ 20 secs
+
+v5.5.9
+- fix lyricsmode scraper
+
+v5.5.8
+- cosmetics
+
+v5.5.7
+- remove xiami scraper
+
+v5.5.6
+- language update
+
+v5.5.5
+- fix ttplayer scraper
+- fix lyricsmode scraper
+
+v5.5.4
+- fix xiami error
+
+v5.5.3
+- handle space in offset tag
+
+v5.5.2
+- move repo to gitlab
+
+v5.5.1
+- add azlyrics scraper
+- re-add minilyrics scraper
+- fix xiami scraper
+
+v5.5.0
+- remove broken scrapers
+
+v5.4.8
+- fix letssingit scraper
+- fix pvr radio
+
+v5.4.7
+- fix letssingit scraper
+- fix xiami scraper
+
+v5.4.6
+- fix embedded uslt lyrics
+
+v5.4.5
+- add test for xiami scraper
+
+v5.4.4
+- add xiami scraper
+
+v5.4.3
+- fix letssingit scraper
+
+v5.4.2
+- fix letssingit scraper
+
+v5.4.1
+- fix letssingit scraper
+
+v5.4.0
+- gomaudio: fix handling of accented characters
+- fix letssingit scraper
+- fix genius scraper
+
+v5.3.9
+- fix letssingit scraper
+- fix getting song title from internet streams
+- don't crash on offset tags without value
+
+v5.3.8
+- cosmetics
+
+v5.3.7
+- add support for synced lyrics in txxx tag
+
+v5.3.6
+- search local file even without song title
+
+v5.3.5
+- filter more lines
+
+v5.3.4
+- filter 'attribution' lines from lyrics
+
+v5.3.3
+- added option to delete lyrics file
+
+v5.3.2
+- save manual sync offset to lrc file
+
+v5.3.1
+- silence notifications
+- highlight selected lyric in list
+
+v5.3.0
+- add manual sync option
+
+v5.2.6
+- fix incorrect results from gomaudio for streaming audio
+
+v5.2.5
+- add global offset option
+
+v5.2.4
+- offset needs to be substracted from the timestamp
+
+v5.2.3
+- cosmetics
+
+v5.2.2
+- add support for lrc offset
+
+v5.2.1
+- sync lrc lyrics with streaming radio
+
+v5.2.0
+- add lyrics.com scraper
+- add letssingit scraper
+
+v5.1.2
+- fix minilyrics scraper
+
+v5.1.1
+- fix baidu lrc scraper
+- fix alsong lrc scraper
+
+v5.1.0
+- fix broken text scrapers
+
+v5.0.9
+- improve stripping of korean text
+- fix parsing lrc timestamps
+- strip lines with duplicate timestamps
+
+v5.0.8
+- fix genius scraper
+- add more accurate matching to genius scraper
+
+v5.0.7
+- add additional listitem properties for external use
+
+v5.0.6
+- fix focussed line selection
+- more accurate time syncing
+
+v5.0.5
+- add support for internet streams
+
+v5.0.4
+- add lrc window property
+
+v5.0.3
+- fix embedded lyrics search
+
+v5.0.2
+- a bit more logging
+
+v5.0.1
+- fixed lyricwiki scraper
+
+v5.0.0
+- remove simplejson support
+- update skin
+- add another file naming template
+- fix for Artist/Album/Track - title.ext
+- also strip korean text
+
+v4.1.5
+- language update
+- cleanup
+
+v4.1.4
+- fix detection of flac lyrics
+
+v4.1.3
+- fix error when clicking on a txt based lyric
+
+v4.1.2
+- update mutagen library
+
+v4.1.1
+- option to remove chinese text from lyrics
+- fix only accept TXXX:lyrics tag
+
+v4.1.0
+- improve embedded mp3 lyrics support
+
+v4.0.2
+- added scraper for genius.com
+- removed lyricstime scraper
+
+v4.0.1
+- update menu action code for jarvis
+
+v3.2.0
+- remove broken lrc scrapers
+- fix unicodedecode crash in gomaudio
+
+v3.1.6
+- fix lyricwiki scraper
+
+v3.1.5
+- fix polish language file
+
+v3.1.4
+- add option to hide notifications
+
+v3.1.3
+- Update background media check to PlayingBackgroundMedia
+
+v3.1.2
+- Clean up the Monitor and Player classes on exit
+
+v3.1.1
+- Do not try and get lyrics if TvTunes is running
+
+v3.1.0
+- add support for mp4 files
+
+v3.0.11
+- properly handle lyrics in the uslt tag
+
+v3.0.10
+- add support for lrc lyrics inside the uslt tag
+
+v3.0.9
+- fix detection od osd key
+
+v3.0.8
+- allow codec info to be shown
+
+v3.0.7
+- better support for multiple artists
+
+v3.0.6
+- fixed missing string in language file
+
+v3.0.5
+- updated language files from Transifex
+
+v3.0.4
+- deprecate xbmc.abortRequested
+
+v3.0.3
+- re-label service setting
+
+v3.0.2
+- fix detection of text based Lyrics3 tags
+- fix some lrc lyrics did not work (time tag not recognised)
+
+v3.0.1
+- fix lyricwiki scraper
+
+v3.0.0
+- kodi name change
+
+v2.0.10
+- several fixes
+
+v2.0.9
+- additional addon tags
+
+v2.0.8
+- add support for flac tags
+- add do_not_analyze property for other addons
+
+v2.0.7
+- make music osd accesible
+- show gui when user clicks osd button
+
+v2.0.6
+- add xml header
+
+v2.0.5
+- fix encoding issue
+
+v2.0.4
+- gotham release
+
+v2.0.3
+- gui cleanup
+
+v2.0.2
+- fix crash when failing to read lyrics file
+- fixed update scraper list when settings change
+
+v2.0.1
+- fixed don't crash when trying to get embedded lyrics from online streams
+- add option to clean song title
+
+v2.0.0
+- convert script to a service
+- auto-hide window when no lyrics are found
+
+v1.0.7
+- fixed blank string in settings
+- changed txxx field now supports both synchronised and regular lyrics
+- fixed potential crash due to unhandled exceptions
+
+v1.0.6
+- fixed potential import of a third party scrapers module
+
+v1.0.5
+- fixed can't show lyric right after reselect in list, need reset control
+- handle encode error in scraper GomAudio
+- added option to save lyrics to song folder
+
+v1.0.4
+- fixed saving lyrics
+- add Korean scraper(Alsong, GomAudio), credit for hojel
+
+v1.0.3
+- language update
+
+v1.0.2
+- add a script running window property
+- added lyrics source as a window property
+- make lyrics available as a window property
+- fixed would fail for users with a special char in their username
+
+v1.0.1
+- fixed can't change lyric for track in cue/ape file
+- fixed decode error in scrape minilyrics
+- added requires for script.module.chardet
+
+v1.0.0
+- initial release
+
+v0.0.1
+- merge cu and lrc lyrics scripts
+
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/default.py b/mythtv/programs/scripts/metadata/Music/lyrics/default.py
new file mode 100644
index 00000000000..8a9251c3b6c
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/default.py
@@ -0,0 +1,29 @@
+from lib.utils import *
+
+log('script version %s started' % ADDONVERSION, debug=True)
+
+# kodi startup, service is disabled, exit
+if sys.argv == [''] and not ADDON.getSettingBool('service'):
+    log('service not enabled', debug=True)
+
+# scraper test, run from addon settings
+elif len(sys.argv) == 2 and sys.argv[1] == 'test':
+    from lib.scrapertest import *
+    test_scrapers()
+
+# kodi startup, service is enabled, start main loop
+elif not WIN.getProperty('culrc.running') == 'true':
+    from lib import gui
+    gui.MAIN()
+
+# service is running, but gui was exited, user clicked lyrics button, reshow gui
+elif not WIN.getProperty('culrc.guirunning') == 'TRUE':
+    WIN.setProperty('culrc.force','TRUE')
+
+# service is running, gui is viisible, user clicked the lyrics button, do nothing
+else:
+    log('script already running', debug=True)
+    if not ADDON.getSettingBool('silent'):
+        xbmcgui.Dialog().notification(ADDONNAME, LANGUAGE(32158), time=2000, sound=False)
+
+log('script version %s ended' % ADDONVERSION, debug=True)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/audiofile.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/audiofile.py
new file mode 100644
index 00000000000..b59ecadac60
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/audiofile.py
@@ -0,0 +1,127 @@
+#-*- coding: UTF-8 -*-
+"""
+read audio stream from audio file
+"""
+
+import os
+import struct
+import xbmcvfs
+
+class UnknownFormat(Exception):pass
+class FormatError(Exception):pass
+
+class AudioFile(object):
+    f = None
+    audioStart = 0
+
+    def AudioFile(self):
+        self.f = None
+        self.audioStart = 0
+
+    def Open(self,filename):
+        self.audioStart = 0
+        self.f = xbmcvfs.File(filename)
+        ext = os.path.splitext(filename)[1].lower()
+        if   ext == '.mp3':  self.AnalyzeMp3()
+        elif ext == '.ogg':  self.AnalyzeOgg()
+        elif ext == '.wma':  self.AnalyzeWma()
+        #elif ext == '.flac':  self.AnalyzeFlac()
+        elif ext == '.flac': pass
+        elif ext == '.ape': pass
+        elif ext == '.wav': pass
+        else: # not supported format
+            self.f.close()
+            self.f = None
+            raise UnknownFormat
+
+    def Close(self):
+        self.f.close()
+        self.f = None
+
+    def ReadAudioStream(self, len, offset=0):
+        self.f.seek(self.audioStart+offset, 0)
+        return self.f.readBytes(len)
+
+    def AnalyzeMp3(self):
+        # Searching ID3v2 tag
+        while True:
+            buf = self.f.readBytes(3)
+            if len(buf) < 3 or self.f.tell() > 50000:
+                # ID tag is not found
+                self.f.seek(0,0)
+                self.audioStart = 0
+                return
+            if buf == b'ID3':
+                self.f.seek(3,1)     # skip version/flag
+                # ID length (synchsafe integer)
+                tl = struct.unpack('4b', self.f.readBytes(4))
+                taglen = (tl[0]<<21)|(tl[1]<<14)|(tl[2]<<7)|tl[3]
+                self.f.seek(taglen,1)
+                break
+            self.f.seek(-2,1)
+        # Searching MPEG SOF
+        while True:
+            buf = self.f.readBytes(1)
+            if len(buf) < 1 or self.f.seek(0,1) > 1000000:
+                raise FormatError
+            if buf == b'\xff':
+                rbit = struct.unpack('B',self.f.readBytes(1))[0] >> 5
+                if rbit == 7:   # 11 1's in total
+                    self.f.seek(-2,1)
+                    self.audioStart = self.f.tell()
+                    return
+
+    def AnalyzeOgg(self):
+        # Parse page (OggS)
+        while True:
+            buf = self.f.readBytes(27)    # header
+            if len(buf) < 27 or self.f.tell() > 50000:
+                # parse error
+                raise FormatError
+            if buf[0:4] != b'OggS':
+                # not supported page format
+                raise UnknownFormat
+            numseg = struct.unpack('B', buf[26])[0]
+            #print "#seg: %d" % numseg
+
+            segtbl = struct.unpack('%dB'%numseg, self.f.readBytes(numseg))    # segment table
+            for seglen in segtbl:
+                buf = self.f.readBytes(7)    # segment header
+                #print "segLen(%s): %d" % (buf[1:7],seglen)
+                if buf == b"\x05vorbis":
+                    self.f.seek(-7,1)   # rollback
+                    self.audioStart = self.f.tell()
+                    return
+                self.f.seek(seglen-7,1) # skip to next segment
+
+    def AnalyzeWma(self):
+        # Searching GUID
+        while True:
+            buf = self.f.readBytes(16)
+            if len(buf) < 16 or self.f.tell() > 50000:
+                raise FormatError
+            guid = buf.encode("hex");
+            if guid == "3626b2758e66cf11a6d900aa0062ce6c":
+                # ASF_Data_Object
+                self.f.seek(-16,1)     # rollback
+                self.audioStart = self.f.tell()
+                return
+            else:
+                objlen = struct.unpack('<Q', self.f.readBytes(8))[0]
+                self.f.seek(objlen-24,1)     # jump to next object
+
+    def AnalyzeFlac(self):
+        if self.f.readBytes(4) != b'fLaC':
+            raise UnknownFormat
+        # Searching GUID
+        while True:
+            buf = self.f.readBytes(4)
+            if len(buf) < 16 or self.f.tell() > 50000:
+                # not found
+                raise FormatError
+            metalen = buf[1] | (buf[2]<<8) | (buf[3]<<16);
+            self.f.seek(metalen,1)   # skip this metadata block
+            if buf[0] & 0x80:
+                # it was the last metadata block
+                self.audioStart = self.f.tell()
+                return
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/lyricsScraper.py
new file mode 100644
index 00000000000..456c04a5503
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/alsong/lyricsScraper.py
@@ -0,0 +1,65 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for http://lyrics.alsong.co.kr/
+driip
+'''
+
+import sys
+import socket
+import urllib.request
+import difflib
+import xml.dom.minidom as xml
+from utilities import *
+
+__title__ = 'Alsong'
+__priority__ = '150'
+__lrc__ = True
+
+socket.setdefaulttimeout(10)
+
+ALSONG_URL = 'http://lyrics.alsong.net/alsongwebservice/service1.asmx'
+
+ALSONG_TMPL = '''\
+<?xml version='1.0' encoding='UTF-8'?>
+<SOAP-ENV:Envelope xmlns:SOAP-ENV='http://www.w3.org/2003/05/soap-envelope' xmlns:SOAP-ENC='http://www.w3.org/2003/05/soap-encoding' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' xmlns:xsd='http://www.w3.org/2001/XMLSchema' xmlns:ns2='ALSongWebServer/Service1Soap' xmlns:ns1='ALSongWebServer' xmlns:ns3='ALSongWebServer/Service1Soap12'>
+<SOAP-ENV:Body>
+    <ns1:GetResembleLyric2>
+    <ns1:stQuery>
+        <ns1:strTitle>%s</ns1:strTitle>
+        <ns1:strArtistName>%s</ns1:strArtistName>
+        <ns1:nCurPage>0</ns1:nCurPage>
+    </ns1:stQuery>
+    </ns1:GetResembleLyric2>
+</SOAP-ENV:Body>
+</SOAP-ENV:Envelope>
+'''
+
+
+class LyricsFetcher:
+    def __init__(self):
+        self.base_url = 'http://lyrics.alsong.co.kr/'
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title))
+        lyrics = Lyrics()
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            headers = {'Content-Type':'text/xml; charset=utf-8'}
+            request = urllib.request.Request(ALSONG_URL, bytes(ALSONG_TMPL % (song.title,song.artist), 'utf-8'), headers)
+            response = urllib.request.urlopen(request)
+            Page = response.read().decode('utf-8')
+        except:
+            return        
+        tree = xml.parseString(Page)
+
+        try:
+            name = tree.getElementsByTagName('strArtistName')[0].childNodes[0].data
+            track = tree.getElementsByTagName('strTitle')[0].childNodes[0].data
+        except:
+            return
+        if (difflib.SequenceMatcher(None, song.artist.lower(), name.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, song.title.lower(), track.lower()).ratio() > 0.8):
+            lyr = tree.getElementsByTagName('strLyric')[0].childNodes[0].data.replace('<br>','\n')
+            lyrics.lyrics = lyr
+            return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/lyricsScraper.py
new file mode 100644
index 00000000000..37792457f55
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/baidu/lyricsScraper.py
@@ -0,0 +1,51 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for http://www.baidu.com
+
+ronie
+'''
+
+import urllib.request
+import socket
+import re
+import chardet
+import difflib
+from utilities import *
+
+__title__ = 'Baidu'
+__priority__ = '130'
+__lrc__ = True
+
+socket.setdefaulttimeout(10)
+
+class LyricsFetcher:
+    def __init__(self):
+        self.BASE_URL = 'http://music.baidu.com/search/lrc?key=%s-%s'
+        self.LRC_URL = 'http://music.baidu.com%s'
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title))
+        lyrics = Lyrics()
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            url = self.BASE_URL % (song.title, song.artist)
+            data = urllib.request.urlopen(url).read().decode('utf-8')
+            songmatch = re.search('song-title.*?<em>(.*?)</em>', data, flags=re.DOTALL)
+            track = songmatch.group(1)
+            artistmatch = re.search('artist-title.*?<em>(.*?)</em>', data, flags=re.DOTALL)
+            name = artistmatch.group(1)
+            urlmatch = re.search("down-lrc-btn.*?':'(.*?)'", data, flags=re.DOTALL)
+            found_url = urlmatch.group(1)
+            if (difflib.SequenceMatcher(None, song.artist.lower(), name.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, song.title.lower(), track.lower()).ratio() > 0.8):
+                lyr = urllib.request.urlopen(self.LRC_URL % found_url).read()
+            else:
+                return
+        except:
+            return
+
+        enc = chardet.detect(lyr)
+        lyr = lyr.decode(enc['encoding'], 'ignore')
+        lyrics.lyrics = lyr
+        return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/lyricsScraper.py
new file mode 100644
index 00000000000..1700d232e16
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/gomaudio/lyricsScraper.py
@@ -0,0 +1,101 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for http://newlyrics.gomtv.com/
+
+edge
+'''
+
+import sys
+import hashlib
+import requests
+import urllib.parse
+import re
+import unicodedata
+from lib.utils import *
+from lib.audiofile import AudioFile
+
+__title__ = 'GomAudio'
+__priority__ = '110'
+__lrc__ = True
+
+
+GOM_URL = 'http://newlyrics.gomtv.com/cgi-bin/lyrics.cgi?cmd=find_get_lyrics&file_key=%s&title=%s&artist=%s&from=gomaudio_local'
+
+def remove_accents(data):
+    nfkd_data = unicodedata.normalize('NFKD', data)
+    return u"".join([c for c in nfkd_data if not unicodedata.combining(c)])
+
+
+class gomClient(object):
+    '''
+    privide Gom specific function, such as key from mp3
+    '''
+    @staticmethod
+    def GetKeyFromFile(file):
+        musf = AudioFile()
+        musf.Open(file)
+        buf = musf.ReadAudioStream(100*1024)	# 100KB from audio data
+        musf.Close()
+        # buffer will be empty for streaming audio
+        if not buf:
+            return
+        # calculate hashkey
+        m = hashlib.md5()
+        m.update(buf)
+        return m.hexdigest()
+
+    @staticmethod
+    def mSecConv(msec):
+        s,ms = divmod(msec/10,100)
+        m,s = divmod(s,60)
+        return m,s,ms
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.base_url = 'http://newlyrics.gomtv.com/'
+
+    def get_lyrics(self, song, key=None, ext=None):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            if not ext:
+               ext = os.path.splitext(song.filepath)[1].lower()
+            sup_ext = ['.mp3', '.ogg', '.wma', '.flac', '.ape', '.wav']
+            if ext in sup_ext and key == None:
+                key = gomClient.GetKeyFromFile(song.filepath)
+            if not key:
+                return None
+            url = GOM_URL %(key, urllib.parse.quote(remove_accents(song.title).encode('euc-kr')), urllib.parse.quote(remove_accents(song.artist).encode('euc-kr')))
+            response = requests.get(url, timeout=10)
+            response.encoding = 'euc-kr'
+            Page = response.text
+        except:
+            log('%s: %s::%s (%d) [%s]' % (
+                    __title__, self.__class__.__name__,
+                    sys.exc_info()[2].tb_frame.f_code.co_name,
+                    sys.exc_info()[2].tb_lineno,
+                    sys.exc_info()[1]
+               ), debug=self.DEBUG)
+            return None
+        if Page[:Page.find('>')+1] != '<lyrics_reply result="0">':
+            return None
+        syncs = re.compile('<sync start="(\d+)">([^<]*)</sync>').findall(Page)
+        lyrline = []
+        lyrline.append('[ti:%s]' %song.title)
+        lyrline.append('[ar:%s]' %song.artist)
+        for sync in syncs:
+            # timeformat conversion
+            t = '%02d:%02d.%02d' % gomClient.mSecConv(int(sync[0]))
+            # unescape string
+            try:
+                s = sync[1].replace('&apos;',"'").replace('&quot;','"')
+                lyrline.append('[%s]%s' %(t,s))
+            except:
+                pass
+        lyrics.lyrics = '\n'.join(lyrline)
+        return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/lyricsScraper.py
new file mode 100644
index 00000000000..5291abc9f3f
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/lyricwiki/lyricsScraper.py
@@ -0,0 +1,67 @@
+#-*- coding: UTF-8 -*-
+import sys
+import re
+import json
+import requests
+from urllib.error import HTTPError
+import urllib.parse
+from html.parser import HTMLParser
+import xbmc
+import xbmcaddon
+from lib.utils import *
+
+__title__ = 'lyricwiki'
+__priority__ = '200'
+__lrc__ = False
+
+LIC_TXT = 'we are not licensed to display the full lyrics for this song at the moment'
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.url = 'http://lyrics.wikia.com/api.php?func=getSong&artist=%s&song=%s&fmt=realjson'
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            req = requests.get(self.url % (urllib.parse.quote(song.artist), urllib.parse.quote(song.title)), timeout=10)
+            response = req.text
+        except:
+            return None
+        data = json.loads(response)
+        try:
+            self.page = data['url']
+        except:
+            return None
+        if not self.page.endswith('action=edit'):
+            log('%s: search url: %s' % (__title__, self.page), debug=self.DEBUG)
+            try:
+                req = requests.get(self.page, timeout=10)
+                response = req.text
+            except requests.exceptions.HTTPError as error:  # strange... sometimes lyrics are returned with a 404 error
+                if error.response.status_code == 404:
+                    response = error.response.text
+                else:
+                    return None
+            except:
+                return None
+            matchcode = re.search("class='lyricbox'>(.*?)<div", response)
+            try:
+                lyricscode = (matchcode.group(1))
+                htmlparser = HTMLParser()
+                lyricstext = htmlparser.unescape(lyricscode).replace('<br />', '\n')
+                lyr = re.sub('<[^<]+?>', '', lyricstext)
+                if LIC_TXT in lyr:
+                    return None
+                lyrics.lyrics = lyr
+                return lyrics
+            except:
+                return None
+        else:
+            return None
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/lyricsScraper.py
new file mode 100644
index 00000000000..3bed05a2fa2
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/minilyrics/lyricsScraper.py
@@ -0,0 +1,161 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for http://www.viewlyrics.com
+
+PedroHLC
+https://github.com/PedroHLC/ViewLyricsOpenSearcher
+
+rikels
+https://github.com/rikels/LyricsSearch
+'''
+
+import re
+import hashlib
+import difflib
+import chardet
+import requests
+from lib.utils import *
+
+__title__ = 'MiniLyrics'
+__priority__ = '100'
+__lrc__ = True
+
+
+class MiniLyrics(object):
+    '''
+    Minilyrics specific functions
+    '''
+    @staticmethod
+    def hexToStr(hexx):
+        string = ''
+        i = 0
+        while (i < (len(hexx) - 1)):
+            string += chr(int(hexx[i] + hexx[i + 1], 16))
+            i += 2
+        return string
+
+    @staticmethod
+    def vl_enc(data, md5_extra):
+        datalen = len(data)
+        md5 = hashlib.md5()
+        md5.update(data + md5_extra)
+        hasheddata = MiniLyrics.hexToStr(md5.hexdigest())
+        j = 0
+        i = 0
+        while (i < datalen):
+            try:
+                j += data[i]
+            except TypeError:
+                j += ord(data[i])
+            i += 1
+        magickey = chr(int(round(float(j) / float(datalen))))
+        encddata = list(range(len(data)))
+        if isinstance(magickey, int):
+            pass
+        else:
+            magickey = ord(magickey)
+        for i in range(datalen):
+            if isinstance(data[i], int):
+                encddata[i] = data[i] ^ magickey
+            else:
+                encddata[i] = ord(data[i]) ^ magickey
+        try:
+            result = '\x02' + chr(magickey) + '\x04\x00\x00\x00' + str(hasheddata) + bytearray(encddata).decode('utf-8')
+        except UnicodeDecodeError:
+            ecd = chardet.detect(bytearray(encddata))
+            if ecd['encoding']:
+                try:
+                    result = '\x02' + chr(magickey) + '\x04\x00\x00\x00' + str(hasheddata) + bytearray(encddata).decode(ecd['encoding'])
+                except:
+                    result = '\x02' + chr(magickey) + '\x04\x00\x00\x00' + str(hasheddata) + "".join(map(chr, bytearray(encddata)))
+            else:
+                result = '\x02' + chr(magickey) + '\x04\x00\x00\x00' + str(hasheddata) + "".join(map(chr, bytearray(encddata)))
+        return result
+
+    @staticmethod
+    def vl_dec(data):
+        magickey = data[1]
+        result = ""
+        i = 22
+        datalen = len(data)
+        if isinstance(magickey, int):
+            pass
+        else:
+            magickey = ord(magickey)
+        for i in range(22, datalen):
+            if isinstance(data[i], int):
+                result += chr(data[i] ^ magickey)
+            else:
+                result += chr(ord(data[i]) ^ magickey)
+        return result
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.proxy = None
+
+    def htmlDecode(self,string):
+        entities = {'&apos;':'\'','&quot;':'"','&gt;':'>','&lt;':'<','&amp;':'&'}
+        for i in entities:
+            string = string.replace(i,entities[i])
+        return string
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        search_url = 'http://search.crintsoft.com/searchlyrics.htm'
+        search_query_base = "<?xml version='1.0' encoding='utf-8' standalone='yes' ?><searchV1 client=\"ViewLyricsOpenSearcher\" artist=\"{artist}\" title=\"{title}\" OnlyMatched=\"1\" />"
+        search_useragent = 'MiniLyrics'
+        search_md5watermark = b'Mlv1clt4.0'
+        search_encquery = MiniLyrics.vl_enc(search_query_base.format(artist=song.artist, title=song.title).encode('utf-8'), search_md5watermark)
+        headers = {"User-Agent": "{ua}".format(ua=search_useragent),
+                   "Content-Length": "{content_length}".format(content_length=len(search_encquery)),
+                   "Connection": "Keep-Alive",
+                   "Expect": "100-continue",
+                   "Content-Type": "application/x-www-form-urlencoded"
+                   }
+        try:
+            request = requests.post(search_url, data=search_encquery, headers=headers, timeout=10)
+            search_result = request.text
+        except:
+            return
+        rawdata = MiniLyrics.vl_dec(search_result)
+        # might be a better way to parse the data 
+        lrcdata = rawdata.replace('\x00', '*')
+        artistmatch = re.search('artist\*(.*?)\*',lrcdata)
+        if not artistmatch:
+            return
+        titlematch = re.search('title\*(.*?)\*',lrcdata)
+        if not titlematch:
+            return
+        artist = artistmatch.group(1)
+        title = titlematch.group(1)
+        links = []
+        if (difflib.SequenceMatcher(None, song.artist.lower(), artist.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, song.title.lower(), title.lower()).ratio() > 0.8):
+            results = re.findall('[a-z0-9/_]*?\.lrc', lrcdata)
+            for item in results:
+                links.append((artist + ' - ' + title, item, artist, title))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        lyr = self.get_lyrics_from_list(links[0])
+        if not lyr:
+            return None
+        lyrics.lyrics = lyr
+        return lyrics
+
+    def get_lyrics_from_list(self, link):
+        title,url,artist,song = link
+        try:
+            f = requests.get('http://search.crintsoft.com/l/' + url, timeout=10)
+            lyrics = f.content
+        except:
+            return
+        enc = chardet.detect(lyrics)
+        lyrics = lyrics.decode(enc['encoding'], 'ignore')
+        return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/lyricsScraper.py
new file mode 100644
index 00000000000..15f108347cc
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/ttplayer/lyricsScraper.py
@@ -0,0 +1,207 @@
+#-*- coding: UTF-8 -*-
+"""
+Scraper for http://lrcct2.ttplayer.com/
+
+taxigps
+"""
+
+import os
+import socket
+import urllib.request
+import re
+import random
+import difflib
+from lib.utils import *
+
+__title__ = "TTPlayer"
+__priority__ = '110'
+__lrc__ = True
+
+UserAgent = 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0'
+
+socket.setdefaulttimeout(10)
+
+LYRIC_TITLE_STRIP=["\(live[^\)]*\)", "\(acoustic[^\)]*\)",
+                    "\([^\)]*mix\)", "\([^\)]*version\)",
+                    "\([^\)]*edit\)", "\(feat[^\)]*\)"]
+LYRIC_TITLE_REPLACE=[("/", "-"),(" & ", " and ")]
+LYRIC_ARTIST_REPLACE=[("/", "-"),(" & ", " and ")]
+
+class ttpClient(object):
+    '''
+    privide ttplayer specific function, such as encoding artist and title,
+    generate a Id code for server authorizition.
+    (see http://ttplyrics.googlecode.com/svn/trunk/crack) 
+    '''
+    @staticmethod
+    def CodeFunc(Id, data):
+        '''
+        Generate a Id Code
+        These code may be ugly coz it is translated
+        from C code which is translated from asm code
+        grabed by ollydbg from ttp_lrcs.dll.
+        (see http://ttplyrics.googlecode.com/svn/trunk/crack) 
+        '''
+        length = len(data)
+
+        tmp2=0
+        tmp3=0
+
+        tmp1 = (Id & 0x0000FF00) >> 8                                                   #右移8位后为x0000015F
+
+            #tmp1 0x0000005F
+        if ((Id & 0x00FF0000) == 0):
+            tmp3 = 0x000000FF & ~tmp1                                                   #CL 0x000000E7
+        else:
+            tmp3 = 0x000000FF & ((Id & 0x00FF0000) >> 16)                               #右移16后为x00000001
+
+        tmp3 = tmp3 | ((0x000000FF & Id) << 8)                                          #tmp3 0x00001801
+        tmp3 = tmp3 << 8                                                                #tmp3 0x00180100
+        tmp3 = tmp3 | (0x000000FF & tmp1)                                               #tmp3 0x0018015F
+        tmp3 = tmp3 << 8                                                                #tmp3 0x18015F00
+        if ((Id & 0xFF000000) == 0) :
+            tmp3 = tmp3 | (0x000000FF & (~Id))                                          #tmp3 0x18015FE7
+        else :
+            tmp3 = tmp3 | (0x000000FF & (Id >> 24))                                     #右移24位后为0x00000000
+
+        #tmp3   18015FE7
+        
+        i=length-1
+        while(i >= 0):
+            char = ord(data[i])
+            if char >= 0x80:
+                char = char - 0x100
+            tmp1 = (char + tmp2) & 0x00000000FFFFFFFF
+            tmp2 = (tmp2 << (i%2 + 4)) & 0x00000000FFFFFFFF
+            tmp2 = (tmp1 + tmp2) & 0x00000000FFFFFFFF
+            #tmp2 = (ord(data[i])) + tmp2 + ((tmp2 << (i%2 + 4)) & 0x00000000FFFFFFFF)
+            i -= 1
+
+        #tmp2 88203cc2
+        i=0
+        tmp1=0
+        while(i<=length-1):
+            char = ord(data[i])
+            if char >= 128:
+                char = char - 256
+            tmp7 = (char + tmp1) & 0x00000000FFFFFFFF
+            tmp1 = (tmp1 << (i%2 + 3)) & 0x00000000FFFFFFFF
+            tmp1 = (tmp1 + tmp7) & 0x00000000FFFFFFFF
+            #tmp1 = (ord(data[i])) + tmp1 + ((tmp1 << (i%2 + 3)) & 0x00000000FFFFFFFF)
+            i += 1
+
+        #EBX 5CC0B3BA
+
+        #EDX = EBX | Id
+        #EBX = EBX | tmp3
+        tmp1 = (((((tmp2 ^ tmp3) & 0x00000000FFFFFFFF) + (tmp1 | Id)) & 0x00000000FFFFFFFF) * (tmp1 | tmp3)) & 0x00000000FFFFFFFF
+        tmp1 = (tmp1 * (tmp2 ^ Id)) & 0x00000000FFFFFFFF
+
+        if tmp1 > 0x80000000:
+            tmp1 = tmp1 - 0x100000000
+        return tmp1
+    
+    @staticmethod
+    def EncodeArtTit(data):
+        data = data.encode('UTF-16').decode('UTF-16')
+        rtn = ''
+        for i in range(len(data)):
+            rtn += '%02x00' % ord(data[i])
+        return rtn
+
+
+class LyricsFetcher:
+    def __init__(self):
+        self.LIST_URL = 'http://ttlrccnc.qianqian.com/dll/lyricsvr.dll?sh?Artist=%s&Title=%s&Flags=0'
+        self.LYRIC_URL = 'http://ttlrccnc.qianqian.com/dll/lyricsvr.dll?dl?Id=%d&Code=%d&uid=01&mac=%012x'
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title))
+        lyrics = Lyrics()
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = song.artist
+        title = song.title
+        # replace ampersands and the like
+        for exp in LYRIC_ARTIST_REPLACE:
+                p = re.compile(exp[0])
+                artist = p.sub(exp[1], artist)
+        for exp in LYRIC_TITLE_REPLACE:
+                p = re.compile(exp[0])
+                title = p.sub(exp[1], title)
+
+        # strip things like "(live at Somewhere)", "(accoustic)", etc
+        for exp in LYRIC_TITLE_STRIP:
+            p = re.compile(exp)
+            title = p.sub('', title)
+
+        # compress spaces
+        title = title.strip().replace('`','').replace('/','')
+        artist = artist.strip().replace('`','').replace('/','')
+
+        try:
+            url = self.LIST_URL %(ttpClient.EncodeArtTit(artist.replace(' ','').lower()), ttpClient.EncodeArtTit(title.replace(' ','').lower()))
+            f = urllib.request.urlopen(url)
+            Page = f.read().decode('utf-8')
+        except:
+            log("%s: %s::%s (%d) [%s]" % (
+                   __title__, self.__class__.__name__,
+                   sys.exc_info()[2].tb_frame.f_code.co_name,
+                   sys.exc_info()[2].tb_lineno,
+                   sys.exc_info()[1]
+                  ))
+            return None
+        links_query = re.compile('<lrc id=\"(.*?)\" artist=\"(.*?)\" title=\"(.*?)\"></lrc>')
+        urls = re.findall(links_query, Page)
+        links = []
+        for x in urls:
+            if (difflib.SequenceMatcher(None, artist.lower(), x[1].lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, title.lower(), x[2].lower()).ratio() > 0.8):
+                links.append((x[1] + ' - ' + x[2], x[0], x[1], x[2]))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr and lyr.startswith('['):
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,Id,artist,song = link
+        try:
+
+            url = self.LYRIC_URL %(int(Id),ttpClient.CodeFunc(int(Id), artist + song), random.randint(0,0xFFFFFFFFFFFF))
+            log('%s: search url: %s' % (__title__, url))
+            header = {'User-Agent':UserAgent}
+            req = urllib.request.Request(url, headers=header)
+            f = urllib.request.urlopen(req)
+            Page = f.read().decode('utf-8')
+        except:
+            log("%s: %s::%s (%d) [%s]" % (
+                   __title__, self.__class__.__name__,
+                   sys.exc_info()[2].tb_frame.f_code.co_name,
+                   sys.exc_info()[2].tb_lineno,
+                   sys.exc_info()[1]
+                  ))
+            return None
+        # ttplayer occasionally returns incorrect lyrics. if we have a 'ti' and/or an 'ar' tag with a value we can check if they match the title and artist
+        if Page.startswith('[ti:'):
+            check = Page.split('\n')
+            if not check[0][4:-1] == '':
+                if (difflib.SequenceMatcher(None, song.lower(), check[0][4:-1].lower()).ratio() > 0.8):
+                    return Page
+                else:
+                    return ''
+            if check[1][0:4] == '[ar:' and not check[1][4:-1] == '':
+                if (difflib.SequenceMatcher(None, artist.lower(), check[1][4:-1].lower()).ratio() > 0.8):
+                    return Page
+                else:
+                    return ''
+            else:
+                return Page
+        elif Page.startswith('['):
+            return Page
+        return ''
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/lyricsScraper.py
new file mode 100644
index 00000000000..b850ac4938d
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/broken-scrapers/xiami/lyricsScraper.py
@@ -0,0 +1,96 @@
+#-*- coding: UTF-8 -*-
+"""
+Scraper for https://xiami.com
+
+Taxigps
+"""
+
+import urllib.parse
+import socket
+import re
+import difflib
+import json
+import chardet
+import requests
+from utilities import *
+
+__title__ = "Xiami"
+__priority__ = '110'
+__lrc__ = True
+
+UserAgent = 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0'
+
+socket.setdefaulttimeout(10)
+
+class LyricsFetcher:
+    def __init__( self ):
+        self.LIST_URL = 'https://www.xiami.com/search?key=%s'
+        self.SONG_URL = 'https://www.xiami.com/song/playlist/id/%s/object_name/default/object_id/0'
+        self.session = requests.Session()
+
+    def get_lyrics(self, song):
+        log( "%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title))
+        lyrics = Lyrics()
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        keyword = "%s %s" % (song.title, song.artist)
+        url = self.LIST_URL % (urllib.parse.quote(keyword))
+        try:
+            response = self.session.get(url, headers={'User-Agent': UserAgent, 'Referer': 'https://www.xiami.com/play'})
+            result = response.text
+        except:
+            log( "%s: %s::%s (%d) [%s]" % (
+                   __title__, self.__class__.__name__,
+                   sys.exc_info()[ 2 ].tb_frame.f_code.co_name,
+                   sys.exc_info()[ 2 ].tb_lineno,
+                   sys.exc_info()[ 1 ]
+                   ))
+            return None
+        match = re.compile('<td class="chkbox">.+?value="(.+?)".+?href="//www.xiami.com/song/[^"]+" title="([^"]+)".*?href="//www.xiami.com/artist/[^"]+" title="([^"]+)"', re.DOTALL).findall(result)
+        links = []
+        for x in match:
+            title = x[1]
+            artist = x[2]
+            if (difflib.SequenceMatcher(None, song.artist.lower(), artist.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, song.title.lower(), title.lower()).ratio() > 0.8):
+                links.append( ( artist + ' - ' + title, x[0], artist, title ) )
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        lyr = self.get_lyrics_from_list(links[0])
+        if not lyr:
+            return None
+        lyrics.lyrics = lyr
+        return lyrics
+
+    def get_lyrics_from_list(self, link):
+        title,id,artist,song = link
+        try:
+            response = self.session.get(self.SONG_URL % (id), headers={'User-Agent': UserAgent, 'Referer': 'https://www.xiami.com/play'})
+            result = response.text
+            data = json.loads(result)
+            if 'data' in data and 'trackList' in data['data'] and data['data']['trackList'] and 'lyric' in data['data']['trackList'][0] and data['data']['trackList'][0]['lyric']:
+                url = data['data']['trackList'][0]['lyric']
+        except:
+            log( "%s: %s::%s (%d) [%s]" % (
+                   __title__, self.__class__.__name__,
+                   sys.exc_info()[ 2 ].tb_frame.f_code.co_name,
+                   sys.exc_info()[ 2 ].tb_lineno,
+                   sys.exc_info()[ 1 ]
+                   ))
+            return
+        try:
+            response = self.session.get(url, headers={'User-Agent': UserAgent, 'Referer': 'https://www.xiami.com/play'})
+            lyrics = response.content
+        except:
+            log( "%s: %s::%s (%d) [%s]" % (
+                   __title__, self.__class__.__name__,
+                   sys.exc_info()[ 2 ].tb_frame.f_code.co_name,
+                   sys.exc_info()[ 2 ].tb_lineno,
+                   sys.exc_info()[ 1 ]
+                   ))
+            return
+        enc = chardet.detect(lyrics)
+        lyrics = lyrics.decode(enc['encoding'], 'ignore')
+        return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/lyricsScraper.py
new file mode 100644
index 00000000000..7fcf294f023
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/azlyrics/lyricsScraper.py
@@ -0,0 +1,42 @@
+#-*- coding: UTF-8 -*-
+import sys
+import re
+import requests
+import html
+import xbmc
+import xbmcaddon
+from lib.utils import *
+
+__title__ = 'azlyrics'
+__priority__ = '230'
+__lrc__ = False
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.url = 'https://www.azlyrics.com/lyrics/%s/%s.html'
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = re.sub("[^a-zA-Z0-9]+", "", song.artist).lower().lstrip('the ')
+        title = re.sub("[^a-zA-Z0-9]+", "", song.title).lower()
+        try:
+            req = requests.get(self.url % (artist, title), timeout=10)
+            response = req.text
+        except:
+            return None
+        req.close()
+        try:
+            lyricscode = response.split('t. -->')[1].split('</div')[0]
+            lyricstext = html.unescape(lyricscode).replace('<br />', '\n')
+            lyr = re.sub('<[^<]+?>', '', lyricstext)
+            lyrics.lyrics = lyr
+            return lyrics
+        except:
+            return None
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/lyricsScraper.py
new file mode 100644
index 00000000000..d24a32bd6fd
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/darklyrics/lyricsScraper.py
@@ -0,0 +1,124 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for http://www.darklyrics.com/ - the largest metal lyrics archive on the Web.
+
+scraper by smory
+'''
+
+import hashlib
+import math
+import requests
+import time
+import urllib.parse
+import re
+from lib.utils import *
+try:
+    from ctypes import c_int32 # ctypes not supported on xbox
+except:
+    pass
+
+__title__ = 'darklyrics'
+__priority__ = '260'
+__lrc__ = False
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.base_url = 'http://www.darklyrics.com/'
+        self.searchUrl = 'http://www.darklyrics.com/search?q=%s'
+        self.cookie = self.getCookie()
+
+    def getCookie(self):
+         # http://www.darklyrics.com/tban.js
+         lastvisitts = 'Nergal' + str(math.ceil(time.time() * 1000 / (60 * 60 * 6 * 1000)))
+         lastvisittscookie = 0
+         i = 0
+         while i < len(lastvisitts):
+             try:
+                 lastvisittscookie = c_int32((c_int32(lastvisittscookie<<5).value - c_int32(lastvisittscookie).value) + ord(lastvisitts[i])).value
+             except:
+                 return
+             i += 1
+         lastvisittscookie = lastvisittscookie & lastvisittscookie
+         return str(lastvisittscookie)
+
+    def search(self, artist, title):
+        term = urllib.parse.quote((artist if artist else '') + '+' + (title if title else ''))
+        try:
+            headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0'}
+            req = requests.get(self.searchUrl % term, headers=headers, cookies={'lastvisitts': self.cookie}, timeout=10)
+            searchResponse = req.text
+        except:
+            return None
+        searchResult = re.findall('<h2><a\shref="(.*?#([0-9]+))".*?>(.*?)</a></h2>', searchResponse)
+        if len(searchResult) == 0:
+            return None
+        links = []
+        i = 0
+        for result in searchResult:
+            a = []
+            a.append(result[2] + (' ' + self.getAlbumName(self.base_url + result[0]) if i < 6 else '')) # title from server + album nane
+            a.append(self.base_url + result[0]) # url with lyrics
+            a.append(artist)
+            a.append(title)
+            a.append(result[1]) # id of the side part containing this song lyrics
+            links.append(a)
+            i += 1
+        return links
+    
+    def findLyrics(self, url, index):
+        try:
+            headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0'}
+            req = requests.get(url, headers=headers, cookies={'lastvisitts': self.cookie}, timeout=10)
+            res = req.text
+        except:
+            return None
+        pattern = '<a\sname="%index%">(.*?)(?:<h3>|<div)' # require multi line and dot all mode
+        pattern = pattern.replace('%index%', index)
+        match = re.search(pattern, res, re.MULTILINE | re.DOTALL)
+        if match:
+            s = match.group(1)
+            s = s.replace('<br />', '')
+            s = s.replace('<i>', '')
+            s = s.replace('</i>', '')
+            s = s.replace('</a>', '')
+            s = s.replace('</h3>', '')
+            return s
+        else:
+            return None
+        
+    def getAlbumName(self, url):
+        try:
+            headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0'}
+            req = requests.get(url, headers=headers, cookies={'lastvisitts': self.cookie}, timeout=10)
+            res = req.text
+        except:
+            return ''
+        match = re.search('<h2>(?:album|single|ep|live):?\s?(.*?)</h2>', res, re.IGNORECASE)
+        if match:
+            return ('(' + match.group(1) + ')').replace('\'', '')
+        else:
+            return ''
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        links = self.search(song.artist , song.title)
+        if(links == None or len(links) == 0):
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        lyr = self.get_lyrics_from_list(links[0])
+        if not lyr:
+            return None
+        lyrics.lyrics = lyr
+        return lyrics
+
+    def get_lyrics_from_list(self, link):
+        title, url, artist, song, index = link
+        return self.findLyrics(url, index)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/lyricsScraper.py
new file mode 100644
index 00000000000..7e8ffcd9023
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/genius/lyricsScraper.py
@@ -0,0 +1,68 @@
+#-*- coding: UTF-8 -*-
+import sys
+import re
+import urllib.parse
+import requests
+import html
+import xbmc
+import xbmcaddon
+import json
+import difflib
+from lib.utils import *
+
+__title__ = 'genius'
+__priority__ = '200'
+__lrc__ = False
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.url = 'http://api.genius.com/search?q=%s%%20%s&access_token=Rq_cyNZ6fUOQr4vhyES6vu1iw3e94RX85ju7S8-0jhM-gftzEvQPG7LJrrnTji11'
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            headers = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; rv:77.0) Gecko/20100101 Firefox/77.0'}
+            url = self.url % (urllib.parse.quote(song.artist), urllib.parse.quote(song.title))
+            req = requests.get(url, headers=headers, timeout=10)
+            response = req.text
+        except:
+            return None
+        data = json.loads(response)
+        try:
+            name = data['response']['hits'][0]['result']['primary_artist']['name']
+            track = data['response']['hits'][0]['result']['title']
+            if (difflib.SequenceMatcher(None, song.artist.lower(), name.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, song.title.lower(), track.lower()).ratio() > 0.8):
+                self.page = data['response']['hits'][0]['result']['url']
+            else:
+                return None
+        except:
+            return None
+        log('%s: search url: %s' % (__title__, self.page), debug=self.DEBUG)
+        try:
+            headers = {'user-agent': 'Mozilla/5.0 (Windows NT 10.0; rv:77.0) Gecko/20100101 Firefox/77.0'}
+            req = requests.get(self.page, headers=headers, timeout=10)
+            response = req.text
+        except:
+            return None
+        response = html.unescape(response)
+        matchcode = re.findall('class="Lyrics__Container.*?">(.*?)</div><div', response, flags=re.DOTALL)
+        try:
+            lyricscode = ""
+            for matchCodeItem in matchcode:
+                lyricscode = lyricscode + matchCodeItem
+            lyr1 = re.sub('<br/>', '\n', lyricscode)
+            lyr2 = re.sub('<[^<]+?>', '', lyr1)
+            lyr3 = lyr2.replace('\\n','\n').strip()
+            if not lyr3 or lyr3 == '[Instrumental]' or lyr3.startswith('Lyrics for this song have yet to be released'):
+                return None
+            lyrics.lyrics = lyr3
+            return lyrics
+        except:
+            return None
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/lyricsScraper.py
new file mode 100644
index 00000000000..5f45834476e
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lrclib/lyricsScraper.py
@@ -0,0 +1,66 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for https://lrclib.net/
+
+lrclib
+
+https://github.com/rtcq/syncedlyrics
+'''
+
+import requests
+import difflib
+from lib.utils import *
+
+__title__ = "lrclib"
+__priority__ = '110'
+__lrc__ = True
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.SEARCH_URL = 'https://lrclib.net/api/search?q=%s-%s'
+        self.LYRIC_URL = 'https://lrclib.net/api/get/%i'
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            url = self.SEARCH_URL % (song.artist, song.title)
+            response = requests.get(url, timeout=10)
+            result = response.json()
+        except:
+            return None
+        links = []
+        for item in result: 
+            artistname = item['artistName']
+            songtitle = item['name']
+            songid = item['id']
+            if (difflib.SequenceMatcher(None, song.artist.lower(), artistname.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, song.title.lower(), songtitle.lower()).ratio() > 0.8):
+                links.append((artistname + ' - ' + songtitle, self.LYRIC_URL % songid, artistname, songtitle))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr:
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,url,artist,song = link
+        try:
+            log('%s: search url: %s' % (__title__, url), debug=self.DEBUG)
+            response = requests.get(url, timeout=10)
+            result = response.json()
+        except:
+            return None
+        if 'syncedLyrics' in result:
+            lyrics = result['syncedLyrics']
+            return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/lyricsScraper.py
new file mode 100644
index 00000000000..a04720c1cce
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricscom/lyricsScraper.py
@@ -0,0 +1,61 @@
+#-*- coding: UTF-8 -*-
+import re
+import requests
+import urllib.parse
+import difflib
+from bs4 import BeautifulSoup
+from lib.utils import *
+
+__title__ = 'lyricscom'
+__priority__ = '240'
+__lrc__ = False
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.url = 'https://www.lyrics.com/serp.php?st=%s&qtype=2'
+
+    def get_lyrics(self, song):
+        sess = requests.Session()
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            request = sess.get(self.url % urllib.parse.quote_plus(song.artist), timeout=10)
+            response = request.text
+        except:
+            return
+        soup = BeautifulSoup(response, 'html.parser')
+        url = ''
+        for link in soup.find_all('a'):
+            if link.string and link.get('href').startswith('artist/'):
+                url = 'https://www.lyrics.com/' + link.get('href')
+                break
+        if url:
+            try:
+                req = sess.get(url, timeout=10)
+                resp = req.text
+            except:
+                return
+            soup = BeautifulSoup(resp, 'html.parser')
+            url = ''
+            for link in soup.find_all('a'):
+                if link.string and (difflib.SequenceMatcher(None, link.string.lower(), song.title.lower()).ratio() > 0.8):
+                    url = 'https://www.lyrics.com' + link.get('href')
+                    break
+            if url:
+                try:
+                    req2 = sess.get(url, timeout=10)
+                    resp2 = req2.text
+                except:
+                    return
+                matchcode = re.search('<pre.*?>(.*?)</pre>', resp2, flags=re.DOTALL)
+                if matchcode:
+                    lyricscode = (matchcode.group(1))
+                    lyr = re.sub('<[^<]+?>', '', lyricscode)
+                    lyrics.lyrics = lyr.replace('\\n','\n')
+                    return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsify/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsify/lyricsScraper.py
new file mode 100644
index 00000000000..dba13e3dd9e
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsify/lyricsScraper.py
@@ -0,0 +1,75 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for https://www.lyricsify.com/
+'''
+
+import requests
+import re
+import difflib
+from bs4 import BeautifulSoup
+from lib.utils import *
+
+__title__ = "Lyricsify"
+__priority__ = '130'
+__lrc__ = True
+
+UserAgent = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36"}
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.SEARCH_URL = 'https://www.lyricsify.com/lyrics/%s/%s'
+        self.LYRIC_URL = 'https://www.lyricsify.com%s'
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = song.artist.replace(' ', '-')
+        title = song.title.replace(' ', '-')
+        try:
+            url = self.SEARCH_URL % (artist, title)
+            search = requests.get(url, headers=UserAgent, timeout=10)
+            response = search.text
+        except:
+            return None
+        links = []
+        soup = BeautifulSoup(response, 'html.parser')
+        for link in soup.find_all('a'):
+            if link.string and link.get('href').startswith('/lrc/'):
+                foundartist = link.string.split(' - ', 1)[0]
+                # some links don't have a proper 'artist - title' format
+                try:
+                    foundsong = link.string.split(' - ', 1)[1].rstrip('.lrc')
+                except:
+                    continue
+                if (difflib.SequenceMatcher(None, artist.lower(), foundartist.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, title.lower(), foundsong.lower()).ratio() > 0.8):
+                    links.append((foundartist + ' - ' + foundsong, self.LYRIC_URL % link.get('href'), foundartist, foundsong))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr:
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,url,artist,song = link
+        try:
+            log('%s: search url: %s' % (__title__, url), debug=self.DEBUG)
+            search = requests.get(url, headers=UserAgent, timeout=10)
+            response = search.text
+        except:
+            return None
+        matchcode = re.search('/h3>(.*?)</div', response, flags=re.DOTALL)
+        if matchcode:
+            lyricscode = (matchcode.group(1))
+            cleanlyrics = re.sub('<[^<]+?>', '', lyricscode)
+            return cleanlyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/lyricsScraper.py
new file mode 100644
index 00000000000..2b57acebfb3
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/lyricsmode/lyricsScraper.py
@@ -0,0 +1,59 @@
+#-*- coding: UTF-8 -*-
+import sys
+import requests
+import urllib.parse
+import re
+from lib.utils import *
+
+__title__ = 'lyricsmode'
+__priority__ = '220'
+__lrc__ = False
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = deAccent(song.artist)
+        title = deAccent(song.title)
+        url = 'http://www.lyricsmode.com/lyrics/%s/%s/%s.html' % (artist.lower()[:1], artist.lower().replace('&','and').replace(' ','_'), title.lower().replace('&','and').replace(' ','_'))
+        result = self.direct_url(url)
+        if not result:
+            result = self.search_url(artist, title)
+        if result:
+            lyr = result.split('style="position: relative;">')[1].split('<div')[0]
+            lyrics.lyrics = lyr.replace('<br />', '')
+            return lyrics
+
+    def direct_url(self, url):
+        try:
+            log('%s: direct url: %s' % (__title__, url), debug=self.DEBUG)
+            song_search = requests.get(url, timeout=10)
+            response = song_search.text
+            if response.find('lyrics_text') >= 0:
+                return response
+        except:
+            log('error in direct url', debug=self.DEBUG)
+
+    def search_url(self, artist, title):
+        try:
+            url = 'http://www.lyricsmode.com/search.php?search=' + urllib.parse.quote_plus(artist.lower() + ' ' + title.lower())
+            log('%s: search url: %s' % (__title__, url), debug=self.DEBUG)
+            song_search = requests.get(url, timeout=10)
+            response = song_search.text
+            matchcode = re.search('lm-list__cell-title">.*?<a href="(.*?)" class="lm-link lm-link--primary', response, flags=re.DOTALL)
+            try:
+                url = 'http://www.lyricsmode.com' + (matchcode.group(1))
+                result = self.direct_url(url)
+                if result:
+                    return result
+            except:
+                return
+        except:
+            log('error in search url', debug=self.DEBUG)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/lyricsScraper.py
new file mode 100644
index 00000000000..2a90ee2bfb0
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/megalobiz/lyricsScraper.py
@@ -0,0 +1,69 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for https://www.megalobiz.com/
+
+megalobiz
+
+https://github.com/rtcq/syncedlyrics
+'''
+
+import requests
+import re
+from bs4 import BeautifulSoup
+from lib.utils import *
+
+__title__ = "Megalobiz"
+__priority__ = '140'
+__lrc__ = True
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.SEARCH_URL = 'https://www.megalobiz.com/search/all?qry=%s-%s&searchButton.x=0&searchButton.y=0'
+        self.LYRIC_URL = 'https://www.megalobiz.com/%s'
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        try:
+            url = self.SEARCH_URL % (song.artist, song.title)
+            response = requests.get(url, timeout=10)
+            result = response.text
+        except:
+            return None
+        links = []
+        soup = BeautifulSoup(result, 'html.parser')
+        for link in soup.find_all('a'):
+            if link.get('href') and link.get('href').startswith('/lrc/maker/'):
+                linktext = link.text.replace('_', ' ').strip()
+                if song.artist.lower() in linktext.lower() and song.title.lower() in linktext.lower():
+                    links.append((linktext, self.LYRIC_URL % link.get('href'), song.artist, song.title))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr:
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,url,artist,song = link
+        try:
+            log('%s: search url: %s' % (__title__, url), debug=self.DEBUG)
+            response = requests.get(url, timeout=10)
+            result = response.text
+        except:
+            return None
+        matchcode = re.search('span id="lrc_[0-9]+_lyrics">(.*?)</span', result, flags=re.DOTALL)
+        if matchcode:
+            lyricscode = (matchcode.group(1))
+            cleanlyrics = re.sub('<[^<]+?>', '', lyricscode)
+            return cleanlyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/lyricsScraper.py
new file mode 100644
index 00000000000..3f546399f75
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/music163/lyricsScraper.py
@@ -0,0 +1,71 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for http://music.163.com/
+
+osdlyrics
+'''
+
+import os
+import requests
+import re
+import random
+import difflib
+from lib.utils import *
+
+__title__ = "Music163"
+__priority__ = '120'
+__lrc__ = True
+
+headers = {}
+headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0'
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.SEARCH_URL = 'http://music.163.com/api/search/get'
+        self.LYRIC_URL = 'http://music.163.com/api/song/lyric'
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = song.artist.replace(' ', '+')
+        title = song.title.replace(' ', '+')
+        search = '?s=%s+%s&type=1' % (artist, title)
+        try:
+            url = self.SEARCH_URL + search
+            response = requests.get(url, headers=headers, timeout=10)
+            result = response.json()
+        except:
+            return None
+        links = []
+        if 'result' in result and 'songs' in result['result']:
+            for item in result['result']['songs']:
+                artists = "+&+".join([a["name"] for a in item["artists"]])
+                if (difflib.SequenceMatcher(None, artist.lower(), artists.lower()).ratio() > 0.6) and (difflib.SequenceMatcher(None, title.lower(), item['name'].lower()).ratio() > 0.8):
+                    links.append((artists + ' - ' + item['name'], self.LYRIC_URL + '?id=' + str(item['id']) + '&lv=-1&kv=-1&tv=-1', artists, item['name']))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr and lyr.startswith('['):
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,url,artist,song = link
+        try:
+            log('%s: search url: %s' % (__title__, url), debug=self.DEBUG)
+            response = requests.get(url, headers=headers, timeout=10)
+            result = response.json()
+        except:
+            return None
+        if 'lrc' in result:
+            return result['lrc']['lyric']
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/lyricsScraper.py
new file mode 100644
index 00000000000..60e6e36b8fb
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatch/lyricsScraper.py
@@ -0,0 +1,86 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for https://www.musixmatch.com/
+
+musixmatch
+'''
+
+import os
+import requests
+import re
+import random
+import difflib
+from bs4 import BeautifulSoup
+from lib.utils import *
+
+__title__ = "musixmatch"
+__priority__ = '210'
+__lrc__ = False
+
+headers = {}
+headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0'
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.SEARCH_URL = 'https://www.musixmatch.com/search/'
+        self.LYRIC_URL = 'https://www.musixmatch.com'
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = song.artist.replace(' ', '+')
+        title = song.title.replace(' ', '+')
+        search = '%s+%s' % (artist, title)
+        try:
+            url = self.SEARCH_URL + search
+            response = requests.get(url, headers=headers, timeout=10)
+            result = response.text
+        except:
+            return None
+        links = []
+        soup = BeautifulSoup(result, 'html.parser')
+        for item in soup.find_all('li', {'class': 'showArtist'}):
+            artistname = item.find('a', {'class': 'artist'}).get_text()
+            songtitle = item.find('a', {'class': 'title'}).get_text()
+            url = item.find('a', {'class': 'title'}).get('href')
+            if (difflib.SequenceMatcher(None, artist.lower(), artistname.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, title.lower(), songtitle.lower()).ratio() > 0.8):
+                links.append((artistname + ' - ' + songtitle, self.LYRIC_URL + url, artistname, songtitle))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr:
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,url,artist,song = link
+        try:
+            log('%s: search url: %s' % (__title__, url), debug=self.DEBUG)
+            response = requests.get(url, headers=headers, timeout=10)
+            result = response.text
+        except:
+            return None
+        soup = BeautifulSoup(result, 'html.parser')
+        lyr = soup.find_all('span', {'class': 'lyrics__content__ok'})
+        if lyr:
+            lyrics = ''
+            for part in lyr:
+                lyrics = lyrics + part.get_text() + '\n'
+            return lyrics
+        else:
+            lyr = soup.find_all('span', {'class': 'lyrics__content__error'})
+            if lyr:
+                lyrics = ''
+                for part in lyr:
+                    lyrics = lyrics + part.get_text() + '\n'
+                return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/lyricsScraper.py
new file mode 100644
index 00000000000..783f818e8ce
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/musixmatchlrc/lyricsScraper.py
@@ -0,0 +1,117 @@
+#-*- coding: UTF-8 -*-
+'''
+Scraper for https://www.musixmatch.com/
+
+musixmatchlrc
+
+https://github.com/rtcq/syncedlyrics
+'''
+
+import requests
+import json
+import time
+import difflib
+import xbmcvfs
+from lib.utils import *
+
+__title__ = "musixmatchlrc"
+__priority__ = '100'
+__lrc__ = True
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+        self.SEARCH_URL = 'https://apic-desktop.musixmatch.com/ws/1.1/%s'
+        self.session = requests.Session()
+        self.session.headers.update(
+            {
+                "authority": "apic-desktop.musixmatch.com",
+                "cookie": "AWSELBCORS=0; AWSELB=0",
+                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0",
+            }
+        )
+        self.current_time = int(time.time())
+
+    def get_token(self):
+        self.token = ''
+        tokenpath = os.path.join(PROFILE, 'musixmatch_token')
+        if xbmcvfs.exists(tokenpath):
+            tokenfile = xbmcvfs.File(tokenpath)
+            tokendata = json.load(tokenfile)
+            tokenfile.close()
+            cached_token = tokendata.get("token")
+            expiration_time = tokendata.get("expiration_time")
+            if cached_token and expiration_time and self.current_time < expiration_time:
+                self.token = cached_token
+        if not self.token:
+            try:
+                url = self.SEARCH_URL % 'token.get'
+                query = [('user_language', 'en'), ('app_id', 'web-desktop-app-v1.0'), ('t', self.current_time)]
+                response = self.session.get(url, params=query, timeout=10)
+                result = response.json()
+            except:
+                return None
+            if 'message' in result and 'body' in result["message"] and 'user_token' in result["message"]["body"]:
+                self.token = result["message"]["body"]["user_token"]
+                expiration_time = self.current_time + 600
+                tokendata = {}
+                tokendata['token'] = self.token
+                tokendata['expiration_time'] = expiration_time
+                tokenfile = xbmcvfs.File(tokenpath, 'w')
+                json.dump(tokendata, tokenfile)
+                tokenfile.close()
+        return self.token
+
+    def get_lyrics(self, song):
+        self.token = self.get_token()
+        if not self.token:
+            return
+        log("%s: searching lyrics for %s - %s" % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = song.artist.replace(' ', '+')
+        title = song.title.replace(' ', '+')
+        search = '%s - %s' % (artist, title)
+        try:
+            url = self.SEARCH_URL % 'track.search'
+            query = [('q', search), ('page_size', '5'), ('page', '1'), ('s_track_rating', 'desc'), ('quorum_factor', '1.0'), ('app_id', 'web-desktop-app-v1.0'), ('usertoken', self.token), ('t', self.current_time)]
+            response = requests.get(url, params=query, timeout=10)
+            result = response.json()
+        except:
+            return None
+        links = []
+        if 'message' in result and 'body' in result["message"] and 'track_list' in result["message"]["body"] and result["message"]["body"]["track_list"]:
+            for item in result["message"]["body"]["track_list"]:
+                artistname = item['track']['artist_name']
+                songtitle = item['track']['track_name']
+                trackid = item['track']['track_id']
+                if (difflib.SequenceMatcher(None, artist.lower(), artistname.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, title.lower(), songtitle.lower()).ratio() > 0.8):
+                    links.append((artistname + ' - ' + songtitle, trackid, artistname, songtitle))
+        if len(links) == 0:
+            return None
+        elif len(links) > 1:
+            lyrics.list = links
+        for link in links:
+            lyr = self.get_lyrics_from_list(link)
+            if lyr:
+                lyrics.lyrics = lyr
+                return lyrics
+        return None
+
+    def get_lyrics_from_list(self, link):
+        title,trackid,artist,song = link
+        try:
+            log('%s: search track id: %s' % (__title__, trackid), debug=self.DEBUG)
+            url = self.SEARCH_URL % 'track.subtitle.get'
+            query = [('track_id', trackid), ('subtitle_format', 'lrc'), ('app_id', 'web-desktop-app-v1.0'), ('usertoken', self.token), ('t', self.current_time)]
+            response = requests.get(url, params=query, timeout=10)
+            result = response.json()
+        except:
+            return None
+        if 'message' in result and 'body' in result["message"] and 'subtitle' in result["message"]["body"] and 'subtitle_body' in result["message"]["body"]["subtitle"]:
+            lyrics = result["message"]["body"]["subtitle"]["subtitle_body"]
+            return lyrics
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/__init__.py
new file mode 100644
index 00000000000..b93054b3ecf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/__init__.py
@@ -0,0 +1 @@
+# Dummy file to make this directory a package.
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/lyricsScraper.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/lyricsScraper.py
new file mode 100644
index 00000000000..e6f556d63c6
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/culrcscrapers/supermusic/lyricsScraper.py
@@ -0,0 +1,64 @@
+#-*- coding: UTF-8 -*-
+import sys
+import re
+import requests
+import html
+import xbmc
+import xbmcaddon
+from lib.utils import *
+
+__title__ = 'supermusic'
+__priority__ = '250'
+__lrc__ = False
+
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+
+    def get_lyrics(self, song):
+        log('%s: searching lyrics for %s - %s' % (__title__, song.artist, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+        artist = song.artist.lower()
+        title = song.title.lower()
+
+        try:
+            req = requests.post('https://supermusic.cz/najdi.php', data={'hladane': title, 'typhladania': 'piesen', 'fraza': 'off'})
+            response = req.text
+        except:
+            return None
+        req.close()
+        url = None
+        try:
+            items = re.search(r'Počet nájdených piesní.+<br><br>(.*)<BR>', response, re.S).group(1)
+            for match in re.finditer(r'<a href=(?P<url>"[^"]+?") target="_parent"><b>(?P<artist>.*?)</b></a> - (?P<type>.+?) \(<a href', items):
+                matched_url, matched_artist, matched_type = match.groups()
+                if matched_type not in ('text', 'akordy a text'):
+                    continue
+                if matched_artist.lower() == artist:
+                    url = matched_url.strip('"')
+                    break
+        except:
+            return None
+
+        if not url:
+            return None
+
+        try:
+            req = requests.get('https://supermusic.cz/%s' % url)
+            response = req.text
+            lyr = re.search(r'class=piesen>(.*?)</font>', response, re.S).group(1)
+            lyr = re.sub(r'<sup>.*?</sup>', '', lyr)
+            lyr = re.sub(r'<br\s*/>\s*', '\n', lyr)
+            lyr = re.sub(r'<!--.*?-->', '', lyr, flags=re.DOTALL)
+            lyr = re.sub(r'<[^>]*?>', '', lyr, flags=re.DOTALL)
+            lyr = lyr.strip('\r\n')
+            lyr = html.unescape(lyr)
+            lyrics.lyrics = lyr
+            return lyrics
+        except:
+            return None
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/embedlrc.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/embedlrc.py
new file mode 100644
index 00000000000..c66d410aca9
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/embedlrc.py
@@ -0,0 +1,183 @@
+from mutagen.flac import FLAC
+from mutagen.mp3 import MP3
+from mutagen.mp4 import MP4
+from mutagen.oggvorbis import OggVorbis
+from mutagen.apev2 import APEv2
+from lib.utils import *
+
+LANGUAGE = ADDON.getLocalizedString
+
+
+class BinaryFile(xbmcvfs.File):
+    def read(self, numBytes):
+        if numBytes == 0:
+            return b""
+        else:
+            return bytes(super().readBytes(numBytes))
+
+
+def getEmbedLyrics(song, getlrc, lyricssettings):
+    lyrics = Lyrics(settings=lyricssettings)
+    lyrics.song = song
+    lyrics.source = LANGUAGE(32002)
+    lyrics.lrc = getlrc
+    lry = lyrics.song.embed
+    if lry:
+        match = isLRC(lry)
+        if (getlrc and match) or ((not getlrc) and (not match)):
+            if lyrics.song.source:
+                lyrics.source = lyrics.song.source
+            lyrics.lyrics = lry
+            return lyrics
+    filename = song.filepath
+    ext = os.path.splitext(filename)[1].lower()
+    sup_ext = ['.mp3', '.flac', '.ogg', '.ape', '.m4a']
+    lry = None
+    if ext in sup_ext:
+        bfile = BinaryFile(filename)
+        if ext == '.mp3':
+            lry = getID3Lyrics(bfile, getlrc)
+            if not lry:
+                try:
+                    lry = getLyrics3(bfile, getlrc)
+                except:
+                    pass
+        elif ext == '.flac':
+            lry = getFlacLyrics(bfile, getlrc)
+        elif ext == '.m4a':
+            lry = getMP4Lyrics(bfile, getlrc)
+        elif ext == '.ogg':
+            lry = getOGGLyrics(bfile, getlrc)
+        elif ext == '.ape':
+            lry = getAPELyrics(bfile, getlrc)
+        bfile.close()
+    if not lry:
+        return None
+    lyrics.lyrics = lry
+    return lyrics
+
+'''
+Get lyrics embed with Lyrics3/Lyrics3V2 format
+See: http://id3.org/Lyrics3
+     http://id3.org/Lyrics3v2
+'''
+def getLyrics3(bfile, getlrc):
+    bfile.seek(-128-9, os.SEEK_END)
+    buf = bfile.read(9)
+    if (buf != b'LYRICS200' and buf != b'LYRICSEND'):
+        bfile.seek(-9, os.SEEK_END)
+        buf = bfile.read(9)
+    if (buf == b'LYRICSEND'):
+        ''' Find Lyrics3v1 '''
+        bfile.seek(-5100-9-11, os.SEEK_CUR)
+        buf = bfile.read(5100+11)
+        start = buf.find(b'LYRICSBEGIN')
+        data = buf[start+11:]
+        enc = chardet.detect(data)
+        content = data.decode(enc['encoding'])
+        if (getlrc and isLRC(content)) or (not getlrc and not isLRC(content)):
+            return content
+    elif (buf == b'LYRICS200'):
+        ''' Find Lyrics3v2 '''
+        bfile.seek(-9-6, os.SEEK_CUR)
+        size = int(bfile.read(6))
+        bfile.seek(-size-6, os.SEEK_CUR)
+        buf = bfile.read(11)
+        if(buf == b'LYRICSBEGIN'):
+            buf = bfile.read(size-11)
+            tags=[]
+            while buf!= '':
+                tag = buf[:3]
+                length = int(buf[3:8])
+                data = buf[8:8+length]
+                enc = chardet.detect(data)
+                content = data.decode(enc['encoding'])
+                if (tag == b'LYR'):
+                    if (getlrc and isLRC(content)) or (not getlrc and not isLRC(content)):
+                        return content
+                buf = buf[8+length:]
+
+def ms2timestamp(ms):
+    mins = '0%s' % int(ms/1000/60)
+    sec = '0%s' % int((ms/1000)%60)
+    msec = '0%s' % int((ms%1000)/10)
+    timestamp = '[%s:%s.%s]' % (mins[-2:],sec[-2:],msec[-2:])
+    return timestamp
+
+'''
+Get USLT/SYLT/TXXX lyrics embed with ID3v2 format
+See: http://id3.org/id3v2.3.0
+'''
+def getID3Lyrics(bfile, getlrc):
+    try:
+        data = MP3(bfile)
+        lyr = ''
+        for tag,value in data.items():
+            if getlrc and tag.startswith('SYLT'):
+                for line in data[tag].text:
+                    txt = line[0].strip()
+                    stamp = ms2timestamp(line[1])
+                    lyr += '%s%s\r\n' % (stamp, txt)
+            elif not getlrc and tag.startswith('USLT'):
+                if data[tag].text:
+                    lyr = data[tag].text
+            elif tag.startswith('TXXX'):
+                if getlrc and tag.upper().endswith('SYNCEDLYRICS'): # TXXX tags contain arbitrary info. only accept 'TXXX:SYNCEDLYRICS'
+                    lyr = data[tag].text[0]
+                elif not getlrc and tag.upper().endswith('LYRICS'): # TXXX tags contain arbitrary info. only accept 'TXXX:LYRICS'
+                    lyr = data[tag].text[0]
+            if lyr:
+                return lyr
+    except:
+        return
+
+def getFlacLyrics(bfile, getlrc):
+    try:
+        tags = FLAC(bfile)
+        if 'lyrics' in tags:
+            lyr = tags['lyrics'][0]
+            match = isLRC(lyr)
+            if (getlrc and match) or ((not getlrc) and (not match)):
+                return lyr
+    except:
+        return
+
+def getMP4Lyrics(bfile, getlrc):
+    try:
+        tags = MP4(bfile)
+        if '©lyr' in tags:
+            lyr = tags['©lyr'][0]
+            match = isLRC(lyr)
+            if (getlrc and match) or ((not getlrc) and (not match)):
+                return lyr
+    except:
+        return
+
+def getOGGLyrics(bfile, getlrc):
+    try:
+        tags = OggVorbis(bfile)
+        if 'lyrics' in tags:
+            lyr = tags['lyrics'][0]
+            match = isLRC(lyr)
+            if (getlrc and match) or ((not getlrc) and (not match)):
+                return lyr
+    except:
+        return
+
+def getAPELyrics(bfile, getlrc):
+    try:
+        tags = APEv2(bfile)
+        if 'lyrics' in tags:
+            lyr = tags['lyrics'][0]
+            match = isLRC(lyr)
+            if (getlrc and match) or ((not getlrc) and (not match)):
+                return lyr
+    except:
+        return
+
+def isLRC(lyr):
+    match = re.compile('\[(\d+):(\d\d)(\.\d+|)\]').search(lyr)
+    if match:
+        return True
+    else:
+        return False
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/gui.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/gui.py
new file mode 100644
index 00000000000..f18036cb297
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/gui.py
@@ -0,0 +1,796 @@
+#-*- coding: UTF-8 -*-
+import threading
+import time
+from threading import Timer
+from lib.utils import *
+from lib.embedlrc import *
+
+
+class MAIN():
+    def __init__(self):
+        WIN.setProperty('culrc.running', 'true')
+        self.get_settings()
+        log('started as service: %s' % str(self.SETTING_SERVICE), debug=self.DEBUG)
+        self.setup_main()
+        self.main_loop()
+        self.cleanup_main()
+
+    def setup_main(self):
+        self.fetchedLyrics = []
+        self.current_lyrics = Lyrics(settings=self.lyricssettings)
+        self.MyPlayer = MyPlayer(function=self.myPlayerChanged, clear=self.clear)
+        self.Monitor = MyMonitor(function=self.update_settings)
+        self.dialog = xbmcgui.Dialog()
+        self.customtimer = False
+        self.starttime = 0
+        self.CULRC_QUIT = False
+        self.CULRC_FIRSTRUN = False
+        self.CULRC_NEWLYRICS = False
+        self.CULRC_NOLYRICS = False
+
+    def cleanup_main(self):
+        # Clean up the monitor and Player classes on exit
+        del self.MyPlayer
+        del self.Monitor
+
+    def get_settings(self):
+        self.DEBUG = ADDON.getSettingBool('log_enabled')
+        self.SETTING_OFFSET = ADDON.getSettingNumber('offset')
+        self.SETTING_SAVE_LYRICS1LRC = ADDON.getSettingBool('save_lyrics1_lrc')
+        self.SETTING_SAVE_LYRICS1TXT = ADDON.getSettingBool('save_lyrics1_txt')
+        self.SETTING_SAVE_LYRICS2LRC = ADDON.getSettingBool('save_lyrics2_lrc')
+        self.SETTING_SAVE_LYRICS2TXT = ADDON.getSettingBool('save_lyrics2_txt')
+        self.SETTING_SEARCH_EMBEDDED = ADDON.getSettingBool('search_embedded')
+        self.SETTING_SEARCH_LRC_FILE = ADDON.getSettingBool('search_lrc_file')
+        self.SETTING_SEARCH_TXT_FILE = ADDON.getSettingBool('search_txt_file')
+        self.SETTING_SERVICE = ADDON.getSettingBool('service')
+        self.SETTING_SILENT = ADDON.getSettingBool('silent')
+        self.SETTING_STRIP = ADDON.getSettingBool('strip')
+        self.SETTING_READ_FILENAME = ADDON.getSettingBool('read_filename')
+        self.SETTING_READ_FILENAME_FORMAT = ADDON.getSettingInt('read_filename_format')
+        self.SETTING_SAVE_FILENAME_FORMAT = ADDON.getSettingInt('save_filename_format')
+        self.SETTING_SAVE_LYRICS_PATH = ADDON.getSettingString('save_lyrics_path')
+        self.SETTING_SAVE_SUBFOLDER = ADDON.getSettingBool('save_subfolder')
+        self.SETTING_SAVE_SUBFOLDER_PATH = ADDON.getSettingString('save_subfolder_path')
+        self.SETTING_CLEAN_TITLE = ADDON.getSettingBool('clean_title')
+        self.lyricssettings = {}
+        self.lyricssettings['debug'] = self.DEBUG
+        self.lyricssettings['read_filename'] = self.SETTING_READ_FILENAME
+        self.lyricssettings['read_filename_format'] = self.SETTING_READ_FILENAME_FORMAT
+        self.lyricssettings['save_filename_format'] = self.SETTING_SAVE_FILENAME_FORMAT
+        self.lyricssettings['save_lyrics_path'] = self.SETTING_SAVE_LYRICS_PATH
+        self.lyricssettings['save_subfolder'] = self.SETTING_SAVE_SUBFOLDER
+        self.lyricssettings['save_subfolder_path'] = self.SETTING_SAVE_SUBFOLDER_PATH
+        self.lyricssettings['clean_title'] = self.SETTING_CLEAN_TITLE
+        self.scrapers = []
+        for scraper in os.listdir(LYRIC_SCRAPER_DIR):
+            # meh to python3 creating folders
+            if os.path.isdir(os.path.join(LYRIC_SCRAPER_DIR, scraper)) and scraper != '__pycache__' and ADDON.getSettingBool(scraper):
+                exec ('from lib.culrcscrapers.%s import lyricsScraper as lyricsScraper_%s' % (scraper, scraper))
+                exec ('self.scrapers.append([lyricsScraper_%s.__priority__,lyricsScraper_%s.LyricsFetcher(debug=self.DEBUG, settings=self.lyricssettings),lyricsScraper_%s.__title__,lyricsScraper_%s.__lrc__])' \
+                     % (scraper, scraper, scraper, scraper))
+        self.scrapers.sort()
+        if (ADDON.getSettingString('save_lyrics_path') == ''):
+            ADDON.setSettingString(id='save_lyrics_path', value=os.path.join(PROFILE, 'lyrics'))
+        if ADDON.getSettingBool('hide_dialog'):
+            WIN.setProperty('culrc.hidedialog', 'True')
+        else:
+            WIN.clearProperty('culrc.hidedialog')
+
+    def main_loop(self):
+        # main loop
+        while (not self.Monitor.abortRequested()) and (not self.CULRC_QUIT):
+            # check if we are on the music visualization screen
+            # do not try and get lyrics for any background media
+            if self.proceed():
+                if not self.CULRC_FIRSTRUN:
+                    # only the first lyrics are fetched by main_loop, the rest is done through onAVChanged. this makes sure both don't run simultaniously
+                    self.CULRC_FIRSTRUN = True
+                    # notify user the script is searching for lyrics
+                    if not self.SETTING_SILENT:
+                        self.dialog.notification(ADDONNAME, LANGUAGE(32004), icon=ADDONICON, time=2000, sound=False)
+                    # start fetching lyrics
+                    self.myPlayerChanged()
+                elif WIN.getProperty('culrc.force') == 'TRUE':
+                    # we're already running, user clicked button on osd
+                    WIN.setProperty('culrc.force','FALSE')
+                    self.current_lyrics = Lyrics(settings=self.lyricssettings)
+                    self.myPlayerChanged()
+                elif xbmc.getCondVisibility('Player.IsInternetStream'):
+                    self.myPlayerChanged()
+            else:
+                # we may have exited the music visualization screen, reset current lyrics so we show them again when re-entering the visualization screen
+                if self.CULRC_FIRSTRUN:
+                    self.current_lyrics = Lyrics(settings=self.lyricssettings)
+                self.CULRC_FIRSTRUN = False
+            xbmc.sleep(100)
+        WIN.clearProperty('culrc.lyrics')
+        WIN.clearProperty('culrc.islrc')
+        WIN.clearProperty('culrc.source')
+        WIN.clearProperty('culrc.haslist')
+        WIN.clearProperty('culrc.running')
+        WIN.clearProperty('culrc.hidedialog')
+
+    def get_lyrics(self, song, prefetch):
+        log('searching memory for lyrics', debug=self.DEBUG)
+        lyrics = self.get_lyrics_from_memory(song)
+        if lyrics:
+            if lyrics.lyrics:
+                log('found lyrics in memory', debug=self.DEBUG)
+            else:
+                log('no lyrics found on previous search', debug=self.DEBUG)
+            return lyrics
+        # searching lyrics for the current song and no pre-fetched lyrics available, hide the gui
+        if not prefetch:
+            self.CULRC_NOLYRICS = True
+        if song.title and self.proceed():
+            lyrics = self.find_lyrics(song)
+            if lyrics.lyrics and self.SETTING_STRIP:
+                # replace CJK and fullwith colon (not present in many font files)
+                lyrics.lyrics = re.sub(r'[ᄀ-ᇿ⺀-⺙⺛-⻳⼀-⿕々〇〡-〩〸-〺〻㐀-䶵一-鿃豈-鶴侮-頻並-龎]+', '', lyrics.lyrics).replace('：',':') 
+        # no song title, we can't search online. try matching local filename
+        elif (self.SETTING_SAVE_LYRICS2LRC or self.SETTING_SAVE_LYRICS2TXT) and self.proceed():
+            lyrics = self.get_lyrics_from_file(song, True)
+            if not lyrics:
+                lyrics = self.get_lyrics_from_file(song, False)
+        if not lyrics:
+            lyrics = Lyrics(settings=self.lyricssettings)
+            lyrics.song = song
+            lyrics.source = ''
+            lyrics.lyrics = ''
+        if self.proceed():
+            self.save_lyrics_to_memory(lyrics)
+        return lyrics
+
+    def find_lyrics(self, song):
+        # search embedded lrc lyrics
+        if self.SETTING_SEARCH_EMBEDDED and song.analyze_safe and self.proceed():
+            log('searching for embedded lrc lyrics', debug=self.DEBUG)
+            try:
+                lyrics = getEmbedLyrics(song, True, self.lyricssettings)
+            except:
+                lyrics = None
+            if (lyrics):
+                log('found embedded lrc lyrics', debug=self.DEBUG)
+                return lyrics
+        # search lrc lyrics from file
+        if self.SETTING_SEARCH_LRC_FILE and self.proceed():
+            log('searching for local lrc files', debug=self.DEBUG)
+            lyrics = self.get_lyrics_from_file(song, True)
+            if (lyrics):
+                log('found lrc lyrics from file', debug=self.DEBUG)
+                return lyrics
+        # search lrc lyrics by scrapers
+        for scraper in self.scrapers:
+            if scraper[3] and self.proceed():
+                lyrics = scraper[1].get_lyrics(song)
+                if (lyrics):
+                    log('found lrc lyrics online', debug=self.DEBUG)
+                    self.save_lyrics_to_file(lyrics)
+                    return lyrics
+        # search embedded txt lyrics
+        if self.SETTING_SEARCH_EMBEDDED and song.analyze_safe and self.proceed():
+            log('searching for embedded txt lyrics', debug=self.DEBUG)
+            try:
+                lyrics = getEmbedLyrics(song, False, self.lyricssettings)
+            except:
+                lyrics = None
+            if lyrics:
+                log('found embedded txt lyrics', debug=self.DEBUG)
+                return lyrics
+        # search txt lyrics from file
+        if self.SETTING_SEARCH_TXT_FILE and self.proceed():
+            log('searching for local txt files', debug=self.DEBUG)
+            lyrics = self.get_lyrics_from_file(song, False)
+            if (lyrics):
+                log('found txt lyrics from file', debug=self.DEBUG)
+                return lyrics
+        # search txt lyrics by scrapers
+        for scraper in self.scrapers:
+            if not scraper[3] and self.proceed():
+                lyrics = scraper[1].get_lyrics(song)
+                if (lyrics):
+                    log('found txt lyrics online', debug=self.DEBUG)
+                    self.save_lyrics_to_file(lyrics)
+                    return lyrics
+        log('no lyrics found', debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.lyricssettings)
+        lyrics.song = song
+        lyrics.source = ''
+        lyrics.lyrics = ''
+        return lyrics
+
+    def get_lyrics_from_memory(self, song):
+        for l in self.fetchedLyrics:
+            if (l.song == song):
+                return l
+        return None
+
+    def get_lyrics_from_file(self, song, getlrc):
+        lyrics = Lyrics(settings=self.lyricssettings)
+        lyrics.song = song
+        lyrics.source = LANGUAGE(32000)
+        lyrics.lrc = getlrc
+        if self.SETTING_SAVE_LYRICS1LRC or self.SETTING_SAVE_LYRICS1TXT:
+            # Search save path by Cu LRC Lyrics
+            lyricsfile = song.path1(getlrc)
+            log('path1: %s' % lyricsfile, debug=self.DEBUG)
+            if xbmcvfs.exists(lyricsfile):
+                lyr = get_textfile(lyricsfile)
+                if lyr != None:
+                    lyrics.lyrics = lyr
+                    return lyrics
+        if self.SETTING_SAVE_LYRICS2LRC or self.SETTING_SAVE_LYRICS2TXT:
+            # Search same path with song file
+            lyricsfile = song.path2(getlrc)
+            log('path2: %s' % lyricsfile, debug=self.DEBUG)
+            if xbmcvfs.exists(lyricsfile):
+                lyr = get_textfile(lyricsfile)
+                if lyr != None:
+                    lyrics.lyrics = lyr
+                    return lyrics
+        return None
+
+    def save_lyrics_to_memory(self, lyrics):
+        savedLyrics = self.get_lyrics_from_memory(lyrics.song)
+        if (savedLyrics is None):
+            self.fetchedLyrics.append(lyrics)
+            self.fetchedLyrics = self.fetchedLyrics[-10:]
+
+    def save_lyrics_to_file(self, lyrics, adjust=None):
+        if isinstance (lyrics.lyrics, str):
+            lyr = lyrics.lyrics
+        else:
+            lyr = lyrics.lyrics
+        if adjust:
+            # save our manual sync offset to file
+            adjust = int(adjust * 1000)
+            # check if there's an existing offset tag
+            found = re.search('\[offset:(.*?)\]', lyr, flags=re.DOTALL)
+            if found:
+                # get the sum of both values
+                try:
+                    adjust = int(found.group(1)) + adjust
+                except:
+                    # offset tag without value
+                    pass
+                # remove the existing offset tag
+                lyr = lyr.replace(found.group(0) + '\n','')
+            # write our new offset tag
+            lyr = '[offset:%i]\n' % adjust + lyr
+        if (self.SETTING_SAVE_LYRICS1LRC and lyrics.lrc) or (self.SETTING_SAVE_LYRICS1TXT and not lyrics.lrc):
+            file_path = lyrics.song.path1(lyrics.lrc)
+            success = self.write_lyrics_file(file_path, lyr)
+        if (self.SETTING_SAVE_LYRICS2LRC and lyrics.lrc) or (self.SETTING_SAVE_LYRICS2TXT and not lyrics.lrc):
+            file_path = lyrics.song.path2(lyrics.lrc)
+            success = self.write_lyrics_file(file_path, lyr)
+
+    def write_lyrics_file(self, path, data):
+        try:
+            if (not xbmcvfs.exists(os.path.dirname(path))):
+                xbmcvfs.mkdirs(os.path.dirname(path))
+            lyrics_file = xbmcvfs.File(path, 'w')
+            lyrics_file.write(data)
+            lyrics_file.close()
+            return True
+        except:
+            log('failed to save lyrics', debug=self.DEBUG)
+            return False
+
+    def remove_lyrics_from_memory(self, lyrics):
+        # delete lyrics from memory
+        if lyrics in self.fetchedLyrics:
+            self.fetchedLyrics.remove(lyrics)
+
+    def delete_lyrics(self, lyrics):
+        # delete lyrics from memory
+        self.remove_lyrics_from_memory(lyrics)
+        # delete saved lyrics
+        if (self.SETTING_SAVE_LYRICS1LRC and lyrics.lrc) or (self.SETTING_SAVE_LYRICS1LRC and not lyrics.lrc):
+            file_path = lyrics.song.path1(lyrics.lrc)
+            success = self.delete_file(file_path)
+        if (self.SETTING_SAVE_LYRICS2LRC and lyrics.lrc) or (self.SETTING_SAVE_LYRICS2LRC and not lyrics.lrc):
+            file_path = lyrics.song.path2(lyrics.lrc)
+            success = self.delete_file(file_path)
+
+    def delete_file(self, path):
+        try:
+            xbmcvfs.delete(path)
+            return True
+        except:
+            log('failed to delete file', debug=self.DEBUG)
+            return False
+
+    def myPlayerChanged(self):
+        if not self.CULRC_FIRSTRUN:
+            return
+        global lyrics
+        songchanged = False
+        for cnt in range(5):
+            song = Song.current(opt=self.lyricssettings)
+            if song and (self.current_lyrics.song != song):
+                songchanged = True
+                if xbmc.getCondVisibility('Player.IsInternetStream') and not xbmc.getInfoLabel('MusicPlayer.TimeRemaining'):
+                    # internet stream that does not provide time, we need our own timer to sync lrc lyrics
+                    self.starttime = time.time()
+                    self.customtimer = True
+                else:
+                    self.customtimer = False
+                log('Current Song: %s - %s' % (song.artist, song.title), debug=self.DEBUG)
+                lyrics = self.get_lyrics(song, False)
+                self.current_lyrics = lyrics
+                # if we have found lyrics and have not skipped to another track while searching for lyrics, show lyrics
+                if lyrics.lyrics and (song == Song.current(opt=self.lyricssettings)):
+                    # signal the gui thread to display the next lyrics
+                    self.CULRC_NOLYRICS = False
+                    self.CULRC_NEWLYRICS = True
+                    # double-check if we're still on the visualisation screen and check if gui is already running
+                    if self.proceed() and not WIN.getProperty('culrc.guirunning') == 'TRUE':
+                        WIN.setProperty('culrc.guirunning', 'TRUE')
+                        self.kwargs = {'service':self.SETTING_SERVICE, 'save':self.save_lyrics_to_file, 'remove':self.remove_lyrics_from_memory, 'delete':self.delete_lyrics, \
+                                       'function':self.return_time, 'callback':self.callback, 'monitor':self.Monitor, 'offset':self.SETTING_OFFSET, 'strip':self.SETTING_STRIP, \
+                                       'debug':self.DEBUG, 'settings':self.lyricssettings}
+                        gui = guiThread(opt=self.kwargs)
+                        gui.start()
+                else:
+                    # signal gui thread to exit
+                    self.CULRC_NOLYRICS = True
+                    if self.MyPlayer.isPlayingAudio() and not self.SETTING_SILENT and self.proceed():
+                        # notify user no lyrics were found
+                        self.dialog.notification(ADDONNAME + ': ' + LANGUAGE(32001), song.artist + ' - ' + song.title, icon=ADDONICON, time=2000, sound=False)
+                break
+            xbmc.sleep(50)
+        # only search for next lyrics if current song has changed and we have not skipped to another track while searching for lyrics
+        if xbmc.getCondVisibility('MusicPlayer.HasNext') and songchanged and (song == Song.current(opt=self.lyricssettings)):
+            next_song = Song.next(opt=self.lyricssettings)
+            if next_song:
+                log('Next Song: %s - %s' % (next_song.artist, next_song.title), debug=self.DEBUG)
+                self.get_lyrics(next_song, True)
+            else:
+                log('Missing Artist or Song name for next track', debug=self.DEBUG)
+
+    def update_settings(self):
+        self.get_settings()
+        if not self.SETTING_SERVICE:
+            # quit the script if mode was changed from service to manual
+            self.CULRC_QUIT = True
+
+    def callback(self, action):
+        if action == 'quit':
+            self.CULRC_QUIT = True
+        elif action == 'newlyrics':
+            if self.CULRC_NEWLYRICS:
+                self.CULRC_NEWLYRICS = False
+                return True
+            return False
+        elif action == 'nolyrics':
+            return self.CULRC_NOLYRICS
+
+    def proceed(self):
+        return xbmc.getCondVisibility('Window.IsVisible(12006)') and not self.Monitor.abortRequested()
+
+    def clear(self):
+        WIN.clearProperty('culrc.lyrics')
+        WIN.clearProperty('culrc.islrc')
+        WIN.clearProperty('culrc.source')
+        WIN.clearProperty('culrc.haslist')
+
+    def return_time(self):
+        return self.customtimer, self.starttime
+
+
+class guiThread(threading.Thread):
+    def __init__(self, *args, **kwargs):
+        threading.Thread.__init__(self)
+        self.kwargs = kwargs['opt']
+
+    def run(self):
+        ui = GUI('script-cu-lrclyrics-main.xml', CWD, 'Default', opt=self.kwargs)
+        ui.doModal()
+        del ui
+        WIN.clearProperty('culrc.guirunning')
+
+
+class syncThread(threading.Thread):
+    def __init__(self, *args, **kwargs):
+        threading.Thread.__init__(self)
+        self.function = kwargs['function']
+        self.adjust = kwargs['adjust']
+        self.save = kwargs['save']
+        self.remove = kwargs['remove']
+        self.lyrics = kwargs['lyrics']
+        self.Monitor = kwargs['monitor']
+
+    def run(self):
+        from lib import sync
+        dialog = sync.GUI('DialogSlider.xml' , CWD, 'Default', offset=self.adjust, function=self.function, monitor=self.Monitor)
+        dialog.doModal()
+        adjust = dialog.val
+        del dialog
+        # safe new offset to file
+        self.save(self.lyrics, adjust)
+        # file has changed, remove it from memory
+        self.remove(self.lyrics)
+
+class GUI(xbmcgui.WindowXMLDialog):
+    def __init__(self, *args, **kwargs):
+        xbmcgui.WindowXMLDialog.__init__(self)
+        self.save = kwargs['opt']['save']
+        self.remove = kwargs['opt']['remove']
+        self.delete = kwargs['opt']['delete']
+        self.function = kwargs['opt']['function']
+        self.callback = kwargs['opt']['callback']
+        self.Monitor = kwargs['opt']['monitor']
+        self.SETTING_OFFSET = kwargs['opt']['offset']
+        self.SETTING_SERVICE = kwargs['opt']['service']
+        self.SETTING_STRIP = kwargs['opt']['strip']
+        self.DEBUG = kwargs['opt']['debug']
+        self.lyricssettings = kwargs['opt']['settings']
+        self.dialog = xbmcgui.Dialog()
+
+    def onInit(self):
+        self.matchlist = ['@', 'www\.(.*?)\.(.*?)', 'QQ(.*?)[1-9]', 'artist ?: ?.', 'album ?: ?.', 'title ?: ?.', 'song ?: ?.', 'by ?: ?.']
+        self.text = self.getControl(110)
+        self.label = self.getControl(200)
+        self.setup_gui()
+        self.process_lyrics()
+        # we have processed the lyrics, reset the new lyrics bool, else we do it again when entering the main loop
+        self.callback('newlyrics')
+        self.gui_loop()
+
+    def process_lyrics(self):
+        global lyrics
+        self.syncadjust = 0.0
+        self.selectedlyric = 0
+        self.lyrics = lyrics
+        self.stop_refresh()
+        self.reset_controls()
+        if self.lyrics.lyrics:
+            self.show_lyrics(self.lyrics)
+        else:
+            WIN.setProperty('culrc.lyrics', LANGUAGE(32001))
+            WIN.clearProperty('culrc.islrc')
+
+        if self.lyrics.list:
+            WIN.setProperty('culrc.haslist', 'true')
+            self.prepare_list(self.lyrics.list)
+        else:
+            WIN.clearProperty('culrc.haslist')
+            self.choices = []
+
+    def gui_loop(self):
+        # gui loop
+        while self.showgui and (not self.Monitor.abortRequested()) and xbmc.Player().isPlayingAudio():
+            # check if we have new lyrics
+            if self.callback('newlyrics'):
+                # show new lyrics
+                self.process_lyrics()
+            # check if we have no lyrics
+            elif self.deleted or self.callback('nolyrics'):
+                # no lyrics, close the gui
+                self.exit_gui('close')
+            elif not xbmc.getCondVisibility('Window.IsVisible(12006)'):
+                # we're not on the visualisation screen anymore
+                self.exit_gui('quit')
+            xbmc.sleep(100)
+        # music ended, close the gui
+        if (not xbmc.Player().isPlayingAudio()):
+            self.exit_gui('quit')
+        # xbmc quits, close the gui 
+        elif self.Monitor.abortRequested():
+            self.exit_gui('quit')
+
+    def setup_gui(self):
+        WIN.clearProperty('culrc.haslist')
+#        self.lock = threading.Lock()
+        self.timer = None
+        self.allowtimer = True
+        self.refreshing = False
+        self.blockOSD = False
+        self.controlId = -1
+        self.pOverlay = []
+        self.choices = []
+        self.scroll_line = int(self.get_page_lines() / 2)
+        self.showgui = True
+        self.deleted = False
+
+    def get_page_lines(self):
+        # we need to close the OSD else we can't get control 110
+        self.blockOSD = True
+        if xbmc.getCondVisibility('Window.IsVisible(musicosd)'):
+            xbmc.executebuiltin('Dialog.Close(musicosd,true)')
+        self.text.setVisible(False)
+        # numpages returns a string, make sure it's not empty
+        while xbmc.getInfoLabel('Container(110).NumPages') and (int(xbmc.getInfoLabel('Container(110).NumPages')) < 2) and (not self.Monitor.abortRequested()):
+            listitem = xbmcgui.ListItem(offscreen=True)
+            self.text.addItem(listitem)
+            xbmc.sleep(5)
+        # xbmc quits, close the gui 
+        if self.Monitor.abortRequested():
+            self.exit_gui('quit')
+        lines = self.text.size() - 1
+        self.blockOSD = False
+        return lines
+
+    def refresh(self):
+#        self.lock.acquire()
+        #Maybe Kodi is not playing any media file
+        try:
+            customtimer, starttime = self.function()
+            if customtimer:
+                cur_time = time.time() - starttime
+            else:
+                cur_time = xbmc.Player().getTime()
+            nums = self.text.size()
+            pos = self.text.getSelectedPosition()
+            if (cur_time < (self.pOverlay[pos][0] - self.syncadjust)):
+                while (pos > 0 and (self.pOverlay[pos - 1][0] - self.syncadjust) > cur_time):
+                    pos = pos -1
+            else:
+                while (pos < nums - 1 and (self.pOverlay[pos + 1][0] - self.syncadjust) < cur_time):
+                    pos = pos +1
+                if (pos + self.scroll_line > nums - 1):
+                    self.text.selectItem(nums - 1)
+                else:
+                    self.text.selectItem(pos + self.scroll_line)
+            self.text.selectItem(pos)
+            self.setFocus(self.text)
+            if (self.allowtimer and cur_time < (self.pOverlay[nums - 1][0] - self.syncadjust)):
+                waittime = (self.pOverlay[pos + 1][0] - self.syncadjust) - cur_time
+                self.timer = Timer(waittime, self.refresh)
+                self.refreshing = True
+                self.timer.start()
+            else:
+                self.refreshing = False
+#            self.lock.release()
+        except:
+            pass
+#            self.lock.release()
+
+    def stop_refresh(self):
+#        self.lock.acquire()
+        try:
+            self.timer.cancel()
+        except:
+            pass
+        self.refreshing = False
+#        self.lock.release()
+
+    def show_lyrics(self, lyrics):
+        WIN.setProperty('culrc.lyrics', lyrics.lyrics)
+        WIN.setProperty('culrc.source', lyrics.source)
+        if lyrics.list:
+            source = '%s (%d)' % (lyrics.source, len(lyrics.list))
+        else:
+            source = lyrics.source
+        self.label.setLabel(source)
+        if lyrics.lrc:
+            WIN.setProperty('culrc.islrc', 'true')
+            self.parser_lyrics(lyrics.lyrics)
+            for num, (time, line) in enumerate(self.pOverlay):
+                parts = self.get_parts(line)
+                listitem = xbmcgui.ListItem(line, offscreen=True)
+                for count, item in enumerate(parts):
+                    listitem.setProperty('part%i' % (count + 1), item)
+                delta = 100000 # in case duration of the last line is undefined
+                if num < len(self.pOverlay) - 1:
+                    delta = (self.pOverlay[num+1][0] - time) * 1000
+                listitem.setProperty('duration', str(int(delta)))
+                listitem.setProperty('time', str(time))
+                self.text.addItem(listitem)
+        else:
+            WIN.clearProperty('culrc.islrc')
+            splitLyrics = lyrics.lyrics.splitlines()
+            for line in splitLyrics:
+                parts = self.get_parts(line)
+                listitem = xbmcgui.ListItem(line, offscreen=True)
+                for count, item in enumerate(parts):
+                    listitem.setProperty('part%i' % (count + 1), item)
+                self.text.addItem(listitem)
+        self.text.selectItem(0)
+        self.text.setVisible(True)
+        xbmc.sleep(5)
+        self.setFocus(self.text)
+        if lyrics.lrc:
+            if (self.allowtimer and self.text.size() > 1):
+                self.refresh()
+
+    def match_pattern(self, line):
+        for item in self.matchlist:
+            match = re.search(item, line, flags=re.IGNORECASE)
+            if match:
+                return True
+
+    def get_parts(self, line):
+        result = ['', '', '', '']
+        parts = line.split(' ', 3)
+        for count, item in enumerate(parts):
+            result[count] = item
+        return result
+
+    def parser_lyrics(self, lyrics):
+        offset = 0.00
+        found = re.search('\[offset:\s?(-?\d+)\]', lyrics)
+        if found:
+            offset = float(found.group(1)) / 1000
+        self.pOverlay = []
+        tag1 = re.compile('\[(\d+):(\d\d)[\.:](\d\d)\]')
+        tag2 = re.compile('\[(\d+):(\d\d)([\.:]\d+|)\]')
+        lyrics = lyrics.replace('\r\n' , '\n')
+        sep = '\n'
+        for x in lyrics.split(sep):
+            if self.match_pattern(x):
+                continue
+            match1 = tag1.match(x)
+            match2 = tag2.match(x)
+            times = []
+            if (match1):
+                while (match1): # [xx:yy.zz]
+                    times.append(float(match1.group(1)) * 60 + float(match1.group(2)) + (float(match1.group(3))/100) + self.SETTING_OFFSET - offset)
+                    y = 6 + len(match1.group(1)) + len(match1.group(3))
+                    x = x[y:]
+                    match1 = tag1.match(x)
+                for time in times:
+                    self.pOverlay.append((time, x))
+            elif (match2): # [xx:yy]
+                while (match2):
+                    times.append(float(match2.group(1)) * 60 + float(match2.group(2)) + self.SETTING_OFFSET - offset)
+                    y = 5 + len(match2.group(1)) + len(match2.group(3))
+                    x = x[y:]
+                    match2 = tag2.match(x)
+                for time in times:
+                    self.pOverlay.append((time, x))
+        self.pOverlay.sort()
+        # don't display/focus the first line from the start of the song
+        self.pOverlay.insert(0, (00.00, ''))
+        if self.SETTING_STRIP:
+            poplist = []
+            prev_time = []
+            prev_line = ''
+            for num, (time, line) in enumerate(self.pOverlay):
+                if time == prev_time:
+                    if len(line) > len(prev_line):
+                        poplist.append(num - 1)
+                    else:
+                        poplist.append(num)
+                prev_time = time
+                prev_line = line
+            for i in reversed(poplist):
+                self.pOverlay.pop(i)
+
+    def prepare_list(self, lyricslist):
+        self.choices = []
+        for song in lyricslist:
+            listitem = xbmcgui.ListItem(song[0], offscreen=True)
+            listitem.setProperty('lyric', str(song))
+            listitem.setProperty('source', lyrics.source)
+            self.choices.append(listitem)
+
+    def reshow_choices(self):
+        if self.choices:
+            select = self.dialog.select(LANGUAGE(32005), self.choices, preselect=self.selectedlyric)
+            if select > -1 and select != self.selectedlyric:
+                self.selectedlyric = select
+                self.stop_refresh()
+                item = self.choices[select]
+                source = item.getProperty('source').lower()
+                lyric = eval(item.getProperty('lyric'))
+                exec ('from lib.culrcscrapers.%s import lyricsScraper as lyricsScraper_%s' % (source, source))
+                scraper = eval('lyricsScraper_%s.LyricsFetcher(debug=self.DEBUG, settings=self.lyricssettings)' % source)
+                self.lyrics.lyrics = scraper.get_lyrics_from_list(lyric)
+                self.text.reset()
+                self.show_lyrics(self.lyrics)
+                self.save(self.lyrics)
+
+    def set_synctime(self, adjust):
+        self.syncadjust = adjust
+
+    def scrolltosync(self):
+        old_time = xbmc.Player().getTime()
+        item = self.text.getSelectedItem()
+        new_time = float(item.getProperty('time'))
+        self.syncadjust = new_time - old_time
+        # safe new offset to file
+        self.save(self.lyrics, self.syncadjust)
+        # file has changed, remove it from memory
+        self.remove(self.lyrics)
+
+    def context_menu(self):
+        labels = ()
+        functions = ()
+        if self.choices:
+            labels += (LANGUAGE(32006),)
+            functions += ('select',)
+        if WIN.getProperty('culrc.islrc') == 'true':
+            labels += (LANGUAGE(32007),)
+            functions += ('sync',)
+        if lyrics.source != LANGUAGE(32002):
+            labels += (LANGUAGE(32167),)
+            functions += ('delete',)
+        if labels:
+            selection = self.dialog.contextmenu(labels)
+            if selection >= 0:
+                if functions[selection] == 'select':
+                    self.reshow_choices()
+                elif functions[selection] == 'sync':
+                    sync = syncThread(adjust=self.syncadjust, function=self.set_synctime, save=self.save, lyrics=self.lyrics, remove=self.remove, monitor=self.Monitor)
+                    sync.start()
+                elif functions[selection] == 'delete':
+                    self.lyrics.lyrics = ''
+                    self.reset_controls()
+                    self.deleted = True
+                    self.delete(self.lyrics)
+
+    def reset_controls(self):
+        self.text.reset()
+        self.label.setLabel('')
+        WIN.clearProperty('culrc.lyrics')
+        WIN.clearProperty('culrc.islrc')
+        WIN.clearProperty('culrc.source')
+
+    def exit_gui(self, action):
+        # in manual mode, we also need to quit the script when the user cancels the gui or music has ended
+        if (not self.SETTING_SERVICE) and (action == 'quit'):
+            # signal the main loop to quit
+            self.callback('quit')
+        self.allowtimer = False
+        self.stop_refresh()
+        self.showgui = False
+        self.close()
+
+    def onClick(self, controlId):
+        if (controlId == 110):
+            # will only work for lrc based lyrics
+            try:
+                item = self.text.getSelectedItem()
+                stamp = float(item.getProperty('time'))
+                xbmc.Player().seekTime(stamp)
+            except:
+                pass
+
+    def onFocus(self, controlId):
+        self.controlId = controlId
+
+    def onAction(self, action):
+        actionId = action.getId()
+        if (actionId in CANCEL_DIALOG):
+            # dialog cancelled, close the gui
+            self.exit_gui('quit')
+        elif (actionId == 101) or (actionId == 117): # ACTION_MOUSE_RIGHT_CLICK / ACTION_CONTEXT_MENU
+            self.context_menu()
+        elif (actionId in ACTION_OSD):
+            if not self.blockOSD:
+                # mouse move constantly calls ACTION_OSD, process only once
+                if not xbmc.getCondVisibility('Window.IsVisible(10120)'):
+                    xbmc.executebuiltin('ActivateWindow(10120)')
+        elif (actionId in ACTION_CODEC):
+            xbmc.executebuiltin('Action(PlayerProcessInfo)')
+        elif (actionId in ACTION_UPDOWN) and (self.controlId == 110) and WIN.getProperty('culrc.islrc') == 'true':
+            self.scrolltosync()
+
+class MyPlayer(xbmc.Player):
+    def __init__(self, *args, **kwargs):
+        xbmc.Player.__init__(self)
+        self.function = kwargs['function']
+        self.clear = kwargs['clear']
+
+    def onAVStarted(self):
+        self.clear()
+        if xbmc.getCondVisibility('Window.IsVisible(12006)'):
+            self.function()
+
+    def onPlayBackStopped(self):
+        self.clear()
+
+    def onPlayBackEnded(self):
+        self.clear()
+
+class MyMonitor(xbmc.Monitor):
+    def __init__(self, *args, **kwargs):
+        xbmc.Monitor.__init__(self)
+        self.function = kwargs['function']
+
+    def onSettingsChanged(self):
+        # sleep before retrieving the new settings
+        xbmc.sleep(500)
+        self.function()
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/scrapertest.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/scrapertest.py
new file mode 100644
index 00000000000..9b64c98414f
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/scrapertest.py
@@ -0,0 +1,268 @@
+#-*- coding: UTF-8 -*-
+import time
+from lib.utils import *
+from lib.culrcscrapers.azlyrics import lyricsScraper as lyricsScraper_azlyrics
+from lib.culrcscrapers.darklyrics import lyricsScraper as lyricsScraper_darklyrics
+from lib.culrcscrapers.genius import lyricsScraper as lyricsScraper_genius
+from lib.culrcscrapers.lrclib import lyricsScraper as lyricsScraper_lrclib
+from lib.culrcscrapers.lyricscom import lyricsScraper as lyricsScraper_lyricscom
+from lib.culrcscrapers.lyricsify import lyricsScraper as lyricsScraper_lyricsify
+from lib.culrcscrapers.lyricsmode import lyricsScraper as lyricsScraper_lyricsmode
+from lib.culrcscrapers.megalobiz import lyricsScraper as lyricsScraper_megalobiz
+from lib.culrcscrapers.music163 import lyricsScraper as lyricsScraper_music163
+from lib.culrcscrapers.musixmatch import lyricsScraper as lyricsScraper_musixmatch
+from lib.culrcscrapers.musixmatchlrc import lyricsScraper as lyricsScraper_musixmatchlrc
+from lib.culrcscrapers.supermusic import lyricsScraper as lyricsScraper_supermusic
+
+FAILED = []
+
+def test_scrapers():
+    lyricssettings = {}
+    lyricssettings['debug'] = ADDON.getSettingBool('log_enabled')
+    lyricssettings['save_filename_format'] = ADDON.getSettingInt('save_filename_format')
+    lyricssettings['save_lyrics_path'] = ADDON.getSettingString('save_lyrics_path')
+    lyricssettings['save_subfolder'] = ADDON.getSettingBool('save_subfolder')
+    lyricssettings['save_subfolder_path'] = ADDON.getSettingString('save_subfolder_path')
+
+    dialog = xbmcgui.DialogProgress()
+    TIMINGS = []
+
+    # test alsong
+    dialog.create(ADDONNAME, LANGUAGE(32163) % 'azlyrics')
+    log('==================== azlyrics ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'La Dispute'
+    song.title = 'Such Small Hands'
+    st = time.time()
+    lyrics = lyricsScraper_azlyrics.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['azlyrics',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('azlyrics')
+        log('FAILED: azlyrics', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test darklyrics
+    dialog.update(8, LANGUAGE(32163) % 'darklyrics')
+    log('==================== darklyrics ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Neurosis'
+    song.title = 'Lost'
+    st = time.time()
+    lyrics = lyricsScraper_darklyrics.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['darklyrics',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('darklyrics')
+        log('FAILED: darklyrics', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test genius
+    dialog.update(16, LANGUAGE(32163) % 'genius')
+    log('==================== genius ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Maren Morris'
+    song.title = 'My Church'
+    st = time.time()
+    lyrics = lyricsScraper_genius.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['genius',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('genius')
+        log('FAILED: genius', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test lrclib
+    dialog.update(24, LANGUAGE(32163) % 'lrclib')
+    log('==================== lrclib ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'CHVRCHES'
+    song.title = 'Clearest Blue'
+    st = time.time()
+    lyrics = lyricsScraper_lrclib.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['lrclib',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('lrclib')
+        log('FAILED: lrclib', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test lyricscom
+    dialog.update(32, LANGUAGE(32163) % 'lyricscom')
+    log('==================== lyricscom ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Blur'
+    song.title = 'You\'re So Great'
+    st = time.time()
+    lyrics = lyricsScraper_lyricscom.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['lyricscom',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('lyricscom')
+        log('FAILED: lyricscom', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test lyricsify
+    dialog.update(40, LANGUAGE(32163) % 'lyricsify')
+    log('==================== lyricsify ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Madonna'
+    song.title = 'Crazy For You'
+    st = time.time()
+    lyrics = lyricsScraper_lyricsify.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['lyricsify',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('lyricsify')
+        log('FAILED: lyricsify', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test lyricsmode
+    dialog.update(48, LANGUAGE(32163) % 'lyricsmode')
+    log('==================== lyricsmode ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Maren Morris'
+    song.title = 'My Church'
+    st = time.time()
+    lyrics = lyricsScraper_lyricsmode.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['lyricsmode',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('lyricsmode')
+        log('FAILED: lyricsmode', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test megalobiz
+    dialog.update(56, LANGUAGE(32163) % 'megalobiz')
+    log('==================== megalobiz ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Michael Jackson'
+    song.title = 'Beat It'
+    st = time.time()
+    lyrics = lyricsScraper_megalobiz.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['megalobiz',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('megalobiz')
+        log('FAILED: megalobiz', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test music163
+    dialog.update(64, LANGUAGE(32163) % 'music163')
+    log('==================== music163 ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Madonna'
+    song.title = 'Vogue'
+    st = time.time()
+    lyrics = lyricsScraper_music163.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['music163',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('music163')
+        log('FAILED: music163', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test musixmatch
+    dialog.update(72, LANGUAGE(32163) % 'musixmatch')
+    log('==================== musixmatch ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Kate Bush'
+    song.title = 'Wuthering Heights'
+    st = time.time()
+    lyrics = lyricsScraper_musixmatch.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['musixmatch',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('musixmatch')
+        log('FAILED: musixmatch', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test musixmatchlrc
+    dialog.update(80, LANGUAGE(32163) % 'musixmatchlrc')
+    log('==================== musixmatchlrc ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Kate Bush'
+    song.title = 'Wuthering Heights'
+    st = time.time()
+    lyrics = lyricsScraper_musixmatchlrc.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['musixmatchlrc',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('musixmatchlrc')
+        log('FAILED: musixmatchlrc', debug=True)
+    if dialog.iscanceled():
+        return
+
+    # test supermusic
+    dialog.update(88, LANGUAGE(32163) % 'supermusic')
+    log('==================== supermusic ====================', debug=True)
+    song = Song(opt=lyricssettings)
+    song.artist = 'Karel Gott'
+    song.title = 'Trezor'
+    st = time.time()
+    lyrics = lyricsScraper_supermusic.LyricsFetcher(settings=lyricssettings, debug=True).get_lyrics(song)
+    ft = time.time()
+    tt = ft - st
+    TIMINGS.append(['supermusic',tt])
+    if lyrics:
+        log(lyrics.lyrics, debug=True)
+    else:
+        FAILED.append('supermusic')
+        log('FAILED: supermusic', debug=True)
+    if dialog.iscanceled():
+        return
+
+    dialog.close()
+    log('=======================================', debug=True)
+    log('FAILED: %s' % str(FAILED), debug=True)
+    log('=======================================', debug=True)
+    for item in TIMINGS:
+        log('%s - %i' % (item[0], item[1]), debug=True)
+    log('=======================================', debug=True)
+    if FAILED:
+        dialog = xbmcgui.Dialog().ok(ADDONNAME, LANGUAGE(32165) % ' / '.join(FAILED))
+    else:
+        dialog = xbmcgui.Dialog().ok(ADDONNAME, LANGUAGE(32164))
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/sync.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/sync.py
new file mode 100644
index 00000000000..93c66a529f9
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/sync.py
@@ -0,0 +1,48 @@
+from lib.utils import *
+
+ADDON = xbmcaddon.Addon()
+LANGUAGE = ADDON.getLocalizedString
+
+class GUI(xbmcgui.WindowXMLDialog):
+    def __init__(self, *args, **kwargs):
+        self.function = kwargs['function']
+        self.offset = kwargs['offset']
+        self.Monitor = kwargs['monitor']
+
+    def onInit(self):
+        self._get_controls()
+        self._init_values()
+        self.exit = False
+        while (not self.Monitor.abortRequested()) and xbmc.getCondVisibility('Player.HasAudio') and (not self.exit):
+            xbmc.sleep(100)
+        self.close()
+
+    def _get_controls(self):
+        self.header = self.getControl(10)
+        self.slider = self.getControl(11)
+        self.label = self.getControl(12)
+
+    def _init_values(self):
+        self.header.setLabel(LANGUAGE(32003))
+        string = self._get_string(self.offset)
+        self.label.setLabel(string)
+        self.slider.setFloat((self.offset * 1.0), -20.0, 0.1, 20.0)
+
+    def _get_string(self, val):
+        if val > 0.0:
+            string = LANGUAGE(32009) % str(val)
+        elif val < 0.0:
+            string = LANGUAGE(32008) % str(-val)
+        else:
+            string = str(val)
+        return string
+
+    def onAction(self, action):
+        if action.getId() in CANCEL_DIALOG:
+            self.exit = True
+        else:
+            val = self.slider.getFloat()
+            self.val = round(val,1)
+            string = self._get_string(self.val)
+            self.label.setLabel(string)
+            self.function(self.val)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lib/utils.py b/mythtv/programs/scripts/metadata/Music/lyrics/lib/utils.py
new file mode 100644
index 00000000000..f9edc8f6104
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lib/utils.py
@@ -0,0 +1,187 @@
+import chardet
+import os
+import re
+import sys
+import unicodedata
+import xbmc
+import xbmcaddon
+import xbmcgui
+import xbmcvfs
+
+ADDON = xbmcaddon.Addon()
+ADDONNAME = ADDON.getAddonInfo('name')
+ADDONICON = ADDON.getAddonInfo('icon')
+ADDONVERSION = ADDON.getAddonInfo('version')
+ADDONID = ADDON.getAddonInfo('id')
+CWD = xbmcvfs.translatePath(ADDON.getAddonInfo('path'))
+PROFILE = xbmcvfs.translatePath(ADDON.getAddonInfo('profile'))
+LANGUAGE = ADDON.getLocalizedString
+
+CANCEL_DIALOG = (9, 10, 92, 216, 247, 257, 275, 61467, 61448,)
+ACTION_OSD = (107, 163,)
+ACTION_CODEC = (0, 27,)
+ACTION_UPDOWN = (3, 4, 105, 106, 111, 112, 603, 604)
+LYRIC_SCRAPER_DIR = os.path.join(CWD, 'lib', 'culrcscrapers')
+WIN = xbmcgui.Window(10000)
+
+def log(*args, **kwargs):
+    if kwargs['debug']:
+        message = '%s: %s' % (ADDONID, args[0])
+        xbmc.log(msg=message, level=xbmc.LOGDEBUG)
+
+def deAccent(str):
+    return unicodedata.normalize('NFKD', str).replace('"', '')
+
+def get_textfile(filepath):
+    try:
+        f = xbmcvfs.File(filepath)
+        data = f.readBytes()
+        f.close()
+        # Detect text encoding
+        enc = chardet.detect(data)
+        if enc['encoding']:
+            return data.decode(enc['encoding'])
+        else:
+            return data
+    except:
+        return None
+
+def get_artist_from_filename(*args, **kwargs):
+    filename = kwargs['filename']
+    SETTING_READ_FILENAME_FORMAT = kwargs['opt']['read_filename_format']
+    DEBUG = kwargs['opt']['debug']
+    try:
+        artist = ''
+        title = ''
+        basename = os.path.basename(filename)
+        # Artist - title.ext
+        if SETTING_READ_FILENAME_FORMAT == 0:
+            artist = basename.split('-', 1)[0].strip()
+            title = os.path.splitext(basename.split('-', 1)[1].strip())[0]
+        # Artist/Album/title.ext or Artist/Album/Track (-) title.ext
+        elif SETTING_READ_FILENAME_FORMAT in (1,2):
+            artist = os.path.basename(os.path.split(os.path.split(filename)[0])[0])
+            # Artist/Album/title.ext
+            if SETTING_READ_FILENAME_FORMAT == 1:
+                title = os.path.splitext(basename)[0]
+            # Artist/Album/Track (-) title.ext
+            elif SETTING_READ_FILENAME_FORMAT == 2:
+                title = os.path.splitext(basename)[0].split(' ', 1)[1].lstrip('-').strip()
+        # Track Artist - title.ext
+        elif SETTING_READ_FILENAME_FORMAT == 3:
+            at = basename.split(' ', 1)[1].strip()
+            artist = at.split('-', 1)[0].strip()
+            title = os.path.splitext(at.split('-', 1)[1].strip())[0]
+        # Track - Artist - title.ext
+        elif SETTING_READ_FILENAME_FORMAT == 4:
+            artist = basename.split('-', 2)[1].strip()
+            title = os.path.splitext(basename.split('-', 2)[2].strip())[0]
+    except:
+        # invalid format selected
+        log('failed to get artist and title from filename', debug=DEBUG)
+    return artist, title
+
+class Lyrics:
+    def __init__(self, *args, **kwargs):
+        settings = kwargs['settings']
+        self.song = Song(opt=settings)
+        self.lyrics = ''
+        self.source = ''
+        self.list = None
+        self.lrc = False
+
+class Song:
+    def __init__(self, *args, **kwargs):
+        self.album = ''
+        self.artist = ''
+        self.title = ''
+        self.filepath = ''
+        self.embed = ''
+        self.source = ''
+        self.analyze_safe = True
+        self.SETTING_SAVE_FILENAME_FORMAT = kwargs['opt']['save_filename_format']
+        self.SETTING_SAVE_LYRICS_PATH = kwargs['opt']['save_lyrics_path']
+        self.SETTING_SAVE_SUBFOLDER = kwargs['opt']['save_subfolder']
+        self.SETTING_SAVE_SUBFOLDER_PATH = kwargs['opt']['save_subfolder_path']
+
+    def __str__(self):
+        return 'Artist: %s, Title: %s' % (self.artist, self.title)
+
+    def __eq__(self, song):
+        return (deAccent(self.artist) == deAccent(song.artist)) and (deAccent(self.title) == deAccent(song.title))
+
+    def path1(self, lrc):
+        if lrc:
+            ext = '.lrc'
+        else:
+            ext = '.txt'
+        # remove invalid filename characters
+        artist = "".join(i for i in self.artist if i not in "\/:*?<>|")
+        title = "".join(i for i in self.title if i not in "\/:*?<>|")
+        if self.SETTING_SAVE_FILENAME_FORMAT == 0:
+            return os.path.join(self.SETTING_SAVE_LYRICS_PATH, artist, title + ext)
+        else:
+            return os.path.join(self.SETTING_SAVE_LYRICS_PATH, artist + ' - ' + title + ext)
+
+    def path2(self, lrc):
+        if lrc:
+            ext = '.lrc'
+        else:
+            ext = '.txt'
+        dirname = os.path.dirname(self.filepath)
+        basename = os.path.basename(self.filepath)
+        filename = basename.rsplit('.', 1)[0]
+        if self.SETTING_SAVE_SUBFOLDER:
+            return os.path.join(dirname, self.SETTING_SAVE_SUBFOLDER_PATH, filename + ext)
+        else:
+            return os.path.join(dirname, filename + ext)
+
+    @staticmethod
+    def current(*args, **kwargs):
+        kwargs = kwargs['opt']
+        song = Song.by_offset(offset=0, opt=kwargs)
+        return song
+
+    @staticmethod
+    def next(*args, **kwargs):
+        kwargs = kwargs['opt']
+        song = Song.by_offset(offset=1, opt=kwargs)
+        if song.artist != '' and song.title != '':
+            return song
+
+    @staticmethod
+    def by_offset(*args, **kwargs):
+        offset = kwargs['offset']
+        SETTING_READ_FILENAME = kwargs['opt']['read_filename']
+        SETTING_CLEAN_TITLE = kwargs['opt']['clean_title']
+        song = Song(opt=kwargs['opt'])
+        if offset > 0:
+            offset_str = '.offset(%i)' % offset
+        else:
+            offset_str = ''
+        song.filepath = xbmc.getInfoLabel('Player%s.Filenameandpath' % offset_str)
+        song.title = xbmc.getInfoLabel('MusicPlayer%s.Title' % offset_str).replace('\\', ' & ').replace('/', ' & ').replace('  ',' ').replace(':','-').strip('.')
+        song.artist = xbmc.getInfoLabel('MusicPlayer%s.Artist' % offset_str).replace('\\', ' & ').replace('/', ' & ').replace('  ',' ').replace(':','-').strip('.')
+        song.embed = xbmc.getInfoLabel('MusicPlayer%s.Lyrics' % offset_str)
+        song.source = xbmc.getInfoLabel('MusicPlayer%s.Property(culrc.source)' % offset_str)
+        # some third party addons may insert the tracknumber in the song title
+        regex = re.compile('\d\d\.\s')
+        match = regex.match(song.title)
+        if match:
+            song.title = song.title[4:]
+        if xbmc.getCondVisibility('Player.IsInternetStream') or xbmc.getCondVisibility('Pvr.IsPlayingRadio'):
+            # disable search for embedded lyrics for internet streams
+            song.analyze_safe = False
+        if not song.artist:
+            # We probably listen to online radio which usually sets the song title as 'Artist - Title' (via ICY StreamTitle)
+            sep = song.title.find('-')
+            if sep > 1:
+                song.artist = song.title[:sep - 1].strip()
+                song.title = song.title[sep + 1:].strip()
+                # The title can contains some additional info in brackets at the end, so we remove it
+                song.title = re.sub(r'\([^\)]*\)$', '', song.title)
+        if (song.filepath and ((not song.title) or (not song.artist) or (SETTING_READ_FILENAME))):
+            song.artist, song.title = get_artist_from_filename(filename=song.filepath, opt=kwargs['opt'])
+        if SETTING_CLEAN_TITLE:
+            song.title = re.sub(r'\([^\)]*\)$', '', song.title)
+        return song
From 9193927976176310b83f798da92c67957059fb97 Mon Sep 17 00:00:00 2001
From: Timothy D Witham <twitham@sbcglobal.net>
Date: Fri, 12 Jan 2024 00:51:29 -0600
Subject: [PATCH] MythMusic: add Kodistubs for use with CU LRC

from https://github.com/romanvm/Kodistubs
---
 .../Music/lyrics/Kodistubs/.gitignore         |  118 +
 .../Music/lyrics/Kodistubs/LICENSE.txt        |  621 +++
 .../Music/lyrics/Kodistubs/MANIFEST.in        |   10 +
 .../Music/lyrics/Kodistubs/README.rst         |   47 +
 .../Music/lyrics/Kodistubs/pyproject.toml     |    3 +
 .../Music/lyrics/Kodistubs/requirements.txt   |    1 +
 .../metadata/Music/lyrics/Kodistubs/setup.cfg |   31 +
 .../metadata/Music/lyrics/Kodistubs/setup.py  |    3 +
 .../metadata/Music/lyrics/Kodistubs/xbmc.py   | 4081 ++++++++++++++
 .../Music/lyrics/Kodistubs/xbmcaddon.py       |  642 +++
 .../Music/lyrics/Kodistubs/xbmcdrm.py         |  215 +
 .../Music/lyrics/Kodistubs/xbmcgui.py         | 4887 +++++++++++++++++
 .../Music/lyrics/Kodistubs/xbmcplugin.py      |  387 ++
 .../Music/lyrics/Kodistubs/xbmcvfs.py         |  542 ++
 14 files changed, 11588 insertions(+)
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/.gitignore
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/LICENSE.txt
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/MANIFEST.in
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/README.rst
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/pyproject.toml
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/requirements.txt
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.cfg
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcdrm.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcplugin.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py

diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/.gitignore b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/.gitignore
new file mode 100644
index 00000000000..59e03e27fb3
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/.gitignore
@@ -0,0 +1,118 @@
+# Created by .ignore support plugin (hsz.mobi)
+### JetBrains template
+# Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion
+
+*.iml
+
+## Directory-based project format:
+.idea/
+# if you remove the above rule, at least ignore the following:
+
+# User-specific stuff:
+# .idea/workspace.xml
+# .idea/tasks.xml
+# .idea/dictionaries
+
+# Sensitive or high-churn files:
+# .idea/dataSources.ids
+# .idea/dataSources.xml
+# .idea/sqlDataSources.xml
+# .idea/dynamic.xml
+# .idea/uiDesigner.xml
+
+# Gradle:
+# .idea/gradle.xml
+# .idea/libraries
+
+# Mongo Explorer plugin:
+# .idea/mongoSettings.xml
+
+## File-based project format:
+*.ipr
+*.iws
+
+## Plugin-specific files:
+
+# IntelliJ
+/out/
+
+# mpeltonen/sbt-idea plugin
+.idea_modules/
+
+# JIRA plugin
+atlassian-ide-plugin.xml
+
+# Crashlytics plugin (for Android Studio and IntelliJ)
+com_crashlytics_export_strings.xml
+crashlytics.properties
+crashlytics-build.properties
+
+
+### Python template
+# Byte-compiled / optimized / DLL files
+__pycache__/
+*.py[cod]
+*$py.class
+
+# C extensions
+*.so
+
+# Distribution / packaging
+.Python
+.venv/
+env/
+build/
+develop-eggs/
+dist/
+downloads/
+eggs/
+.eggs/
+lib/
+lib64/
+parts/
+sdist/
+var/
+*.egg-info/
+.installed.cfg
+*.egg
+
+# PyInstaller
+#  Usually these files are written by a python script from a template
+#  before PyInstaller builds the exe, so as to inject date/other infos into it.
+*.manifest
+*.spec
+
+# Installer logs
+pip-log.txt
+pip-delete-this-directory.txt
+
+# Unit test / coverage reports
+htmlcov/
+.tox/
+.coverage
+.coverage.*
+.cache
+nosetests.xml
+coverage.xml
+*,cover
+
+# Translations
+*.mo
+*.pot
+
+# Django stuff:
+*.log
+
+# Sphinx documentation
+docs/_build/
+
+# PyBuilder
+target/
+
+epydoc.cmd
+epydoc.cfg
+_docs/
+venv/
+venv.cmd
+.venv3/
+docs/_autosummary/xbmc*
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/LICENSE.txt b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/LICENSE.txt
new file mode 100644
index 00000000000..94a04532226
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/LICENSE.txt
@@ -0,0 +1,621 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/MANIFEST.in b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/MANIFEST.in
new file mode 100644
index 00000000000..c82a48fdd5d
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/MANIFEST.in
@@ -0,0 +1,10 @@
+include xbmc.py
+include xbmcaddon.py
+include xbmcgui.py
+include xbmcplugin.py
+include xbmcvfs.py
+include kodistubs_meta.py
+include setup.py
+include LICENSE.txt
+include README.rst
+global-exclude *.pyc *.pyo
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/README.rst b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/README.rst
new file mode 100644
index 00000000000..85ff83b2cc9
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/README.rst
@@ -0,0 +1,47 @@
+Kodistubs
+=========
+(former xbmcstubs)
+------------------
+
+.. image:: https://badge.fury.io/py/Kodistubs.svg
+    :target: https://badge.fury.io/py/Kodistubs
+
+Kodi stubs are Python files that can help you develop addons for `Kodi (XBMC)`_ Media Center.
+Use them in your favorite IDE to enable autocompletion and view docstrings
+for Kodi Python API functions, classes and methods.
+Kodistubs also include `PEP-484`_ type annotations for all functions
+and methods.
+
+You can install Kodistubs into your working virtual environment using ``pip``::
+
+    $ pip install Kodistubs
+
+Read `Kodistubs documentation`_ for more info on how to use Kodi stubs.
+
+Kodistubs major version corresponds to the version of Kodi they have been generated from.
+Current Kodistubs are compatible with Python 3.6 and above. Kodistubs for Kodi versions that used
+Python 2.x for addons can be found in ``python2`` branch.
+
+**Warning**: Kodistubs are literally stubs and do not include any useful code,
+so don't try to run your program outside Kodi unless you add some testing code into Kodistubs
+or use some mocking library to mock Kodi Python API.
+
+Current Kodistubs have been generated from scratch using `this script`_ from Doxygen XML files and
+SWIG XML Python binding definitions that, in their turn, have been generated
+from Kodi sources. Old Kodistubs can be found in ``legacy`` branch.
+
+I try to keep Kodi stubs in sync with Kodi Python API development, but it may happen
+that I miss something. Don't hesitate to open issues or submit pull requests if you notice
+discrepancies with the actual state of Kodi Python API.
+
+
+`Discussion topic on Kodi forum`_
+
+License: `GPL v.3`_
+
+.. _Kodi (XBMC): http://kodi.tv
+.. _Discussion topic on Kodi forum: http://forum.kodi.tv/showthread.php?tid=173780
+.. _GPL v.3: http://www.gnu.org/licenses/gpl.html
+.. _Kodistubs documentation: https://romanvm.github.io/Kodistubs/
+.. _PEP-484: https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code
+.. _this script: https://github.com/romanvm/kodistubs-generator
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/pyproject.toml b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/pyproject.toml
new file mode 100644
index 00000000000..9787c3bdf00
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/pyproject.toml
@@ -0,0 +1,3 @@
+[build-system]
+requires = ["setuptools", "wheel"]
+build-backend = "setuptools.build_meta"
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/requirements.txt b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/requirements.txt
new file mode 100644
index 00000000000..2806c164989
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/requirements.txt
@@ -0,0 +1 @@
+Sphinx
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.cfg b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.cfg
new file mode 100644
index 00000000000..6939982148e
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.cfg
@@ -0,0 +1,31 @@
+[metadata]
+name = Kodistubs
+version = 20.0.1
+author = Roman Miroshnychenko
+author_email = roman1972@gmail.com
+url = https://github.com/romanvm/Kodistubs
+description = Stub modules that re-create Kodi Python API
+long_description = file: README.rst
+long_description_content_type = text/x-rst
+keywords = kodi documentation inspection
+license = GPL-3.0-only
+classifiers =
+    Environment :: Plugins
+    License :: OSI Approved :: GNU General Public License v3 (GPLv3)
+    Operating System :: OS Independent
+    Programming Language :: Python :: 3
+    Topic :: Software Development :: Libraries
+    Topic :: Software Development :: Libraries :: Python Modules
+platform = any
+
+[options]
+py_modules =
+    xbmc
+    xbmcaddon
+    xbmcgui
+    xbmcplugin
+    xbmcvfs
+    xbmcdrm
+zip_safe = False
+include_package_data = True
+python_requires = >=3.6
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.py
new file mode 100644
index 00000000000..606849326a4
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/setup.py
@@ -0,0 +1,3 @@
+from setuptools import setup
+
+setup()
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py
new file mode 100644
index 00000000000..27438224eac
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py
@@ -0,0 +1,4081 @@
+# This file is generated from Kodi source code and post-edited
+# to correct code style and docstrings formatting.
+# License: GPL v.3 <https://www.gnu.org/licenses/gpl-3.0.en.html>
+"""
+**General functions on Kodi.**
+
+Offers classes and functions that provide information about the media currently
+playing and that allow manipulation of the media player (such as starting a new
+song). You can also find system information using the functions available in
+this library.
+"""
+from typing import Union, List, Dict, Tuple, Optional
+
+__kodistubs__ = True
+
+DRIVE_NOT_READY = 1
+ENGLISH_NAME = 2
+ISO_639_1 = 0
+ISO_639_2 = 1
+LOGDEBUG = 0
+LOGERROR = 3
+LOGFATAL = 4
+LOGINFO = 1
+LOGNONE = 5
+LOGWARNING = 2
+PLAYLIST_MUSIC = 0
+PLAYLIST_VIDEO = 1
+SERVER_AIRPLAYSERVER = 2
+SERVER_EVENTSERVER = 6
+SERVER_JSONRPCSERVER = 3
+SERVER_UPNPRENDERER = 4
+SERVER_UPNPSERVER = 5
+SERVER_WEBSERVER = 1
+SERVER_ZEROCONF = 7
+TRAY_CLOSED_MEDIA_PRESENT = 3
+TRAY_CLOSED_NO_MEDIA = 2
+TRAY_OPEN = 1
+
+
+class InfoTagGame:
+    """
+    **Kodi's game info tag class.**
+
+    Access and / or modify the game metadata of a ListItem.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        tag = item.getGameInfoTag()
+        
+        title = tag.getTitle()
+        tag.setDeveloper('John Doe')
+        ...
+    """
+    
+    def __init__(self, offscreen: bool = False) -> None:
+        pass
+    
+    def getTitle(self) -> str:
+        """
+        Gets the title of the game.
+
+        :return: [string] title
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getPlatform(self) -> str:
+        """
+        Gets the platform on which the game is run.
+
+        :return: [string] platform
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getGenres(self) -> List[str]:
+        """
+        Gets the genres of the game.
+
+        :return: [list] genres
+
+        @python_v20 New function added.
+        """
+        return [""]
+    
+    def getPublisher(self) -> str:
+        """
+        Gets the publisher of the game.
+
+        :return: [string] publisher
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getDeveloper(self) -> str:
+        """
+        Gets the developer of the game.
+
+        :return: [string] developer
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getOverview(self) -> str:
+        """
+        Gets the overview of the game.
+
+        :return: [string] overview
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getYear(self) -> int:
+        """
+        Gets the year in which the game was published.
+
+        :return: [integer] year
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getGameClient(self) -> str:
+        """
+        Gets the add-on ID of the game client executing the game.
+
+        :return: [string] game client
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def setTitle(self, title: str) -> None:
+        """
+        Sets the title of the game.
+
+        :param title: string - title.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setPlatform(self, platform: str) -> None:
+        """
+        Sets the platform on which the game is run.
+
+        :param platform: string - platform.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setGenres(self, genres: List[str]) -> None:
+        """
+        Sets the genres of the game.
+
+        :param genres: list - genres.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setPublisher(self, publisher: str) -> None:
+        """
+        Sets the publisher of the game.
+
+        :param publisher: string - publisher.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setDeveloper(self, developer: str) -> None:
+        """
+        Sets the developer of the game.
+
+        :param developer: string - title.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setOverview(self, overview: str) -> None:
+        """
+        Sets the overview of the game.
+
+        :param overview: string - overview.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setYear(self, year: int) -> None:
+        """
+        Sets the year in which the game was published.
+
+        :param year: integer - year.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setGameClient(self, gameClient: str) -> None:
+        """
+        Sets the add-on ID of the game client executing the game.
+
+        :param gameClient: string - game client.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+
+class InfoTagMusic:
+    """
+    **Kodi's music info tag class.**
+
+    Access and / or modify the music metadata of a ListItem.
+
+    Example::
+
+        ...
+        tag = xbmc.Player().getMusicInfoTag()
+        
+        title = tag.getTitle()
+        url   = tag.getURL()
+        ...
+    """
+    
+    def __init__(self, offscreen: bool = False) -> None:
+        pass
+    
+    def getDbId(self) -> int:
+        """
+        Get identification number of tag in database.
+
+        :return: [integer] database id.
+
+        @python_v18 New function added.
+        """
+        return 0
+    
+    def getURL(self) -> str:
+        """
+        Returns url of source as string from music info tag.
+
+        :return: [string] Url of source
+        """
+        return ""
+    
+    def getTitle(self) -> str:
+        """
+        Returns the title from music as string on info tag.
+
+        :return: [string] Music title
+        """
+        return ""
+    
+    def getMediaType(self) -> str:
+        """
+        Get the media type of the music item.
+
+        :return: [string] media type
+
+        Available strings about media type for music:
+
+        ====== ============================= 
+        String Description                   
+        ====== ============================= 
+        artist If it is defined as an artist 
+        album  If it is defined as an album  
+        song   If it is defined as a song    
+        ====== ============================= 
+
+        @python_v18 New function added.
+        """
+        return ""
+    
+    def getArtist(self) -> str:
+        """
+        Returns the artist from music as string if present.
+
+        :return: [string] Music artist
+        """
+        return ""
+    
+    def getAlbum(self) -> str:
+        """
+        Returns the album from music tag as string if present.
+
+        :return: [string] Music album name
+        """
+        return ""
+    
+    def getAlbumArtist(self) -> str:
+        """
+        Returns the album artist from music tag as string if present.
+
+        :return: [string] Music album artist name
+        """
+        return ""
+    
+    def getGenre(self) -> str:
+        """
+        Returns the genre name from music tag as string if present.
+
+        :return: [string] Genre name
+
+        @python_v20 Deprecated. Use **`getGenres()`** instead.
+        """
+        return ""
+    
+    def getGenres(self) -> List[str]:
+        """
+        Returns the list of genres from music tag if present.
+
+        :return: [list]`List` of genres
+
+        @python_v20 New function added.
+        """
+        return [""]
+    
+    def getDuration(self) -> int:
+        """
+        Returns the duration of music as integer from info tag.
+
+        :return: [integer] Duration
+        """
+        return 0
+    
+    def getYear(self) -> int:
+        """
+        Returns the year of music as integer from info tag.
+
+        :return: [integer] Year
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getRating(self) -> int:
+        """
+        Returns the scraped rating as integer.
+
+        :return: [integer] Rating
+        """
+        return 0
+    
+    def getUserRating(self) -> int:
+        """
+        Returns the user rating as integer (-1 if not existing)
+
+        :return: [integer] User rating
+        """
+        return 0
+    
+    def getTrack(self) -> int:
+        """
+        Returns the track number (if present) from music info tag as integer.
+
+        :return: [integer] Track number
+        """
+        return 0
+    
+    def getDisc(self) -> int:
+        """
+        Returns the disk number (if present) from music info tag as integer.
+
+        :return: [integer] Disc number
+        """
+        return 0
+    
+    def getReleaseDate(self) -> str:
+        """
+        Returns the release date as string from music info tag (if present).
+
+        :return: [string] Release date
+        """
+        return ""
+    
+    def getListeners(self) -> int:
+        """
+        Returns the listeners as integer from music info tag.
+
+        :return: [integer] Listeners
+        """
+        return 0
+    
+    def getPlayCount(self) -> int:
+        """
+        Returns the number of carried out playbacks.
+
+        :return: [integer] Playback count
+        """
+        return 0
+    
+    def getLastPlayed(self) -> str:
+        """
+        Returns last played time as string from music info tag.
+
+        :return: [string] Last played date / time on tag
+
+        @python_v20 Deprecated. Use **`getLastPlayedAsW3C()`** instead.
+        """
+        return ""
+    
+    def getLastPlayedAsW3C(self) -> str:
+        """
+        Returns last played time as string in W3C format (YYYY-MM-DDThh:mm:ssTZD).
+
+        :return: [string] Last played datetime (W3C)
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getComment(self) -> str:
+        """
+        Returns comment as string from music info tag.
+
+        :return: [string] Comment on tag
+        """
+        return ""
+    
+    def getLyrics(self) -> str:
+        """
+        Returns a string from lyrics.
+
+        :return: [string] Lyrics on tag
+        """
+        return ""
+    
+    def getMusicBrainzTrackID(self) -> str:
+        """
+        Returns the MusicBrainz Recording ID from music info tag (if present).
+
+        :return: [string] MusicBrainz Recording ID
+
+        @python_v19 New function added.
+        """
+        return ""
+    
+    def getMusicBrainzArtistID(self) -> List[str]:
+        """
+        Returns the MusicBrainz Artist IDs from music info tag (if present).
+
+        :return: [list] MusicBrainz Artist IDs
+
+        @python_v19 New function added.
+        """
+        return [""]
+    
+    def getMusicBrainzAlbumID(self) -> str:
+        """
+        Returns the MusicBrainz Release ID from music info tag (if present).
+
+        :return: [string] MusicBrainz Release ID
+
+        @python_v19 New function added.
+        """
+        return ""
+    
+    def getMusicBrainzReleaseGroupID(self) -> str:
+        """
+        Returns the MusicBrainz Release Group ID from music info tag (if present).
+
+        :return: [string] MusicBrainz Release Group ID
+
+        @python_v19 New function added.
+        """
+        return ""
+    
+    def getMusicBrainzAlbumArtistID(self) -> List[str]:
+        """
+        Returns the MusicBrainz Release Artist IDs from music info tag (if present).
+
+        :return: [list] MusicBrainz Release Artist IDs
+
+        @python_v19 New function added.
+        """
+        return [""]
+    
+    def setDbId(self, dbId: int, type: str) -> None:
+        """
+        Set the database identifier of the music item.
+
+        :param dbId: integer - Database identifier.
+        :param type: string - Media type of the item.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setURL(self, url: str) -> None:
+        """
+        Set the URL of the music item.
+
+        :param url: string - URL.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setMediaType(self, mediaType: str) -> None:
+        """
+        Set the media type of the music item.
+
+        :param mediaType: string - Media type.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setTrack(self, track: int) -> None:
+        """
+        Set the track number of the song.
+
+        :param track: integer - Track number.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setDisc(self, disc: int) -> None:
+        """
+        Set the disc number of the song.
+
+        :param disc: integer - Disc number.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setDuration(self, duration: int) -> None:
+        """
+        Set the duration of the song.
+
+        :param duration: integer - Duration in seconds.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setYear(self, year: int) -> None:
+        """
+        Set the year of the music item.
+
+        :param year: integer - Year.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setReleaseDate(self, releaseDate: str) -> None:
+        """
+        Set the release date of the music item.
+
+        :param releaseDate: string - Release date in ISO8601 format (YYYY, YYYY-MM or YYYY-MM-DD).
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setListeners(self, listeners: int) -> None:
+        """
+        Set the number of listeners of the music item.
+
+        :param listeners: integer - Number of listeners.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setPlayCount(self, playcount: int) -> None:
+        """
+        Set the playcount of the music item.
+
+        :param playcount: integer - Playcount.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setGenres(self, genres: List[str]) -> None:
+        """
+        Set the genres of the music item.
+
+        :param genres: list - Genres.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setAlbum(self, album: str) -> None:
+        """
+        Set the album of the music item.
+
+        :param album: string - Album.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setArtist(self, artist: str) -> None:
+        """
+        Set the artist(s) of the music item.
+
+        :param artist: string - Artist(s).
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setAlbumArtist(self, albumArtist: str) -> None:
+        """
+        Set the album artist(s) of the music item.
+
+        :param albumArtist: string - Album artist(s).
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setTitle(self, title: str) -> None:
+        """
+        Set the title of the music item.
+
+        :param title: string - Title.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setRating(self, rating: float) -> None:
+        """
+        Set the rating of the music item.
+
+        :param rating: float - Rating.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setUserRating(self, userrating: int) -> None:
+        """
+        Set the user rating of the music item.
+
+        :param userrating: integer - User rating.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setLyrics(self, lyrics: str) -> None:
+        """
+        Set the lyrics of the song.
+
+        :param lyrics: string - Lyrics.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setLastPlayed(self, lastPlayed: str) -> None:
+        """
+        Set the last played date of the music item.
+
+        :param lastPlayed: string - Last played date (YYYY-MM-DD HH:MM:SS).
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setMusicBrainzTrackID(self, musicBrainzTrackID: str) -> None:
+        """
+        Set the MusicBrainz track ID of the song.
+
+        :param musicBrainzTrackID: string - MusicBrainz track ID.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setMusicBrainzArtistID(self, musicBrainzArtistID: List[str]) -> None:
+        """
+        Set the MusicBrainz artist IDs of the music item.
+
+        :param musicBrainzArtistID: list - MusicBrainz artist IDs.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setMusicBrainzAlbumID(self, musicBrainzAlbumID: str) -> None:
+        """
+        Set the MusicBrainz album ID of the music item.
+
+        :param musicBrainzAlbumID: string - MusicBrainz album ID.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setMusicBrainzReleaseGroupID(self, musicBrainzReleaseGroupID: str) -> None:
+        """
+        Set the MusicBrainz release group ID of the music item.
+
+        :param musicBrainzReleaseGroupID: string - MusicBrainz release group ID.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setMusicBrainzAlbumArtistID(self, musicBrainzAlbumArtistID: List[str]) -> None:
+        """
+        Set the MusicBrainz album artist IDs of the music item.
+
+        :param musicBrainzAlbumArtistID: list - MusicBrainz album artist IDs.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setComment(self, comment: str) -> None:
+        """
+        Set the comment of the music item.
+
+        :param comment: string - Comment.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+
+class InfoTagPicture:
+    """
+    **Kodi's picture info tag class.**
+
+    Access and / or modify the picture metadata of a ListItem.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        tag = item.getPictureInfoTag()
+        
+        datetime_taken  = tag.getDateTimeTaken()
+        tag.setResolution(1920, 1080)
+        ...
+    """
+    
+    def __init__(self, offscreen: bool = False) -> None:
+        pass
+    
+    def getResolution(self) -> str:
+        """
+        Get the resolution of the picture in the format "w x h".
+
+        :return: [string] Resolution of the picture in the format "w x h".
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def setResolution(self, width: int, height: int) -> None:
+        """
+        Sets the resolution of the picture.
+
+        :param width: int - Width of the picture in pixels.
+        :param height: int - Height of the picture in pixels.
+        
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setDateTimeTaken(self, datetimetaken: str) -> None:
+        """
+        Sets the date and time at which the picture was taken in W3C format. The
+        following formats are supported:
+
+        YYYY
+
+        YYYY-MM-DD
+
+        YYYY-MM-DDThh:mm[TZD]
+
+        YYYY-MM-DDThh:mm:ss[TZD] where the timezone (TZD) is always optional and can be
+        in one of the following formats:
+
+        Z (for UTC)
+
+        +hh:mm
+
+        -hh:mm
+
+        :param datetimetaken: string - Date and time at which the picture was taken in W3C format.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+
+class InfoTagRadioRDS:
+    """
+    **Kodi's radio RDS info tag class.**
+
+    To get radio RDS info tag data of currently played `PVR` radio channel source.
+
+    .. note::
+        Info tag load is only be possible from present player class.  Also
+        is all the data variable from radio channels and not known on
+        beginning of radio receiving.
+
+    Example::
+
+        ...
+        tag = xbmc.Player().getRadioRDSInfoTag()
+        
+        title  = tag.getTitle()
+        artist = tag.getArtist()
+        ...
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def getTitle(self) -> str:
+        """
+        Title of the item on the air; i.e. song title.
+
+        :return: Title
+        """
+        return ""
+    
+    def getBand(self) -> str:
+        """
+        Band of the item on air.
+
+        :return: Band
+        """
+        return ""
+    
+    def getArtist(self) -> str:
+        """
+        Artist of the item on air.
+
+        :return: Artist
+        """
+        return ""
+    
+    def getComposer(self) -> str:
+        """
+        Get the Composer of the music.
+
+        :return: Composer
+        """
+        return ""
+    
+    def getConductor(self) -> str:
+        """
+        Get the Conductor of the Band.
+
+        :return: Conductor
+        """
+        return ""
+    
+    def getAlbum(self) -> str:
+        """
+        Album of item on air.
+
+        :return: Album name
+        """
+        return ""
+    
+    def getComment(self) -> str:
+        """
+        Get Comment text from channel.
+
+        :return: Comment
+        """
+        return ""
+    
+    def getAlbumTrackNumber(self) -> int:
+        """
+        Get the album track number of currently sended music.
+
+        :return: Track Number
+        """
+        return 0
+    
+    def getInfoNews(self) -> str:
+        """
+        Get News informations.
+
+        :return: News Information
+        """
+        return ""
+    
+    def getInfoNewsLocal(self) -> str:
+        """
+        Get Local news informations.
+
+        :return: Local News Information
+        """
+        return ""
+    
+    def getInfoSport(self) -> str:
+        """
+        Get Sport informations.
+
+        :return: Sport Information
+        """
+        return ""
+    
+    def getInfoStock(self) -> str:
+        """
+        Get Stock informations.
+
+        :return: Stock Information
+        """
+        return ""
+    
+    def getInfoWeather(self) -> str:
+        """
+        Get Weather informations.
+
+        :return: Weather Information
+        """
+        return ""
+    
+    def getInfoHoroscope(self) -> str:
+        """
+        Get Horoscope informations.
+
+        :return: Horoscope Information
+        """
+        return ""
+    
+    def getInfoCinema(self) -> str:
+        """
+        Get Cinema informations.
+
+        :return: Cinema Information
+        """
+        return ""
+    
+    def getInfoLottery(self) -> str:
+        """
+        Get Lottery informations.
+
+        :return: Lottery Information
+        """
+        return ""
+    
+    def getInfoOther(self) -> str:
+        """
+        Get other informations.
+
+        :return: Other Information
+        """
+        return ""
+    
+    def getEditorialStaff(self) -> str:
+        """
+        Get Editorial Staff names.
+
+        :return: Editorial Staff
+        """
+        return ""
+    
+    def getProgStation(self) -> str:
+        """
+        Name describing station.
+
+        :return: Program Station
+        """
+        return ""
+    
+    def getProgStyle(self) -> str:
+        """
+        The the radio channel style currently used.
+
+        :return: Program Style
+        """
+        return ""
+    
+    def getProgHost(self) -> str:
+        """
+        Host of current radio show.
+
+        :return: Program Host
+        """
+        return ""
+    
+    def getProgWebsite(self) -> str:
+        """
+        Link to URL (web page) for radio station homepage.
+
+        :return: Program Website
+        """
+        return ""
+    
+    def getProgNow(self) -> str:
+        """
+        Current radio program show.
+
+        :return: Program Now
+        """
+        return ""
+    
+    def getProgNext(self) -> str:
+        """
+        Next program show.
+
+        :return: Program Next
+        """
+        return ""
+    
+    def getPhoneHotline(self) -> str:
+        """
+        Telephone number of the radio station's hotline.
+
+        :return: Phone Hotline
+        """
+        return ""
+    
+    def getEMailHotline(self) -> str:
+        """
+        Email address of the radio station's studio.
+
+        :return: EMail Hotline
+        """
+        return ""
+    
+    def getPhoneStudio(self) -> str:
+        """
+        Telephone number of the radio station's studio.
+
+        :return: Phone Studio
+        """
+        return ""
+    
+    def getEMailStudio(self) -> str:
+        """
+        Email address of radio station studio.
+
+        :return: EMail Studio
+        """
+        return ""
+    
+    def getSMSStudio(self) -> str:
+        """
+        SMS (Text Messaging) number for studio.
+
+        :return: SMS Studio
+        """
+        return ""
+    
+
+class Actor:
+    """
+    **`Actor` class used in combination with `InfoTagVideo`.**
+
+    Represents a single actor in the cast of a video item wrapped by `InfoTagVideo`.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        actor = xbmc.Actor('Sean Connery', 'James Bond', order=1)
+        ...
+    """
+    
+    def __init__(self, name: str = "",
+                 role: str = "",
+                 order: int = -1,
+                 thumbnail: str = "") -> None:
+        pass
+    
+    def getName(self) -> str:
+        """
+        Get the name of the actor.
+
+        :return: [string] Name of the actor
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getRole(self) -> str:
+        """
+        Get the role of the actor in the specific video item.
+
+        :return: [string] Role of the actor in the specific video item
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getOrder(self) -> int:
+        """
+        Get the order of the actor in the cast of the specific video item.
+
+        :return: [integer] Order of the actor in the cast of the specific video item
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getThumbnail(self) -> str:
+        """
+        Get the path / URL to the thumbnail of the actor.
+
+        :return: [string] Path / URL to the thumbnail of the actor
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def setName(self, name: str) -> None:
+        """
+        Set the name of the actor.
+
+        :param name: string - Name of the actor.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setRole(self, role: str) -> None:
+        """
+        Set the role of the actor in the specific video item.
+
+        :param role: string - Role of the actor in the specific video item.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setOrder(self, order: int) -> None:
+        """
+        Set the order of the actor in the cast of the specific video item.
+
+        :param order: integer - Order of the actor in the cast of the specific video item.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setThumbnail(self, thumbnail: str) -> None:
+        """
+        Set the path / URL to the thumbnail of the actor.
+
+        :param thumbnail: string - Path / URL to the thumbnail of the actor.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+
+class VideoStreamDetail:
+    """
+    **Video stream details class used in combination with `InfoTagVideo`.**
+
+    Represents a single selectable video stream for a video item wrapped
+    by `InfoTagVideo`.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        videostream = xbmc.VideoStreamDetail(1920, 1080, language='English')
+        ...
+    """
+    
+    def __init__(self, width: int = 0,
+                 height: int = 0,
+                 aspect: float = 0.0,
+                 duration: int = 0,
+                 codec: str = "",
+                 stereoMode: str = "",
+                 language: str = "",
+                 hdrType: str = "") -> None:
+        pass
+    
+    def getWidth(self) -> int:
+        """
+        Get the width of the video stream in pixel.
+
+        :return: [integer] Width of the video stream
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getHeight(self) -> int:
+        """
+        Get the height of the video stream in pixel.
+
+        :return: [integer] Height of the video stream
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getAspect(self) -> float:
+        """
+        Get the aspect ratio of the video stream.
+
+        :return: [float] Aspect ratio of the video stream
+
+        @python_v20 New function added.
+        """
+        return 0.0
+    
+    def getDuration(self) -> int:
+        """
+        Get the duration of the video stream in seconds.
+
+        :return: [float] Duration of the video stream in seconds
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getCodec(self) -> str:
+        """
+        Get the codec of the stream.
+
+        :return: [string] Codec of the stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getStereoMode(self) -> str:
+        """
+        Get the stereo mode of the video stream.
+
+        :return: [string] Stereo mode of the video stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getLanguage(self) -> str:
+        """
+        Get the language of the stream.
+
+        :return: [string] Language of the stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getHDRType(self) -> str:
+        """
+        Get the HDR type of the stream.
+
+        :return: [string] HDR type of the stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def setWidth(self, width: int) -> None:
+        """
+        Set the width of the video stream in pixel.
+
+        :param width: integer - Width of the video stream in pixel.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setHeight(self, height: int) -> None:
+        """
+        Set the height of the video stream in pixel.
+
+        :param height: integer - Height of the video stream in pixel.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setAspect(self, aspect: float) -> None:
+        """
+        Set the aspect ratio of the video stream.
+
+        :param aspect: float - Aspect ratio of the video stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setDuration(self, duration: int) -> None:
+        """
+        Set the duration of the video stream in seconds.
+
+        :param duration: integer - Duration of the video stream in seconds.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setCodec(self, codec: str) -> None:
+        """
+        Set the codec of the stream.
+
+        :param codec: string - Codec of the stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setStereoMode(self, stereoMode: str) -> None:
+        """
+        Set the stereo mode of the video stream.
+
+        :param stereoMode: string - Stereo mode of the video stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setLanguage(self, language: str) -> None:
+        """
+        Set the language of the stream.
+
+        :param language: string - Language of the stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setHDRType(self, hdrType: str) -> None:
+        """
+        Set the HDR type of the stream.
+
+        :param hdrType: string - HDR type of the stream. The following types are supported:
+            dolbyvision, hdr10, hlg
+
+        @python_v20 New function added.
+        """
+        pass
+    
+
+class AudioStreamDetail:
+    """
+    **Audio stream details class used in combination with `InfoTagVideo`.**
+
+    Represents a single selectable audio stream for a video item wrapped
+    by `InfoTagVideo`.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        audiostream = xbmc.AudioStreamDetail(6, 'DTS', 'English')
+        ...
+    """
+    
+    def __init__(self, channels: int = -1,
+                 codec: str = "",
+                 language: str = "") -> None:
+        pass
+    
+    def getChannels(self) -> int:
+        """
+        Get the number of channels in the stream.
+
+        :return: [integer] Number of channels in the stream
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getCodec(self) -> str:
+        """
+        Get the codec of the stream.
+
+        :return: [string] Codec of the stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getLanguage(self) -> str:
+        """
+        Get the language of the stream.
+
+        :return: [string] Language of the stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def setChannels(self, channels: int) -> None:
+        """
+        Set the number of channels in the stream.
+
+        :param channels: integer - Number of channels in the stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setCodec(self, codec: str) -> None:
+        """
+        Set the codec of the stream.
+
+        :param codec: string - Codec of the stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setLanguage(self, language: str) -> None:
+        """
+        Set the language of the stream.
+
+        :param language: string - Language of the stream.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+
+class SubtitleStreamDetail:
+    """
+    **Subtitle stream details class used in combination with `InfoTagVideo`.**
+
+    Represents a single selectable subtitle stream for a video item wrapped
+    by `InfoTagVideo`.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        subtitlestream = xbmc.SubtitleStreamDetail('English')
+        ...
+    """
+    
+    def __init__(self, language: str = "") -> None:
+        pass
+    
+    def getLanguage(self) -> str:
+        """
+        Get the language of the stream.
+
+        :return: [string] Language of the stream
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def setLanguage(self, language: str) -> None:
+        """
+        Set the language of the stream.
+
+        :param language: string - Language of the stream.
+
+        @python_v20 New function added.
+        """
+        pass
+
+
+class InfoTagVideo:
+    """
+    **Kodi's video info tag class.**
+
+    Access and / or modify the video metadata of a ListItem.
+
+    Example::
+
+        ...
+        tag = xbmc.Player().getVideoInfoTag()
+        
+        title = tag.getTitle()
+        file  = tag.getFile()
+        ...
+    """
+    
+    def __init__(self, offscreen: bool = False) -> None:
+        pass
+    
+    def getDbId(self) -> int:
+        """
+        Get identification number of tag in database
+
+        :return: [integer] database id
+
+        @python_v17 New function added.
+        """
+        return 0
+    
+    def getDirector(self) -> str:
+        """
+        Getfilm director who has made the film (if present).
+
+        :return: [string] Film director name.
+
+        @python_v20 Deprecated. Use **`getDirectors()`** instead.
+        """
+        return ""
+    
+    def getDirectors(self) -> List[str]:
+        """
+        Get a list offilm directors who have made the film (if present).
+
+        :return: [list]`List` of film director names.
+
+        @python_v20 New function added.
+        """
+        return [""]
+    
+    def getWritingCredits(self) -> str:
+        """
+        Get the writing credits if present from video info tag.
+
+        :return: [string] Writing credits
+
+        @python_v20 Deprecated. Use **`getWriters()`** instead.
+        """
+        return ""
+    
+    def getWriters(self) -> List[str]:
+        """
+        Get the list of writers (if present) from video info tag.
+
+        :return: [list] `List` of writers
+
+        @python_v20 New function added.
+        """
+        return [""]
+    
+    def getGenre(self) -> str:
+        """
+        To get theVideo Genre if available.
+
+        :return: [string] Genre name
+
+        @python_v20 Deprecated. Use **`getGenres()`** instead.
+        """
+        return ""
+    
+    def getGenres(self) -> List[str]:
+        """
+        Get the list ofVideo Genres if available.
+
+        :return: [list]`List` of genres
+
+        @python_v20 New function added.
+        """
+        return [""]
+    
+    def getTagLine(self) -> str:
+        """
+        Get video tag line if available.
+
+        :return: [string] Video tag line
+        """
+        return ""
+    
+    def getPlotOutline(self) -> str:
+        """
+        Get the outline plot of the video if present.
+
+        :return: [string] Outline plot
+        """
+        return ""
+    
+    def getPlot(self) -> str:
+        """
+        Get the plot of the video if present.
+
+        :return: [string] Plot
+        """
+        return ""
+    
+    def getPictureURL(self) -> str:
+        """
+        Get a picture URL of the video to show as screenshot.
+
+        :return: [string] Picture URL
+        """
+        return ""
+    
+    def getTitle(self) -> str:
+        """
+        Get the video title.
+
+        :return: [string] Video title
+        """
+        return ""
+    
+    def getTVShowTitle(self) -> str:
+        """
+        Get the video TV show title.
+
+        :return: [string] TV show title
+
+        @python_v17 New function added.
+        """
+        return ""
+    
+    def getMediaType(self) -> str:
+        """
+        Get the media type of the video.
+
+        :return: [string] media type
+
+        Available strings about media type for video:
+
+        ========== ====================================
+        String     Description
+        ========== ====================================
+        video      For normal video
+        set        For a selection of video
+        musicvideo To define it as music video
+        movie      To define it as normal movie
+        tvshow     If this is it defined as tvshow
+        season     The type is used as a series season
+        episode    The type is used as a series episode
+        ========== ====================================
+
+        @python_v17 New function added.
+        """
+        return ""
+    
+    def getVotes(self) -> str:
+        """
+        Get the video votes if available from video info tag.
+
+        :return: [string] Votes
+
+        @python_v20 Deprecated. Use **`getVotesAsInt()`** instead.
+        """
+        return ""
+    
+    def getVotesAsInt(self, type: str = "") -> int:
+        """
+        Get the votes of the rating (if available) as an integer.
+
+        :param type: [opt] string - the type of the rating.  Some rating type values (any
+            string possible):
+
+        ===== ==================
+        Label Type
+        ===== ==================
+        imdb  string - type name
+        tvdb  string - type name
+        tmdb  string - type name
+        anidb string - type name
+        ===== ==================
+
+        :return: [integer] Votes
+
+        @python_v20 New function added.
+        """
+        return 0
+    
+    def getCast(self) -> str:
+        """
+        To get the cast of the video when available.
+
+        :return: [string] Video casts
+
+        @python_v20 Deprecated. Use **`getActors()`** instead.
+        """
+        return ""
+    
+    def getActors(self) -> List[Actor]:
+        """
+        Get the cast of the video if available.
+
+        :return: [list]`List` of actors
+
+        @python_v20 New function added.
+        """
+        return [Actor()]
+    
+    def getFile(self) -> str:
+        """
+        To get the video file name.
+
+        :return: [string] File name
+        """
+        return ""
+    
+    def getPath(self) -> str:
+        """
+        To get the path where the video is stored.
+
+        :return: [string] Path
+        """
+        return ""
+    
+    def getFilenameAndPath(self) -> str:
+        """
+        To get the full path with filename where the video is stored.
+
+        :return: [string] File name and Path
+
+        @python_v19 New function added.
+        """
+        return ""
+    
+    def getIMDBNumber(self) -> str:
+        """
+        To get theIMDb number of the video (if present).
+
+        :return: [string] IMDb number
+        """
+        return ""
+    
+    def getSeason(self) -> int:
+        """
+        To get season number of a series
+
+        :return: [integer] season number
+
+        @python_v17 New function added.
+        """
+        return 0
+    
+    def getEpisode(self) -> int:
+        """
+        To get episode number of a series
+
+        :return: [integer] episode number
+
+        @python_v17 New function added.
+        """
+        return 0
+    
+    def getYear(self) -> int:
+        """
+        Get production year of video if present.
+
+        :return: [integer] Production Year
+        """
+        return 0
+    
+    def getRating(self, type: str = "") -> float:
+        """
+        Get the video rating if present as float (double where supported).
+
+        :param type: [opt] string - the type of the rating.  Some rating type values (any
+            string possible):
+
+        ===== ==================
+        Label Type
+        ===== ==================
+        imdb  string - type name
+        tvdb  string - type name
+        tmdb  string - type name
+        anidb string - type name
+        ===== ==================
+
+        :return: [float] The rating of the video
+
+        @python_v20 Optional ``type`` parameter added.
+        """
+        return 0.0
+    
+    def getUserRating(self) -> int:
+        """
+        Get the user rating if present as integer.
+
+        :return: [integer] The user rating of the video
+        """
+        return 0
+    
+    def getPlayCount(self) -> int:
+        """
+        To get the number of plays of the video.
+
+        :return: [integer] Play Count
+        """
+        return 0
+    
+    def getLastPlayed(self) -> str:
+        """
+        Get the last played date / time as string.
+
+        :return: [string] Last played date / time
+
+        @python_v20 Deprecated. Use **`getLastPlayedAsW3C()`** instead.
+        """
+        return ""
+    
+    def getLastPlayedAsW3C(self) -> str:
+        """
+        Get last played datetime as string in W3C format (YYYY-MM-DDThh:mm:ssTZD).
+
+        :return: [string] Last played datetime (W3C)
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getOriginalTitle(self) -> str:
+        """
+        To get the original title of the video.
+
+        :return: [string] Original title
+        """
+        return ""
+    
+    def getPremiered(self) -> str:
+        """
+        To getpremiered date of the video, if available.
+
+        :return: [string]
+
+        @python_v20 Deprecated. Use **`getPremieredAsW3C()`** instead.
+        """
+        return ""
+    
+    def getPremieredAsW3C(self) -> str:
+        """
+        Getpremiered date as string in W3C format (YYYY-MM-DD).
+
+        :return: [string] Premiered date (W3C)
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getFirstAired(self) -> str:
+        """
+        Returns first aired date as string from info tag.
+
+        :return: [string] First aired date
+
+        @python_v20 Deprecated. Use **`getFirstAiredAsW3C()`** instead.
+        """
+        return ""
+    
+    def getFirstAiredAsW3C(self) -> str:
+        """
+        Get first aired date as string in W3C format (YYYY-MM-DD).
+
+        :return: [string] First aired date (W3C)
+
+        @python_v20 New function added.
+        """
+        return ""
+    
+    def getTrailer(self) -> str:
+        """
+        To get the path where the trailer is stored.
+
+        :return: [string] Trailer path
+
+        @python_v17 New function added.
+        """
+        return ""
+    
+    def getArtist(self) -> List[str]:
+        """
+        To get the artist name (for musicvideos)
+
+        :return: [List[str]] Artist name
+
+        @python_v18 New function added.
+        """
+        return [""]
+    
+    def getAlbum(self) -> str:
+        """
+        To get the album name (for musicvideos)
+
+        :return: [string] Album name
+
+        @python_v18 New function added.
+        """
+        return ""
+    
+    def getTrack(self) -> int:
+        """
+        To get the track number (for musicvideos)
+
+        :return: [int] Track number
+
+        @python_v18 New function added.
+        """
+        return 0
+    
+    def getDuration(self) -> int:
+        """
+        To get the duration
+
+        :return: [unsigned int] Duration
+
+        @python_v18 New function added.
+        """
+        return 0
+    
+    def getResumeTime(self) -> float:
+        """
+        Gets the resume time of the video item.
+
+        :return: [double] Resume time
+
+        @python_v20 New function added.
+        """
+        return 0.0
+
+    def getResumeTimeTotal(self) -> float:
+        """
+        Gets the total duration stored with the resume time of the video item.
+
+        :return: [double] Total duration stored with the resume time
+
+        @python_v20 New function added.
+        """
+        return 0.0
+
+    def getUniqueID(self, key: str) -> str:
+        """
+        Get the unique ID of the given key. A unique ID is an identifier used by a
+        (online) video database used to identify a video in its database.
+
+        :param key: string - uniqueID name.  Some default uniqueID values (any string
+            possible):
+
+        ===== ======================
+        Label Type
+        ===== ======================
+        imdb  string - uniqueid name
+        tvdb  string - uniqueid name
+        tmdb  string - uniqueid name
+        anidb string - uniqueid name
+        ===== ======================
+
+        @python_v20 New function added.
+        """
+        return ""
+
+    def setUniqueID(self, uniqueid: str,
+                    type: str = "",
+                    isdefault: bool = False) -> None:
+        """
+        Set the given unique ID. A unique ID is an identifier used by a (online) video
+        database used to identify a video in its database.
+
+        :param uniqueid: string - value of the unique ID.
+        :param type: [opt] string - type / label of the unique ID.
+        :param isdefault: [opt] bool - whether the given unique ID is the default unique ID.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setUniqueIDs(self, uniqueIDs: Dict[str, str],
+                     defaultuniqueid: str = "") -> None:
+        """
+        Set the given unique IDs. A unique ID is an identifier used by a (online) video
+        database used to identify a video in its database.
+
+        :param values: dictionary - pairs of{ 'label: 'value' }`.
+        :param defaultuniqueid: [opt] string - the name of default uniqueID.
+
+        Some example values (any string possible):
+
+        ===== ======================
+        Label Type
+        ===== ======================
+        imdb  string - uniqueid name
+        tvdb  string - uniqueid name
+        tmdb  string - uniqueid name
+        anidb string - uniqueid name
+        ===== ======================
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setDbId(self, dbid: int) -> None:
+        """
+        Set the database identifier of the video item.
+
+        :param dbid: integer - Database identifier.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setYear(self, year: int) -> None:
+        """
+        Set the year of the video item.
+
+        :param year: integer - Year.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setEpisode(self, episode: int) -> None:
+        """
+        Set the episode number of the episode.
+
+        :param episode: integer - Episode number.
+
+        @python_v20 New function added.
+        """
+        pass
+    
+    def setSeason(self, season: int) -> None:
+        """
+        Set the season number of the video item.
+
+        :param season: integer - Season number.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setSortEpisode(self, sortepisode: int) -> None:
+        """
+        Set the episode sort number of the episode.
+
+        :param sortepisode: integer - Episode sort number.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setSortSeason(self, sortseason: int) -> None:
+        """
+        Set the season sort number of the season.
+
+        :param sortseason: integer - Season sort number.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setEpisodeGuide(self, episodeguide: str) -> None:
+        """
+        Set the episode guide of the video item.
+
+        :param episodeguide: string - Episode guide.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTop250(self, top250: int) -> None:
+        """
+        Set the top 250 number of the video item.
+
+        :param top250: integer - Top 250 number.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setSetId(self, setid: int) -> None:
+        """
+        Set the movie set identifier of the video item.
+
+        :param setid: integer - Set identifier.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTrackNumber(self, tracknumber: int) -> None:
+        """
+        Set the track number of the music video item.
+
+        :param tracknumber: integer - Track number.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setRating(self, rating: float,
+                  votes: int = 0,
+                  type: str = "",
+                  isdefault: bool = False) -> None:
+        """
+        Set the rating of the video item.
+
+        :param rating: float - Rating number.
+        :param votes: integer - Number of votes.
+        :param type: string - Type of the rating.
+        :param isdefault: bool - Whether the rating is the default or not.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setRatings(self, ratings: Dict[str, Tuple[float, int]],
+                   defaultrating: str = "") -> None:
+        """
+        Set the ratings of the video item.
+
+        :param ratings: dictionary -{ 'type: (rating, votes) }`.
+        :param defaultrating: string - Type / Label of the default rating.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setUserRating(self, userrating: int) -> None:
+        """
+        Set the user rating of the video item.
+
+        :param userrating: integer - User rating.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setPlaycount(self, playcount: int) -> None:
+        """
+        Set the playcount of the video item.
+
+        :param playcount: integer - Playcount.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setMpaa(self, mpaa: str) -> None:
+        """
+        Set the MPAA rating of the video item.
+
+        :param mpaa: string - MPAA rating.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setPlot(self, plot: str) -> None:
+        """
+        Set the plot of the video item.
+
+        :param plot: string - Plot.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setPlotOutline(self, plotoutline: str) -> None:
+        """
+        Set the plot outline of the video item.
+
+        :param plotoutline: string - Plot outline.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTitle(self, title: str) -> None:
+        """
+        Set the title of the video item.
+
+        :param title: string - Title.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setOriginalTitle(self, originaltitle: str) -> None:
+        """
+        Set the original title of the video item.
+
+        :param originaltitle: string - Original title.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setSortTitle(self, sorttitle: str) -> None:
+        """
+        Set the sort title of the video item.
+
+        :param sorttitle: string - Sort title.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTagLine(self, tagline: str) -> None:
+        """
+        Set the tagline of the video item.
+
+        :param tagline: string - Tagline.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTvShowTitle(self, tvshowtitle: str) -> None:
+        """
+        Set the TV show title of the video item.
+
+        :param tvshowtitle: string - TV show title.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTvShowStatus(self, status: str) -> None:
+        """
+        Set the TV show status of the video item.
+
+        :param status: string - TV show status.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setGenres(self, genre: List[str]) -> None:
+        """
+        Set the genres of the video item.
+
+        :param genre: list - Genres.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setCountries(self, countries: List[str]) -> None:
+        """
+        Set the countries of the video item.
+
+        :param countries: list - Countries.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setDirectors(self, directors: List[str]) -> None:
+        """
+        Set the directors of the video item.
+
+        :param directors: list - Directors.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setStudios(self, studios: List[str]) -> None:
+        """
+        Set the studios of the video item.
+
+        :param studios: list - Studios.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setWriters(self, writers: List[str]) -> None:
+        """
+        Set the writers of the video item.
+
+        :param writers: list - Writers.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setDuration(self, duration: int) -> None:
+        """
+        Set the duration of the video item.
+
+        :param duration: integer - Duration in seconds.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setPremiered(self, premiered: str) -> None:
+        """
+        Set the premiere date of the video item.
+
+        :param premiered: string - Premiere date.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setSet(self, set: str) -> None:
+        """
+        Set the movie set (name) of the video item.
+
+        :param set: string - Movie set (name).
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setSetOverview(self, setoverview: str) -> None:
+        """
+        Set the movie set overview of the video item.
+
+        :param setoverview: string - Movie set overview.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTags(self, tags: List[str]) -> None:
+        """
+        Set the tags of the video item.
+
+        :param tags: list - Tags.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setProductionCode(self, productioncode: str) -> None:
+        """
+        Set the production code of the video item.
+
+        :param productioncode: string - Production code.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setFirstAired(self, firstaired: str) -> None:
+        """
+        Set the first aired date of the video item.
+
+        :param firstaired: string - First aired date.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setLastPlayed(self, lastplayed: str) -> None:
+        """
+        Set the last played date of the video item.
+
+        :param lastplayed: string - Last played date (YYYY-MM-DD HH:MM:SS).
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setAlbum(self, album: str) -> None:
+        """
+        Set the album of the video item.
+
+        :param album: string - Album.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setVotes(self, votes: int) -> None:
+        """
+        Set the number of votes of the video item.
+
+        :param votes: integer - Number of votes.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setTrailer(self, trailer: str) -> None:
+        """
+        Set the trailer of the video item.
+
+        :param trailer: string - Trailer.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setPath(self, path: str) -> None:
+        """
+        Set the path of the video item.
+
+        :param path: string - Path.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setFilenameAndPath(self, filenameandpath: str) -> None:
+        """
+        Set the filename and path of the video item.
+
+        :param filenameandpath: string - Filename and path.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setIMDBNumber(self, imdbnumber: str) -> None:
+        """
+        Set the IMDb number of the video item.
+
+        :param imdbnumber: string - IMDb number.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setDateAdded(self, dateadded: str) -> None:
+        """
+        Set the date added of the video item.
+
+        :param dateadded: string - Date added (YYYY-MM-DD HH:MM:SS).
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setMediaType(self, mediatype: str) -> None:
+        """
+        Set the media type of the video item.
+
+        :param mediatype: string - Media type.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setShowLinks(self, showlinks: List[str]) -> None:
+        """
+        Set the TV show links of the movie.
+
+        :param showlinks: list - TV show links.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setArtists(self, artists: List[str]) -> None:
+        """
+        Set the artists of the music video item.
+
+        :param artists: list - Artists.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setCast(self, actors: List[Actor]) -> None:
+        """
+        Set the cast / actors of the video item.
+
+        :param actors: list - Cast / Actors.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def setResumePoint(self, time: float, totaltime: float = 0.0) -> None:
+        """
+        Set the resume point of the video item.
+
+        :param time: float - Resume point in seconds.
+        :param totaltime: float - Total duration in seconds.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def addSeason(self, number: int, name: str = "") -> None:
+        """
+        Add a season with name. It needs at least the season number.
+
+        :param number: int - the number of the season.
+        :param name: string - the name of the season. Default "".
+
+        @python_v20 New function added.
+
+        Example::
+
+            ...
+            # addSeason(number, name))
+            infotagvideo.addSeason(1, "Murder House")
+            ...
+        """
+        pass
+
+    def addSeasons(self, namedseasons: List[Tuple[int, str]]) -> None:
+        """
+        Add named seasons to the TV show.
+
+        :param namedseasons: list -``[ (season, name) ]``.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def addVideoStream(self, stream: VideoStreamDetail) -> None:
+        """
+        Add a video stream to the video item.
+
+        :param stream: `VideoStreamDetail` - Video stream.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def addAudioStream(self, stream: AudioStreamDetail) -> None:
+        """
+        Add an audio stream to the video item.
+
+        :param stream: `AudioStreamDetail` - Audio stream.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def addSubtitleStream(self, stream: SubtitleStreamDetail) -> None:
+        """
+        Add a subtitle stream to the video item.
+
+        :param stream: `SubtitleStreamDetail` - Subtitle stream.
+
+        @python_v20 New function added.
+        """
+        pass
+
+    def addAvailableArtwork(self, url: str,
+                            arttype: str = "",
+                            preview: str = "",
+                            referrer: str = "",
+                            cache: str = "",
+                            post: bool = False,
+                            isgz: bool = False,
+                            season: int = -1) -> None:
+        """
+        Add an image to available artworks (needed for video scrapers)
+
+        :param url: string - image path url
+        :param arttype: string - image type
+        :param preview: [opt] string - image preview path url
+        :param referrer: [opt] string - referrer url
+        :param cache: [opt] string - filename in cache
+        :param post: [opt] bool - use post to retrieve the image (default false)
+        :param isgz: [opt] bool - use gzip to retrieve the image (default false)
+        :param season: [opt] integer - number of season in case of season thumb
+
+        @python_v20 New function added.
+
+        Example::
+
+            ...
+            infotagvideo.addAvailableArtwork(path_to_image_1, "thumb")
+            ...
+        """
+        pass
+
+
+class Keyboard:
+    """
+    **Kodi's keyboard class.**
+
+    Creates a new `Keyboard` object with default text heading and hidden input flag
+    if supplied.
+
+    :param default: : [opt] string - default text entry.
+    :param heading: : [opt] string - keyboard heading.
+    :param hidden: : [opt] boolean - True for hidden text entry.
+
+    Example::
+
+        ..
+        kb = xbmc.Keyboard('default', 'heading', True)
+        kb.setDefault('password') # optional
+        kb.setHeading('Enter password') # optional
+        kb.setHiddenInput(True) # optional
+        kb.doModal()
+        if (kb.isConfirmed()):
+        text = kb.getText()
+        ..
+    """
+    
+    def __init__(self, line: str = "",
+                 heading: str = "",
+                 hidden: bool = False) -> None:
+        pass
+    
+    def doModal(self, autoclose: int = 0) -> None:
+        """
+        Show keyboard and wait for user action.
+
+        :param autoclose: [opt] integer - milliseconds to autoclose dialog. (default=do not
+            autoclose)
+
+        Example::
+
+            ..
+            kb.doModal(30000)
+            ..
+        """
+        pass
+    
+    def setDefault(self, line: str = "") -> None:
+        """
+        Set the default text entry.
+
+        :param line: string - default text entry.
+
+        Example::
+
+            ..
+            kb.setDefault('password')
+            ..
+        """
+        pass
+    
+    def setHiddenInput(self, hidden: bool = False) -> None:
+        """
+        Allows hidden text entry.
+
+        :param hidden: boolean - True for hidden text entry.
+
+        Example::
+
+            ..
+            kb.setHiddenInput(True)
+            ..
+        """
+        pass
+    
+    def setHeading(self, heading: str) -> None:
+        """
+        Set the keyboard heading.
+
+        :param heading: string - keyboard heading.
+
+        Example::
+
+            ..
+            kb.setHeading('Enter password')
+            ..
+        """
+        pass
+    
+    def getText(self) -> str:
+        """
+        Returns the user input as a string.
+
+        .. note::
+            This will always return the text entry even if you cancel the
+            keyboard. Use the `isConfirmed()` method to check if user cancelled
+            the keyboard.
+
+        :return: get the in keyboard entered text
+
+        Example::
+
+            ..
+            text = kb.getText()
+            ..
+        """
+        return ""
+    
+    def isConfirmed(self) -> bool:
+        """
+        Returns False if the user cancelled the input.
+
+        :return: true if confirmed, if cancelled false
+
+        Example::
+
+            ..
+            if (kb.isConfirmed()):
+            ..
+        """
+        return True
+    
+
+class Monitor:
+    """
+    **Kodi's monitor class.**
+
+    Creates a new monitor to notify addon about changes.
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def onSettingsChanged(self) -> None:
+        """
+        onSettingsChanged method.
+
+        Will be called when addon settings are changed
+        """
+        pass
+    
+    def onScreensaverActivated(self) -> None:
+        """
+        onScreensaverActivated method.
+
+        Will be called when screensaver kicks in
+        """
+        pass
+    
+    def onScreensaverDeactivated(self) -> None:
+        """
+        onScreensaverDeactivated method.
+
+        Will be called when screensaver goes off
+        """
+        pass
+    
+    def onDPMSActivated(self) -> None:
+        """
+        onDPMSActivated method.
+
+        Will be called when energysaving/DPMS gets active
+        """
+        pass
+    
+    def onDPMSDeactivated(self) -> None:
+        """
+        onDPMSDeactivated method.
+
+        Will be called when energysaving/DPMS is turned off
+        """
+        pass
+    
+    def onScanStarted(self, library: str) -> None:
+        """
+        onScanStarted method.
+
+        :param library: Video / music as string
+
+        .. note::
+            Will be called when library clean has ended and return video or
+            music to indicate which library is being scanned
+
+        @python_v14 New function added.
+        """
+        pass
+    
+    def onScanFinished(self, library: str) -> None:
+        """
+        onScanFinished method.
+
+        :param library: Video / music as string
+
+        .. note::
+            Will be called when library clean has ended and return video or
+            music to indicate which library has been scanned
+
+        @python_v14 New function added.
+        """
+        pass
+    
+    def onCleanStarted(self, library: str) -> None:
+        """
+        onCleanStarted method.
+
+        :param library: Video / music as string
+
+        .. note::
+            Will be called when library clean has ended and return video or
+            music to indicate which library has been cleaned
+
+        @python_v14 New function added.
+        """
+        pass
+    
+    def onCleanFinished(self, library: str) -> None:
+        """
+        onCleanFinished method.
+
+        :param library: Video / music as string
+
+        .. note::
+            Will be called when library clean has ended and return video or
+            music to indicate which library has been finished
+
+        @python_v14 New function added.
+        """
+        pass
+    
+    def onNotification(self, sender: str, method: str, data: str) -> None:
+        """
+        onNotification method.
+
+        :param sender: Sender of the notification
+        :param method: Name of the notification
+        :param data: JSON-encoded data of the notification
+
+        .. note::
+            Will be called when Kodi receives or sends a notification
+
+        @python_v13 New function added.
+        """
+        pass
+    
+    def waitForAbort(self, timeout: float = -1) -> bool:
+        """
+        Wait for Abort
+
+        Block until abort is requested, or until timeout occurs. If an abort requested
+        have already been made, return immediately.
+
+        :param timeout: [opt] float - timeout in seconds. Default: no timeout.
+        :return: True when abort have been requested, False if a timeout is given and the operation times out.
+
+        @python_v14 New function added.
+
+        Example::
+
+            ..
+            monitor = xbmc.Monitor()
+            # do something
+            monitor.waitForAbort(10) # sleeps for 10 secs or returns early if kodi aborts
+            if monitor.abortRequested():
+            # abort was requested to Kodi (e.g. shutdown), do your cleanup logic
+            ..
+        """
+        return True
+    
+    def abortRequested(self) -> bool:
+        """
+        Returns True if abort has been requested.
+
+        :return: True if requested
+
+        @python_v14 New function added.
+        """
+        return True
+    
+
+class Player:
+    """
+    **Kodi's player.**
+
+    To become and create the class to play something.
+
+    Example::
+
+        ...
+        xbmc.Player().play(url, listitem, windowed)
+        ...
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def play(self, item: Union[str,  'PlayList'] = "",
+             listitem: Optional['xbmcgui.ListItem'] = None,
+             windowed: bool = False,
+             startpos: int = -1) -> None:
+        """
+        Play an item.
+
+        :param item: [opt] string - filename, url or playlist
+        :param listitem: [opt] listitem - used with setInfo() to set different infolabels.
+        :param windowed: [opt] bool - true=play video windowed, false=play users
+            preference.(default)
+        :param startpos: [opt] int - starting position when playing a playlist. Default = -1
+
+        .. note::
+            If item is not given then the `Player` will try to play the current
+            item in the current playlist.   You can use the above as keywords
+            for arguments and skip certain optional arguments.  Once you use a
+            keyword, all following arguments require the keyword.
+
+        Example::
+
+            ...
+            listitem = xbmcgui.ListItem('Ironman')
+            listitem.setInfo('video', {'Title': 'Ironman', 'Genre': 'Science Fiction'})
+            xbmc.Player().play(url, listitem, windowed)
+            xbmc.Player().play(playlist, listitem, windowed, startpos)
+            ...
+        """
+        pass
+    
+    def stop(self) -> None:
+        """
+        Stop playing.
+        """
+        pass
+    
+    def pause(self) -> None:
+        """
+        Pause or resume playing if already paused.
+        """
+        pass
+    
+    def playnext(self) -> None:
+        """
+        Play next item in playlist.
+        """
+        pass
+    
+    def playprevious(self) -> None:
+        """
+        Play previous item in playlist.
+        """
+        pass
+    
+    def playselected(self, selected: int) -> None:
+        """
+        Play a certain item from the current playlist.
+
+        :param selected: Integer - Item to select
+        """
+        pass
+    
+    def isPlaying(self) -> bool:
+        """
+        Check Kodi is playing something.
+
+        :return: True if Kodi is playing a file.
+        """
+        return True
+    
+    def isPlayingAudio(self) -> bool:
+        """
+        Check for playing audio.
+
+        :return: True if Kodi is playing an audio file.
+        """
+        return True
+    
+    def isPlayingVideo(self) -> bool:
+        """
+        Check for playing video.
+
+        :return: True if Kodi is playing a video.
+        """
+        return True
+    
+    def isPlayingRDS(self) -> bool:
+        """
+        Check for playing radio data system (RDS).
+
+        :return: True if kodi is playing a radio data system (RDS).
+        """
+        return True
+    
+    def isExternalPlayer(self) -> bool:
+        """
+        Check for external player.
+
+        :return: True if kodi is playing using an external player.
+
+        @python_v18 New function added.
+        """
+        return True
+    
+    def getPlayingFile(self) -> str:
+        """
+        Returns the current playing file as a string.
+
+        .. note::
+            For LiveTV, returns a **pvr://** url which is not translatable to
+            an OS specific file or external url.
+
+        :return: Playing filename
+        :raises Exception: If player is not playing a file.
+        """
+        return ""
+    
+    def getPlayingItem(self) -> 'xbmcgui.ListItem':
+        """
+        Returns the current playing item.
+
+        :return: Playing item
+        :raises Exception: If player is not playing a file.
+
+        @python_v20 New function added.
+        """
+        from xbmcgui import ListItem
+        return ListItem()
+    
+    def getTime(self) -> float:
+        """
+        Get playing time.
+
+        Returns the current time of the current playing media as fractional seconds.
+
+        :return: Current time as fractional seconds
+        :raises Exception: If player is not playing a file.
+        """
+        return 0.0
+    
+    def seekTime(self, seekTime: float) -> None:
+        """
+        Seek time.
+
+        Seeks the specified amount of time as fractional seconds. The time specified is
+        relative to the beginning of the currently. playing media file.
+
+        :param seekTime: Time to seek as fractional seconds
+        :raises Exception: If player is not playing a file.
+        """
+        pass
+    
+    def setSubtitles(self, subtitleFile: str) -> None:
+        """
+        Set subtitle file and enable subtitles.
+
+        :param subtitleFile: File to use as source ofsubtitles
+        """
+        pass
+    
+    def showSubtitles(self, bVisible: bool) -> None:
+        """
+        Enable / disable subtitles.
+
+        :param visible: [boolean] True for visible subtitles.
+
+        Example::
+
+            ...
+            xbmc.Player().showSubtitles(True)
+            ...
+        """
+        pass
+    
+    def getSubtitles(self) -> str:
+        """
+        Get subtitle stream name.
+
+        :return: Stream name
+        """
+        return ""
+    
+    def getAvailableSubtitleStreams(self) -> List[str]:
+        """
+        Get Subtitle stream names.
+
+        :return: `List` of subtitle streams as name
+        """
+        return [""]
+    
+    def setSubtitleStream(self, iStream: int) -> None:
+        """
+        Set Subtitle Stream.
+
+        :param iStream: [int] Subtitle stream to select for play
+
+        Example::
+
+            ...
+            xbmc.Player().setSubtitleStream(1)
+            ...
+        """
+        pass
+    
+    def updateInfoTag(self, item: 'xbmcgui.ListItem') -> None:
+        """
+        Update info labels for currently playing item.
+
+        :param item: ListItem with new info
+        :raises Exception: If player is not playing a file
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            item = xbmcgui.ListItem()
+            item.setPath(xbmc.Player().getPlayingFile())
+            item.setInfo('music', {'title' : 'foo', 'artist' : 'bar'})
+            xbmc.Player().updateInfoTag(item)
+            ...
+        """
+        pass
+    
+    def getVideoInfoTag(self) -> InfoTagVideo:
+        """
+        To get video info tag.
+
+        Returns the VideoInfoTag of the current playing Movie.
+
+        :return: Video info tag
+        :raises Exception: If player is not playing a file or current file is not a movie file.
+        """
+        return InfoTagVideo()
+    
+    def getMusicInfoTag(self) -> InfoTagMusic:
+        """
+        To get music info tag.
+
+        Returns the MusicInfoTag of the current playing 'Song'.
+
+        :return: Music info tag
+        :raises Exception: If player is not playing a file or current file is not a music file.
+        """
+        return InfoTagMusic()
+    
+    def getRadioRDSInfoTag(self) -> InfoTagRadioRDS:
+        """
+        To get Radio RDS info tag
+
+        Returns the RadioRDSInfoTag of the current playing 'Radio Song if. present'.
+
+        :return: Radio RDS info tag
+        :raises Exception: If player is not playing a file or current file is not a rds file.
+        """
+        return InfoTagRadioRDS()
+    
+    def getTotalTime(self) -> float:
+        """
+        To get total playing time.
+
+        Returns the total time of the current playing media in seconds. This is only
+        accurate to the full second.
+
+        :return: Total time of the current playing media
+        :raises Exception: If player is not playing a file.
+        """
+        return 0.0
+    
+    def getAvailableAudioStreams(self) -> List[str]:
+        """
+        Get Audio stream names
+
+        :return: `List` of audio streams as name
+        """
+        return [""]
+    
+    def setAudioStream(self, iStream: int) -> None:
+        """
+        Set Audio Stream.
+
+        :param iStream: [int] Audio stream to select for play
+
+        Example::
+
+            ...
+            xbmc.Player().setAudioStream(1)
+            ...
+        """
+        pass
+    
+    def getAvailableVideoStreams(self) -> List[str]:
+        """
+        Get Video stream names
+
+        :return: `List` of video streams as name
+        """
+        return [""]
+    
+    def setVideoStream(self, iStream: int) -> None:
+        """
+        Set Video Stream.
+
+        :param iStream: [int] Video stream to select for play
+
+        Example::
+
+            ...
+            xbmc.Player().setVideoStream(1)
+            ...
+        """
+        pass
+    
+    def onPlayBackStarted(self) -> None:
+        """
+        onPlayBackStarted method.
+
+        Will be called when Kodi player starts. Video or audio might not be available at
+        this point.
+
+        @python_v18 Use `onAVStarted()` instead if you need to detect if Kodi is actually
+        playing a media file (i.e, if a stream is available)
+        """
+        pass
+    
+    def onAVStarted(self) -> None:
+        """
+        onAVStarted method.
+
+        Will be called when Kodi has a video or audiostream.
+
+        @python_v18 New function added.
+        """
+        pass
+    
+    def onAVChange(self) -> None:
+        """
+        onAVChange method.
+
+        Will be called when Kodi has a video, audio or subtitle stream. Also happens
+        when the stream changes.
+
+        @python_v18 New function added.
+        """
+        pass
+    
+    def onPlayBackEnded(self) -> None:
+        """
+        onPlayBackEnded method.
+
+        Will be called when Kodi stops playing a file.
+        """
+        pass
+    
+    def onPlayBackStopped(self) -> None:
+        """
+        onPlayBackStopped method.
+
+        Will be called when user stops Kodi playing a file.
+        """
+        pass
+    
+    def onPlayBackError(self) -> None:
+        """
+        onPlayBackError method.
+
+        Will be called when playback stops due to an error.
+        """
+        pass
+    
+    def onPlayBackPaused(self) -> None:
+        """
+        onPlayBackPaused method.
+
+        Will be called when user pauses a playing file.
+        """
+        pass
+    
+    def onPlayBackResumed(self) -> None:
+        """
+        onPlayBackResumed method.
+
+        Will be called when user resumes a paused file.
+        """
+        pass
+    
+    def onQueueNextItem(self) -> None:
+        """
+        onQueueNextItem method.
+
+        Will be called when user queues the next item.
+        """
+        pass
+    
+    def onPlayBackSpeedChanged(self, speed: int) -> None:
+        """
+        onPlayBackSpeedChanged method.
+
+        Will be called when players speed changes (eg. user FF/RW).
+
+        :param speed: [integer] Current speed of player
+
+        .. note::
+            Negative speed means player is rewinding, 1 is normal playback
+            speed.
+        """
+        pass
+    
+    def onPlayBackSeek(self, time: int, seekOffset: int) -> None:
+        """
+        onPlayBackSeek method.
+
+        Will be called when user seeks to a time.
+
+        :param time: [integer] Time to seek to
+        :param seekOffset: [integer] ?
+        """
+        pass
+    
+    def onPlayBackSeekChapter(self, chapter: int) -> None:
+        """
+        onPlayBackSeekChapter method.
+
+        Will be called when user performs a chapter seek.
+
+        :param chapter: [integer] Chapter to seek to
+        """
+        pass
+    
+
+class PlayList:
+    """
+    **Kodi's Play `List` class.**
+
+    To create and edit a playlist which can be handled by the player.
+
+    :param playList: [integer] To define the stream type
+
+    ===== =================== =================================== 
+    Value Integer String      Description                         
+    ===== =================== =================================== 
+    0     xbmc.PLAYLIST_MUSIC Playlist for music files or streams 
+    1     xbmc.PLAYLIST_VIDEO Playlist for video files or streams 
+    ===== =================== =================================== 
+
+    Example::
+
+        ...
+        play=xbmc.PlayList(xbmc.PLAYLIST_VIDEO)
+        ...
+    """
+    
+    def __init__(self, playList: int) -> None:
+        pass
+    
+    def getPlayListId(self) -> int:
+        """
+        Get the `PlayList` Identifier
+
+        :return: Id as an integer.
+        """
+        return 0
+    
+    def add(self, url: str,
+            listitem: Optional['xbmcgui.ListItem'] = None,
+            index: int = -1) -> None:
+        """
+        Adds a new file to the playlist.
+
+        :param url: string or unicode - filename or url to add.
+        :param listitem: [opt] listitem - used with setInfo() to set different infolabels.
+        :param index: [opt] integer - position to add playlist item. (default=end)
+
+        .. note::
+            You can use the above as keywords for arguments and skip certain
+            optional arguments.  Once you use a keyword, all following
+            arguments require the keyword.
+
+        Example::
+
+            ..
+            playlist = xbmc.PlayList(xbmc.PLAYLIST_VIDEO)
+            video = 'F:\\movies\\Ironman.mov'
+            listitem = xbmcgui.ListItem('Ironman', thumbnailImage='F:\\movies\\Ironman.tbn')
+            listitem.setInfo('video', {'Title': 'Ironman', 'Genre': 'Science Fiction'})
+            playlist.add(url=video, listitem=listitem, index=7)
+            ..
+        """
+        pass
+    
+    def load(self, filename: str) -> bool:
+        """
+        Load a playlist.
+
+        Clear current playlist and copy items from the file to this Playlist filename
+        can be like .pls or .m3u ...
+
+        :param filename: File with list to play inside
+        :return: False if unable to load playlist
+        """
+        return True
+    
+    def remove(self, filename: str) -> None:
+        """
+        Remove an item with this filename from the playlist.
+
+        :param filename: The file to remove from list.
+        """
+        pass
+    
+    def clear(self) -> None:
+        """
+        Clear all items in the playlist.
+        """
+        pass
+    
+    def size(self) -> int:
+        """
+        Returns the total number of PlayListItems in this playlist.
+
+        :return: Amount of playlist entries.
+        """
+        return 0
+    
+    def shuffle(self) -> None:
+        """
+        Shuffle the playlist.
+        """
+        pass
+    
+    def unshuffle(self) -> None:
+        """
+        Unshuffle the playlist.
+        """
+        pass
+    
+    def getposition(self) -> int:
+        """
+        Returns the position of the current song in this playlist.
+
+        :return: Position of the current song
+        """
+        return 0
+    
+
+class RenderCapture:
+    """
+    **Kodi's render capture.**
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def getWidth(self) -> int:
+        """
+        Get width
+
+        To get width of captured image as set during `RenderCapture.capture()`. Returns 0
+        prior to calling capture.
+
+        :return: Width or 0 prior to calling capture
+        """
+        return 0
+    
+    def getHeight(self) -> int:
+        """
+        Get height
+
+        To get height of captured image as set during `RenderCapture.capture()`. Returns
+        0 prior to calling capture.
+
+        :return: height or 0 prior to calling capture
+        """
+        return 0
+    
+    def getAspectRatio(self) -> float:
+        """
+        Get aspect ratio of currently displayed video.
+
+        :return: Aspect ratio
+
+        This may be called prior to calling `RenderCapture.capture()`.
+        """
+        return 0.0
+    
+    def getImageFormat(self) -> str:
+        """
+        Get image format
+
+        :return: Format of captured image: 'BGRA'
+
+        @python_v17 Image will now always be returned in BGRA
+        """
+        return ""
+    
+    def getImage(self, msecs: int = 0) -> bytearray:
+        """
+        Returns captured image as a bytearray.
+
+        :param msecs: [opt] Milliseconds to wait. Waits 1000ms if not specified
+        :return: Captured image as a bytearray
+
+        .. note::
+            The size of the image is m_width * m_height * 4
+
+        @python_v17 Added the option to specify wait time in msec.
+        """
+        return bytearray()
+    
+    def capture(self, width: int, height: int) -> None:
+        """
+        Issue capture request.
+
+        :param width: Width capture image should be rendered to
+        :param height: Height capture image should should be rendered to
+
+        @python_v17 Removed the option to pass **flags**
+        """
+        pass
+
+
+def log(msg: str, level: int = LOGDEBUG) -> None:
+    """
+    Write a string to Kodi's log file and the debug window.
+
+    :param msg: string - text to output.
+    :param level: [opt] integer - log level to output at.(default=LOGDEBUG)
+
+    =============== ================================================================================
+    Value:          Description:
+    =============== ================================================================================
+    xbmc.LOGDEBUG   In depth information about the status of Kodi. This information can pretty much
+                    only be deciphered by a developer or long time Kodi power user.
+    xbmc.LOGINFO    Something has happened. It's not a problem, we just thought you might want
+                    to know. Fairly excessive output that most people won't care about.
+    xbmc.LOGWARNING Something potentially bad has happened. If Kodi did something you didn't expect,
+                    this is probably why. Watch for errors to follow.
+    xbmc.LOGERROR   This event is bad. Something has failed. You likely noticed problems with
+                    the application be it skin artifacts, failure of playback a crash, etc.
+    xbmc.LOGFATAL   We're screwed. Kodi is about to crash.
+    =============== ================================================================================
+
+    .. note::
+        Addon developers are advised to keep ``LOGDEBUG`` as the default
+        logging level and to use conservative logging (log only if
+        needed). Excessive logging makes it harder to debug kodi itself.
+
+    Logging in kodi has a global configuration level that controls how
+    text is written to the log. This global logging behaviour can be
+    changed in the GUI (**Settings -> System -> Logging**) (debug toggle)
+    or furthered configured in advancedsettings (loglevel setting).
+
+    Text is written to the log for the following conditions:
+
+    * loglevel == -1 (NONE, nothing at all is logged to the log)
+
+    * loglevel == 0 (NORMAL, shows ``LOGINFO``,``LOGWARNING``,``LOGERROR``
+      and ``LOGFATAL``) - Default kodi behaviour
+
+    * loglevel == 1 (DEBUG, shows all) - Behaviour if you toggle debug log in the GUI
+
+    @python_v17 Default level changed from ``LOGNOTICE`` to ``LOGDEBUG``
+
+    @python_v19 Removed ``LOGNOTICE`` (use ``LOGINFO``) and ``LOGSEVERE`` (use ``LOGFATAL``)
+
+    Example::
+
+        ..
+        xbmc.log(msg='This is a test string.', level=xbmc.LOGDEBUG);
+        ..
+    """
+    pass
+
+
+def shutdown() -> None:
+    """
+    Shutdown the htpc.
+
+    Example::
+
+        ..
+        xbmc.shutdown()
+        ..
+    """
+    pass
+
+
+def restart() -> None:
+    """
+    Restart the htpc.
+
+    Example::
+
+        ..
+        xbmc.restart()
+        ..
+    """
+    pass
+
+
+def executescript(script: str) -> None:
+    """
+    Execute a python script.
+
+    :param script: string - script filename to execute.
+
+    Example::
+
+        ..
+        xbmc.executescript('special://home/scripts/update.py')
+        ..
+    """
+    pass
+
+
+def executebuiltin(function: str, wait: bool = False) -> None:
+    """
+    Execute a built in Kodi function.
+
+    :param function: string - builtin function to execute.
+    :param wait: [opt] bool - If Kodi should wait for the builtin function execution to
+        finish (default False)
+
+    List of builtin functions: https://kodi.wiki/view/List_of_built-in_functions
+
+    Example::
+
+        ..
+        xbmc.executebuiltin('Skin.SetString(abc,def)')
+        ..
+    """
+    pass
+
+
+def executeJSONRPC(jsonrpccommand: str) -> str:
+    """
+    Execute an JSONRPC command.
+
+    :param jsonrpccommand: string - jsonrpc command to execute.
+    :return: jsonrpc return string
+
+    Example::
+
+        ..
+        response = xbmc.executeJSONRPC('{ "jsonrpc": "2.0", "method": "JSONRPC.Introspect", "id": 1 }')
+        ..
+    """
+    return ""
+
+
+def sleep(timemillis: int) -> None:
+    """
+    Sleeps for 'time' (msec).
+
+    :param time: integer - number of msec to sleep.
+    :raises TypeError: If time is not an integer.
+
+    This is useful if you need to sleep for a small amount of time (milisecond
+    range) somewhere in your addon logic. Please note that Kodi will attempt to stop
+    any running scripts when signaled to exit and wait for a maximum of 5 seconds
+    before trying to force stop your script. If your addon makes use
+    of `xbmc.sleep()` incorrectly (long periods of time, e.g. that exceed the force
+    stop waiting time) it may lead to Kodi hanging on shutdown. In case your addon
+    needs long sleep/idle periods use `xbmc.Monitor().waitForAbort(secs)` instead.
+
+    Example::
+
+        ..
+        xbmc.sleep(2000) # sleeps for 2 seconds
+        ..
+    """
+    pass
+
+
+def getLocalizedString(id: int) -> str:
+    """
+    Get a localized 'unicode string'.
+
+    :param id: integer - id# for string you want to localize.
+    :return: Localized 'unicode string'
+
+    .. note::
+        See strings.po in``\language\{yourlanguage}\`` for which id you
+        need for a string.
+
+    Example::
+
+        ..
+        locstr = xbmc.getLocalizedString(6)
+        ..
+    """
+    return ""
+
+
+def getSkinDir() -> str:
+    """
+    Get the active skin directory.
+
+    :return: The active skin directory as a string
+
+    .. note::
+        This is not the full path like
+        'special://home/addons/MediaCenter', but only 'MediaCenter'.
+
+    Example::
+
+        ..
+        skindir = xbmc.getSkinDir()
+        ..
+    """
+    return ""
+
+
+def getLanguage(format: int = ENGLISH_NAME, region: bool = False) -> str:
+    """
+    Get the active language.
+
+    :param format: [opt] format of the returned language string
+
+    ================= ========================================================== 
+    Value             Description                                                
+    ================= ========================================================== 
+    xbmc.ISO_639_1    Two letter code as defined in ISO 639-1                    
+    xbmc.ISO_639_2    Three letter code as defined in ISO 639-2/T or ISO 639-2/B 
+    xbmc.ENGLISH_NAME Full language name in English (default)                    
+    ================= ========================================================== 
+
+    :param region: [opt] append the region delimited by "-" of the language (setting) to
+        the returned language string
+    :return: The active language as a string
+
+    @python_v13 Added new options **format** and **region**.
+
+    Example::
+
+        ..
+        language = xbmc.getLanguage(xbmc.ENGLISH_NAME)
+        ..
+    """
+    return ""
+
+
+def getIPAddress() -> str:
+    """
+    Get the current ip address.
+
+    :return: The current ip address as a string
+
+    Example::
+
+        ..
+        ip = xbmc.getIPAddress()
+        ..
+    """
+    return ""
+
+
+def getDVDState() -> int:
+    """
+    Returns the dvd state as an integer.
+
+    :return: Values for state are:
+
+    ===== ============================== 
+    Value Name                           
+    ===== ============================== 
+    1     xbmc.DRIVE_NOT_READY           
+    16    xbmc.TRAY_OPEN                 
+    64    xbmc.TRAY_CLOSED_NO_MEDIA      
+    96    xbmc.TRAY_CLOSED_MEDIA_PRESENT 
+    ===== ============================== 
+
+    Example::
+
+        ..
+        dvdstate = xbmc.getDVDState()
+        ..
+    """
+    return 0
+
+
+def getFreeMem() -> int:
+    """
+    Get amount of free memory in MB.
+
+    :return: The amount of free memory in MB as an integer
+
+    Example::
+
+        ..
+        freemem = xbmc.getFreeMem()
+        ..
+    """
+    return 0
+
+
+def getInfoLabel(cLine: str) -> str:
+    """
+    Get a info label
+
+    :param infotag: string - infoTag for value you want returned.
+    :return: InfoLabel as a string
+
+    List of InfoLabels: https://kodi.wiki/view/InfoLabels
+
+    Example::
+
+        ..
+        label = xbmc.getInfoLabel('Weather.Conditions')
+        ..
+    """
+    return ""
+
+
+def getInfoImage(infotag: str) -> str:
+    """
+    Get filename including path to the InfoImage's thumbnail.
+
+    :param infotag: string - infotag for value you want returned
+    :return: Filename including path to the InfoImage's thumbnail as a string
+
+    List of InfoTags: http://kodi.wiki/view/InfoLabels
+
+    Example::
+
+        ..
+        filename = xbmc.getInfoImage('Weather.Conditions')
+        ..
+    """
+    return ""
+
+
+def playSFX(filename: str, useCached: bool = True) -> None:
+    """
+    Plays a wav file by filename
+
+    :param filename: string - filename of the wav file to play
+    :param useCached: [opt] bool - False = Dump any previously cached wav associated with
+        filename
+
+    @python_v14 Added new option **useCached**.
+
+    Example::
+
+        ..
+        xbmc.playSFX('special://xbmc/scripts/dingdong.wav')
+        xbmc.playSFX('special://xbmc/scripts/dingdong.wav',False)
+        ..
+    """
+    pass
+
+
+def stopSFX() -> None:
+    """
+    Stops wav file
+
+    @python_v14 New function added.
+
+    Example::
+
+        ..
+        xbmc.stopSFX()
+        ..
+    """
+    pass
+
+
+def enableNavSounds(yesNo: bool) -> None:
+    """
+    Enables/Disables nav sounds
+
+    :param yesNo: bool - enable (True) or disable (False) nav sounds
+
+    Example::
+
+        ..
+        xbmc.enableNavSounds(True)
+        ..
+    """
+    pass
+
+
+def getCondVisibility(condition: str) -> bool:
+    """
+    Get visibility conditions
+
+    :param condition: string - condition to check
+    :return: True (if the condition is verified) or False (otherwise)
+
+    List of boolean conditions: https://kodi.wiki/view/List_of_boolean_conditions
+
+    .. note::
+        You can combine two (or more) of the above settings by
+        using ``+`` as an AND operator, ``|`` as an OR operator, ``!``
+        as a NOT operator, and ``[`` and ``]`` to bracket expressions.
+
+    Example::
+
+        ..
+        visible = xbmc.getCondVisibility('[Control.IsVisible(41) + !Control.IsVisible(12)]')
+        ..
+    """
+    return True
+
+
+def getGlobalIdleTime() -> int:
+    """
+    Get the elapsed idle time in seconds.
+
+    :return: Elapsed idle time in seconds as an integer
+
+    Example::
+
+        ..
+        t = xbmc.getGlobalIdleTime()
+        ..
+    """
+    return 0
+
+
+def getCacheThumbName(path: str) -> str:
+    """
+    Get thumb cache filename.
+
+    :param path: string - path to file
+    :return: Thumb cache filename
+
+    Example::
+
+        ..
+        thumb = xbmc.getCacheThumbName('f:\\videos\\movie.avi')
+        ..
+    """
+    return ""
+
+
+def getCleanMovieTitle(path: str,
+                       usefoldername: bool = False) -> Tuple[str, str]:
+    """
+    Get clean movie title and year string if available.
+
+    :param path: string - String to clean
+    :param usefoldername: [opt] bool - use folder names (defaults to false)
+    :return: Clean movie title and year string if available.
+
+    Example::
+
+        ..
+        title, year = xbmc.getCleanMovieTitle('/path/to/moviefolder/test.avi', True)
+        ..
+    """
+    return "", ""
+
+
+def getRegion(id: str) -> str:
+    """
+    Returns your regions setting as a string for the specified id.
+
+    :param id: string - id of setting to return
+    :return: Region setting
+
+    .. note::
+        choices are (dateshort, datelong, time, meridiem, tempunit,
+        speedunit)
+
+    Example::
+
+        ..
+        date_long_format = xbmc.getRegion('datelong')
+        ..
+    """
+    return ""
+
+
+def getSupportedMedia(mediaType: str) -> str:
+    """
+    Get the supported file types for the specific media.
+
+    :param media: string - media type
+    :return: Supported file types for the specific media as a string
+
+    .. note::
+        Media type can be (video, music, picture). The return value is a
+        pipe separated string of filetypes (eg. ``'.mov |.avi'``).
+
+    Example::
+
+        ..
+        mTypes = xbmc.getSupportedMedia('video')
+        ..
+    """
+    return ""
+
+
+def skinHasImage(image: str) -> bool:
+    """
+    Check skin for presence of Image.
+
+    :param image: string - image filename
+    :return: True if the image file exists in the skin
+
+    .. note::
+        If the media resides in a subfolder include it.
+        (eg. home-myfiles\home-myfiles2.png).
+
+    Example::
+
+        ..
+        exists = xbmc.skinHasImage('ButtonFocusedTexture.png')
+        ..
+    """
+    return True
+
+
+def startServer(iTyp: int, bStart: bool) -> bool:
+    """
+    Start or stop a server.
+
+    :param typ: integer - use SERVER_* constants  Used format of the returned language
+        string
+
+    ========================= ====================================================================== 
+    Value                     Description                                                            
+    ========================= ====================================================================== 
+    xbmc.SERVER_WEBSERVER     To control Kodi's builtin webserver                                    
+    xbmc.SERVER_AIRPLAYSERVER AirPlay is a proprietary protocol stack/suite developed by Apple Inc.  
+    xbmc.SERVER_JSONRPCSERVER Control JSON-RPC HTTP/TCP socket-based interface                       
+    xbmc.SERVER_UPNPRENDERER  UPnP client (aka UPnP renderer)                                        
+    xbmc.SERVER_UPNPSERVER    Control built-in UPnP A/V media server (UPnP-server)                   
+    xbmc.SERVER_EVENTSERVER   Set eventServer part that accepts remote device input on all platforms 
+    xbmc.SERVER_ZEROCONF      Control Kodi's Avahi Zeroconf                                          
+    ========================= ====================================================================== 
+
+    :param bStart: bool - start (True) or stop (False) a server
+    :return: bool - True or False
+
+    @python_v20 Removed option **bWait**.
+
+    Example::
+
+        ..
+        xbmc.startServer(xbmc.SERVER_AIRPLAYSERVER, False)
+        ..
+    """
+    return True
+
+
+def audioSuspend() -> None:
+    """
+    Suspend Audio engine.
+
+    Example::
+
+        ..
+        xbmc.audioSuspend()
+        ..
+    """
+    pass
+
+
+def audioResume() -> None:
+    """
+    Resume Audio engine.
+
+    Example::
+
+        ..
+        xbmc.audioResume()
+        ..
+    """
+    pass
+
+
+def getUserAgent() -> str:
+    """
+    Returns Kodi's HTTP UserAgent string
+
+    :return: HTTP user agent
+
+    Example::
+
+        ..
+        xbmc.getUserAgent()
+        ..
+
+    example output: Kodi/17.0-ALPHA1 (X11; Linux x86_64) Ubuntu/15.10 App_Bitness/64
+    Version/17.0-ALPHA1-Git:2015-12-23-5770d28
+    """
+    return ""
+
+
+def convertLanguage(language: str, format: int) -> str:
+    """
+    Returns the given language converted to the given format as a string.
+
+    :param language: string either as name in English, two letter code (ISO 639-1), or
+        three letter code (ISO 639-2/T(B)
+    :param format: format of the returned language string
+
+    ================= ========================================================== 
+    Value             Description                                                
+    ================= ========================================================== 
+    xbmc.ISO_639_1    Two letter code as defined in ISO 639-1                    
+    xbmc.ISO_639_2    Three letter code as defined in ISO 639-2/T or ISO 639-2/B 
+    xbmc.ENGLISH_NAME Full language name in English (default)                    
+    ================= ========================================================== 
+
+    :return: Converted Language string
+
+    @python_v13 New function added.
+
+    Example::
+
+        ..
+        language = xbmc.convertLanguage(English, xbmc.ISO_639_2)
+        ..
+    """
+    return ""
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py
new file mode 100644
index 00000000000..d4c7803fbbf
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py
@@ -0,0 +1,642 @@
+# This file is generated from Kodi source code and post-edited
+# to correct code style and docstrings formatting.
+# License: GPL v.3 <https://www.gnu.org/licenses/gpl-3.0.en.html>
+"""
+**Kodi's addon class.**
+"""
+from typing import List, Optional
+
+__kodistubs__ = True
+
+
+
+
+class Addon:
+    """
+    **Kodi's addon class.**
+
+    Offers classes and functions that manipulate the add-on settings, information
+    and localization.
+
+    Creates a new AddOn class.
+
+    :param id: [opt] string - id of the addon as specified inaddon.xml
+
+    .. note::
+        Specifying the addon id is not needed.  Important however is that
+        the addon folder has the same name as the AddOn id provided
+        inaddon.xml.  You can optionally specify the addon id from another
+        installed addon to retrieve settings from it.
+
+    @python_v13 **id** is optional as it will be auto detected for this
+    add-on instance.
+
+    Example::
+
+        ..
+        self.Addon = xbmcaddon.Addon()
+        self.Addon = xbmcaddon.Addon('script.foo.bar')
+        ..
+    """
+    
+    def __init__(self, id: Optional[str] = None) -> None:
+        pass
+    
+    def getLocalizedString(self, id: int) -> str:
+        """
+        Returns an addon's localized 'string'.
+
+        :param id: integer - id# for string you want to localize.
+        :return: Localized 'string'
+
+        @python_v13 **id** is optional as it will be auto detected for this
+        add-on instance.
+
+        Example::
+
+            ..
+            locstr = self.Addon.`getLocalizedString`(32000)
+            ..
+        """
+        return ""
+    
+    def getSettings(self) -> 'Settings':
+        """
+        Returns a wrapper around the addon's settings.
+
+        :return: `Settings` wrapper
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings = self.Addon.getSettings()
+            ..
+        """
+        return Settings()
+    
+    def getSetting(self, id: str) -> str:
+        """
+        Returns the value of a setting as string.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: Setting as a string
+
+        @python_v13 **id** is optional as it will be auto detected for this
+        add-on instance.
+
+        Example::
+
+            ..
+            apikey = self.Addon.getSetting('apikey')
+            ..
+        """
+        return ""
+    
+    def getSettingBool(self, id: str) -> bool:
+        """
+        Returns the value of a setting as a boolean.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: Setting as a boolean
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.getBool()`** instead.
+
+        Example::
+
+            ..
+            enabled = self.Addon.getSettingBool('enabled')
+            ..
+        """
+        return True
+    
+    def getSettingInt(self, id: str) -> int:
+        """
+        Returns the value of a setting as an integer.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: Setting as an integer
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.getInt()`** instead.
+
+        Example::
+
+            ..
+            max = self.Addon.getSettingInt('max')
+            ..
+        """
+        return 0
+    
+    def getSettingNumber(self, id: str) -> float:
+        """
+        Returns the value of a setting as a floating point number.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: Setting as a floating point number
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.getNumber()`** instead.
+
+        Example::
+
+            ..
+            max = self.Addon.getSettingNumber('max')
+            ..
+        """
+        return 0.0
+    
+    def getSettingString(self, id: str) -> str:
+        """
+        Returns the value of a setting as a string.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: Setting as a string
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.getString()`** instead.
+
+        Example::
+
+            ..
+            apikey = self.Addon.getSettingString('apikey')
+            ..
+        """
+        return ""
+    
+    def setSetting(self, id: str, value: str) -> None:
+        """
+        Sets a script setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: string - value of the setting.
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v13 **id** is optional as it will be auto detected for this
+        add-on instance.
+
+        Example::
+
+            ..
+            self.Addon.`setSetting`(id='username', value='teamkodi')
+            ..
+        """
+        pass
+    
+    def setSettingBool(self, id: str, value: bool) -> bool:
+        """
+        Sets a script setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: boolean - value of the setting.
+        :return: True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.setBool()`** instead.
+
+        Example::
+
+            ..
+            self.Addon.setSettingBool(id='enabled', value=True)
+            ..
+        """
+        return True
+    
+    def setSettingInt(self, id: str, value: int) -> bool:
+        """
+        Sets a script setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: integer - value of the setting.
+        :return: True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.setInt()`** instead.
+
+        Example::
+
+            ..
+            self.Addon.setSettingInt(id='max', value=5)
+            ..
+        """
+        return True
+    
+    def setSettingNumber(self, id: str, value: float) -> bool:
+        """
+        Sets a script setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: float - value of the setting.
+        :return: True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.setNumber()`** instead.
+
+        Example::
+
+            ..
+            self.Addon.setSettingNumber(id='max', value=5.5)
+            ..
+        """
+        return True
+    
+    def setSettingString(self, id: str, value: str) -> bool:
+        """
+        Sets a script setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: string or unicode - value of the setting.
+        :return: True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **`Settings.setString()`** instead.
+
+        Example::
+
+            ..
+            self.Addon.setSettingString(id='username', value='teamkodi')
+            ..
+        """
+        return True
+    
+    def openSettings(self) -> None:
+        """
+        Opens this scripts settings dialog.
+
+        Example::
+
+            ..
+            self.Addon.openSettings()
+            ..
+        """
+        pass
+    
+    def getAddonInfo(self, id: str) -> str:
+        """
+        Returns the value of an addon property as a string.
+
+        :param id: string - id of the property that the module needs to access.
+
+        Choices for the property are
+
+        ====== ========= =========== ========== 
+        author changelog description disclaimer 
+        fanart icon      id          name       
+        path   profile   stars       summary    
+        type   version                          
+        ====== ========= =========== ========== 
+
+        :return: AddOn property as a string
+
+        Example::
+
+            ..
+            version = self.Addon.getAddonInfo('version')
+            ..
+        """
+        return ""
+    
+
+class Settings:
+    """
+    **Add-on settings**
+
+    This wrapper provides access to the settings specific to an add-on. It supports
+    reading and writing specific setting values.
+
+    @python_v20 New class added.
+
+    Example::
+
+        ...
+        settings = xbmcaddon.Addon('id').getSettings()
+        ...
+    """
+    
+    def getBool(self, id: str) -> bool:
+        """
+        Returns the value of a setting as a boolean.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: bool - Setting as a boolean
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            enabled = settings.getBool('enabled')
+            ..
+        """
+        return True
+    
+    def getInt(self, id: str) -> int:
+        """
+        Returns the value of a setting as an integer.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: integer - Setting as an integer
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            max = settings.getInt('max')
+            ..
+        """
+        return 0
+    
+    def getNumber(self, id: str) -> float:
+        """
+        Returns the value of a setting as a floating point number.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: float - Setting as a floating point number
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            max = settings.getNumber('max')
+            ..
+        """
+        return 0.0
+    
+    def getString(self, id: str) -> str:
+        """
+        Returns the value of a setting as a unicode string.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: string - Setting as a unicode string
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            apikey = settings.getString('apikey')
+            ..
+        """
+        return ""
+    
+    def getBoolList(self, id: str) -> List[bool]:
+        """
+        Returns the value of a setting as a list of booleans.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: list - Setting as a list of booleans
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            enabled = settings.getBoolList('enabled')
+            ..
+        """
+        return [True]
+    
+    def getIntList(self, id: str) -> List[int]:
+        """
+        Returns the value of a setting as a list of integers.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: list - Setting as a list of integers
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            ids = settings.getIntList('ids')
+            ..
+        """
+        return [0]
+    
+    def getNumberList(self, id: str) -> List[float]:
+        """
+        Returns the value of a setting as a list of floating point numbers.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: list - Setting as a list of floating point numbers
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            max = settings.getNumberList('max')
+            ..
+        """
+        return [0.0]
+    
+    def getStringList(self, id: str) -> List[str]:
+        """
+        Returns the value of a setting as a list of unicode strings.
+
+        :param id: string - id of the setting that the module needs to access.
+        :return: list - Setting as a list of unicode strings
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            views = settings.getStringList('views')
+            ..
+        """
+        return [""]
+    
+    def setBool(self, id: str, value: bool) -> None:
+        """
+        Sets the value of a setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: bool - value of the setting.
+        :return: bool - True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setBool(id='enabled', value=True)
+            ..
+        """
+        pass
+    
+    def setInt(self, id: str, value: int) -> None:
+        """
+        Sets the value of a setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: integer - value of the setting.
+        :return: bool - True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setInt(id='max', value=5)
+            ..
+        """
+        pass
+    
+    def setNumber(self, id: str, value: float) -> None:
+        """
+        Sets the value of a setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: float - value of the setting.
+        :return: bool - True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setNumber(id='max', value=5.5)
+            ..
+        """
+        pass
+    
+    def setString(self, id: str, value: str) -> None:
+        """
+        Sets the value of a setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param value: string or unicode - value of the setting.
+        :return: bool - True if the value of the setting was set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setString(id='username', value='teamkodi')
+            ..
+        """
+        pass
+    
+    def setBoolList(self, id: str, values: List[bool]) -> None:
+        """
+        Sets the boolean values of a list setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param values: list of boolean - values of the setting.
+        :return: bool - True if the values of the setting were set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setBoolList(id='enabled', values=[ True, False ])
+            ..
+        """
+        pass
+    
+    def setIntList(self, id: str, values: List[int]) -> None:
+        """
+        Sets the integer values of a list setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param values: list of int - values of the setting.
+        :return: bool - True if the values of the setting were set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setIntList(id='max', values=[ 5, 23 ])
+            ..
+        """
+        pass
+    
+    def setNumberList(self, id: str, values: List[float]) -> None:
+        """
+        Sets the floating point values of a list setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param values: list of float - values of the setting.
+        :return: bool - True if the values of the setting were set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setNumberList(id='max', values=[ 5.5, 5.8 ])
+            ..
+        """
+        pass
+    
+    def setStringList(self, id: str, values: List[str]) -> None:
+        """
+        Sets the string values of a list setting.
+
+        :param id: string - id of the setting that the module needs to access.
+        :param values: list of string or unicode - values of the setting.
+        :return: bool - True if the values of the setting were set, false otherwise
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            settings.setStringList(id='username', values=[ 'team', 'kodi' ])
+            ..
+        """
+        pass
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcdrm.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcdrm.py
new file mode 100644
index 00000000000..05d575d666b
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcdrm.py
@@ -0,0 +1,215 @@
+# This file is generated from Kodi source code and post-edited
+# to correct code style and docstrings formatting.
+# License: GPL v.3 <https://www.gnu.org/licenses/gpl-3.0.en.html>
+"""
+**Kodi's DRM class.**
+"""
+from typing import Union, Dict
+
+__kodistubs__ = True
+
+
+class CryptoSession:
+    """
+    **Kodi's DRM class.**
+
+    Offers classes and functions that allow a developer to work with DRM-protected
+    contents like Widevine.
+
+    This type of functionality is closely related to the type of DRM used and the
+    service to be implemented.
+
+    Using the `CryptoSession` constructor allow you to have access to a DRM session.
+    With a DRM session you can read and write the DRM
+    properties `GetPropertyString`,`SetPropertyString` and establish session keys
+    with GetKeyRequest and `ProvideKeyResponse`, or resume previous session keys
+    with `RestoreKeys`.
+
+    When the session keys are established you can use these methods to perform
+    various operations:`Encrypt` /`Decrypt` for data encryption / decryption,`Sign`
+    /`Verify` for make or verify data-signature. Useful for example to implement
+    encrypted communication between a client and the server.
+
+    An example where such functionality is useful is the Message Security Layer
+    (MSL) transmission protocol used in some VOD applications. This protocol (or
+    rather framework) is used to increase the level of security in the exchange of
+    messages (such as licences, manifests or other data), which defines a security
+    extension / layer on top of the HTTP protocol.
+
+    Constructor for DRM crypto session
+
+    :param UUID: string - 16 byte UUID of the DRM system to use
+    :param cipherAlgorithm: string - Algorithm used for encryption / decryption ciphers
+    :param macAlgorithm: string - Algorithm used for sign / verify
+    :raises RuntimeException: If the session can not be established
+
+    @python_v18 New class added.
+
+    Example::
+
+        ..
+        uuid_widevine = 'edef8ba9-79d6-4ace-a3c8-27dcd51d21ed'
+        crypto_session = xbmcdrm.CryptoSession(uuid_widevine, 'AES/CBC/NoPadding', 'HmacSHA256')
+        ..
+    """
+    
+    def __init__(self, UUID: str,
+                 cipherAlgorithm: str,
+                 macAlgorithm: str) -> None:
+        pass
+    
+    def GetKeyRequest(self, init: Union[str, bytes, bytearray],
+                      mimeType: str,
+                      offlineKey: bool,
+                      optionalParameters: Dict[str, str]) -> bytearray:
+        """
+        Generate a key request
+
+        Generate a key request, used for request/response exchange between the app and a
+        license server to obtain or release keys used to decrypt encrypted content.
+        After the app has received the key request response from the license server, it
+        should deliver to the response to the DRM instance using the
+        method `ProvideKeyResponse`, to activate the keys.
+
+        :param init: byte - Initialization bytes container-specific data, its meaning is
+            interpreted based on the mime type provided in the mimeType
+            parameter. It could contain, for example, the content ID, key ID
+            or other data required in generating the key request.
+        :param mimeType: string - Type of media which is exchanged (e.g. "application/xml",
+            "video/mp4")
+        :param offlineKey: bool - Specifies the type of the request. The request may be to
+            acquire keys for Streaming or Offline content
+        :param optionalParameters: [opt] map - Will be included in the key request message to allow a
+            client application to provide additional message parameters to the
+            server
+        :return: byte - The opaque key request data (challenge) which is send to key server
+
+        @python_v18 New function added.
+
+        @python_v19 With python 3 the init param must be a bytearray instead of byte.
+        """
+        return bytearray()
+    
+    def GetPropertyString(self, name: str) -> str:
+        """
+        Request a system specific property value of the DRM system.
+
+        :param Name: string - Name of the property to query
+        :return: Value of the requested property
+
+        @python_v18 New function added.
+        """
+        return ""
+    
+    def ProvideKeyResponse(self, response: Union[str, bytes, bytearray]) -> str:
+        """
+        Provide a key response
+
+        When a key response is received from the license server, must be sent to the DRM
+        instance by using provideKeyResponse. See also GetKeyRequest.
+
+        :param response: byte - Key data returned from the license server
+        :return: A keySetId if the response is for an offline key requests which can be used later
+            with restoreKeys, else return empty for streaming key requests.
+
+        @python_v18 New function added.
+
+        @python_v19 With python 3 the response argument must be a bytearray instead of byte.
+        """
+        return ""
+    
+    def RemoveKeys(self) -> None:
+        """
+        Removes all keys currently loaded in a session.
+
+        @python_v18 New function added.
+        """
+        pass
+    
+    def RestoreKeys(self, keySetId: str) -> None:
+        """
+        Restores session keys stored during previous `ProvideKeyResponse` call.
+
+        :param keySetId: string - Identifies the saved key set to restore. This value must
+            never be null.
+
+        @python_v18 New function added.
+        """
+        pass
+    
+    def SetPropertyString(self, name: str, value: str) -> None:
+        """
+        Set a system specific property value in the DRM system.
+
+        :param name: string - Name of the property. This value must never be null.
+        :param value: string - Value of the property to set. This value must never be null.
+
+        @python_v18 New function added.
+        """
+        pass
+    
+    def Decrypt(self, cipherKeyId: Union[str, bytes, bytearray],
+                input: Union[str, bytes, bytearray],
+                iv: Union[str, bytes, bytearray]) -> bytearray:
+        """
+        Decrypt an encrypted data by using session keys.
+
+        :param cipherKeyId: byte - Encryption key id (provided from a service handshake)
+        :param input: byte - Cipher text to decrypt
+        :param iv: byte - Initialization vector of cipher text
+        :return: Decrypted input data
+
+        @python_v18 New function added.
+
+        @python_v19 With python 3 all arguments need to be of type bytearray instead of byte.
+        """
+        return bytearray()
+    
+    def Encrypt(self, cipherKeyId: Union[str, bytes, bytearray],
+                input: Union[str, bytes, bytearray],
+                iv: Union[str, bytes, bytearray]) -> bytearray:
+        """
+        Encrypt data by using session keys.
+
+        :param cipherKeyId: byte - Encryption key id (provided from a service handshake)
+        :param input: byte - Encrypted text
+        :param iv: byte - Initialization vector of encrypted text
+        :return: byte - Encrypted input data
+
+        @python_v18 New function added.
+
+        @python_v19 With python 3 all arguments need to be of type bytearray instead of byte.
+        """
+        return bytearray()
+    
+    def Sign(self, macKeyId: Union[str, bytes, bytearray],
+             message: Union[str, bytes, bytearray]) -> bytearray:
+        """
+        Generate a DRM encrypted signature for a text message.
+
+        :param macKeyId: byte - HMAC key id (provided from a service handshake)
+        :param message: byte - Message text on which to base the signature
+        :return: byte - Signature
+
+        @python_v18 New function added.
+
+        @python_v19 With python 3 all arguments need to be of type bytearray instead of byte.
+        """
+        return bytearray()
+    
+    def Verify(self, macKeyId: Union[str, bytes, bytearray],
+               message: Union[str, bytes, bytearray],
+               signature: Union[str, bytes, bytearray]) -> bool:
+        """
+        Verify the validity of a DRM signature of a text message.
+
+        :param macKeyId: byte - HMAC key id (provided from a service handshake)
+        :param message: byte - Message text on which the signature is based
+        :param signature: byte - The signature to verify
+        :return: true when the signature is valid
+
+        @python_v18 New function added.
+
+        @python_v19 With python 3 for all arguments is needed to pass bytearray instead of byte.
+        """
+        return True
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py
new file mode 100644
index 00000000000..e63c3f8287d
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py
@@ -0,0 +1,4887 @@
+# This file is generated from Kodi source code and post-edited
+# to correct code style and docstrings formatting.
+# License: GPL v.3 <https://www.gnu.org/licenses/gpl-3.0.en.html>
+"""
+**GUI functions on Kodi.**
+
+Offers classes and functions that manipulate the Graphical User Interface
+through windows, dialogs, and various control widgets.
+"""
+from typing import Union, List, Dict, Tuple, Optional
+
+__kodistubs__ = True
+
+ACTION_ANALOG_FORWARD = 113
+ACTION_ANALOG_MOVE = 49
+ACTION_ANALOG_MOVE_X_LEFT = 601
+ACTION_ANALOG_MOVE_X_RIGHT = 602
+ACTION_ANALOG_MOVE_Y_DOWN = 604
+ACTION_ANALOG_MOVE_Y_UP = 603
+ACTION_ANALOG_REWIND = 114
+ACTION_ANALOG_SEEK_BACK = 125
+ACTION_ANALOG_SEEK_FORWARD = 124
+ACTION_ASPECT_RATIO = 19
+ACTION_AUDIO_DELAY = 161
+ACTION_AUDIO_DELAY_MIN = 54
+ACTION_AUDIO_DELAY_PLUS = 55
+ACTION_AUDIO_NEXT_LANGUAGE = 56
+ACTION_BACKSPACE = 110
+ACTION_BIG_STEP_BACK = 23
+ACTION_BIG_STEP_FORWARD = 22
+ACTION_BROWSE_SUBTITLE = 247
+ACTION_BUILT_IN_FUNCTION = 122
+ACTION_CALIBRATE_RESET = 48
+ACTION_CALIBRATE_SWAP_ARROWS = 47
+ACTION_CHANGE_RESOLUTION = 57
+ACTION_CHANNEL_DOWN = 185
+ACTION_CHANNEL_NUMBER_SEP = 192
+ACTION_CHANNEL_SWITCH = 183
+ACTION_CHANNEL_UP = 184
+ACTION_CHAPTER_OR_BIG_STEP_BACK = 98
+ACTION_CHAPTER_OR_BIG_STEP_FORWARD = 97
+ACTION_CONTEXT_MENU = 117
+ACTION_COPY_ITEM = 81
+ACTION_CREATE_BOOKMARK = 96
+ACTION_CREATE_EPISODE_BOOKMARK = 95
+ACTION_CURSOR_LEFT = 120
+ACTION_CURSOR_RIGHT = 121
+ACTION_CYCLE_SUBTITLE = 99
+ACTION_CYCLE_TONEMAP_METHOD = 261
+ACTION_DECREASE_PAR = 220
+ACTION_DECREASE_RATING = 137
+ACTION_DELETE_ITEM = 80
+ACTION_ENTER = 135
+ACTION_ERROR = 998
+ACTION_FILTER = 233
+ACTION_FILTER_CLEAR = 150
+ACTION_FILTER_SMS2 = 151
+ACTION_FILTER_SMS3 = 152
+ACTION_FILTER_SMS4 = 153
+ACTION_FILTER_SMS5 = 154
+ACTION_FILTER_SMS6 = 155
+ACTION_FILTER_SMS7 = 156
+ACTION_FILTER_SMS8 = 157
+ACTION_FILTER_SMS9 = 158
+ACTION_FIRST_PAGE = 159
+ACTION_FORWARD = 16
+ACTION_GESTURE_ABORT = 505
+ACTION_GESTURE_BEGIN = 501
+ACTION_GESTURE_END = 599
+ACTION_GESTURE_NOTIFY = 500
+ACTION_GESTURE_PAN = 504
+ACTION_GESTURE_ROTATE = 503
+ACTION_GESTURE_SWIPE_DOWN = 541
+ACTION_GESTURE_SWIPE_DOWN_TEN = 550
+ACTION_GESTURE_SWIPE_LEFT = 511
+ACTION_GESTURE_SWIPE_LEFT_TEN = 520
+ACTION_GESTURE_SWIPE_RIGHT = 521
+ACTION_GESTURE_SWIPE_RIGHT_TEN = 530
+ACTION_GESTURE_SWIPE_UP = 531
+ACTION_GESTURE_SWIPE_UP_TEN = 540
+ACTION_GESTURE_ZOOM = 502
+ACTION_GUIPROFILE_BEGIN = 204
+ACTION_HDR_TOGGLE = 260
+ACTION_HIGHLIGHT_ITEM = 8
+ACTION_INCREASE_PAR = 219
+ACTION_INCREASE_RATING = 136
+ACTION_INPUT_TEXT = 244
+ACTION_JUMP_SMS2 = 142
+ACTION_JUMP_SMS3 = 143
+ACTION_JUMP_SMS4 = 144
+ACTION_JUMP_SMS5 = 145
+ACTION_JUMP_SMS6 = 146
+ACTION_JUMP_SMS7 = 147
+ACTION_JUMP_SMS8 = 148
+ACTION_JUMP_SMS9 = 149
+ACTION_LAST_PAGE = 160
+ACTION_MENU = 163
+ACTION_MOUSE_DOUBLE_CLICK = 103
+ACTION_MOUSE_DRAG = 106
+ACTION_MOUSE_DRAG_END = 109
+ACTION_MOUSE_END = 109
+ACTION_MOUSE_LEFT_CLICK = 100
+ACTION_MOUSE_LONG_CLICK = 108
+ACTION_MOUSE_MIDDLE_CLICK = 102
+ACTION_MOUSE_MOVE = 107
+ACTION_MOUSE_RIGHT_CLICK = 101
+ACTION_MOUSE_START = 100
+ACTION_MOUSE_WHEEL_DOWN = 105
+ACTION_MOUSE_WHEEL_UP = 104
+ACTION_MOVE_DOWN = 4
+ACTION_MOVE_ITEM = 82
+ACTION_MOVE_ITEM_DOWN = 116
+ACTION_MOVE_ITEM_UP = 115
+ACTION_MOVE_LEFT = 1
+ACTION_MOVE_RIGHT = 2
+ACTION_MOVE_UP = 3
+ACTION_MUTE = 91
+ACTION_NAV_BACK = 92
+ACTION_NEXT_CHANNELGROUP = 186
+ACTION_NEXT_CONTROL = 181
+ACTION_NEXT_ITEM = 14
+ACTION_NEXT_LETTER = 140
+ACTION_NEXT_PICTURE = 28
+ACTION_NEXT_SCENE = 138
+ACTION_NEXT_SUBTITLE = 26
+ACTION_NONE = 0
+ACTION_NOOP = 999
+ACTION_PAGE_DOWN = 6
+ACTION_PAGE_UP = 5
+ACTION_PARENT_DIR = 9
+ACTION_PASTE = 180
+ACTION_PAUSE = 12
+ACTION_PLAYER_DEBUG = 27
+ACTION_PLAYER_DEBUG_VIDEO = 262
+ACTION_PLAYER_FORWARD = 77
+ACTION_PLAYER_PLAY = 79
+ACTION_PLAYER_PLAYPAUSE = 229
+ACTION_PLAYER_PROCESS_INFO = 69
+ACTION_PLAYER_PROGRAM_SELECT = 70
+ACTION_PLAYER_RESET = 248
+ACTION_PLAYER_RESOLUTION_SELECT = 71
+ACTION_PLAYER_REWIND = 78
+ACTION_PREVIOUS_CHANNELGROUP = 187
+ACTION_PREVIOUS_MENU = 10
+ACTION_PREV_CONTROL = 182
+ACTION_PREV_ITEM = 15
+ACTION_PREV_LETTER = 141
+ACTION_PREV_PICTURE = 29
+ACTION_PREV_SCENE = 139
+ACTION_PVR_ANNOUNCE_REMINDERS = 193
+ACTION_PVR_PLAY = 188
+ACTION_PVR_PLAY_RADIO = 190
+ACTION_PVR_PLAY_TV = 189
+ACTION_PVR_SHOW_TIMER_RULE = 191
+ACTION_QUEUE_ITEM = 34
+ACTION_QUEUE_ITEM_NEXT = 251
+ACTION_RECORD = 170
+ACTION_RELOAD_KEYMAPS = 203
+ACTION_REMOVE_ITEM = 35
+ACTION_RENAME_ITEM = 87
+ACTION_REWIND = 17
+ACTION_ROTATE_PICTURE_CCW = 51
+ACTION_ROTATE_PICTURE_CW = 50
+ACTION_SCAN_ITEM = 201
+ACTION_SCROLL_DOWN = 112
+ACTION_SCROLL_UP = 111
+ACTION_SELECT_ITEM = 7
+ACTION_SETTINGS_LEVEL_CHANGE = 242
+ACTION_SETTINGS_RESET = 241
+ACTION_SET_RATING = 164
+ACTION_SHIFT = 118
+ACTION_SHOW_FULLSCREEN = 36
+ACTION_SHOW_GUI = 18
+ACTION_SHOW_INFO = 11
+ACTION_SHOW_OSD = 24
+ACTION_SHOW_OSD_TIME = 123
+ACTION_SHOW_PLAYLIST = 33
+ACTION_SHOW_SUBTITLES = 25
+ACTION_SHOW_VIDEOMENU = 134
+ACTION_SMALL_STEP_BACK = 76
+ACTION_STEP_BACK = 21
+ACTION_STEP_FORWARD = 20
+ACTION_STEREOMODE_NEXT = 235
+ACTION_STEREOMODE_PREVIOUS = 236
+ACTION_STEREOMODE_SELECT = 238
+ACTION_STEREOMODE_SET = 240
+ACTION_STEREOMODE_TOGGLE = 237
+ACTION_STEREOMODE_TOMONO = 239
+ACTION_STOP = 13
+ACTION_SUBTITLE_ALIGN = 232
+ACTION_SUBTITLE_DELAY = 162
+ACTION_SUBTITLE_DELAY_MIN = 52
+ACTION_SUBTITLE_DELAY_PLUS = 53
+ACTION_SUBTITLE_VSHIFT_DOWN = 231
+ACTION_SUBTITLE_VSHIFT_UP = 230
+ACTION_SWITCH_PLAYER = 234
+ACTION_SYMBOLS = 119
+ACTION_TAKE_SCREENSHOT = 85
+ACTION_TELETEXT_BLUE = 218
+ACTION_TELETEXT_GREEN = 216
+ACTION_TELETEXT_RED = 215
+ACTION_TELETEXT_YELLOW = 217
+ACTION_TOGGLE_COMMSKIP = 246
+ACTION_TOGGLE_DIGITAL_ANALOG = 202
+ACTION_TOGGLE_FONT = 249
+ACTION_TOGGLE_FULLSCREEN = 199
+ACTION_TOGGLE_SOURCE_DEST = 32
+ACTION_TOGGLE_WATCHED = 200
+ACTION_TOUCH_LONGPRESS = 411
+ACTION_TOUCH_LONGPRESS_TEN = 420
+ACTION_TOUCH_TAP = 401
+ACTION_TOUCH_TAP_TEN = 410
+ACTION_TRIGGER_OSD = 243
+ACTION_VIDEO_NEXT_STREAM = 250
+ACTION_VIS_PRESET_LOCK = 130
+ACTION_VIS_PRESET_NEXT = 128
+ACTION_VIS_PRESET_PREV = 129
+ACTION_VIS_PRESET_RANDOM = 131
+ACTION_VIS_PRESET_SHOW = 126
+ACTION_VIS_RATE_PRESET_MINUS = 133
+ACTION_VIS_RATE_PRESET_PLUS = 132
+ACTION_VOICE_RECOGNIZE = 300
+ACTION_VOLAMP = 90
+ACTION_VOLAMP_DOWN = 94
+ACTION_VOLAMP_UP = 93
+ACTION_VOLUME_DOWN = 89
+ACTION_VOLUME_SET = 245
+ACTION_VOLUME_UP = 88
+ACTION_VSHIFT_DOWN = 228
+ACTION_VSHIFT_UP = 227
+ACTION_ZOOM_IN = 31
+ACTION_ZOOM_LEVEL_1 = 38
+ACTION_ZOOM_LEVEL_2 = 39
+ACTION_ZOOM_LEVEL_3 = 40
+ACTION_ZOOM_LEVEL_4 = 41
+ACTION_ZOOM_LEVEL_5 = 42
+ACTION_ZOOM_LEVEL_6 = 43
+ACTION_ZOOM_LEVEL_7 = 44
+ACTION_ZOOM_LEVEL_8 = 45
+ACTION_ZOOM_LEVEL_9 = 46
+ACTION_ZOOM_LEVEL_NORMAL = 37
+ACTION_ZOOM_OUT = 30
+ALPHANUM_HIDE_INPUT = 2
+CONTROL_TEXT_OFFSET_X = 10
+CONTROL_TEXT_OFFSET_Y = 2
+DLG_YESNO_CUSTOM_BTN = 12
+DLG_YESNO_NO_BTN = 10
+DLG_YESNO_YES_BTN = 11
+HORIZONTAL = 0
+ICON_OVERLAY_HD = 6
+ICON_OVERLAY_LOCKED = 3
+ICON_OVERLAY_NONE = 0
+ICON_OVERLAY_RAR = 1
+ICON_OVERLAY_UNWATCHED = 4
+ICON_OVERLAY_WATCHED = 5
+ICON_OVERLAY_ZIP = 2
+ICON_TYPE_FILES = 106
+ICON_TYPE_MUSIC = 103
+ICON_TYPE_NONE = 101
+ICON_TYPE_PICTURES = 104
+ICON_TYPE_PROGRAMS = 102
+ICON_TYPE_SETTINGS = 109
+ICON_TYPE_VIDEOS = 105
+ICON_TYPE_WEATHER = 107
+INPUT_ALPHANUM = 0
+INPUT_DATE = 2
+INPUT_IPADDRESS = 4
+INPUT_NUMERIC = 1
+INPUT_PASSWORD = 5
+INPUT_TIME = 3
+INPUT_TYPE_DATE = 4
+INPUT_TYPE_IPADDRESS = 5
+INPUT_TYPE_NUMBER = 1
+INPUT_TYPE_PASSWORD = 6
+INPUT_TYPE_PASSWORD_MD5 = 7
+INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW = 10
+INPUT_TYPE_SECONDS = 2
+INPUT_TYPE_TEXT = 0
+INPUT_TYPE_TIME = 3
+KEY_APPCOMMAND = 53248
+KEY_BUTTON_A = 256
+KEY_BUTTON_B = 257
+KEY_BUTTON_BACK = 275
+KEY_BUTTON_BLACK = 260
+KEY_BUTTON_DPAD_DOWN = 271
+KEY_BUTTON_DPAD_LEFT = 272
+KEY_BUTTON_DPAD_RIGHT = 273
+KEY_BUTTON_DPAD_UP = 270
+KEY_BUTTON_LEFT_ANALOG_TRIGGER = 278
+KEY_BUTTON_LEFT_THUMB_BUTTON = 276
+KEY_BUTTON_LEFT_THUMB_STICK = 264
+KEY_BUTTON_LEFT_THUMB_STICK_DOWN = 281
+KEY_BUTTON_LEFT_THUMB_STICK_LEFT = 282
+KEY_BUTTON_LEFT_THUMB_STICK_RIGHT = 283
+KEY_BUTTON_LEFT_THUMB_STICK_UP = 280
+KEY_BUTTON_LEFT_TRIGGER = 262
+KEY_BUTTON_RIGHT_ANALOG_TRIGGER = 279
+KEY_BUTTON_RIGHT_THUMB_BUTTON = 277
+KEY_BUTTON_RIGHT_THUMB_STICK = 265
+KEY_BUTTON_RIGHT_THUMB_STICK_DOWN = 267
+KEY_BUTTON_RIGHT_THUMB_STICK_LEFT = 268
+KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT = 269
+KEY_BUTTON_RIGHT_THUMB_STICK_UP = 266
+KEY_BUTTON_RIGHT_TRIGGER = 263
+KEY_BUTTON_START = 274
+KEY_BUTTON_WHITE = 261
+KEY_BUTTON_X = 258
+KEY_BUTTON_Y = 259
+KEY_INVALID = 65535
+KEY_MOUSE_CLICK = 57344
+KEY_MOUSE_DOUBLE_CLICK = 57360
+KEY_MOUSE_DRAG = 57604
+KEY_MOUSE_DRAG_END = 57606
+KEY_MOUSE_DRAG_START = 57605
+KEY_MOUSE_END = 61439
+KEY_MOUSE_LONG_CLICK = 57376
+KEY_MOUSE_MIDDLECLICK = 57346
+KEY_MOUSE_MOVE = 57603
+KEY_MOUSE_NOOP = 61439
+KEY_MOUSE_RDRAG = 57607
+KEY_MOUSE_RDRAG_END = 57609
+KEY_MOUSE_RDRAG_START = 57608
+KEY_MOUSE_RIGHTCLICK = 57345
+KEY_MOUSE_START = 57344
+KEY_MOUSE_WHEEL_DOWN = 57602
+KEY_MOUSE_WHEEL_UP = 57601
+KEY_UNICODE = 61952
+KEY_VKEY = 61440
+KEY_VMOUSE = 61439
+NOTIFICATION_ERROR = 'error'
+NOTIFICATION_INFO = 'info'
+NOTIFICATION_WARNING = 'warning'
+PASSWORD_VERIFY = 1
+REMOTE_0 = 58
+REMOTE_1 = 59
+REMOTE_2 = 60
+REMOTE_3 = 61
+REMOTE_4 = 62
+REMOTE_5 = 63
+REMOTE_6 = 64
+REMOTE_7 = 65
+REMOTE_8 = 66
+REMOTE_9 = 67
+VERTICAL = 1
+
+
+class Control:
+    """
+    **Code based skin access**
+
+    Offers classes and functions that manipulate the add-on gui controls.
+
+    Kodi is noted as having a very flexible and robust framework for its GUI, making
+    theme-skinning and personal customization very accessible. Users can create
+    their own skin (or modify an existing skin) and share it with others.
+
+    Kodi includes a new GUI library written from scratch. This library allows you to
+    skin/change everything you see in Kodi, from the images, the sizes and positions
+    of all controls, colours, fonts, and text, through to altering navigation and
+    even adding new functionality. The skin system is quite complex, and this
+    portion of the manual is dedicated to providing in depth information on how it
+    all works, along with tips to make the experience a little more pleasant.
+    """
+
+    def __init__(self) -> None:
+        pass
+    
+    def getId(self) -> int:
+        """
+        Returns the control's current id as an integer.
+
+        :return: int - Current id
+
+        Example::
+
+            ...
+            id = self.button.getId()
+            ...
+        """
+        return 0
+    
+    def getX(self) -> int:
+        """
+        Returns the control's current X position.
+
+        :return: int - Current X position
+
+        Example::
+
+            ...
+            posX = self.button.getX()
+            ...
+        """
+        return 0
+    
+    def getY(self) -> int:
+        """
+        Returns the control's current Y position.
+
+        :return: int - Current Y position
+
+        Example::
+
+            ...
+            posY = self.button.getY()
+            ...
+        """
+        return 0
+    
+    def getHeight(self) -> int:
+        """
+        Returns the control's current height as an integer.
+
+        :return: int - Current height
+
+        Example::
+
+            ...
+            height = self.button.getHeight()
+            ...
+        """
+        return 0
+    
+    def getWidth(self) -> int:
+        """
+        Returns the control's current width as an integer.
+
+        :return: int - Current width
+
+        Example::
+
+            ...
+            width = self.button.getWidth()
+            ...
+        """
+        return 0
+    
+    def setEnabled(self, enabled: bool) -> None:
+        """
+        Sets the control's enabled/disabled state.
+
+        :param enabled: bool - True=enabled / False=disabled.
+
+        Example::
+
+            ...
+            self.button.setEnabled(False)
+            ...
+        """
+        pass
+    
+    def setVisible(self, visible: bool) -> None:
+        """
+        Sets the control's visible/hidden state.
+
+        :param visible: bool - True=visible / False=hidden.
+
+        @python_v19 You can now define the visible state of a control before
+        it being added to a window. This value will be taken into account when
+        the control is later added.
+
+        Example::
+
+            ...
+            self.button.setVisible(False)
+            ...
+        """
+        pass
+    
+    def isVisible(self) -> bool:
+        """
+        Get the control's visible/hidden state with respect to the container/window
+
+        .. note::
+            If a given control is set visible (c.f.`setVisible()` but was not
+            yet added to a window, this method will return ``False`` (the
+            control is not visible yet since it was not added to the window).
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            if self.button.isVisible():
+            ...
+        """
+        return True
+    
+    def setVisibleCondition(self, visible: str,
+                            allowHiddenFocus: bool = False) -> None:
+        """
+        Sets the control's visible condition.
+
+        Allows Kodi to control the visible status of the control.
+
+        List of Conditions: https://kodi.wiki/view/List_of_boolean_conditions
+
+        :param visible: string - Visible condition
+        :param allowHiddenFocus: [opt] bool - True = gains focus even if hidden
+
+        Example::
+
+            ...
+            # setVisibleCondition(visible[,allowHiddenFocus])
+            self.button.setVisibleCondition('[Control.IsVisible(41) + !Control.IsVisible(12)]', True)
+            ...
+        """
+        pass
+    
+    def setEnableCondition(self, enable: str) -> None:
+        """
+        Sets the control's enabled condition.
+
+        Allows Kodi to control the enabled status of the control.
+
+        List of Conditions
+
+        :param enable: string - Enable condition.
+
+        Example::
+
+            ...
+            # setEnableCondition(enable)
+            self.button.setEnableCondition('System.InternetState')
+            ...
+        """
+        pass
+    
+    def setAnimations(self, eventAttr: List[Tuple[str, str]]) -> None:
+        """
+        Sets the control's animations.
+
+        **[(event,attr,)*]**: list - A list of tuples consisting of event and attributes
+        pairs.
+
+        Animating your skin
+
+        :param event: string - The event to animate.
+        :param attr: string - The whole attribute string separated by spaces.
+
+        Example::
+
+            ...
+            # setAnimations([(event, attr,)*])
+            self.button.setAnimations([('focus', 'effect=zoom end=90,247,220,56 time=0',)])
+            ...
+        """
+        pass
+    
+    def setPosition(self, x: int, y: int) -> None:
+        """
+        Sets the controls position.
+
+        :param x: integer - x coordinate of control.
+        :param y: integer - y coordinate of control.
+
+        .. note::
+            You may use negative integers. (e.g sliding a control into view)
+
+        Example::
+
+            ...
+            self.button.setPosition(100, 250)
+            ...
+        """
+        pass
+    
+    def setWidth(self, width: int) -> None:
+        """
+        Sets the controls width.
+
+        :param width: integer - width of control.
+
+        Example::
+
+            ...
+            self.image.setWidth(100)
+            ...
+        """
+        pass
+    
+    def setHeight(self, height: int) -> None:
+        """
+        Sets the controls height.
+
+        :param height: integer - height of control.
+
+        Example::
+
+            ...
+            self.image.setHeight(100)
+            ...
+        """
+        pass
+    
+    def setNavigation(self, up: 'Control',
+                      down: 'Control',
+                      left: 'Control',
+                      right: 'Control') -> None:
+        """
+        Sets the controls navigation.
+
+        :param up: control object - control to navigate to on up.
+        :param down: control object - control to navigate to on down.
+        :param left: control object - control to navigate to on left.
+        :param right: control object - control to navigate to on right.
+        :raises TypeError: if one of the supplied arguments is not a control type.
+        :raises ReferenceError: if one of the controls is not added to a window.
+
+        .. note::
+            Same
+            as `controlUp()`,`controlDown()`,`controlLeft()`,`controlRight()`.
+            Set to self to disable navigation for that direction.
+
+        Example::
+
+            ...
+            self.button.setNavigation(self.button1, self.button2, self.button3, self.button4)
+            ...
+        """
+        pass
+    
+    def controlUp(self, up: 'Control') -> None:
+        """
+        Sets the controls up navigation.
+
+        :param control: control object - control to navigate to on up.
+        :raises TypeError: if one of the supplied arguments is not a control type.
+        :raises ReferenceError: if one of the controls is not added to a window.
+
+        .. note::
+            You can also use `setNavigation()`. Set to self to disable
+            navigation.
+
+        Example::
+
+            ...
+            self.button.controlUp(self.button1)
+            ...
+        """
+        pass
+    
+    def controlDown(self, control: 'Control') -> None:
+        """
+        Sets the controls down navigation.
+
+        :param control: control object - control to navigate to on down.
+        :raises TypeError: if one of the supplied arguments is not a control type.
+        :raises ReferenceError: if one of the controls is not added to a window.
+
+        .. note::
+            You can also use `setNavigation()`. Set to self to disable
+            navigation.
+
+        Example::
+
+            ...
+            self.button.controlDown(self.button1)
+            ...
+        """
+        pass
+    
+    def controlLeft(self, control: 'Control') -> None:
+        """
+        Sets the controls left navigation.
+
+        :param control: control object - control to navigate to on left.
+        :raises TypeError: if one of the supplied arguments is not a control type.
+        :raises ReferenceError: if one of the controls is not added to a window.
+
+        .. note::
+            You can also use `setNavigation()`. Set to self to disable
+            navigation.
+
+        Example::
+
+            ...
+            self.button.controlLeft(self.button1)
+            ...
+        """
+        pass
+    
+    def controlRight(self, control: 'Control') -> None:
+        """
+        Sets the controls right navigation.
+
+        :param control: control object - control to navigate to on right.
+        :raises TypeError: if one of the supplied arguments is not a control type.
+        :raises ReferenceError: if one of the controls is not added to a window.
+
+        .. note::
+            You can also use `setNavigation()`. Set to self to disable
+            navigation.
+
+        Example::
+
+            ...
+            self.button.controlRight(self.button1)
+            ...
+        """
+        pass
+    
+
+class ControlSpin(Control):
+    """
+    **Used for cycling up/down controls.**
+
+    Offers classes and functions that manipulate the add-on gui controls.
+
+    **Code based skin access.**
+
+    The spin control is used for when a list of options can be chosen (such as a
+    page up/down control). You can choose the position, size, and look of the spin
+    control.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    **Not working yet**. You can't create this object, it is returned by objects
+    like `ControlTextBox` and `ControlList`.
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def setTextures(self, up: str,
+                    down: str,
+                    upFocus: str,
+                    downFocus: str,
+                    upDisabled: str,
+                    downDisabled: str) -> None:
+        """
+        Sets textures for this control.
+
+        Texture are image files that are used for example in the skin
+
+        **Not working yet**.
+
+        :param up: label - for the up arrow when it doesn't have focus.
+        :param down: label - for the down button when it is not focused.
+        :param upFocus: label - for the up button when it has focus.
+        :param downFocus: label - for the down button when it has focus.
+        :param upDisabled: label - for the up arrow when the button is disabled.
+        :param downDisabled: label - for the up arrow when the button is disabled.
+
+        Example::
+
+            ...
+            # setTextures(up, down, upFocus, downFocus, upDisabled, downDisabled)
+            
+            ...
+        """
+        pass
+    
+
+class ControlLabel(Control):
+    """
+    **Used to show some lines of text.**
+
+    The label control is used for displaying text in Kodi. You can choose the font,
+    size, colour, location and contents of the text to be displayed.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param label: string or unicode - text string.
+    :param font: [opt] string - font used for label text. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of enabled label's label. (e.g. '0xFFFFFFFF')
+    :param disabledColor: [opt] hexstring - color of disabled label's label. (e.g. '0xFFFF3300')
+    :param alignment: [opt] integer - alignment of label  Flags for alignment used as bits
+        to have several together:
+
+    ================ ========== ============== 
+    Defination name  Bitflag    Description    
+    ================ ========== ============== 
+    XBFONT_LEFT      0x00000000 Align X left   
+    XBFONT_RIGHT     0x00000001 Align X right  
+    XBFONT_CENTER_X  0x00000002 Align X center 
+    XBFONT_CENTER_Y  0x00000004 Align Y center 
+    XBFONT_TRUNCATED 0x00000008 Truncated text 
+    XBFONT_JUSTIFIED 0x00000010 Justify text   
+    ================ ========== ============== 
+
+    :param hasPath: [opt] bool - True=stores a path / False=no path
+    :param angle: [opt] integer - angle of control. (**+** rotates CCW, **-** rotates C)
+
+    Example::
+
+        ...
+        # ControlLabel(x, y, width, height, label[, font, textColor,
+        #              disabledColor, alignment, hasPath, angle])
+        self.label = xbmcgui.ControlLabel(100, 250, 125, 75, 'Status', angle=45)
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 label: str,
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 alignment: int = 0,
+                 hasPath: bool = False,
+                 angle: int = 0) -> None:
+        pass
+    
+    def getLabel(self) -> str:
+        """
+        Returns the text value for this label.
+
+        :return: This label
+
+        Example::
+
+            ...
+            label = self.label.getLabel()
+            ...
+        """
+        return ""
+    
+    def setLabel(self, label: str = "",
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 shadowColor: Optional[str] = None,
+                 focusedColor: Optional[str] = None,
+                 label2: str = "") -> None:
+        """
+        Sets text for this label.
+
+        :param label: string or unicode - text string.
+        :param font: [opt] string - font used for label text. (e.g. 'font13')
+        :param textColor: [opt] hexstring - color of enabled label's label. (e.g. '0xFFFFFFFF')
+        :param disabledColor: [opt] hexstring - color of disabled label's label. (e.g. '0xFFFF3300')
+        :param shadowColor: [opt] hexstring - color of button's label's shadow. (e.g.
+            '0xFF000000')
+        :param focusedColor: [opt] hexstring - color of focused button's label. (e.g. '0xFF00FFFF')
+        :param label2: [opt] string or unicode - text string.
+
+        Example::
+
+            ...
+            self.label.setLabel('Status')
+            ...
+        """
+        pass
+    
+
+class ControlEdit(Control):
+    """
+    **Used as an input control for the osd keyboard and other input fields.**
+
+    The edit control allows a user to input text in Kodi. You can choose the font,
+    size, colour, location and header of the text to be displayed.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param label: string or unicode - text string.
+    :param font: [opt] string - font used for label text. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of enabled label's label. (e.g. '0xFFFFFFFF')
+    :param disabledColor: [opt] hexstring - color of disabled label's label. (e.g. '0xFFFF3300')
+    :param alignment: [opt] integer - alignment of label  Flags for alignment used as bits
+        to have several together:
+
+    ================ ========== ============== 
+    Defination name  Bitflag    Description    
+    ================ ========== ============== 
+    XBFONT_LEFT      0x00000000 Align X left   
+    XBFONT_RIGHT     0x00000001 Align X right  
+    XBFONT_CENTER_X  0x00000002 Align X center 
+    XBFONT_CENTER_Y  0x00000004 Align Y center 
+    XBFONT_TRUNCATED 0x00000008 Truncated text 
+    XBFONT_JUSTIFIED 0x00000010 Justify text   
+    ================ ========== ============== 
+
+    :param focusTexture: [opt] string - filename for focus texture.
+    :param noFocusTexture: [opt] string - filename for no focus texture.
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    @python_v18 Deprecated **isPassword** @python_v19 Removed **isPassword**
+
+    Example::
+
+        ...
+        self.edit = xbmcgui.ControlEdit(100, 250, 125, 75, 'Status')
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 label: str,
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 _alignment: int = 0,
+                 focusTexture: Optional[str] = None,
+                 noFocusTexture: Optional[str] = None) -> None:
+        pass
+    
+    def setLabel(self, label: str = "",
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 shadowColor: Optional[str] = None,
+                 focusedColor: Optional[str] = None,
+                 label2: str = "") -> None:
+        """
+        Sets text heading for this edit control.
+
+        :param label: string or unicode - text string.
+        :param font: [opt] string - font used for label text. (e.g. 'font13')
+        :param textColor: [opt] hexstring - color of enabled label's label. (e.g. '0xFFFFFFFF')
+        :param disabledColor: [opt] hexstring - color of disabled label's label. (e.g. '0xFFFF3300')
+        :param shadowColor: [opt] hexstring - color of button's label's shadow. (e.g.
+            '0xFF000000')
+        :param focusedColor: [opt] hexstring - color of focused button's label. (e.g. '0xFF00FFFF')
+        :param label2: [opt] string or unicode - text string.
+
+        Example::
+
+            ...
+            self.edit.setLabel('Status')
+            ...
+        """
+        pass
+    
+    def getLabel(self) -> str:
+        """
+        Returns the text heading for this edit control.
+
+        :return: Heading text
+
+        Example::
+
+            ...
+            label = self.edit.getLabel()
+            ...
+        """
+        return ""
+    
+    def setText(self, text: str) -> None:
+        """
+        Sets text value for this edit control.
+
+        :param value: string or unicode - text string.
+
+        Example::
+
+            ...
+            self.edit.setText('online')
+            ...
+        """
+        pass
+    
+    def getText(self) -> str:
+        """
+        Returns the text value for this edit control.
+
+        :return: Text value of control
+
+        @python_v14 New function added.
+
+        Example::
+
+            ...
+            value = self.edit.getText()
+            ...
+        """
+        return ""
+    
+    def setType(self, type: int, heading: str) -> None:
+        """
+        Sets the type of this edit control.
+
+        :param type: integer - type of the edit control.
+
+        ============================================= =========================================== 
+        Param                                         Definition                                  
+        ============================================= =========================================== 
+        xbmcgui.INPUT_TYPE_TEXT                       (standard keyboard)                         
+        xbmcgui.INPUT_TYPE_NUMBER                     (format: #)                                 
+        xbmcgui.INPUT_TYPE_DATE                       (format: DD/MM/YYYY)                        
+        xbmcgui.INPUT_TYPE_TIME                       (format: HH:MM)                             
+        xbmcgui.INPUT_TYPE_IPADDRESS                  (format: #.#.#.#)                           
+        xbmcgui.INPUT_TYPE_PASSWORD                   (input is masked)                           
+        xbmcgui.INPUT_TYPE_PASSWORD_MD5               (input is masked, return md5 hash of input) 
+        xbmcgui.INPUT_TYPE_SECONDS                    (format: SS or MM:SS or HH:MM:SS or MM min) 
+        xbmcgui.INPUT_TYPE_PASSWORD_NUMBER_VERIFY_NEW (numeric input is masked)                   
+        ============================================= =========================================== 
+
+        :param heading: string or unicode - heading that will be used for to numeric or
+            keyboard dialog when the edit control is clicked.
+
+        @python_v18 New function added.
+
+        @python_v19 New option added to mask numeric input.
+
+        Example::
+
+            ...
+            self.edit.setType(xbmcgui.INPUT_TYPE_TIME, 'Please enter the time')
+            ...
+        """
+        pass
+    
+
+class ControlList(Control):
+    """
+    **Used for a scrolling lists of items. Replaces the list control.**
+
+    The list container is one of several containers used to display items from file
+    lists in various ways. The list container is very flexible - it's only
+    restriction is that it is a list - i.e. a single column or row of items. The
+    layout of the items is very flexible and is up to the skinner.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param font: [opt] string - font used for items label. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of items label. (e.g. '0xFFFFFFFF')
+    :param buttonTexture: [opt] string - filename for focus texture.
+    :param buttonFocusTexture: [opt] string - filename for no focus texture.
+    :param selectedColor: [opt] integer - x offset of label.
+    :param imageWidth: [opt] integer - width of items icon or thumbnail.
+    :param imageHeight: [opt] integer - height of items icon or thumbnail.
+    :param itemTextXOffset: [opt] integer - x offset of items label.
+    :param itemTextYOffset: [opt] integer - y offset of items label.
+    :param itemHeight: [opt] integer - height of items.
+    :param space: [opt] integer - space between items.
+    :param alignmentY: [opt] integer - Y-axis alignment of items label  Flags for alignment
+        used as bits to have several together:
+
+    ================ ========== ============== 
+    Defination name  Bitflag    Description    
+    ================ ========== ============== 
+    XBFONT_LEFT      0x00000000 Align X left   
+    XBFONT_RIGHT     0x00000001 Align X right  
+    XBFONT_CENTER_X  0x00000002 Align X center 
+    XBFONT_CENTER_Y  0x00000004 Align Y center 
+    XBFONT_TRUNCATED 0x00000008 Truncated text 
+    XBFONT_JUSTIFIED 0x00000010 Justify text   
+    ================ ========== ============== 
+
+    :param shadowColor: [opt] hexstring - color of items label's shadow. (e.g. '0xFF000000')
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    Example::
+
+        ...
+        self.cList = xbmcgui.ControlList(100, 250, 200, 250, 'font14', space=5)
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 buttonTexture: Optional[str] = None,
+                 buttonFocusTexture: Optional[str] = None,
+                 selectedColor: Optional[str] = None,
+                 _imageWidth: int = 10,
+                 _imageHeight: int = 10,
+                 _itemTextXOffset: int = 10,
+                 _itemTextYOffset: int = 2,
+                 _itemHeight: int = 27,
+                 _space: int = 2,
+                 _alignmentY: int = 4) -> None:
+        pass
+    
+    def addItem(self, item: Union[str,  'ListItem'],
+                sendMessage: bool = True) -> None:
+        """
+        Add a new item to this list control.
+
+        :param item: string, unicode or `ListItem` - item to add.
+
+        Example::
+
+            ...
+            cList.addItem('Reboot Kodi')
+            ...
+        """
+        pass
+    
+    def addItems(self, items: List[Union[str,  'ListItem']]) -> None:
+        """
+        Adds a list of listitems or strings to this list control.
+
+        :param items: `List` - list of strings, unicode objects or ListItems to add.
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        Large lists benefit considerably, than using the standard `addItem()`
+
+        Example::
+
+            ...
+            cList.addItems(items=listitems)
+            ...
+        """
+        pass
+    
+    def selectItem(self, item: int) -> None:
+        """
+        Select an item by index number.
+
+        :param item: integer - index number of the item to select.
+
+        Example::
+
+            ...
+            cList.selectItem(12)
+            ...
+        """
+        pass
+    
+    def removeItem(self, index: int) -> None:
+        """
+        Remove an item by index number.
+
+        :param index: integer - index number of the item to remove.
+
+        @python_v13 New function added.
+
+        Example::
+
+            ...
+            cList.removeItem(12)
+            ...
+        """
+        pass
+    
+    def reset(self) -> None:
+        """
+        Clear all ListItems in this control list.
+
+        Calling```reset()``` will destroy any```ListItem``` objects in
+        the```ControlList``` if not hold by any other class. Make sure you you don't
+        call```addItems()``` with the previous```ListItem``` references after
+        calling```reset()```. If you need to preserve the```ListItem``` objects
+        after```reset()``` make sure you store them as members of your```WindowXML```
+        class (see examples).
+
+        **Examples**::
+
+            ...
+            cList.reset()
+            ...
+
+        The below example shows you how you can reset the```ControlList``` but this time
+        avoiding```ListItem``` object destruction. The example assumes ``self`` as
+        a```WindowXMLDialog``` instance containing a```ControlList``` with id = 800. The
+        class preserves the```ListItem``` objects in a class member variable.
+
+        ::
+            ...
+            # Get all the ListItem objects in the control
+            self.list_control = self.getControl(800) # ControlList object
+            self.listitems = [self.list_control.getListItem(item) for item in range(0, self.list_control.size())]
+            # Reset the ControlList control
+            self.list_control.reset()
+            #
+            # do something with your ListItem objects here (e.g. sorting.)
+            # ...
+            #
+            # Add them again to the ControlList
+            self.list_control.addItems(self.listitems)
+            ...
+        """
+        pass
+    
+    def getSpinControl(self) -> Control:
+        """
+        Returns the associated `ControlSpin` object.
+
+        Not working completely yet  After adding this control list to a window it is not
+        possible to change the settings of this spin control.
+
+        Example::
+
+            ...
+            ctl = cList.getSpinControl()
+            ...
+        """
+        return Control()
+    
+    def getSelectedPosition(self) -> int:
+        """
+        Returns the position of the selected item as an integer.
+
+        .. note::
+            Returns -1 for empty lists.
+
+        Example::
+
+            ...
+            pos = cList.getSelectedPosition()
+            ...
+        """
+        return 0
+    
+    def getSelectedItem(self) -> 'ListItem':
+        """
+        Returns the selected item as a `ListItem` object.
+
+        :return: The selected item
+
+        .. note::
+            Same as `getSelectedPosition()`, but instead of an integer
+            a `ListItem` object is returned. Returns None for empty lists.  See
+            windowexample.py on how to use this.
+
+        Example::
+
+            ...
+            item = cList.getSelectedItem()
+            ...
+        """
+        return ListItem()
+    
+    def setImageDimensions(self, imageWidth: int, imageHeight: int) -> None:
+        """
+        Sets the width/height of items icon or thumbnail.
+
+        :param imageWidth: [opt] integer - width of items icon or thumbnail.
+        :param imageHeight: [opt] integer - height of items icon or thumbnail.
+
+        Example::
+
+            ...
+            cList.setImageDimensions(18, 18)
+            ...
+        """
+        pass
+    
+    def setSpace(self, space: int) -> None:
+        """
+        Sets the space between items.
+
+        :param space: [opt] integer - space between items.
+
+        Example::
+
+            ...
+            cList.setSpace(5)
+            ...
+        """
+        pass
+    
+    def setPageControlVisible(self, visible: bool) -> None:
+        """
+        Sets the spin control's visible/hidden state.
+
+        :param visible: boolean - True=visible / False=hidden.
+
+        Example::
+
+            ...
+            cList.setPageControlVisible(True)
+            ...
+        """
+        pass
+    
+    def size(self) -> int:
+        """
+        Returns the total number of items in this list control as an integer.
+
+        :return: Total number of items
+
+        Example::
+
+            ...
+            cnt = cList.size()
+            ...
+        """
+        return 0
+    
+    def getItemHeight(self) -> int:
+        """
+        Returns the control's current item height as an integer.
+
+        :return: Current item heigh
+
+        Example::
+
+            ..
+            item_height = self.cList.getItemHeight()
+            ...
+        """
+        return 0
+    
+    def getSpace(self) -> int:
+        """
+        Returns the control's space between items as an integer.
+
+        :return: Space between items
+
+        Example::
+
+            ...
+            gap = self.cList.getSpace()
+            ...
+        """
+        return 0
+    
+    def getListItem(self, index: int) -> 'ListItem':
+        """
+        Returns a given `ListItem` in this `List`.
+
+        :param index: integer - index number of item to return.
+        :return: `List` item
+
+        :raises ValueError: if index is out of range.
+
+        Example::
+
+            ...
+            listitem = cList.getListItem(6)
+            ...
+        """
+        return ListItem()
+    
+    def setStaticContent(self, items: List['ListItem']) -> None:
+        """
+        Fills a static list with a list of listitems.
+
+        :param items: `List` - list of listitems to add.
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        Example::
+
+            ...
+            cList.setStaticContent(items=listitems)
+            ...
+        """
+        pass
+    
+
+class ControlFadeLabel(Control):
+    """
+    **Used to show multiple pieces of text in the same position, by fading from one
+    to the other.**
+
+    The fade label control is used for displaying multiple pieces of text in the
+    same space in Kodi. You can choose the font, size, colour, location and contents
+    of the text to be displayed. The first piece of information to display fades in
+    over 50 frames, then scrolls off to the left. Once it is finished scrolling off
+    screen, the second piece of information fades in and the process repeats. A fade
+    label control is not supported in a list container.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param font: [opt] string - font used for label text. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of fadelabel's labels. (e.g. '0xFFFFFFFF')
+    :param alignment: [opt] integer - alignment of label  Flags for alignment used as bits
+        to have several together:
+
+    ================ ========== ============== 
+    Defination name  Bitflag    Description    
+    ================ ========== ============== 
+    XBFONT_LEFT      0x00000000 Align X left   
+    XBFONT_RIGHT     0x00000001 Align X right  
+    XBFONT_CENTER_X  0x00000002 Align X center 
+    XBFONT_CENTER_Y  0x00000004 Align Y center 
+    XBFONT_TRUNCATED 0x00000008 Truncated text 
+    XBFONT_JUSTIFIED 0x00000010 Justify text   
+    ================ ========== ============== 
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    Example::
+
+        ...
+        self.fadelabel = xbmcgui.ControlFadeLabel(100, 250, 200, 50, textColor='0xFFFFFFFF')
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 _alignment: int = 0) -> None:
+        pass
+    
+    def addLabel(self, label: str) -> None:
+        """
+        Add a label to this control for scrolling.
+
+        :param label: string or unicode - text string to add.
+
+        .. note::
+            To remove added text use```reset()``` for them.
+
+        Example::
+
+            ...
+            self.fadelabel.addLabel('This is a line of text that can scroll.')
+            ...
+        """
+        pass
+    
+    def setScrolling(self, scroll: bool) -> None:
+        """
+        Set scrolling. If set to false, the labels won't scroll. Defaults to true.
+
+        :param scroll: boolean - True = enabled / False = disabled
+
+        Example::
+
+            ...
+            self.fadelabel.setScrolling(False)
+            ...
+        """
+        pass
+    
+
+class ControlTextBox(Control):
+    """
+    **Used to show a multi-page piece of text.**
+
+    The text box is used for showing a large multipage piece of text in Kodi. You
+    can choose the position, size, and look of the text.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param font: [opt] string - font used for text. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of textbox's text. (e.g. '0xFFFFFFFF')
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    Example::
+
+        ...
+        # ControlTextBox(x, y, width, height[, font, textColor])
+        self.textbox = xbmcgui.ControlTextBox(100, 250, 300, 300, textColor='0xFFFFFFFF')
+        ...
+
+    As stated above, the GUI control is only created once added to a window. The
+    example below shows how a `ControlTextBox` can be created, added to the current
+    window and have some of its properties changed.
+
+    **Extended example**::
+
+        ...
+        textbox = xbmcgui.ControlTextBox(100, 250, 300, 300, textColor='0xFFFFFFFF')
+        window = xbmcgui.Window(xbmcgui.getCurrentWindowId())
+        window.addControl(textbox)
+        textbox.setText("My Text Box")
+        textbox.scroll()
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None) -> None:
+        pass
+    
+    def setText(self, text: str) -> None:
+        """
+        Sets the text for this textbox.
+
+        :param text: string - text string.
+
+        @python_v19 setText can now be used before adding the control to the window (the
+        defined value is taken into consideration when the control is created)
+
+        Example::
+
+            ...
+            # setText(text)
+            self.textbox.setText('This is a line of text that can wrap.')
+            ...
+        """
+        pass
+    
+    def getText(self) -> str:
+        """
+        Returns the text value for this textbox.
+
+        :return: To get text from box
+
+        @python_v19 `getText()` can now be used before adding the control to the window
+
+        Example::
+
+            ...
+            # getText()
+            text = self.text.getText()
+            ...
+        """
+        return ""
+    
+    def reset(self) -> None:
+        """
+        Clear's this textbox.
+
+        @python_v19 `reset()` will reset any text defined for this control even before
+        you add the control to the window
+
+        Example::
+
+            ...
+            # reset()
+            self.textbox.reset()
+            ...
+        """
+        pass
+    
+    def scroll(self, id: int) -> None:
+        """
+        Scrolls to the given position.
+
+        :param id: integer - position to scroll to.
+
+        .. note::
+            `scroll()` only works after the control is added to a window.
+
+        Example::
+
+            ...
+            # scroll(position)
+            self.textbox.scroll(10)
+            ...
+        """
+        pass
+    
+    def autoScroll(self, delay: int, time: int, repeat: int) -> None:
+        """
+        Set autoscrolling times.
+
+        :param delay: integer - Scroll delay (in ms)
+        :param time: integer - Scroll time (in ms)
+        :param repeat: integer - Repeat time
+
+        .. note::
+            autoScroll only works after you add the control to a window.
+
+        @python_v15 New function added.
+
+        Example::
+
+            ...
+            self.textbox.autoScroll(1, 2, 1)
+            ...
+        """
+        pass
+    
+
+class ControlImage(Control):
+    """
+    **Used to show an image.**
+
+    The image control is used for displaying images in Kodi. You can choose the
+    position, size, transparency and contents of the image to be displayed.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param filename: string - image filename.
+    :param aspectRatio: [opt] integer - (values 0 = stretch (default), 1 = scale up (crops), 2
+        = scale down (black bar)
+    :param colorDiffuse: hexString - (example, '0xC0FF0000' (red tint))
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    Example::
+
+        ...
+        # ControlImage(x, y, width, height, filename[, aspectRatio, colorDiffuse])
+        self.image = xbmcgui.ControlImage(100, 250, 125, 75, aspectRatio=2)
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 filename: str,
+                 aspectRatio: int = 0,
+                 colorDiffuse: Optional[str] = None) -> None:
+        pass
+    
+    def setImage(self, imageFilename: str, useCache: bool = True) -> None:
+        """
+        Changes the image.
+
+        :param filename: string - image filename.
+        :param useCache: [opt] bool - True=use cache (default) / False=don't use cache.
+
+        @python_v13 Added new option **useCache**.
+
+        Example::
+
+            ...
+            # setImage(filename[, useCache])
+            self.image.setImage('special://home/scripts/test.png')
+            self.image.setImage('special://home/scripts/test.png', False)
+            ...
+        """
+        pass
+    
+    def setColorDiffuse(self, hexString: str) -> None:
+        """
+        Changes the images color.
+
+        :param colorDiffuse: hexString - (example, '0xC0FF0000' (red tint))
+
+        Example::
+
+            ...
+            # setColorDiffuse(colorDiffuse)
+            self.image.setColorDiffuse('0xC0FF0000')
+            ...
+        """
+        pass
+    
+
+class ControlProgress(Control):
+    """
+    **Used to show the progress of a particular operation.**
+
+    The progress control is used to show the progress of an item that may take a
+    long time, or to show how far through a movie you are. You can choose the
+    position, size, and look of the progress control.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param filename: string - image filename.
+    :param texturebg: [opt] string - specifies the image file whichshould be displayed in
+        the background of the progress control.
+    :param textureleft: [opt] string - specifies the image file whichshould be displayed for
+        the left side of the progress bar. This is rendered on the left
+        side of the bar.
+    :param texturemid: [opt] string - specifies the image file which should be displayed for
+        the middl portion of the progress bar. This is the ``fill`` texture
+        used to fill up the bar. It's positioned on the right of
+        the``<lefttexture>`` texture, and fills the gap between
+        the``<lefttexture>`` and``<righttexture>`` textures, depending on
+        how far progressed the item is.
+    :param textureright: [opt] string - specifies the image file which should be displayed for
+        the right side of the progress bar. This is rendered on the right
+        side of the bar.
+    :param textureoverlay: [opt] string - specifies the image file which should be displayed over
+        the top of all other images in the progress bar. It is centered
+        vertically and horizontally within the space taken up by the
+        background image.
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    Example::
+
+        ...
+        # ControlProgress(x, y, width, height, filename[, texturebg, textureleft, texturemid, textureright, textureoverlay])
+        self.image = xbmcgui.ControlProgress(100, 250, 250, 30, 'special://home/scripts/test.png')
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 texturebg: Optional[str] = None,
+                 textureleft: Optional[str] = None,
+                 texturemid: Optional[str] = None,
+                 textureright: Optional[str] = None,
+                 textureoverlay: Optional[str] = None) -> None:
+        pass
+    
+    def setPercent(self, pct: float) -> None:
+        """
+        Sets the percentage of the progressbar to show.
+
+        :param percent: float - percentage of the bar to show.
+
+        .. note::
+            valid range for percent is 0-100
+
+        Example::
+
+            ...
+            # setPercent(percent)
+            self.progress.setPercent(60)
+            ...
+        """
+        pass
+    
+    def getPercent(self) -> float:
+        """
+        Returns a float of the percent of the progress.
+
+        :return: Percent position
+
+        Example::
+
+            ...
+            # getPercent()
+            print(self.progress.getPercent())
+            ...
+        """
+        return 0.0
+    
+
+class ControlButton(Control):
+    """
+    **A standard push button control.**
+
+    The button control is used for creating push buttons in Kodi. You can choose the
+    position, size, and look of the button, as well as choosing what action(s)
+    should be performed when pushed.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param label: string or unicode - text string.
+    :param focusTexture: [opt] string - filename for focus texture.
+    :param noFocusTexture: [opt] string - filename for no focus texture.
+    :param textOffsetX: [opt] integer - x offset of label.
+    :param textOffsetY: [opt] integer - y offset of label.
+    :param alignment: [opt] integer - alignment of label  Flags for alignment used as bits
+        to have several together:
+
+    ================ ========== ============== 
+    Defination name  Bitflag    Description    
+    ================ ========== ============== 
+    XBFONT_LEFT      0x00000000 Align X left   
+    XBFONT_RIGHT     0x00000001 Align X right  
+    XBFONT_CENTER_X  0x00000002 Align X center 
+    XBFONT_CENTER_Y  0x00000004 Align Y center 
+    XBFONT_TRUNCATED 0x00000008 Truncated text 
+    XBFONT_JUSTIFIED 0x00000010 Justify text   
+    ================ ========== ============== 
+
+    :param font: [opt] string - font used for label text. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of enabled button's label. (e.g. '0xFFFFFFFF')
+    :param disabledColor: [opt] hexstring - color of disabled button's label. (e.g.
+        '0xFFFF3300')
+    :param angle: [opt] integer - angle of control. (+ rotates CCW, - rotates CW)
+    :param shadowColor: [opt] hexstring - color of button's label's shadow. (e.g.
+        '0xFF000000')
+    :param focusedColor: [opt] hexstring - color of focused button's label. (e.g. '0xFF00FFFF')
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    Example::
+
+        ...
+        # ControlButton(x, y, width, height, label[, focusTexture, noFocusTexture, textOffsetX, textOffsetY,
+        #               alignment, font, textColor, disabledColor, angle, shadowColor, focusedColor])
+        self.button = xbmcgui.ControlButton(100, 250, 200, 50, 'Status', font='font14')
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 label: str,
+                 focusTexture: Optional[str] = None,
+                 noFocusTexture: Optional[str] = None,
+                 textOffsetX: int = 10,
+                 textOffsetY: int = 2,
+                 alignment: int = (0|4),
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 angle: int = 0,
+                 shadowColor: Optional[str] = None,
+                 focusedColor: Optional[str] = None) -> None:
+        pass
+    
+    def setLabel(self, label: str = "",
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 shadowColor: Optional[str] = None,
+                 focusedColor: Optional[str] = None,
+                 label2: str = "") -> None:
+        """
+        Sets this buttons text attributes.
+
+        :param label: [opt] string or unicode - text string.
+        :param font: [opt] string - font used for label text. (e.g. 'font13')
+        :param textColor: [opt] hexstring - color of enabled button's label. (e.g. '0xFFFFFFFF')
+        :param disabledColor: [opt] hexstring - color of disabled button's label. (e.g.
+            '0xFFFF3300')
+        :param shadowColor: [opt] hexstring - color of button's label's shadow. (e.g.
+            '0xFF000000')
+        :param focusedColor: [opt] hexstring - color of focused button's label. (e.g. '0xFFFFFF00')
+        :param label2: [opt] string or unicode - text string.
+
+        .. note::
+            You can use the above as keywords for arguments and skip certain
+            optional arguments.  Once you use a keyword, all following
+            arguments require the keyword.
+
+        Example::
+
+            ...
+            # setLabel([label, font, textColor, disabledColor, shadowColor, focusedColor])
+            self.button.setLabel('Status', 'font14', '0xFFFFFFFF', '0xFFFF3300', '0xFF000000')
+            ...
+        """
+        pass
+    
+    def setDisabledColor(self, color: str) -> None:
+        """
+        Sets this buttons disabled color.
+
+        :param disabledColor: hexstring - color of disabled button's label. (e.g. '0xFFFF3300')
+
+        Example::
+
+            ...
+            # setDisabledColor(disabledColor)
+            self.button.setDisabledColor('0xFFFF3300')
+            ...
+        """
+        pass
+    
+    def getLabel(self) -> str:
+        """
+        Returns the buttons label as a unicode string.
+
+        :return: Unicode string
+
+        Example::
+
+            ...
+            # getLabel()
+            label = self.button.getLabel()
+            ...
+        """
+        return ""
+    
+    def getLabel2(self) -> str:
+        """
+        Returns the buttons label2 as a string.
+
+        :return: string of label 2
+
+        Example::
+
+            ...
+            # getLabel2()
+            label = self.button.getLabel2()
+            ...
+        """
+        return ""
+    
+
+class ControlGroup(Control):
+    """
+    **Used to group controls together.**
+
+    The group control is one of the most important controls. It allows you to group
+    controls together, applying attributes to all of them at once. It also remembers
+    the last navigated button in the group, so you can set the ``<onup>`` of a
+    control to a group of controls to have it always go back to the one you were at
+    before. It also allows you to position controls more accurately relative to each
+    other, as any controls within a group take their coordinates from the group's
+    top left corner (or from elsewhere if you use the ``r`` attribute). You can
+    have as many groups as you like within the skin, and groups within groups are
+    handled with no issues.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+
+    Example::
+
+        ...
+        self.group = xbmcgui.ControlGroup(100, 250, 125, 75)
+        ...
+    """
+    
+    def __init__(self, x: int, y: int, width: int, height: int) -> None:
+        pass
+    
+
+class ControlRadioButton(Control):
+    """
+    **A radio button control (as used for on/off settings).**
+
+    The radio button control is used for creating push button on/off settings in
+    Kodi. You can choose the position, size, and look of the button, as well as the
+    focused and unfocused radio textures. Used for settings controls.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control.
+    :param y: integer - y coordinate of control.
+    :param width: integer - width of control.
+    :param height: integer - height of control.
+    :param label: string or unicode - text string.
+    :param focusOnTexture: [opt] string - filename for radio ON focused texture.
+    :param noFocusOnTexture: [opt] string - filename for radio ON not focused texture.
+    :param focusOfTexture: [opt] string - filename for radio OFF focused texture.
+    :param noFocusOffTexture: [opt] string - filename for radio OFF not focused texture.
+    :param focusTexture: [opt] string - filename for focused button texture.
+    :param noFocusTexture: [opt] string - filename for not focused button texture.
+    :param textOffsetX: [opt] integer - horizontal text offset
+    :param textOffsetY: [opt] integer - vertical text offset
+    :param alignment: [opt] integer - alignment of label  Flags for alignment used as bits
+        to have several together:
+
+    ================ ========== ============== 
+    Defination name  Bitflag    Description    
+    ================ ========== ============== 
+    XBFONT_LEFT      0x00000000 Align X left   
+    XBFONT_RIGHT     0x00000001 Align X right  
+    XBFONT_CENTER_X  0x00000002 Align X center 
+    XBFONT_CENTER_Y  0x00000004 Align Y center 
+    XBFONT_TRUNCATED 0x00000008 Truncated text 
+    XBFONT_JUSTIFIED 0x00000010 Justify text   
+    ================ ========== ============== 
+
+    :param font: [opt] string - font used for label text. (e.g. 'font13')
+    :param textColor: [opt] hexstring - color of label when control is enabled.
+        radiobutton's label. (e.g. '0xFFFFFFFF')
+    :param disabledColor: [opt] hexstring - color of label when control is disabled. (e.g.
+        '0xFFFF3300')
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    @python_v13 New function added.
+
+    Example::
+
+        ...
+        self.radiobutton = xbmcgui.ControlRadioButton(100, 250, 200, 50, 'Enable', font='font14')
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 label: str,
+                 focusOnTexture: Optional[str] = None,
+                 noFocusOnTexture: Optional[str] = None,
+                 focusOffTexture: Optional[str] = None,
+                 noFocusOffTexture: Optional[str] = None,
+                 focusTexture: Optional[str] = None,
+                 noFocusTexture: Optional[str] = None,
+                 textOffsetX: int = 10,
+                 textOffsetY: int = 2,
+                 _alignment: int = (0|4),
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 angle: int = 0,
+                 shadowColor: Optional[str] = None,
+                 focusedColor: Optional[str] = None,
+                 disabledOnTexture: Optional[str] = None,
+                 disabledOffTexture: Optional[str] = None) -> None:
+        pass
+    
+    def setSelected(self, selected: bool) -> None:
+        """
+        **Sets the radio buttons's selected status.**
+
+        :param selected: bool - True=selected (on) / False=not selected (off)
+
+        .. note::
+            You can use the above as keywords for arguments and skip certain
+            optional arguments.  Once you use a keyword, all following
+            arguments require the keyword.
+
+        Example::
+
+            ...
+            self.radiobutton.setSelected(True)
+            ...
+        """
+        pass
+    
+    def isSelected(self) -> bool:
+        """
+        Returns the radio buttons's selected status.
+
+        :return: True if selected on
+
+        Example::
+
+            ...
+            is = self.radiobutton.isSelected()
+            ...
+        """
+        return True
+    
+    def setLabel(self, label: str = "",
+                 font: Optional[str] = None,
+                 textColor: Optional[str] = None,
+                 disabledColor: Optional[str] = None,
+                 shadowColor: Optional[str] = None,
+                 focusedColor: Optional[str] = None,
+                 label2: str = "") -> None:
+        """
+        Sets the radio buttons text attributes.
+
+        :param label: string or unicode - text string.
+        :param font: [opt] string - font used for label text. (e.g. 'font13')
+        :param textColor: [opt] hexstring - color of enabled radio button's label. (e.g.
+            '0xFFFFFFFF')
+        :param disabledColor: [opt] hexstring - color of disabled radio button's label. (e.g.
+            '0xFFFF3300')
+        :param shadowColor: [opt] hexstring - color of radio button's label's shadow. (e.g.
+            '0xFF000000')
+        :param focusedColor: [opt] hexstring - color of focused radio button's label. (e.g.
+            '0xFFFFFF00')
+
+        .. note::
+            You can use the above as keywords for arguments and skip certain
+            optional arguments.  Once you use a keyword, all following
+            arguments require the keyword.
+
+        Example::
+
+            ...
+            # setLabel(label[, font, textColor, disabledColor, shadowColor, focusedColor])
+            self.radiobutton.setLabel('Status', 'font14', '0xFFFFFFFF', '0xFFFF3300', '0xFF000000')
+            ...
+        """
+        pass
+    
+    def setRadioDimension(self, x: int,
+                          y: int,
+                          width: int,
+                          height: int) -> None:
+        """
+        Sets the radio buttons's radio texture's position and size.
+
+        :param x: integer - x coordinate of radio texture.
+        :param y: integer - y coordinate of radio texture.
+        :param width: integer - width of radio texture.
+        :param height: integer - height of radio texture.
+
+        .. note::
+            You can use the above as keywords for arguments and skip certain
+            optional arguments.  Once you use a keyword, all following
+            arguments require the keyword.
+
+        Example::
+
+            ...
+            self.radiobutton.setRadioDimension(x=100, y=5, width=20, height=20)
+            ...
+        """
+        pass
+    
+
+class ControlSlider(Control):
+    """
+    **Used for a volume slider.**
+
+    The slider control is used for things where a sliding bar best represents the
+    operation at hand (such as a volume control or seek control). You can choose the
+    position, size, and look of the slider control.
+
+    .. note::
+        This class include also all calls from `Control`
+
+    :param x: integer - x coordinate of control
+    :param y: integer - y coordinate of control
+    :param width: integer - width of control
+    :param height: integer - height of control
+    :param textureback: [opt] string - image filename
+    :param texture: [opt] string - image filename
+    :param texturefocus: [opt] string - image filename
+    :param orientation: [opt] integer - orientation of slider (xbmcgui.HORIZONTAL /
+        xbmcgui.VERTICAL (default))
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments.  Once you use a keyword, all following
+        arguments require the keyword.  After you create the control, you
+        need to add it to the window with addControl().
+
+    @python_v17 **orientation** option added.
+
+    Example::
+
+        ...
+        self.slider = xbmcgui.ControlSlider(100, 250, 350, 40)
+        ...
+    """
+    
+    def __init__(self, x: int,
+                 y: int,
+                 width: int,
+                 height: int,
+                 textureback: Optional[str] = None,
+                 texture: Optional[str] = None,
+                 texturefocus: Optional[str] = None,
+                 orientation: int = 1) -> None:
+        pass
+    
+    def getPercent(self) -> float:
+        """
+        Returns a float of the percent of the slider.
+
+        :return: float - Percent of slider
+
+        Example::
+
+            ...
+            print(self.slider.getPercent())
+            ...
+        """
+        return 0.0
+    
+    def setPercent(self, pct: float) -> None:
+        """
+        Sets the percent of the slider.
+
+        :param pct: float - Percent value of slider
+
+        Example::
+
+            ...
+            self.slider.setPercent(50)
+            ...
+        """
+        pass
+    
+    def getInt(self) -> int:
+        """
+        Returns the value of the slider.
+
+        :return: int - value of slider
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            print(self.slider.getInt())
+            ...
+        """
+        return 0
+    
+    def setInt(self, value: int, min: int, delta: int, max: int) -> None:
+        """
+        Sets the range, value and step size of the slider.
+
+        :param value: int - value of slider
+        :param min: int - min of slider
+        :param delta: int - step size of slider
+        :param max: int - max of slider
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            self.slider.setInt(450, 200, 10, 900)
+            ...
+        """
+        pass
+    
+    def getFloat(self) -> float:
+        """
+        Returns the value of the slider.
+
+        :return: float - value of slider
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            print(self.slider.getFloat())
+            ...
+        """
+        return 0.0
+    
+    def setFloat(self, value: float,
+                 min: float,
+                 delta: float,
+                 max: float) -> None:
+        """
+        Sets the range, value and step size of the slider.
+
+        :param value: float - value of slider
+        :param min: float - min of slider
+        :param delta: float - step size of slider
+        :param max: float - max of slider
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            self.slider.setFloat(15.0, 10.0, 1.0, 20.0)
+            ...
+        """
+        pass
+    
+
+class Dialog:
+    """
+    **Kodi's dialog class**
+
+    The graphical control element dialog box (also called dialogue box or just
+    dialog) is a small window that communicates information to the user and prompts
+    them for a response.
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def yesno(self, heading: str,
+              message: str,
+              nolabel: str = "",
+              yeslabel: str = "",
+              autoclose: int = 0,
+              defaultbutton: int = DLG_YESNO_NO_BTN) -> bool:
+        """
+        **Yes / no dialog**
+
+        The Yes / No dialog can be used to inform the user about questions and get the
+        answer.
+
+        :param heading: string or unicode - dialog heading.
+        :param message: string or unicode - message text.
+        :param nolabel: [opt] label to put on the no button.
+        :param yeslabel: [opt] label to put on the yes button.
+        :param autoclose: [opt] integer - milliseconds to autoclose dialog. (default=do not
+            autoclose)
+        :param defaultbutton: [opt] integer - specifies the default focused
+            button.(default=DLG_YESNO_NO_BTN)
+
+        ============================ =================================== 
+        Value:                       Description:                        
+        ============================ =================================== 
+        xbmcgui.DLG_YESNO_NO_BTN     Set the "No" button as default.     
+        xbmcgui.DLG_YESNO_YES_BTN    Set the "Yes" button as default.    
+        xbmcgui.DLG_YESNO_CUSTOM_BTN Set the "Custom" button as default. 
+        ============================ =================================== 
+
+        :return: Returns True if 'Yes' was pressed, else False.
+
+        @python_v13 Added new option **autoclose**.
+
+        @python_v19 Renamed option **line1** to **message**.
+
+        @python_v19 Removed option **line2**.
+
+        @python_v19 Removed option **line3**.
+
+        @python_v20 Added new option **defaultbutton**.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ret = dialog.yesno('Kodi', 'Do you want to exit this script?')
+            ..
+        """
+        return True
+    
+    def yesnocustom(self, heading: str,
+                    message: str,
+                    customlabel: str,
+                    nolabel: str = "",
+                    yeslabel: str = "",
+                    autoclose: int = 0,
+                    defaultbutton: int = DLG_YESNO_NO_BTN) -> int:
+        """
+        **Yes / no / custom dialog**
+
+        The YesNoCustom dialog can be used to inform the user about questions and get
+        the answer. The dialog provides a third button appart from yes and no. Button
+        labels are fully customizable.
+
+        :param heading: string or unicode - dialog heading.
+        :param message: string or unicode - message text.
+        :param customlabel: string or unicode - label to put on the custom button.
+        :param nolabel: [opt] label to put on the no button.
+        :param yeslabel: [opt] label to put on the yes button.
+        :param autoclose: [opt] integer - milliseconds to autoclose dialog. (default=do not
+            autoclose)
+        :param defaultbutton: [opt] integer - specifies the default focused
+            button.(default=DLG_YESNO_NO_BTN)
+
+        ============================ =================================== 
+        Value:                       Description:                        
+        ============================ =================================== 
+        xbmcgui.DLG_YESNO_NO_BTN     Set the "No" button as default.     
+        xbmcgui.DLG_YESNO_YES_BTN    Set the "Yes" button as default.    
+        xbmcgui.DLG_YESNO_CUSTOM_BTN Set the "Custom" button as default. 
+        ============================ =================================== 
+
+        :return: Returns the integer value for the selected button (-1:cancelled, 0:no, 1:yes, 2:custom)
+
+        @python_v19 New function added.
+
+        @python_v20 Added new option **defaultbutton**.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ret = dialog.yesnocustom('Kodi', 'Question?', 'Maybe')
+            ..
+        """
+        return 0
+    
+    def info(self, item: 'ListItem') -> bool:
+        """
+        **Info dialog**
+
+        Show the corresponding info dialog for a given listitem
+
+        :param listitem: `xbmcgui.ListItem` -`ListItem` to show info for.
+        :return: Returns whether the dialog opened successfully.
+
+        @python_v17 New function added.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ret = dialog.info(listitem)
+            ..
+        """
+        return True
+    
+    def select(self, heading: str,
+               list: List[Union[str,  'ListItem']],
+               autoclose: int = 0,
+               preselect: int = -1,
+               useDetails: bool = False) -> int:
+        """
+        **Select dialog**
+
+        Show of a dialog to select of an entry as a key
+
+        :param heading: string or unicode - dialog heading.
+        :param list: list of strings / xbmcgui.ListItems - list of items shown in dialog.
+        :param autoclose: [opt] integer - milliseconds to autoclose dialog. (default=do not
+            autoclose)
+        :param preselect: [opt] integer - index of preselected item. (default=no preselected
+            item)
+        :param useDetails: [opt] bool - use detailed list instead of a compact list.
+            (default=false)
+        :return: Returns the position of the highlighted item as an integer.
+
+        @python_v17 **preselect** option added.
+
+        @python_v17 Added new option **useDetails**.
+
+        @python_v17 Allow listitems for parameter **list**
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ret = dialog.select('Choose a playlist', ['Playlist #1', 'Playlist #2, 'Playlist #3'])
+            ..
+        """
+        return 0
+    
+    def contextmenu(self, list: List[str]) -> int:
+        """
+        Show a context menu.
+
+        :param list: string list - list of items.
+        :return: the position of the highlighted item as an integer (-1 if cancelled).
+
+        @python_v17 New function addedExample::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ret = dialog.contextmenu(['Option #1', 'Option #2', 'Option #3'])
+            ..
+        """
+        return 0
+    
+    def multiselect(self, heading: str,
+                    options: List[Union[str,  'ListItem']],
+                    autoclose: int = 0,
+                    preselect: Optional[List[int]] = None,
+                    useDetails: bool = False) -> List[int]:
+        """
+        Show a multi-select dialog.
+
+        :param heading: string or unicode - dialog heading.
+        :param options: list of strings / xbmcgui.ListItems - options to choose from.
+        :param autoclose: [opt] integer - milliseconds to autoclose dialog. (default=do not
+            autoclose)
+        :param preselect: [opt] list of int - indexes of items to preselect in list (default: do
+            not preselect any item)
+        :param useDetails: [opt] bool - use detailed list instead of a compact list.
+            (default=false)
+        :return: Returns the selected items as a list of indices, or None if cancelled.
+
+        @python_v16 New function added.
+
+        @python_v17 Added new option **preselect**.
+
+        @python_v17 Added new option **useDetails**.
+
+        @python_v17 Allow listitems for parameter **options**
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ret = dialog.multiselect("Choose something", ["Foo", "Bar", "Baz"], preselect=[1,2])
+            ..
+        """
+        return [0]
+    
+    def ok(self, heading: str, message: str) -> bool:
+        """
+        **OK dialog**
+
+        The functions permit the call of a dialog of information, a confirmation of the
+        user by press from OK required.
+
+        :param heading: string or unicode - dialog heading.
+        :param message: string or unicode - message text.
+        :return: Returns True if 'Ok' was pressed, else False.
+
+        @python_v19 Renamed option **line1** to **message**.
+
+        @python_v19 Removed option **line2**.
+
+        @python_v19 Removed option **line3**.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            ok = dialog.ok('Kodi', 'There was an error.')
+            ..
+        """
+        return True
+    
+    def textviewer(self, heading: str,
+                   text: str,
+                   usemono: bool = False) -> None:
+        """
+        **TextViewer dialog**
+
+        The text viewer dialog can be used to display descriptions, help texts or other
+        larger texts.
+
+        :param heading: string or unicode - dialog heading.
+        :param text: string or unicode - text.
+        :param usemono: [opt] bool - use monospace font
+
+        @python_v16 New function added.
+
+        @python_v18 New optional param added **usemono**.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            dialog.textviewer('Plot', 'Some movie plot.')
+            ..
+        """
+        pass
+    
+    def browse(self, type: int,
+               heading: str,
+               shares: str,
+               mask: str = "",
+               useThumbs: bool = False,
+               treatAsFolder: bool = False,
+               defaultt: str = "",
+               enableMultiple: bool = False) -> Union[str,  List[str]]:
+        """
+        **Browser dialog**
+
+        The function offer the possibility to select a file by the user of the add-on.
+
+        It allows all the options that are possible in Kodi itself and offers all
+        support file types.
+
+        :param type: integer - the type of browse dialog.
+
+        ===== ============================ 
+        Param Name                         
+        ===== ============================ 
+        0     ShowAndGetDirectory          
+        1     ShowAndGetFile               
+        2     ShowAndGetImage              
+        3     ShowAndGetWriteableDirectory 
+        ===== ============================ 
+
+        :param heading: string or unicode - dialog heading.
+        :param shares: string or unicode - fromsources.xml
+
+        ========== ============================================= 
+        Param      Name                                          
+        ========== ============================================= 
+        "programs" list program addons                           
+        "video"    list video sources                            
+        "music"    list music sources                            
+        "pictures" list picture sources                          
+        "files"    list file sources (added through filemanager) 
+        "games"    list game sources                             
+        "local"    list local drives                             
+        ""         list local drives and network shares          
+        ========== ============================================= 
+
+        :param mask: [opt] string or unicode - '|' separated file mask. (i.e. '.jpg|.png')
+        :param useThumbs: [opt] boolean - if True autoswitch to Thumb view if files exist.
+        :param treatAsFolder: [opt] boolean - if True playlists and archives act as folders.
+        :param defaultt: [opt] string - default path or file.
+        :param enableMultiple: [opt] boolean - if True multiple file selection is enabled.
+        :return: If enableMultiple is False (default): returns filename and/or path as a string
+            to the location of the highlighted item, if user pressed 'Ok' or a masked item
+            was selected. Returns the default value if dialog was canceled.
+            If enableMultiple is True: returns tuple of marked filenames as a string if user
+            pressed 'Ok' or a masked item was selected. Returns empty tuple if dialog was canceled.
+
+         If type is 0 or 3 the enableMultiple parameter is ignore
+
+        @python_v18 New option added to browse network and/or local drives.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            fn = dialog.browse(3, 'Kodi', 'files', '', False, False, False, 'special://masterprofile/script_data/Kodi Lyrics')
+            ..
+        """
+        return ""
+    
+    def browseSingle(self, type: int,
+                     heading: str,
+                     shares: str,
+                     mask: str = "",
+                     useThumbs: bool = False,
+                     treatAsFolder: bool = False,
+                     defaultt: str = "") -> str:
+        """
+        **Browse single dialog**
+
+        The function offer the possibility to select a file by the user of the add-on.
+
+        It allows all the options that are possible in Kodi itself and offers all
+        support file types.
+
+        :param type: integer - the type of browse dialog.
+
+        ===== ============================ 
+        Param Name                         
+        ===== ============================ 
+        0     ShowAndGetDirectory          
+        1     ShowAndGetFile               
+        2     ShowAndGetImage              
+        3     ShowAndGetWriteableDirectory 
+        ===== ============================ 
+
+        :param heading: string or unicode - dialog heading.
+        :param shares: string or unicode - fromsources.xml
+
+        ========== ============================================= 
+        Param      Name                                          
+        ========== ============================================= 
+        "programs" list program addons                           
+        "video"    list video sources                            
+        "music"    list music sources                            
+        "pictures" list picture sources                          
+        "files"    list file sources (added through filemanager) 
+        "games"    list game sources                             
+        "local"    list local drives                             
+        ""         list local drives and network shares          
+        ========== ============================================= 
+
+        :param mask: [opt] string or unicode - '|' separated file mask. (i.e. '.jpg|.png')
+        :param useThumbs: [opt] boolean - if True autoswitch to Thumb view if files exist
+            (default=false).
+        :param treatAsFolder: [opt] boolean - if True playlists and archives act as folders
+            (default=false).
+        :param defaultt: [opt] string - default path or file.
+        :return: Returns filename and/or path as a string to the location of the highlighted item,
+            if user pressed 'Ok' or a masked item was selected.
+            Returns the default value if dialog was canceled.
+
+        @python_v18 New option added to browse network and/or local drives.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            fn = dialog.browseSingle(3, 'Kodi', 'files', '', False, False, 'special://masterprofile/script_data/Kodi Lyrics')
+            ..
+        """
+        return ""
+    
+    def browseMultiple(self, type: int,
+                       heading: str,
+                       shares: str,
+                       mask: str = "",
+                       useThumbs: bool = False,
+                       treatAsFolder: bool = False,
+                       defaultt: str = "") -> List[str]:
+        """
+        **Browser dialog**
+
+        The function offer the possibility to select multiple files by the user of the
+        add-on.
+
+        It allows all the options that are possible in Kodi itself and offers all
+        support file types.
+
+        :param type: integer - the type of browse dialog.
+
+        ===== =============== 
+        Param Name            
+        ===== =============== 
+        1     ShowAndGetFile  
+        2     ShowAndGetImage 
+        ===== =============== 
+
+        :param heading: string or unicode - dialog heading.
+        :param shares: string or unicode - from sources.xml
+
+        ========== ============================================= 
+        Param      Name                                          
+        ========== ============================================= 
+        "programs" list program addons                           
+        "video"    list video sources                            
+        "music"    list music sources                            
+        "pictures" list picture sources                          
+        "files"    list file sources (added through filemanager) 
+        "games"    list game sources                             
+        "local"    list local drives                             
+        ""         list local drives and network shares          
+        ========== ============================================= 
+
+        :param mask: [opt] string or unicode - '|' separated file mask. (i.e. '.jpg|.png')
+        :param useThumbs: [opt] boolean - if True autoswitch to Thumb view if files exist
+            (default=false).
+        :param treatAsFolder: [opt] boolean - if True playlists and archives act as folders
+            (default=false).
+        :param defaultt: [opt] string - default path or file.
+        :return: Returns tuple of marked filenames as a string," if user pressed 'Ok' or
+            a masked item was selected. Returns empty tuple if dialog was canceled.
+
+        @python_v18 New option added to browse network and/or local drives.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            fn = dialog.browseMultiple(2, 'Kodi', 'files', '', False, False, 'special://masterprofile/script_data/Kodi Lyrics')
+            ..
+        """
+        return [""]
+    
+    def numeric(self, type: int,
+                heading: str,
+                defaultt: str = "",
+                bHiddenInput: bool = False) -> str:
+        """
+        **Numeric dialog**
+
+        The function have to be permitted by the user for the representation of a
+        numeric keyboard around an input.
+
+        :param type: integer - the type of numeric dialog.
+
+        ===== ======================== ============================ 
+        Param Name                     Format                       
+        ===== ======================== ============================ 
+        0     ShowAndGetNumber         (default format: ``#``)
+        1     ShowAndGetDate           (default format: ``DD/MM/YYYY``)
+        2     ShowAndGetTime           (default format: ``HH:MM``)
+        3     ShowAndGetIPAddress      (default format: ``#.#.#.#``)
+        4     ShowAndVerifyNewPassword (default format: ``*``)
+        ===== ======================== ============================ 
+
+        :param heading: string or unicode - dialog heading (will be ignored for type 4).
+        :param defaultt: [opt] string - default value.
+        :param bHiddenInput: [opt] bool - mask input (available for type 0).
+        :return: Returns the entered data as a string. Returns the default value if dialog was canceled.
+
+        @python_v19 New option added ShowAndVerifyNewPassword.
+
+        @python_v19 Added new option **bHiddenInput**.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            d = dialog.numeric(1, 'Enter date of birth')
+            ..
+        """
+        return ""
+    
+    def notification(self, heading: str,
+                     message: str,
+                     icon: str = "",
+                     time: int = 0,
+                     sound: bool = True) -> None:
+        """
+        Show a Notification alert.
+
+        :param heading: string - dialog heading.
+        :param message: string - dialog message.
+        :param icon: [opt] string - icon to use. (default xbmcgui.NOTIFICATION_INFO)
+        :param time: [opt] integer - time in milliseconds (default 5000)
+        :param sound: [opt] bool - play notification sound (default True)
+
+        Builtin Icons:
+
+        * xbmcgui.NOTIFICATION_INFO
+
+        * xbmcgui.NOTIFICATION_WARNING
+
+        * xbmcgui.NOTIFICATION_ERROR
+
+        @python_v13 New function added.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            dialog.notification('Movie Trailers', 'Finding Nemo download finished.', xbmcgui.NOTIFICATION_INFO, 5000)
+            ..
+        """
+        pass
+    
+    def input(self, heading: str,
+              defaultt: str = "",
+              type: int = INPUT_ALPHANUM,
+              option: int = 0,
+              autoclose: int = 0) -> str:
+        """
+        Show an Input dialog.
+
+        :param heading: string - dialog heading.
+        :param defaultt: [opt] string - default value. (default=empty string)
+        :param type: [opt] integer - the type of keyboard dialog.
+            (default=`xbmcgui.INPUT_ALPHANUM`)
+
+        ============================= =========================================== 
+        Parameter                     Format                                      
+        ============================= =========================================== 
+        ``xbmcgui.INPUT_ALPHANUM``    (standard keyboard)
+        ``xbmcgui.INPUT_NUMERIC``     (format: #)
+        ``xbmcgui.INPUT_DATE``        (format: DD/MM/YYYY)
+        ``xbmcgui.INPUT_TIME``        (format: HH:MM)
+        ``xbmcgui.INPUT_IPADDRESS``   (format: #.#.#.#)
+        ``xbmcgui.INPUT_PASSWORD``    (return md5 hash of input, input is masked)
+        ============================= =========================================== 
+
+        :param option: [opt] integer - option for the dialog. (see Options below)  Password
+            dialog:  ``xbmcgui.PASSWORD_VERIFY`` (verifies an existing
+            (default) md5 hashed password) Alphanum dialog:
+            ``xbmcgui.ALPHANUM_HIDE_INPUT`` (masks input)
+        :param autoclose: [opt] integer - milliseconds to autoclose dialog. (default=do not
+            autoclose)
+        :return: Returns the entered data as a string. Returns an empty string if dialog was canceled.
+
+        @python_v13 New function added.
+
+        Example::
+
+            ..
+            dialog = xbmcgui.Dialog()
+            d = dialog.input('Enter secret code', type=xbmcgui.INPUT_ALPHANUM, option=xbmcgui.ALPHANUM_HIDE_INPUT)
+            ..
+        """
+        return ""
+    
+    def colorpicker(self, heading: str,
+                    selectedcolor: str = "",
+                    colorfile: str = "",
+                    colorlist: List['ListItem'] = ()) -> str:
+        """
+        Show a color selection dialog.
+
+        :param heading: string - dialog heading.
+        :param selectedcolor: [opt] string - hex value of the preselected color.
+        :param colorfile: [opt] string - xml file containing color definitions. **XML content
+            style:**
+            <colors>
+            <color name="white">ffffffff</color>
+            <color name="grey">7fffffff</color>
+            <color name="green">ff00ff7f</color>
+            </colors>
+        :param colorlist: [opt] xbmcgui.ListItems - where label defines the color name and
+            label2 is set to the hex value.
+        :return: Returns the hex value of the selected color as a string.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ..
+            # colorfile example
+            dialog = xbmcgui.Dialog()
+            value = dialog.colorpicker('Select color', 'ff00ff00', 'os.path.join(xbmcaddon.Addon().getAddonInfo("path"), "colors.xml")')
+            ..
+            # colorlist example
+            listitems = []
+            l1 = xbmcgui.ListItem("red", "FFFF0000")
+            l2 = xbmcgui.ListItem("green", "FF00FF00")
+            l3 = xbmcgui.ListItem("blue", "FF0000FF")
+            listitems.append(l1)
+            listitems.append(l2)
+            listitems.append(l3)
+            dialog = xbmcgui.Dialog()
+            value = dialog.colorpicker("Select color", "FF0000FF", colorlist=listitems)
+            ..
+        """
+        return ""
+    
+
+class DialogProgress:
+    """
+    **Kodi's progress dialog class (Duh!)**
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def create(self, heading: str, message: str = "") -> None:
+        """
+        Create and show a progress dialog.
+
+        :param heading: string or unicode - dialog heading.
+        :param message: [opt] string or unicode - message text.
+
+        .. note::
+            Use `update()` to update lines and progressbar.
+
+        @python_v19 Renamed option **line1** to **message**.
+
+        @python_v19 Removed option **line2**.
+
+        @python_v19 Removed option **line3**.
+
+        Example::
+
+            ..
+            pDialog = xbmcgui.DialogProgress()
+            pDialog.create('Kodi', 'Initializing script...')
+            ..
+        """
+        pass
+    
+    def update(self, percent: int, message: str = "") -> None:
+        """
+        Updates the progress dialog.
+
+        :param percent: integer - percent complete. (0:100)
+        :param message: [opt] string or unicode - message text.
+
+        @python_v19 Renamed option **line1** to **message**.
+
+        @python_v19 Removed option **line2**.
+
+        @python_v19 Removed option **line3**.
+
+        Example::
+
+            ..
+            pDialog.update(25, 'Importing modules...')
+            ..
+        """
+        pass
+    
+    def close(self) -> None:
+        """
+        Close the progress dialog.
+
+        Example::
+
+            ..
+            pDialog.close()
+            ..
+        """
+        pass
+    
+    def iscanceled(self) -> bool:
+        """
+        Checks progress is canceled.
+
+        :return: True if the user pressed cancel.
+
+        Example::
+
+            ..
+            if (pDialog.iscanceled()): return
+            ..
+        """
+        return True
+    
+
+class DialogProgressBG:
+    """
+    **Kodi's background progress dialog class**
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def deallocating(self) -> None:
+        """
+        This method is meant to be called from the destructor of the lowest level class.
+
+        It's virtual because it's a convenient place to receive messages that we're
+        about to go be deleted but prior to any real tear-down.
+
+        Any overloading classes need to remember to pass the call up the chain.
+        """
+        pass
+    
+    def create(self, heading: str, message: str = "") -> None:
+        """
+        Create and show a background progress dialog.
+
+        :param heading: string or unicode - dialog heading.
+        :param message: [opt] string or unicode - message text.
+
+        .. note::
+            'heading' is used for the dialog's id. Use a unique heading.
+            Use `update()` to update heading, message and progressbar.
+
+        Example::
+
+            ..
+            pDialog = xbmcgui.DialogProgressBG()
+            pDialog.create('Movie Trailers', 'Downloading Monsters Inc... .')
+            ..
+        """
+        pass
+    
+    def update(self, percent: int = 0,
+               heading: str = "",
+               message: str = "") -> None:
+        """
+        Updates the background progress dialog.
+
+        :param percent: [opt] integer - percent complete. (0:100)
+        :param heading: [opt] string or unicode - dialog heading.
+        :param message: [opt] string or unicode - message text.
+
+        .. note::
+            To clear heading or message, you must pass a blank character.
+
+        Example::
+
+            ..
+            pDialog.update(25, message='Downloading Finding Nemo ...')
+            ..
+        """
+        pass
+    
+    def close(self) -> None:
+        """
+        Close the background progress dialog
+
+        Example::
+
+            ..
+            pDialog.close()
+            ..
+        """
+        pass
+    
+    def isFinished(self) -> bool:
+        """
+        Checks progress is finished
+
+        :return: True if the background dialog is active.
+
+        Example::
+
+            ..
+            if (pDialog.isFinished()): return
+            ..
+        """
+        return True
+    
+
+class ListItem:
+    """
+    **Selectable window list item.**
+    """
+    
+    def __init__(self, label: str = "",
+                 label2: str = "",
+                 path: str = "",
+                 offscreen: bool = False) -> None:
+        pass
+    
+    def getLabel(self) -> str:
+        """
+        Returns the listitem label.
+
+        :return: Label of item
+
+        Example::
+
+            ...
+            # getLabel()
+            label = listitem.getLabel()
+            ...
+        """
+        return ""
+    
+    def getLabel2(self) -> str:
+        """
+        Returns the second listitem label.
+
+        :return: Second label of item
+
+        Example::
+
+            ...
+            # getLabel2()
+            label = listitem.getLabel2()
+            ...
+        """
+        return ""
+    
+    def setLabel(self, label: str) -> None:
+        """
+        Sets the listitem's label.
+
+        :param label: string or unicode - text string.
+
+        Example::
+
+            ...
+            # setLabel(label)
+            listitem.setLabel('Casino Royale')
+            ...
+        """
+        pass
+    
+    def setLabel2(self, label: str) -> None:
+        """
+        Sets the listitem's label2.
+
+        :param label: string or unicode - text string.
+
+        Example::
+
+            ...
+            # setLabel2(label)
+            listitem.setLabel2('Casino Royale')
+            ...
+        """
+        pass
+    
+    def getDateTime(self) -> str:
+        """
+        Returns the list item's datetime in W3C format (YYYY-MM-DDThh:mm:ssTZD).
+
+        :return: string or unicode - datetime string (W3C).
+
+        @python_v20 New function added.
+
+        Example::
+
+            ...
+            # getDateTime()
+            strDateTime = listitem.getDateTime()
+            ...
+        """
+        return ""
+    
+    def setDateTime(self, dateTime: str) -> None:
+        """
+        Sets the list item's datetime in W3C format. The following formats are
+        supported:
+
+        YYYY
+
+        YYYY-MM-DD
+
+        YYYY-MM-DDThh:mm[TZD]
+
+        YYYY-MM-DDThh:mm:ss[TZD] where the timezone (TZD) is always optional and can be
+        in one of the following formats:
+
+        Z (for UTC)
+
+        +hh:mm
+
+        -hh:mm
+
+        :param label: string or unicode - datetime string (W3C).
+
+        @python_v20 New function added.
+
+        Example::
+
+            ...
+            # setDate(dateTime)
+            listitem.setDateTime('2021-03-09T12:30:00Z')
+            ...
+        """
+        pass
+    
+    def setArt(self, dictionary: Dict[str, str]) -> None:
+        """
+        Sets the listitem's art
+
+        :param values: dictionary - pairs of ``{ label: value }``. Some default art values
+            (any string possible):
+
+        ========= ======================= 
+        Label     Type                    
+        ========= ======================= 
+        thumb     string - image filename 
+        poster    string - image filename 
+        banner    string - image filename 
+        fanart    string - image filename 
+        clearart  string - image filename 
+        clearlogo string - image filename 
+        landscape string - image filename 
+        icon      string - image filename 
+        ========= ======================= 
+
+        @python_v13 New function added.
+
+        @python_v16 Added new label **icon**.
+
+        Example::
+
+            ...
+            # setArt(values)
+            listitem.setArt({ 'poster': 'poster.png', 'banner' : 'banner.png' })
+            ...
+        """
+        pass
+    
+    def setIsFolder(self, isFolder: bool) -> None:
+        """
+        Sets if this listitem is a folder.
+
+        :param isFolder: bool - True=folder / False=not a folder (default).
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            # setIsFolder(isFolder)
+            listitem.setIsFolder(True)
+            ...
+        """
+        pass
+    
+    def setUniqueIDs(self, dictionary: Dict[str, str],
+                     defaultrating: str = "") -> None:
+        """
+        Sets the listitem's uniqueID
+
+        :param values: dictionary - pairs of``{ label: value }``.
+        :param defaultrating: [opt] string - the name of default rating.
+
+        Some example values (any string possible):
+
+        ===== ====================== 
+        Label Type                   
+        ===== ====================== 
+        imdb  string - uniqueid name 
+        tvdb  string - uniqueid name 
+        tmdb  string - uniqueid name 
+        anidb string - uniqueid name 
+        ===== ====================== 
+
+        @python_v20 Deprecated. Use **InfoTagVideo.setUniqueIDs()** instead.
+
+        Example::
+
+            ...
+            # setUniqueIDs(values, defaultrating)
+            listitem.setUniqueIDs({ 'imdb': 'tt8938399', 'tmdb' : '9837493' }, "imdb")
+            ...
+        """
+        pass
+    
+    def setRating(self, type: str,
+                  rating: float,
+                  votes: int = 0,
+                  defaultt: bool = False) -> None:
+        """
+        Sets a listitem's rating. It needs at least type and rating param
+
+        :param type: string - the type of the rating. Any string.
+        :param rating: float - the value of the rating.
+        :param votes: int - the number of votes. Default 0.
+        :param defaultt: bool - is the default rating?. Default False.  Some example type (any
+            string possible):
+
+        ===== ==================== 
+        Label Type                 
+        ===== ==================== 
+        imdb  string - rating type 
+        tvdb  string - rating type 
+        tmdb  string - rating type 
+        anidb string - rating type 
+        ===== ==================== 
+
+        @python_v20 Deprecated. Use **InfoTagVideo.setRating()** instead.
+
+        Example::
+
+            ...
+            # setRating(type, rating, votes, defaultt))
+            listitem.setRating("imdb", 4.6, 8940, True)
+            ...
+        """
+        pass
+    
+    def addSeason(self, number: int, name: str = "") -> None:
+        """
+        Add a season with name to a listitem. It needs at least the season number
+
+        :param number: int - the number of the season.
+        :param name: string - the name of the season. Default "".
+
+        @python_v18 New function added.
+
+        @python_v20 Deprecated. Use **InfoTagVideo.addSeason()**
+        or **InfoTagVideo.addSeasons()** instead.
+
+        Example::
+
+            ...
+            # addSeason(number, name))
+            listitem.addSeason(1, "Murder House")
+            ...
+        """
+        pass
+    
+    def getArt(self, key: str) -> str:
+        """
+        Returns a listitem art path as a string, similar to an infolabel.
+
+        :param key: string - art name.  Some default art values (any string possible):
+
+        ========= =================== 
+        Label     Type                
+        ========= =================== 
+        thumb     string - image path 
+        poster    string - image path 
+        banner    string - image path 
+        fanart    string - image path 
+        clearart  string - image path 
+        clearlogo string - image path 
+        landscape string - image path 
+        icon      string - image path 
+        ========= =================== 
+
+        @python_v17 New function added.
+
+        Example::
+
+            ...
+            poster = listitem.getArt('poster')
+            ...
+        """
+        return ""
+    
+    def isFolder(self) -> bool:
+        """
+        Returns whether the item is a folder or not.
+
+        @python_v20 New function added.
+
+        Example::
+
+            ...
+            isFolder = listitem.isFolder()
+            ...
+        """
+        return True
+    
+    def getUniqueID(self, key: str) -> str:
+        """
+        Returns a listitem uniqueID as a string, similar to an infolabel.
+
+        :param key: string - uniqueID name.  Some default uniqueID values (any string
+            possible):
+
+        ===== ====================== 
+        Label Type                   
+        ===== ====================== 
+        imdb  string - uniqueid name 
+        tvdb  string - uniqueid name 
+        tmdb  string - uniqueid name 
+        anidb string - uniqueid name 
+        ===== ====================== 
+
+        @python_v20 Deprecated. Use **InfoTagVideo.getUniqueID()** instead.
+
+        Example::
+
+            ...
+            uniqueID = listitem.getUniqueID('imdb')
+            ...
+        """
+        return ""
+    
+    def getRating(self, key: str) -> float:
+        """
+        Returns a listitem rating as a float.
+
+        :param key: string - rating type.  Some default key values (any string possible):
+
+        ===== ================== 
+        Label Type               
+        ===== ================== 
+        imdb  string - type name 
+        tvdb  string - type name 
+        tmdb  string - type name 
+        anidb string - type name 
+        ===== ================== 
+
+        @python_v20 Deprecated. Use **InfoTagVideo.getRating()** instead.
+
+        Example::
+
+            ...
+            rating = listitem.getRating('imdb')
+            ...
+        """
+        return 0.0
+    
+    def getVotes(self, key: str) -> int:
+        """
+        Returns a listitem votes as a integer.
+
+        :param key: string - rating type.  Some default key values (any string possible):
+
+        ===== ================== 
+        Label Type               
+        ===== ================== 
+        imdb  string - type name 
+        tvdb  string - type name 
+        tmdb  string - type name 
+        anidb string - type name 
+        ===== ================== 
+
+        @python_v20 Deprecated. Use **InfoTagVideo.getVotesAsInt()** instead.
+
+        Example::
+
+            ...
+            votes = listitem.getVotes('imdb')
+            ...
+        """
+        return 0
+    
+    def select(self, selected: bool) -> None:
+        """
+        Sets the listitem's selected status.
+
+        :param selected: bool - True=selected/False=not selected
+
+        Example::
+
+            ...
+            # select(selected)
+            listitem.select(True)
+            ...
+        """
+        pass
+    
+    def isSelected(self) -> bool:
+        """
+        Returns the listitem's selected status.
+
+        :return: bool - true if selected, otherwise false
+
+        Example::
+
+            ...
+            # isSelected()
+            selected = listitem.isSelected()
+            ...
+        """
+        return True
+    
+    def setInfo(self, type: str, infoLabels: Dict[str, str]) -> None:
+        """
+        Sets the listitem's infoLabels.
+
+        :param type: string - type of info labels
+        :param infoLabels: dictionary - pairs of ``{ label: value }``
+
+        **Available types**
+
+        ============ ==================== 
+        Command name Description          
+        ============ ==================== 
+        video        Video information    
+        music        Music information    
+        pictures     Pictures informanion 
+        game         Game information     
+        ============ ==================== 
+
+        .. note::
+            To set pictures exif info, prepend ``exif:`` to the label. Exif
+            values must be passed as strings, separate value pairs with a
+            comma. (eg. ``{'exif:resolution': '720,480'}``). See
+            kodi_pictures_infotag for valid strings.
+
+            You can use the above
+            as keywords for arguments and skip certain optional arguments.
+            Once you use a keyword, all following arguments require the
+            keyword.
+
+        **General Values** (that apply to all types):
+
+        ========== ============================================================================ 
+        Info label Description                                                                  
+        ========== ============================================================================ 
+        count      integer (12) - can be used to store an id for later, or for sorting purposes 
+        size       long (1024) - size in bytes                                                  
+        date       string (d.m.Y / 01.01.2009) - file date                                      
+        ========== ============================================================================ 
+
+        **Video Values**:
+
+        ============= ==================================================================================================
+        Info label    Description
+        ============= ==================================================================================================
+        genre         string (Comedy) or list of strings (["Comedy", "Animation", "Drama"])                                                 
+        country       string (Germany) or list of strings (["Germany", "Italy", "France"])                                                  
+        year          integer (2009)                                                                                                        
+        episode       integer (4)                                                                                                           
+        season        integer (1)                                                                                                           
+        sortepisode   integer (4)                                                                                                           
+        sortseason    integer (1)                                                                                                           
+        episodeguide  string (Episode guide)                                                                                                
+        showlink      string (Battlestar Galactica) or list of strings (["Battlestar Galactica", "Caprica"])                                
+        top250        integer (192)                                                                                                         
+        setid         integer (14)                                                                                                          
+        tracknumber   integer (3)                                                                                                           
+        rating        float (6.4) - range is 0..10                                                                                          
+        userrating    integer (9) - range is 1..10 (0 to reset)                                                                             
+        watched       deprecated - use playcount instead                                                                                    
+        playcount     integer (2) - number of times this item has been played                                                               
+        overlay       integer (2) - range is ``0..7``. See Overlay icon types for values                                                     
+        cast          list (["Michal C. Hall","Jennifer Carpenter"]) - if provided a list of tuples cast will
+                      be interpreted as castandrole
+        castandrole   list of tuples ([("Michael C. Hall","Dexter"),("Jennifer Carpenter","Debra")])                                        
+        director      string (Dagur Kari) or list of strings (["Dagur Kari", "Quentin Tarantino", "Chrstopher Nolan"])                      
+        mpaa          string (PG-13)                                                                                                        
+        plot          string (Long Description)                                                                                             
+        plotoutline   string (Short Description)                                                                                            
+        title         string (Big Fan)                                                                                                      
+        originaltitle string (Big Fan)                                                                                                      
+        sorttitle     string (Big Fan)                                                                                                      
+        duration      integer (245) - duration in seconds                                                                                   
+        studio        string (Warner Bros.) or list of strings (["Warner Bros.", "Disney", "Paramount"])                                    
+        tagline       string (An awesome movie) - short description of movie                                                                
+        writer        string (Robert D. Siegel) or list of strings
+                      (["Robert D. Siegel", "Jonathan Nolan", "J.K. Rowling"])
+        tvshowtitle   string (Heroes)                                                                                                       
+        premiered     string (2005-03-04)                                                                                                   
+        status        string (Continuing) - status of a TVshow                                                                              
+        set           string (Batman Collection) - name of the collection                                                                   
+        setoverview   string (All Batman movies) - overview of the collection                                                               
+        tag           string (cult) or list of strings (["cult", "documentary", "best movies"]) - movie tag                                 
+        imdbnumber    string (tt0110293) - IMDb code                                                                                        
+        code          string (101) - Production code                                                                                        
+        aired         string (2008-12-07)                                                                                                   
+        credits       string (Andy Kaufman) or list of strings (["Dagur Kari", "Quentin Tarantino", "Chrstopher Nolan"])
+                      - writing credits
+        lastplayed    string (Y-m-d h:m:s = 2009-04-05 23:16:04)                                                                            
+        album         string (The Joshua Tree)                                                                                              
+        artist        list (['U2'])                                                                                                         
+        votes         string (12345 votes)                                                                                                  
+        path          string (/home/user/movie.avi)                                                                                         
+        trailer       string (/home/user/trailer.avi)                                                                                       
+        dateadded     string (Y-m-d h:m:s = 2009-04-05 23:16:04)                                                                            
+        mediatype     string - "video", "movie", "tvshow", "season", "episode" or "musicvideo"                                              
+        dbid          integer (23) - Only add this for items which are part of the local db. You also need to set
+                      the correct 'mediatype'!
+        ============= ==================================================================================================
+
+        **Music Values**:
+
+        ======================== =======================================================================================
+        Info label               Description                                                                                                          
+        ======================== =======================================================================================
+        tracknumber              integer (8)                                                                                                          
+        discnumber               integer (2)                                                                                                          
+        duration                 integer (245) - duration in seconds                                                                                  
+        year                     integer (1998)                                                                                                       
+        genre                    string (Rock)                                                                                                        
+        album                    string (Pulse)                                                                                                       
+        artist                   string (Muse)                                                                                                        
+        title                    string (American Pie)                                                                                                
+        rating                   float - range is between 0 and 10                                                                                    
+        userrating               integer - range is 1..10                                                                                             
+        lyrics                   string (On a dark desert highway...)                                                                                 
+        playcount                integer (2) - number of times this item has been played                                                              
+        lastplayed               string (Y-m-d h:m:s = 2009-04-05 23:16:04)                                                                           
+        mediatype                string - "music", "song", "album", "artist"                                                                          
+        dbid                     integer (23) - Only add this for items which are part of the local db.
+                                 You also need to set the correct 'mediatype'!
+        listeners                integer (25614)                                                                                                      
+        musicbrainztrackid       string (cd1de9af-0b71-4503-9f96-9f5efe27923c)                                                                        
+        musicbrainzartistid      string (d87e52c5-bb8d-4da8-b941-9f4928627dc8)                                                                        
+        musicbrainzalbumid       string (24944755-2f68-3778-974e-f572a9e30108)                                                                        
+        musicbrainzalbumartistid string (d87e52c5-bb8d-4da8-b941-9f4928627dc8)                                                                        
+        comment                  string (This is a great song)                                                                                        
+        ======================== =======================================================================================
+
+        **Picture Values**:
+
+        =========== ==================================================== 
+        Info label  Description                                          
+        =========== ==================================================== 
+        title       string (In the last summer-1)                        
+        picturepath string (``/home/username/pictures/img001.jpg``)      
+        exif*       string (See kodi_pictures_infotag for valid strings) 
+        =========== ==================================================== 
+
+        **Game Values**:
+
+        ========== ============================= 
+        Info label Description                   
+        ========== ============================= 
+        title      string (Super Mario Bros.)    
+        platform   string (Atari 2600)           
+        genres     list (["Action","Strategy"])  
+        publisher  string (Nintendo)             
+        developer  string (Square)               
+        overview   string (Long Description)     
+        year       integer (1980)                
+        gameclient string (game.libretro.fceumm) 
+        ========== ============================= 
+
+        @python_v14 Added new label **discnumber**.
+
+        @python_v15 **duration** has to be set in seconds.
+
+        @python_v16 Added new label **mediatype**.
+
+        @python_v17 Added labels **setid**, **set**, **imdbnumber**, **code**, **dbid** (video),
+        **path** and **userrating**. Expanded the possible infoLabels for the option **mediatype**.
+
+        @python_v18 Added new**game ** type and associated infolabels. Added
+        labels **dbid** (music), **setoverview**, **tag**, **sortepisode**, **sortseason **,
+        **episodeguide**, **showlink**. Extended labels **genre**, **country**, **director**,
+        **studio**, **writer**, **tag**, **credits** to also use a list of strings.
+
+        @python_v20 Partially deprecated. Use explicit setters
+        in **InfoTagVideo**, **InfoTagMusic**, **InfoTagPicture** or **InfoTagGame** instead.
+
+        Example::
+
+            ...
+            listitem.setInfo('video', { 'genre': 'Comedy' })
+            ...
+        """
+        pass
+    
+    def setCast(self, actors: List[Dict[str, str]]) -> None:
+        """
+        Set cast including thumbnails
+
+        :param actors: list of dictionaries (see below for relevant keys)
+
+        Keys:
+
+        ========= ============================================= 
+        Label     Description                                   
+        ========= ============================================= 
+        name      string (Michael C. Hall)                      
+        role      string (Dexter)                               
+        thumbnail string (http://www.someurl.com/someimage.png) 
+        order     integer (1)                                   
+        ========= ============================================= 
+
+        @python_v17 New function added.
+
+        @python_v20 Deprecated. Use **InfoTagVideo.setCast()** instead.
+
+        Example::
+
+            ...
+            actors = [{"name": "Actor 1", "role": "role 1"}, {"name": "Actor 2", "role": "role 2"}]
+            listitem.setCast(actors)
+            ...
+        """
+        pass
+    
+    def setAvailableFanart(self, images: List[Dict[str, str]]) -> None:
+        """
+        Set available images (needed for video scrapers)
+
+        :param images: list of dictionaries (see below for relevant keys)
+
+        Keys:
+
+        ======= ========================================================== 
+        Label   Description                                                
+        ======= ========================================================== 
+        image   string (http://www.someurl.com/someimage.png)              
+        preview [opt] string (http://www.someurl.com/somepreviewimage.png)
+        colors  [opt] string (either comma separated Kodi hex values
+                ("``FFFFFFFF,DDDDDDDD``") or TVDB RGB Int Triplets
+                ("``|68,69,59|69,70,58|78,78,68|``"))
+        ======= ==========================================================
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            fanart = [{"image": path_to_image_1, "preview": path_to_preview_1},
+                      {"image": path_to_image_2, "preview": path_to_preview_2}]
+            listitem.setAvailableFanart(fanart)
+            ...
+        """
+        pass
+    
+    def addAvailableArtwork(self, url: str,
+                            art_type: str = "",
+                            preview: str = "",
+                            referrer: str = "",
+                            cache: str = "",
+                            post: bool = False,
+                            isgz: bool = False,
+                            season: int = -1) -> None:
+        """
+        Add an image to available artworks (needed for video scrapers)
+
+        :param url: string (image path url)
+        :param art_type: string (image type)
+        :param preview: [opt] string (image preview path url)
+        :param referrer: [opt] string (referrer url)
+        :param cache: [opt] string (filename in cache)
+        :param post: [opt] bool (use post to retrieve the image, default false)
+        :param isgz: [opt] bool (use gzip to retrieve the image, default false)
+        :param season: [opt] integer (number of season in case of season thumb)
+
+        @python_v18 New function added. @python_v19 New param added (preview).
+
+        @python_v20 Deprecated. Use **InfoTagVideo.addAvailableArtwork()**
+        instead.
+
+        Example::
+
+            ...
+            listitem.addAvailableArtwork(path_to_image_1, "thumb")
+            ...
+        """
+        pass
+    
+    def addStreamInfo(self, cType: str, dictionary: Dict[str, str]) -> None:
+        """
+        Add a stream with details.
+
+        :param type: string - type of stream(video/audio/subtitle).
+        :param values: dictionary - pairs of { label: value }.
+
+        Video Values:
+
+        ======== ================= 
+        Label    Description       
+        ======== ================= 
+        codec    string (h264)     
+        aspect   float (1.78)      
+        width    integer (1280)    
+        height   integer (720)     
+        duration integer (seconds) 
+        ======== ================= 
+
+        Audio Values:
+
+        ======== ============ 
+        Label    Description  
+        ======== ============ 
+        codec    string (dts) 
+        language string (en)  
+        channels integer (2)  
+        ======== ============ 
+
+        Subtitle Values:
+
+        ======== =========== 
+        Label    Description 
+        ======== =========== 
+        language string (en) 
+        ======== =========== 
+
+        @python_v20 Deprecated.
+        Use **InfoTagVideo.addVideoStream()**, **InfoTagVideo.addAudioStream()**
+        or **InfoTagVideo.addSubtitleStream()** instead.
+
+        Example::
+
+            ...
+            listitem.addStreamInfo('video', { 'codec': 'h264', 'width' : 1280 })
+            ...
+        """
+        pass
+    
+    def addContextMenuItems(self, items: List[Tuple[str, str]],
+                            replaceItems: bool = False) -> None:
+        """
+        Adds item(s) to the context menu for media lists.
+
+        :param items: list - [(label, action),*] A list of tuples consisting of label and
+            action pairs.  label (string or unicode) - item's label, action
+            (string or unicode) - any available built-in function.
+
+        .. note::
+            You can use the above as keywords for arguments and skip certain
+            optional arguments.  Once you use a keyword, all following
+            arguments require the keyword.
+
+        @python_v17 Completely removed previously available
+        argument **replaceItems**.
+
+        Example::
+
+            ...
+            listitem.addContextMenuItems([('Theater Showtimes', 'RunScript(script.myaddon,title=Iron Man)')])
+            ...
+        """
+        pass
+    
+    def setProperty(self, key: str, value: str) -> None:
+        """
+        Sets a listitem property, similar to an infolabel.
+
+        :param key: string - property name.
+        :param value: string or unicode - value of property.
+
+        .. note::
+            Key is NOT case sensitive.  You can use the above as keywords for
+            arguments and skip certain optional arguments.  Once you use a
+            keyword, all following arguments require the keyword.   Some of
+            these are treated internally by Kodi, such as the 'StartOffset'
+            property, which is the offset in seconds at which to start
+            playback of an item. Others may be used in the skin to add extra
+            information, such as 'WatchedCount' for tvshow items
+
+        **Internal Properties**
+
+        ================== =============================================================================================
+        Key                Description                                                                                                                           
+        ================== =============================================================================================
+        inputstream        string (inputstream.adaptive) - Set the inputstream add-on that will be used to play the item                                         
+        IsPlayable         string - "true", "false" - Mark the item as playable,**mandatory for playable items **                                                 
+        MimeType           string (application/x-mpegURL) - Set the MimeType of the item before playback                                                         
+        ResumeTime         float (1962.0) - Set the resume point of the item in seconds                                                                          
+        SpecialSort        string - "top", "bottom" - The item will remain at the top or bottom of the current list                                              
+        StartOffset        float (60.0) - Set the offset in seconds at which to start playback of the item                                                       
+        StartPercent       float (15.0) - Set the percentage at which to start playback of the item                                                              
+        StationName        string ("My Station Name") - Used to enforce/override MusicPlayer.StationName infolabel from
+                           addons (e.g. in radio addons)
+        TotalTime          float (7848.0) - Set the total time of the item in seconds                                                                            
+        OverrideInfotag    string - "true", "false" - When true will override all info from previous listitem                                                    
+        ForceResolvePlugin string - "true", "false" - When true ensures that a plugin will always receive callbacks
+                           to resolve paths (useful for playlist cases)
+        ================== =============================================================================================
+
+        @python_v20 OverrideInfotag property added
+
+        @python_v20 **ResumeTime** and **TotalTime** deprecated.
+        Use **InfoTagVideo.setResumePoint()** instead.
+
+        @python_v20 ForceResolvePlugin property added
+
+        Example::
+
+            ...
+            listitem.setProperty('AspectRatio', '1.85 : 1')
+            listitem.setProperty('StartOffset', '256.4')
+            ...
+        """
+        pass
+    
+    def setProperties(self, dictionary: Dict[str, str]) -> None:
+        """
+        Sets multiple properties for listitem's
+
+        :param values: dictionary - pairs of ``{ label: value }``.
+
+        @python_v18 New function added.
+
+        Example::
+
+            ...
+            # setProperties(values)
+            listitem.setProperties({ 'AspectRatio': '1.85', 'StartOffset' : '256.4' })
+            ...
+        """
+        pass
+    
+    def getProperty(self, key: str) -> str:
+        """
+        Returns a listitem property as a string, similar to an infolabel.
+
+        :param key: string - property name.
+
+        .. note::
+            Key is NOT case sensitive.  You can use the above as keywords for
+            arguments and skip certain optional arguments.  Once you use a
+            keyword, all following arguments require the keyword.
+
+        @python_v20 **ResumeTime** and **TotalTime** deprecated.
+        Use **InfoTagVideo.getResumeTime()**
+        and **InfoTagVideo.getResumeTimeTotal()** instead.
+
+        Example::
+
+            ...
+            AspectRatio = listitem.getProperty('AspectRatio')
+            ...
+        """
+        return ""
+    
+    def setPath(self, path: str) -> None:
+        """
+        Sets the listitem's path.
+
+        :param path: string or unicode - path, activated when item is clicked.
+
+        .. note::
+            You can use the above as keywords for arguments.
+
+        Example::
+
+            ...
+            listitem.setPath(path='/path/to/some/file.ext')
+            ...
+        """
+        pass
+    
+    def setMimeType(self, mimetype: str) -> None:
+        """
+        Sets the listitem's mimetype if known.
+
+        :param mimetype: string or unicode - mimetype
+
+        If known prehand, this can (but does not have to) avoid HEAD requests
+        being sent to HTTP servers to figure out file type.
+        """
+        pass
+    
+    def setContentLookup(self, enable: bool) -> None:
+        """
+        Enable or disable content lookup for item.
+
+        If disabled, HEAD requests to e.g determine mime type will not be sent.
+
+        :param enable: bool to enable content lookup
+
+        @python_v16 New function added.
+        """
+        pass
+    
+    def setSubtitles(self, subtitleFiles: List[str]) -> None:
+        """
+        Sets subtitles for this listitem.
+
+        :param subtitleFiles: list with path to subtitle files
+
+        Example::
+
+            ...
+            listitem.setSubtitles(['special://temp/example.srt', 'http://example.com/example.srt'])
+            ...
+
+        @python_v14 New function added.
+        """
+        pass
+    
+    def getPath(self) -> str:
+        """
+        Returns the path of this listitem.
+
+        :return: [string] filename
+
+        @python_v17 New function added.
+        """
+        return ""
+    
+    def getVideoInfoTag(self) -> 'xbmc.InfoTagVideo':
+        """
+        Returns the VideoInfoTag for this item.
+
+        :return: video info tag
+
+        @python_v15 New function added.
+        """
+        from xbmc import InfoTagVideo
+        return InfoTagVideo()
+    
+    def getMusicInfoTag(self) -> 'xbmc.InfoTagMusic':
+        """
+        Returns the MusicInfoTag for this item.
+
+        :return: music info tag
+
+        @python_v15 New function added.
+        """
+        from xbmc import InfoTagMusic
+        return InfoTagMusic()
+    
+    def getPictureInfoTag(self) -> 'xbmc.InfoTagPicture':
+        """
+        Returns the InfoTagPicture for this item.
+
+        :return: picture info tag
+
+        @python_v20 New function added.
+        """
+        from xbmc import InfoTagPicture
+        return InfoTagPicture()
+    
+    def getGameInfoTag(self) -> 'xbmc.InfoTagGame':
+        """
+        Returns the InfoTagGame for this item.
+
+        :return: game info tag
+
+        @python_v20 New function added.
+        """
+        from xbmc import InfoTagGame
+        return InfoTagGame()
+    
+
+class Action:
+    """
+    **`Action` class.**
+
+    This class serves in addition to identify carried out kodi_key_action_ids of
+    Kodi and to be able to carry out thereby own necessary steps.
+
+    The data of this class are always transmitted by callback `Window::onAction` at a
+    window.
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+    def getId(self) -> int:
+        """
+        To get kodi_key_action_ids
+
+        This function returns the identification code used by the explained order, it is
+        necessary to determine the type of command from kodi_key_action_ids.
+
+        :return: The action's current id as a long or 0 if no action is mapped in the xml's.
+
+        Example::
+
+            ..
+            def onAction(self, action):
+            if action.getId() == ACTION_PREVIOUS_MENU:
+            print('action received: previous')
+            ..
+        """
+        return 0
+    
+    def getButtonCode(self) -> int:
+        """
+        Returns the button code for this action.
+
+        :return: [integer] button code
+        """
+        return 0
+    
+    def getAmount1(self) -> float:
+        """
+        Returns the first amount of force applied to the thumbstick.
+
+        :return: [float] first amount
+        """
+        return 0.0
+    
+    def getAmount2(self) -> float:
+        """
+        Returns the second amount of force applied to the thumbstick.
+
+        :return: [float] second amount
+        """
+        return 0.0
+    
+
+class Window:
+    """
+    **GUI window class for Add-Ons.**
+
+    This class allows over their functions to create and edit windows that can be
+    accessed from an Add-On.
+
+    Likewise, all functions from here as well in the other window
+    classes `WindowDialog`,`WindowXML` and `WindowXMLDialog` with inserted and
+    available.
+
+    Constructor for windowCreates a new from Add-On usable window class. This is to create window for
+    related controls by system calls.
+
+    :param existingWindowId: [opt] Specify an id to use an existing window.
+    :raises ValueError: if supplied window Id does not exist.
+    :raises Exception: if more then 200 windows are created.
+
+    Deleting this window will activate the old window that was active and
+    resets (not delete) all controls that are associated with this window.
+
+    Example::
+
+        ..
+        win = xbmcgui.Window()
+        width = win.getWidth()
+        ..
+    """
+    
+    def __init__(self, existingWindowId: int = -1) -> None:
+        pass
+    
+    def show(self) -> None:
+        """
+        Show this window.
+
+        Shows this window by activating it, calling `close()` after it wil activate the
+        current window again.
+
+        .. note::
+            If your script ends this window will be closed to. To show it
+            forever, make a loop at the end of your script or use `doModal()`
+            instead.
+        """
+        pass
+    
+    def setFocus(self, pControl: Control) -> None:
+        """
+        Give the supplied control focus.
+
+        :param `Control`: `Control` class to focus
+        :raises TypeError: If supplied argument is not a `Control` type
+        :raises SystemError: On Internal error
+        :raises RuntimeError: If control is not added to a window
+        """
+        pass
+    
+    def setFocusId(self, iControlId: int) -> None:
+        """
+        Gives the control with the supplied focus.
+
+        :param ControlId: [integer] On skin defined id of control
+        :raises SystemError: On Internal error
+        :raises RuntimeError: If control is not added to a window
+        """
+        pass
+    
+    def getFocus(self) -> Control:
+        """
+        Returns the control which is focused.
+
+        :return: Focused control class
+
+        :raises SystemError: On Internal error
+        :raises RuntimeError: If no control has focus
+        """
+        return Control()
+    
+    def getFocusId(self) -> int:
+        """
+        Returns the id of the control which is focused.
+
+        :return: Focused control id
+        :raises SystemError: On Internal error
+        :raises RuntimeError: If no control has focus
+        """
+        return 0
+    
+    def removeControl(self, pControl: Control) -> None:
+        """
+        Removes the control from this window.
+
+        :param `Control`: `Control` class to remove
+        :raises TypeError: If supplied argument is not a `Control` type
+        :raises RuntimeError: If control is not added to this window
+
+        This will not delete the control. It is only removed from the window.
+        """
+        pass
+    
+    def removeControls(self, pControls: List[Control]) -> None:
+        """
+        Removes a list of controls from this window.
+
+        :param `List`: `List` with controls to remove
+        :raises TypeError: If supplied argument is not a `Control` type
+        :raises RuntimeError: If control is not added to this window
+
+        This will not delete the controls. They are only removed from the
+        window.
+        """
+        pass
+    
+    def getHeight(self) -> int:
+        """
+        Returns the height of this `Window` instance.
+
+        :return: `Window` height in pixels
+
+        @python_v18 Function changed
+        """
+        return 0
+    
+    def getWidth(self) -> int:
+        """
+        Returns the width of this `Window` instance.
+
+        :return: `Window` width in pixels
+
+        @python_v18 Function changed
+        """
+        return 0
+    
+    def setProperty(self, key: str, value: str) -> None:
+        """
+        Sets a window property, similar to an infolabel.
+
+        :param key: string - property name.
+        :param value: string or unicode - value of property.
+
+        .. note::
+            Key is NOT case sensitive. Setting value to an empty string is
+            equivalent to clearProperty(key).  You can use the above as
+            keywords for arguments and skip certain optional arguments.  Once
+            you use a keyword, all following arguments require the keyword.
+
+        Example::
+
+            ..
+            win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
+            win.setProperty('Category', 'Newest')
+            ..
+        """
+        pass
+    
+    def getProperty(self, key: str) -> str:
+        """
+        Returns a window property as a string, similar to an infolabel.
+
+        :param key: string - property name.
+
+        .. note::
+            Key is NOT case sensitive.  You can use the above as keywords for
+            arguments and skip certain optional arguments. Once you use a
+            keyword, all following arguments require the keyword.
+
+        Example::
+
+            ..
+            win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
+            category = win.getProperty('Category')
+            ..
+        """
+        return ""
+    
+    def clearProperty(self, key: str) -> None:
+        """
+        Clears the specific window property.
+
+        :param key: string - property name.
+
+        .. note::
+            Key is NOT case sensitive. Equivalent to setProperty(key,'') You
+            can use the above as keywords for arguments and skip certain
+            optional arguments. Once you use a keyword, all following
+            arguments require the keyword.
+
+        Example::
+
+            ..
+            win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
+            win.clearProperty('Category')
+            ..
+        """
+        pass
+    
+    def clearProperties(self) -> None:
+        """
+        Clears all window properties.
+
+        Example::
+
+            ..
+            win = xbmcgui.Window(xbmcgui.getCurrentWindowId())
+            win.clearProperties()
+            ..
+        """
+        pass
+    
+    def close(self) -> None:
+        """
+        Closes this window.
+
+        Closes this window by activating the old window.
+
+        .. note::
+            The window is not deleted with this method.
+        """
+        pass
+    
+    def doModal(self) -> None:
+        """
+        Display this window until `close()` is called.
+        """
+        pass
+    
+    def addControl(self, pControl: Control) -> None:
+        """
+        Add a `Control` to this window.
+
+        :param `Control`: `Control` to add
+        :raises TypeError: If supplied argument is not a `Control` type
+        :raises ReferenceError: If control is already used in another window
+        :raises RuntimeError: Should not happen :-)
+
+        The next controls can be added to a window atm
+
+        ==================== =======================================================================
+        Control-class        Description                                                                                     
+        ==================== =======================================================================
+        `ControlLabel`       Label control to show text                                                                      
+        `ControlFadeLabel`   The fadelabel has multiple labels which it cycles through                                       
+        `ControlTextBox`     To show bigger text field                                                                       
+        `ControlButton`      Brings a button to do some actions                                                              
+        `ControlEdit`        The edit control allows a user to input text in Kodi                                            
+        `ControlFadeLabel`   The fade label control is used for displaying multiple pieces of text
+                             in the same space in Kodi
+        `ControlList`        Add a list for something like files                                                             
+        `ControlGroup`       Is for a group which brings the others together                                                 
+        `ControlImage`       Controls a image on skin                                                                        
+        `ControlRadioButton` For a radio button which handle boolean values                                                  
+        `ControlProgress`    Progress bar for a performed work or something else                                             
+        `ControlSlider`      The slider control is used for things where a sliding bar best
+                             represents the operation at hand
+        `ControlSpin`        The spin control is used for when a list of options can be chosen                               
+        `ControlTextBox`     The text box is used for showing a large multipage piece of text
+                             in Kodi
+        ==================== =======================================================================
+        """
+        pass
+    
+    def addControls(self, pControls: List[Control]) -> None:
+        """
+        Add a list of Controls to this window.
+
+        :param `List`: `List` with controls to add
+        :raises TypeError: If supplied argument is not of `List` type, or a control is not
+            of `Control` type
+        :raises ReferenceError: If control is already used in another window
+        :raises RuntimeError: Should not happen :-)
+        """
+        pass
+    
+    def getControl(self, iControlId: int) -> Control:
+        """
+        Gets the control from this window.
+
+        :param controlId: `Control` id to get
+        :raises Exception: If `Control` doesn't exist
+
+        controlId doesn't have to be a python control, it can be a control id from a
+        Kodi window too (you can find id's in the xml files.
+
+        .. note::
+            Not python controls are not completely usable yet You can only use
+            the `Control` functions
+        """
+        return Control()
+    
+    def onAction(self, action: Action) -> None:
+        """
+        **onAction method.**
+
+        This method will receive all actions that the main program will send to this
+        window.
+
+        :param self: Own base class pointer
+        :param action: The action id to perform, see `Action` to get use of them
+
+        .. note::
+            By default, only the ``PREVIOUS_MENU`` and ``NAV_BACK`` actions are
+            handled. Overwrite this method to let your script handle all
+            actions.Don't forget to capture ``ACTION_PREVIOUS_MENU``
+            or ``ACTION_NAV_BACK``, else the user can't close this window.
+
+        Example::
+
+            ..
+            # Define own function where becomes called from Kodi
+            def onAction(self, action):
+            if action.getId() == ACTION_PREVIOUS_MENU:
+            print('action received: previous')
+            self.close()
+            if action.getId() == ACTION_SHOW_INFO:
+            print('action received: show info')
+            if action.getId() == ACTION_STOP:
+            print('action received: stop')
+            if action.getId() == ACTION_PAUSE:
+            print('action received: pause')
+            ..
+        """
+        pass
+    
+    def onControl(self, control: Control) -> None:
+        """
+        **onControl method.**
+
+        This method will receive all click events on owned and selected controls when
+        the control itself doesn't handle the message.
+
+        :param self: Own base class pointer
+        :param control: The `Control` class
+
+        Example::
+
+            ..
+            # Define own function where becomes called from Kodi
+            def onControl(self, control):
+            print("Window.onControl(control=[%s])"%control)
+            ..
+        """
+        pass
+    
+    def onClick(self, controlId: int) -> None:
+        """
+        **onClick method.**
+
+        This method will receive all click events that the main program will send to
+        this window.
+
+        :param self: Own base class pointer
+        :param controlId: The one time clicked GUI control identifier
+
+        Example::
+
+            ..
+            # Define own function where becomes called from Kodi
+            def onClick(self,controlId):
+            if controlId == 10:
+            print("The control with Id 10 is clicked")
+            ..
+        """
+        pass
+    
+    def onDoubleClick(self, controlId: int) -> None:
+        """
+        **onDoubleClick method.**
+
+        This method will receive all double click events that the main program will send
+        to this window.
+
+        :param self: Own base class pointer
+        :param controlId: The double clicked GUI control identifier
+
+        Example::
+
+            ..
+            # Define own function where becomes called from Kodi
+            def onDoubleClick(self,controlId):
+            if controlId == 10:
+            print("The control with Id 10 is double clicked")
+            ..
+        """
+        pass
+    
+    def onFocus(self, controlId: int) -> None:
+        """
+        **onFocus method.**
+
+        This method will receive all focus events that the main program will send to
+        this window.
+
+        :param self: Own base class pointer
+        :param controlId: The focused GUI control identifier
+
+        Example::
+
+            ..
+            # Define own function where becomes called from Kodi
+            def onDoubleClick(self,controlId):
+            if controlId == 10:
+            print("The control with Id 10 is focused")
+            ..
+        """
+        pass
+    
+    def onInit(self) -> None:
+        """
+        **onInit method.**
+
+        This method will be called to initialize the window
+
+        :param self: Own base class pointer
+
+        Example::
+
+            ..
+            # Define own function where becomes called from Kodi
+            def onInit(self):
+            print("Window.onInit method called from Kodi")
+            ..
+        """
+        pass
+    
+
+class WindowDialog(Window):
+    """
+    **GUI window dialog class for Add-Ons.**
+
+    Creates a new window from Add-On usable dialog class. This is to create window
+    for related controls by system calls.
+
+    :param windowId: [opt] Specify an id to use an existing window.
+    :raises ValueError: if supplied window Id does not exist.
+    :raises Exception: if more then 200 windows are created.
+
+    Deleting this window will activate the old window that was active and
+    resets (not delete) all controls that are associated with this window.
+
+    Example::
+
+        ..
+        dialog = xbmcgui.WindowDialog()
+        width = dialog.getWidth()
+        ..
+    """
+    
+    def __init__(self) -> None:
+        pass
+    
+
+class WindowXML(Window):
+    """
+    **GUI xml window class.**
+
+    Creates a new xml file based window class.
+
+    .. note::
+        This class include also all calls from ```Window```.
+
+    :param xmlFilename: string - the name of the xml file to look for.
+    :param scriptPath: string - path to script. used to fallback to if the xml doesn't exist
+        in the current skin. (eg xbmcaddon.Addon().getAddonInfo('path'))
+    :param defaultSkin: [opt] string - name of the folder in the skins path to look in for the
+        xml. (default='Default')
+    :param defaultRes: [opt] string - default skins resolution. (1080i, 720p, ntsc16x9, ntsc,
+        pal16x9 or pal. default='720p')
+    :param isMedia: [opt] bool - if False, create a regular window. if True, create a
+        mediawindow. (default=False)
+    :raises Exception: if more then 200 windows are created.
+
+    Skin folder structure is e.g. **resources/skins/Default/720p**
+
+    Deleting this window will activate the old window that was active and
+    resets (not delete) all controls that are associated with this window.
+
+    @python_v18 New param added **isMedia**.
+
+    Example::
+
+        ..
+        win = xbmcgui.WindowXML('script-Lyrics-main.xml', xbmcaddon.Addon().getAddonInfo('path'), 'default', '1080i', False)
+        win.doModal()
+        del win
+        ..
+
+    On functions defined input variable ``controlId`` (GUI control identifier)** is
+    the on window.xml defined value behind type added with ``id="..."`` and used
+    to identify for changes there and on callbacks.
+
+    .. code-block:: xml
+
+        <control type="label" id="31">
+        <description>Title Label</description>
+        ...
+        </control>
+        <control type="progress" id="32">
+        <description>progress control</description>
+        ...
+        </control>
+    """
+    
+    def __init__(self, xmlFilename: str,
+                 scriptPath: str,
+                 defaultSkin: str = "Default",
+                 defaultRes: str = "720p",
+                 isMedia: bool = False) -> None:
+        pass
+    
+    def addItem(self, item: Union[str,  ListItem],
+                position: int = 2147483647) -> None:
+        """
+        Add a new item to this `Window ``List`.
+
+        :param item: string, unicode or `ListItem` - item to add.
+        :param position: [opt] integer - position of item to add. (NO Int = Adds to bottom,0
+            adds to top, 1 adds to one below from top, -1 adds to one above
+            from bottom etc etc)  If integer positions are greater than list
+            size, negative positions will add to top of list, positive
+            positions will add to bottom of list
+
+        Example::
+
+            ..
+            self.addItem('Reboot Kodi', 0)
+            ..
+        """
+        pass
+    
+    def addItems(self, items: List[Union[str,  ListItem]]) -> None:
+        """
+        Add a list of items to to the window list.
+
+        :param items: `List` - list of strings, unicode objects or ListItems to add.
+
+        Example::
+
+            ..
+            self.addItems(['Reboot Kodi', 'Restart Kodi'])
+            ..
+        """
+        pass
+    
+    def removeItem(self, position: int) -> None:
+        """
+        Removes a specified item based on position, from the `Window ``List`.
+
+        :param position: integer - position of item to remove.
+
+        Example::
+
+            ..
+            self.removeItem(5)
+            ..
+        """
+        pass
+    
+    def getCurrentListPosition(self) -> int:
+        """
+        Gets the current position in the `Window ``List`.
+
+        Example::
+
+            ..
+            pos = self.getCurrentListPosition()
+            ..
+        """
+        return 0
+    
+    def setCurrentListPosition(self, position: int) -> None:
+        """
+        Set the current position in the `Window ``List`.
+
+        :param position: integer - position of item to set.
+
+        Example::
+
+            ..
+            self.setCurrentListPosition(5)
+            ..
+        """
+        pass
+    
+    def getListItem(self, position: int) -> ListItem:
+        """
+        Returns a given `ListItem` in this `Window ``List`.
+
+        :param position: integer - position of item to return.
+
+        Example::
+
+            ..
+            listitem = self.getListItem(6)
+            ..
+        """
+        return ListItem()
+    
+    def getListSize(self) -> int:
+        """
+        Returns the number of items in this `Window ``List`.
+
+        Example::
+
+            ..
+            listSize = self.getListSize()
+            ..
+        """
+        return 0
+    
+    def clearList(self) -> None:
+        """
+        Clear the `Window ``List`.
+
+        Example::
+
+            ..
+            self.clearList()
+            ..
+        """
+        pass
+    
+    def setContainerProperty(self, strProperty: str, strValue: str) -> None:
+        """
+        Sets a container property, similar to an infolabel.
+
+        :param key: string - property name.
+        :param value: string or unicode - value of property.
+
+        .. note::
+            Key is NOT case sensitive. You can use the above as keywords for
+            arguments and skip certain optional arguments. Once you use a
+            keyword, all following arguments require the keyword.
+
+        @python_v17 Changed function from **setProperty**
+        to **setContainerProperty**.
+
+        Example::
+
+            ..
+            self.setContainerProperty('Category', 'Newest')
+            ..
+        """
+        pass
+    
+    def setContent(self, strValue: str) -> None:
+        """
+        Sets the content type of the container.
+
+        :param value: string or unicode - content value.
+
+        **Available content types**
+
+        =========== ========================================= 
+        Name        Media                                     
+        =========== ========================================= 
+        actors      Videos                                    
+        addons      Addons, Music, Pictures, Programs, Videos 
+        albums      Music, Videos                             
+        artists     Music, Videos                             
+        countries   Music, Videos                             
+        directors   Videos                                    
+        files       Music, Videos                             
+        games       Games                                     
+        genres      Music, Videos                             
+        images      Pictures                                  
+        mixed       Music, Videos                             
+        movies      Videos                                    
+        Musicvideos Music, Videos                             
+        playlists   Music, Videos                             
+        seasons     Videos                                    
+        sets        Videos                                    
+        songs       Music                                     
+        studios     Music, Videos                             
+        tags        Music, Videos                             
+        tvshows     Videos                                    
+        videos      Videos                                    
+        years       Music, Videos                             
+        =========== ========================================= 
+
+        @python_v18 Added new function.
+
+        Example::
+
+            ..
+            self.setContent('movies')
+            ..
+        """
+        pass
+    
+    def getCurrentContainerId(self) -> int:
+        """
+        Get the id of the currently visible container.
+
+        @python_v17 Added new function.
+
+        Example::
+
+            ..
+            container_id = self.getCurrentContainerId()
+            ..
+        """
+        return 0
+    
+
+class WindowXMLDialog(WindowXML):
+    """
+    **GUI xml window dialog**
+
+    Creates a new xml file based window dialog class.
+
+    :param xmlFilename: string - the name of the xml file to look for.
+    :param scriptPath: string - path to script. used to fallback to if the xml doesn't exist
+        in the current skin. (eg xbmcaddon.Addon().getAddonInfo('path'))
+    :param defaultSkin: [opt] string - name of the folder in the skins path to look in for the
+        xml. (default='Default')
+    :param defaultRes: [opt] string - default skins resolution. (1080i, 720p, ntsc16x9, ntsc,
+        pal16x9 or pal. default='720p')
+    :raises Exception: if more then 200 windows are created.
+
+    .. note::
+        Skin folder structure is e.g. **resources/skins/Default/720p**
+
+    Example::
+
+        ..
+        dialog = xbmcgui.WindowXMLDialog('script-Lyrics-main.xml', xbmcaddon.Addon().getAddonInfo('path'), 'default', '1080i')
+        dialog.doModal()
+        del dialog
+        ..
+
+    On functions defined input variable ``controlId`` (GUI control identifier)** is
+    the on window.xml defined value behind type added with ``id="..."`` and used
+    to identify for changes there and on callbacks.
+
+    .. code-block:: xml
+
+        <control type="label" id="31">
+        <description>Title Label</description>
+        ...
+        </control>
+        <control type="progress" id="32">
+        <description>progress control</description>
+        ...
+        </control>
+    """
+    
+    def __init__(self, xmlFilename: str,
+                 scriptPath: str,
+                 defaultSkin: str = "Default",
+                 defaultRes: str = "720p") -> None:
+        pass
+
+
+def getCurrentWindowId() -> int:
+    """
+    Returns the id for the current 'active' window as an integer.
+
+    :return: The currently active window Id
+
+    Example::
+
+        ..
+        wid = xbmcgui.getCurrentWindowId()
+        ..
+    """
+    return 0
+
+
+def getCurrentWindowDialogId() -> int:
+    """
+    Returns the id for the current 'active' dialog as an integer.
+
+    :return: The currently active dialog Id
+
+    Example::
+
+        ..
+        wid = xbmcgui.getCurrentWindowDialogId()
+        ..
+    """
+    return 0
+
+
+def getScreenHeight() -> int:
+    """
+    Returns the height of this screen.
+
+    :return: Screen height
+
+    @python_v18 New function added.
+    """
+    return 0
+
+
+def getScreenWidth() -> int:
+    """
+    Returns the width of this screen.
+
+    :return: Screen width
+
+    @python_v18 New function added.
+    """
+    return 0
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcplugin.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcplugin.py
new file mode 100644
index 00000000000..13519bbbd8e
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcplugin.py
@@ -0,0 +1,387 @@
+# This file is generated from Kodi source code and post-edited
+# to correct code style and docstrings formatting.
+# License: GPL v.3 <https://www.gnu.org/licenses/gpl-3.0.en.html>
+"""
+**Plugin functions on Kodi.**
+
+Offers classes and functions that allow a developer to present information
+through Kodi's standard menu structure. While plugins don't have the same
+flexibility as scripts, they boast significantly quicker development time and a
+more consistent user experience.
+"""
+from typing import List, Tuple, Optional
+
+__kodistubs__ = True
+
+SORT_METHOD_ALBUM = 14
+SORT_METHOD_ALBUM_IGNORE_THE = 15
+SORT_METHOD_ARTIST = 11
+SORT_METHOD_ARTIST_IGNORE_THE = 13
+SORT_METHOD_BITRATE = 43
+SORT_METHOD_CHANNEL = 41
+SORT_METHOD_COUNTRY = 17
+SORT_METHOD_DATE = 3
+SORT_METHOD_DATEADDED = 21
+SORT_METHOD_DATE_TAKEN = 44
+SORT_METHOD_DRIVE_TYPE = 6
+SORT_METHOD_DURATION = 8
+SORT_METHOD_EPISODE = 24
+SORT_METHOD_FILE = 5
+SORT_METHOD_FULLPATH = 35
+SORT_METHOD_GENRE = 16
+SORT_METHOD_LABEL = 1
+SORT_METHOD_LABEL_IGNORE_FOLDERS = 36
+SORT_METHOD_LABEL_IGNORE_THE = 2
+SORT_METHOD_LASTPLAYED = 37
+SORT_METHOD_LISTENERS = 39
+SORT_METHOD_MPAA_RATING = 31
+SORT_METHOD_NONE = 0
+SORT_METHOD_PLAYCOUNT = 38
+SORT_METHOD_PLAYLIST_ORDER = 23
+SORT_METHOD_PRODUCTIONCODE = 28
+SORT_METHOD_PROGRAM_COUNT = 22
+SORT_METHOD_SIZE = 4
+SORT_METHOD_SONG_RATING = 29
+SORT_METHOD_SONG_USER_RATING = 30
+SORT_METHOD_STUDIO = 33
+SORT_METHOD_STUDIO_IGNORE_THE = 34
+SORT_METHOD_TITLE = 9
+SORT_METHOD_TITLE_IGNORE_THE = 10
+SORT_METHOD_TRACKNUM = 7
+SORT_METHOD_UNSORTED = 40
+SORT_METHOD_VIDEO_ORIGINAL_TITLE = 49
+SORT_METHOD_VIDEO_ORIGINAL_TITLE_IGNORE_THE = 50
+SORT_METHOD_VIDEO_RATING = 19
+SORT_METHOD_VIDEO_RUNTIME = 32
+SORT_METHOD_VIDEO_SORT_TITLE = 26
+SORT_METHOD_VIDEO_SORT_TITLE_IGNORE_THE = 27
+SORT_METHOD_VIDEO_TITLE = 25
+SORT_METHOD_VIDEO_USER_RATING = 20
+SORT_METHOD_VIDEO_YEAR = 18
+
+
+def addDirectoryItem(handle: int,
+                     url: str,
+                     listitem: 'xbmcgui.ListItem',
+                     isFolder: bool = False,
+                     totalItems: int = 0) -> bool:
+    """
+    Callback function to pass directory contents back to Kodi.
+
+    :param handle: integer - handle the plugin was started with.
+    :param url: string - url of the entry. would be ``plugin://`` for another virtual
+        directory
+    :param listitem: ListItem - item to add.
+    :param isFolder: [opt] bool - True=folder / False=not a folder(default).
+    :param totalItems: [opt] integer - total number of items that will be passed.(used for
+        progressbar)
+    :return: Returns a bool for successful completion.
+
+    .. note::
+        You can use the above as keywords for arguments and skip certain
+        optional arguments. Once you use a keyword, all following
+        arguments require the keyword.
+
+    Example::
+
+        ..
+        if not xbmcplugin.addDirectoryItem(int(sys.argv[1]), 'F:\\Trailers\\300.mov', listitem, totalItems=50): break
+        ..
+    """
+    return True
+
+
+def addDirectoryItems(handle: int,
+                      items: List[Tuple[str,  'xbmcgui.ListItem',  bool]],
+                      totalItems: int = 0) -> bool:
+    """
+    Callback function to pass directory contents back to Kodi as a list.
+
+    :param handle: integer - handle the plugin was started with.
+    :param items: List - list of (url, listitem[, isFolder]) as a tuple to add.
+    :param totalItems: [opt] integer - total number of items that will be passed.(used for
+        progressbar)
+    :return: Returns a bool for successful completion.
+
+    Large lists benefit over using the standard `addDirectoryItem()`. You may call
+    this more than once to add items in chunks.
+
+    Example::
+
+        ..
+        if not xbmcplugin.addDirectoryItems(int(sys.argv[1]), [(url, listitem, False,)]: raise
+        ..
+    """
+    return True
+
+
+def endOfDirectory(handle: int,
+                   succeeded: bool = True,
+                   updateListing: bool = False,
+                   cacheToDisc: bool = True) -> None:
+    """
+    Callback function to tell Kodi that the end of the directory listing in a
+    virtualPythonFolder module is reached.
+
+    :param handle: integer - handle the plugin was started with.
+    :param succeeded: [opt] bool - True=script completed successfully(Default)/False=Script
+        did not.
+    :param updateListing: [opt] bool - True=this folder should update the current
+        listing/False=Folder is a subfolder(Default).
+    :param cacheToDisc: [opt] bool - True=Folder will cache if extended
+        time(default)/False=this folder will never cache to disc.
+
+    Example::
+
+        ..
+        xbmcplugin.endOfDirectory(int(sys.argv[1]), cacheToDisc=False)
+        ..
+    """
+    pass
+
+
+def setResolvedUrl(handle: int,
+                   succeeded: bool,
+                   listitem: 'xbmcgui.ListItem') -> None:
+    """
+    Callback function to tell Kodi that the file plugin has been resolved to a url
+
+    :param handle: integer - handle the plugin was started with.
+    :param succeeded: bool - True=script completed successfully/False=Script did not.
+    :param listitem: ListItem - item the file plugin resolved to for playback.
+
+    Example::
+
+        ..
+        xbmcplugin.setResolvedUrl(int(sys.argv[1]), True, listitem)
+        ..
+    """
+    pass
+
+
+def addSortMethod(handle: int,
+                  sortMethod: int,
+                  labelMask: str = "",
+                  label2Mask: str = "") -> None:
+    """
+    @brief \python_func{ xbmcplugin.addSortMethod(handle, sortMethod
+    [,labelMask, label2Mask]) }Adds a sorting method for the media list.
+
+    :param handle: integer - handle the plugin was started with.
+    :param sortMethod: integer - see available sort methods at the bottom (or see SortUtils).
+
+    =================================================================== ================================================
+    Value                                                               Description                                             
+    =================================================================== ================================================
+    xbmcplugin.SORT_METHOD_NONE                                         Do not sort                                             
+    xbmcplugin.SORT_METHOD_LABEL                                        Sort by label                                           
+    xbmcplugin.SORT_METHOD_LABEL_IGNORE_THE                             Sort by the label and ignore "The" before               
+    xbmcplugin.SORT_METHOD_DATE                                         Sort by the date                                        
+    xbmcplugin.SORT_METHOD_SIZE                                         Sort by the size                                        
+    xbmcplugin.SORT_METHOD_FILE                                         Sort by the file                                        
+    xbmcplugin.SORT_METHOD_DRIVE_TYPE                                   Sort by the drive type                                  
+    xbmcplugin.SORT_METHOD_TRACKNUM                                     Sort by the track number                                
+    xbmcplugin.SORT_METHOD_DURATION                                     Sort by the duration                                    
+    xbmcplugin.SORT_METHOD_TITLE                                        Sort by the title                                       
+    xbmcplugin.SORT_METHOD_TITLE_IGNORE_THE                             Sort by the title and ignore "The" before               
+    xbmcplugin.SORT_METHOD_ARTIST                                       Sort by the artist                                      
+    xbmcplugin.SORT_METHOD_ARTIST_IGNORE_THE                            Sort by the artist and ignore "The" before              
+    xbmcplugin.SORT_METHOD_ALBUM                                        Sort by the album                                       
+    xbmcplugin.SORT_METHOD_ALBUM_IGNORE_THE                             Sort by the album and ignore "The" before               
+    xbmcplugin.SORT_METHOD_GENRE                                        Sort by the genre                                       
+    xbmcplugin.SORT_SORT_METHOD_VIDEO_YEAR, xbmcplugin.SORT_METHOD_YEAR Sort by the year                                        
+    xbmcplugin.SORT_METHOD_VIDEO_RATING                                 Sort by the video rating                                
+    xbmcplugin.SORT_METHOD_PROGRAM_COUNT                                Sort by the program count                               
+    xbmcplugin.SORT_METHOD_PLAYLIST_ORDER                               Sort by the playlist order                              
+    xbmcplugin.SORT_METHOD_EPISODE                                      Sort by the episode                                     
+    xbmcplugin.SORT_METHOD_VIDEO_TITLE                                  Sort by the video title                                 
+    xbmcplugin.SORT_METHOD_VIDEO_SORT_TITLE                             Sort by the video sort title                            
+    xbmcplugin.SORT_METHOD_VIDEO_SORT_TITLE_IGNORE_THE                  Sort by the video sort title and ignore
+                                                                        "The" before
+    xbmcplugin.SORT_METHOD_PRODUCTIONCODE                               Sort by the production code                             
+    xbmcplugin.SORT_METHOD_SONG_RATING                                  Sort by the song rating                                 
+    xbmcplugin.SORT_METHOD_MPAA_RATING                                  Sort by the mpaa rating                                 
+    xbmcplugin.SORT_METHOD_VIDEO_RUNTIME                                Sort by video runtime                                   
+    xbmcplugin.SORT_METHOD_STUDIO                                       Sort by the studio                                      
+    xbmcplugin.SORT_METHOD_STUDIO_IGNORE_THE                            Sort by the studio and ignore "The" before              
+    xbmcplugin.SORT_METHOD_UNSORTED                                     Use list not sorted                                     
+    xbmcplugin.SORT_METHOD_BITRATE                                      Sort by the bitrate                                     
+    xbmcplugin.SORT_METHOD_LISTENERS                                    Sort by the listeners                                   
+    xbmcplugin.SORT_METHOD_COUNTRY                                      Sort by the country                                     
+    xbmcplugin.SORT_METHOD_DATEADDED                                    Sort by the added date                                  
+    xbmcplugin.SORT_METHOD_FULLPATH                                     Sort by the full path name                              
+    xbmcplugin.SORT_METHOD_LABEL_IGNORE_FOLDERS                         Sort by the label names and ignore related
+                                                                        folder names
+    xbmcplugin.SORT_METHOD_LASTPLAYED                                   Sort by last played date                                
+    xbmcplugin.SORT_METHOD_PLAYCOUNT                                    Sort by the play count                                  
+    xbmcplugin.SORT_METHOD_CHANNEL                                      Sort by the channel                                     
+    xbmcplugin.SORT_METHOD_DATE_TAKEN                                   Sort by the taken date                                  
+    xbmcplugin.SORT_METHOD_VIDEO_USER_RATING                            Sort by the rating of the user of video                 
+    xbmcplugin.SORT_METHOD_SONG_USER_RATING                             Sort by the rating of the user of song                  
+    =================================================================== ================================================
+
+    :param labelMask: [opt] string - the label mask to use for the first label.  applies to:
+
+    ========================== ======================= 
+    sortMethod                 labelMask               
+    ========================== ======================= 
+    SORT_METHOD_TRACKNUM       Defaults to``[%N. ]%T`` 
+    SORT_METHOD_EPISODE        Defaults to``%H. %T``   
+    SORT_METHOD_PRODUCTIONCODE Defaults to``%H. %T``   
+    All other sort methods     Defaults to``%T``       
+    ========================== ======================= 
+
+    :param label2Mask: [opt] string - the label mask to use for the second label. Defaults
+        to``%D``  applies to:
+
+    ================================ ==================== =======================================
+    SORT_METHOD_NONE                 SORT_METHOD_UNSORTED SORT_METHOD_VIDEO_TITLE                 
+    SORT_METHOD_TRACKNUM             SORT_METHOD_FILE     SORT_METHOD_TITLE                       
+    SORT_METHOD_TITLE_IGNORE_THE     SORT_METHOD_LABEL    SORT_METHOD_LABEL_IGNORE_THE            
+    SORT_METHOD_VIDEO_SORT_TITLE     SORT_METHOD_FULLPATH SORT_METHOD_VIDEO_SORT_TITLE_IGNORE_THE 
+    SORT_METHOD_LABEL_IGNORE_FOLDERS SORT_METHOD_CHANNEL                                          
+    ================================ ==================== ======================================= 
+
+    .. note::
+        to add multiple sort methods just call the method multiple times.
+
+    @python_v13 Added new sort **SORT_METHOD_DATE_TAKEN**, **SORT_METHOD_COU
+    NTRY**, **SORT_METHOD_DATEADDED**, **SORT_METHOD_FULLPATH**, **SORT_METHO
+    D_LABEL_IGNORE_FOLDERS**, **SORT_METHOD_LASTPLAYED**, **SORT_METHOD_PLAY
+    COUNT**, **SORT_METHOD_CHANNEL**.
+
+    @python_v17 Added new sort **SORT_METHOD_VIDEO_USER_RATING**.
+
+    @python_v19 Added new option **labelMask**.
+
+    Example::
+
+        ..
+        xbmcplugin.addSortMethod(int(sys.argv[1]), xbmcplugin.SORTMETHOD_DATEADDED)
+        ..
+    """
+    pass
+
+
+def getSetting(handle: int, id: str) -> str:
+    """
+    Returns the value of a setting as a string.
+
+    :param handle: integer - handle the plugin was started with.
+    :param id: string - id of the setting that the module needs to access.
+    :return: Setting value as string
+
+    .. note::
+        You can use the above as a keyword.
+
+    Example::
+
+        ..
+        apikey = xbmcplugin.getSetting(int(sys.argv[1]), 'apikey')
+        ..
+    """
+    return ""
+
+
+def setSetting(handle: int, id: str, value: str) -> None:
+    """
+    Sets a plugin setting for the current running plugin.
+
+    :param handle: integer - handle the plugin was started with.
+    :param id: string - id of the setting that the module needs to access.
+    :param value: string or unicode - value of the setting.
+
+    Example::
+
+        ..
+        xbmcplugin.setSetting(int(sys.argv[1]), id='username', value='teamxbmc')
+        ..
+    """
+    pass
+
+
+def setContent(handle: int, content: str) -> None:
+    """
+    Sets the plugins content.
+
+    :param handle: integer - handle the plugin was started with.
+    :param content: string - content type (eg. movies)
+
+    Available content strings
+
+    ====== ======= ======== ===========
+    files  songs   artists  albums      
+    movies tvshows episodes musicvideos 
+    videos images  games                
+    ====== ======= ======== =========== 
+
+    Use **videos** for all videos which do not apply to the more specific mentioned
+    ones like "movies", "episodes" etc. A good example is youtube.
+
+    @python_v18 Added new **games** contentExample::
+
+        ..
+        xbmcplugin.setContent(int(sys.argv[1]), 'movies')
+        ..
+    """
+    pass
+
+
+def setPluginCategory(handle: int, category: str) -> None:
+    """
+    Sets the plugins name for skins to display.
+
+    :param handle: integer - handle the plugin was started with.
+    :param category: string or unicode - plugins sub category.
+
+    Example::
+
+        ..
+        xbmcplugin.setPluginCategory(int(sys.argv[1]), 'Comedy')
+        ..
+    """
+    pass
+
+
+def setPluginFanart(handle: int,
+                    image: Optional[str] = None,
+                    color1: Optional[str] = None,
+                    color2: Optional[str] = None,
+                    color3: Optional[str] = None) -> None:
+    """
+    Sets the plugins fanart and color for skins to display.
+
+    :param handle: integer - handle the plugin was started with.
+    :param image: [opt] string - path to fanart image.
+    :param color1: [opt] hexstring - color1. (e.g. '0xFFFFFFFF')
+    :param color2: [opt] hexstring - color2. (e.g. '0xFFFF3300')
+    :param color3: [opt] hexstring - color3. (e.g. '0xFF000000')
+
+    Example::
+
+        ..
+        xbmcplugin.setPluginFanart(int(sys.argv[1]), 'special://home/addons/plugins/video/Apple movie trailers II/fanart.png',
+                                   color2='0xFFFF3300')
+        ..
+    """
+    pass
+
+
+def setProperty(handle: int, key: str, value: str) -> None:
+    """
+    Sets a container property for this plugin.
+
+    :param handle: integer - handle the plugin was started with.
+    :param key: string - property name.
+    :param value: string or unicode - value of property.
+
+    .. note::
+        Key is NOT case sensitive.
+
+    Example::
+
+        ..
+        xbmcplugin.setProperty(int(sys.argv[1]), 'Emulator', 'M.A.M.E.')
+        ..
+    """
+    pass
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py
new file mode 100644
index 00000000000..bd68cdda33b
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py
@@ -0,0 +1,542 @@
+# This file is generated from Kodi source code and post-edited
+# to correct code style and docstrings formatting.
+# License: GPL v.3 <https://www.gnu.org/licenses/gpl-3.0.en.html>
+"""
+**Virtual file system functions on Kodi.**
+
+Offers classes and functions offers access to the Virtual File Server (VFS)
+which you can use to manipulate files and folders.
+"""
+from typing import Union, List, Tuple, Optional
+
+__kodistubs__ = True
+
+
+class File:
+    """
+    **Kodi's file class.**
+
+    :param filepath: string Selected file path
+    :param mode: [opt] string Additional mode options (if no mode is supplied, the
+        default is Open for Read).
+
+    ==== ============== 
+    Mode Description    
+    ==== ============== 
+    w    Open for write 
+    ==== ============== 
+
+    @python_v19 Added context manager support
+
+    Example::
+
+        ..
+        f = xbmcvfs.File(file, 'w')
+        ..
+
+    Example (v19 and up)::
+
+        ..
+        with xbmcvfs.File(file, 'w') as f:
+            ..
+            ..
+    """
+    
+    def __init__(self, filepath: str, mode: Optional[str] = None) -> None:
+        pass
+
+    def __enter__(self) -> 'File':  # Required for context manager
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):  # Required for context manager
+        pass
+    
+    def read(self, numBytes: int = 0) -> str:
+        """
+        Read file parts as string.
+
+        :param bytes: [opt] How many bytes to read - if not set it will read the whole file
+        :return: string
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file)
+            b = f.read()
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file) as file:
+                b = f.read()
+                ..
+        """
+        return ""
+    
+    def readBytes(self, numBytes: int = 0) -> bytearray:
+        """
+        Read bytes from file.
+
+        :param numbytes: How many bytes to read [opt]- if not set it will read the whole file
+        :return: bytearray
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file)
+            b = f.readBytes()
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file) as f:
+                b = f.readBytes()
+                ..
+        """
+        return bytearray()
+    
+    def write(self, buffer: Union[str,  bytes,  bytearray]) -> bool:
+        """
+        To write given data in file.
+
+        :param buffer: Buffer to write to file
+        :return: True on success.
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file, 'w')
+            result = f.write(buffer)
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file, 'w') as f:
+                result = f.write(buffer)
+                ..
+        """
+        return True
+    
+    def size(self) -> int:
+        """
+        Get the file size.
+
+        :return: The file size
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file)
+            s = f.size()
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file) as f:
+                s = f.size()
+                ..
+        """
+        return 0
+    
+    def seek(self, seekBytes: int, iWhence: int = 0) -> int:
+        """
+        Seek to position in file.
+
+        :param seekBytes: position in the file
+        :param iWhence: [opt] where in a file to seek from[0 beginning, 1 current , 2 end
+            position]
+
+        @python_v19 Function changed. param **iWhence** is now optional.
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file)
+            result = f.seek(8129, 0)
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file) as f:
+                result = f.seek(8129, 0)
+                ..
+        """
+        return 0
+    
+    def tell(self) -> int:
+        """
+        Get the current position in the file.
+
+        :return: The file position
+
+        @python_v19 New function added
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file)
+            s = f.tell()
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file) as f:
+                s = f.tell()
+                ..
+        """
+        return 0
+    
+    def close(self) -> None:
+        """
+        Close opened file.
+
+        Example::
+
+            ..
+            f = xbmcvfs.File(file)
+            f.close()
+            ..
+
+        Example (v19 and up)::
+
+            ..
+            with xbmcvfs.File(file) as f:
+                ..
+                ..
+        """
+        pass
+    
+
+class Stat:
+    """
+    **Get file or file system status.**
+
+    These class return information about a file. Execute (search) permission is
+    required on all of the directories in path that lead to the file.
+
+    :param path: [string] file or folder
+
+    @python_v12 New function added
+
+    Example::
+
+        ..
+        st = xbmcvfs.Stat(path)
+        modified = st.st_mtime()
+        ..
+    """
+    
+    def __init__(self, path: str) -> None:
+        pass
+    
+    def st_mode(self) -> int:
+        """
+        To get file protection.
+
+        :return: st_mode
+        """
+        return 0
+    
+    def st_ino(self) -> int:
+        """
+        To get inode number.
+
+        :return: st_ino
+        """
+        return 0
+    
+    def st_dev(self) -> int:
+        """
+        To get ID of device containing file.
+
+        The st_dev field describes the device on which this file resides.
+
+        :return: st_dev
+        """
+        return 0
+    
+    def st_nlink(self) -> int:
+        """
+        To get number of hard links.
+
+        :return: st_nlink
+        """
+        return 0
+    
+    def st_uid(self) -> int:
+        """
+        To get user ID of owner.
+
+        :return: st_uid
+        """
+        return 0
+    
+    def st_gid(self) -> int:
+        """
+        To get group ID of owner.
+
+        :return: st_gid
+        """
+        return 0
+    
+    def st_size(self) -> int:
+        """
+        To get total size, in bytes.
+
+        The st_size field gives the size of the file (if it is a regular file or a
+        symbolic link) in bytes. The size of a symbolic link (only on Linux and Mac OS X)
+        is the length of the pathname it contains, without a terminating null byte.
+
+        :return: st_size
+        """
+        return 0
+    
+    def st_atime(self) -> int:
+        """
+        To get time of last access.
+
+        :return: st_atime
+        """
+        return 0
+    
+    def st_mtime(self) -> int:
+        """
+        To get time of last modification.
+
+        :return: st_mtime
+        """
+        return 0
+    
+    def st_ctime(self) -> int:
+        """
+        To get time of last status change.
+
+        :return: st_ctime
+        """
+        return 0
+    
+
+def copy(strSource: str, strDestination: str) -> bool:
+    """
+    Copy file to destination, returns true/false.
+
+    :param source: file to copy.
+    :param destination: destination file
+    :return: True if successed
+
+    Example::
+
+        ..
+        success = xbmcvfs.copy(source, destination)
+        ..
+    """
+    return True
+
+
+def delete(file: str) -> bool:
+    """
+    Delete a file
+
+    :param file: File to delete
+    :return: True if successed
+
+    Example::
+
+        ..
+        xbmcvfs.delete(file)
+        ..
+    """
+    return True
+
+
+def rename(file: str, newFile: str) -> bool:
+    """
+    Rename a file
+
+    :param file: File to rename
+    :param newFileName: New filename, including the full path
+    :return: True if successed
+
+    .. note::
+        Moving files between different filesystem (eg. local to nfs://) is
+        not possible on all platforms. You may have to do it manually by
+        using the copy and deleteFile functions.
+
+    Example::
+
+        ..
+        success = xbmcvfs.rename(file,newFileName)
+        ..
+    """
+    return True
+
+
+def exists(path: str) -> bool:
+    """
+    Check for a file or folder existence
+
+    :param path: File or folder (folder must end with slash or backslash)
+    :return: True if successed
+
+    Example::
+
+        ..
+        success = xbmcvfs.exists(path)
+        ..
+    """
+    return True
+
+
+def makeLegalFilename(filename: str) -> str:
+    """
+    Returns a legal filename or path as a string.
+
+    :param filename: string - filename/path to make legal
+    :return: Legal filename or path as a string
+
+    .. note::
+        The returned value is platform-specific. This is due to the fact
+        that the chars that need to be replaced to make a path legal
+        depend on the underlying OS filesystem. This is useful, for
+        example, if you want to create a file or folder based on data over
+        which you have no control (e.g. an external API).
+
+    @python_v19 New function added (replaces old **xbmc.makeLegalFilename**)
+
+    Example::
+
+        ..
+        # windows
+        >> xbmcvfs.makeLegalFilename('C://Trailers/Ice Age: The Meltdown.avi')
+        C:\Trailers\Ice Age_ The Meltdown.avi
+        # non-windows
+        >> xbmcvfs.makeLegalFilename("///\\jk???lj????.mpg")
+        /jk___lj____.mpg
+        ..
+    """
+    return ""
+
+
+def translatePath(path: str) -> str:
+    """
+    Returns the translated path.
+
+    :param path: string - Path to format
+    :return: Translated path
+
+    .. note::
+        Only useful if you are coding for both Linux and Windows. e.g.
+        Converts 'special://home' -> '/home/[username]/.kodi' on Linux.
+
+    @python_v19 New function added (replaces old **xbmc.translatePath**)
+
+    Example::
+
+        ..
+        fpath = xbmcvfs.translatePath('special://home')
+        ..
+    """
+    return ""
+
+
+def validatePath(path: str) -> str:
+    """
+    Returns the validated path.
+
+    :param path: string - Path to format
+    :return: Validated path
+
+    .. note::
+        The result is platform-specific. Only useful if you are coding for
+        multiple platfforms for fixing slash problems (e.g. Corrects
+        'Z://something' -> 'Z:\something').
+
+    @python_v19 New function added (replaces old **xbmc.validatePath**)
+
+    Example::
+
+        ..
+        fpath = xbmcvfs.validatePath(somepath)
+        ..
+    """
+    return ""
+
+
+def mkdir(path: str) -> bool:
+    """
+    Create a folder.
+
+    :param path: Folder to create
+    :return: True if successed
+
+    Example::
+
+        ..
+        success = xbmcvfs.mkdir(path)
+        ..
+    """
+    return True
+
+
+def mkdirs(path: str) -> bool:
+    """
+    Make all directories along the path
+
+    Create folder(s) - it will create all folders in the path.
+
+    :param path: Folders to create
+    :return: True if successed
+
+    Example::
+
+        ..
+        success = xbmcvfs.mkdirs(path)
+        ..
+    """
+    return True
+
+
+def rmdir(path: str, force: bool = False) -> bool:
+    """
+    Remove a folder.
+
+    :param path: string - Folder to remove
+    :param force: [opt] bool - Force directory removal (default False). This can be
+        useful if the directory is not empty.
+    :return: bool - True if successful, False otherwise
+
+    Example::
+
+        ..
+        success = xbmcvfs.rmdir(path)
+        ..
+    """
+    return True
+
+
+def listdir(path: str) -> Tuple[List[str], List[str]]:
+    """
+    Lists content of a folder.
+
+    :param path: Folder to get list from
+    :return: Directory content list
+
+    Example::
+
+        ..
+        dirs, files = xbmcvfs.listdir(path)
+        ..
+    """
+    return [""], [""]
From ff983994c9aabea3bf074f27e11d6e8953c1a543 Mon Sep 17 00:00:00 2001
From: Timothy D Witham <twitham@sbcglobal.net>
Date: Fri, 12 Jan 2024 00:56:44 -0600
Subject: [PATCH] MythMusic: patch Kodistubs to work with CU LRC

---
 .../metadata/Music/lyrics/Kodistubs/xbmc.py   |  3 +++
 .../Music/lyrics/Kodistubs/xbmcaddon.py       |  6 ++++-
 .../Music/lyrics/Kodistubs/xbmcgui.py         |  8 ++++++-
 .../Music/lyrics/Kodistubs/xbmcvfs.py         | 22 ++++++++++++++-----
 4 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py
index 27438224eac..fa1e70e36e7 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmc.py
@@ -3532,6 +3532,9 @@ def log(msg: str, level: int = LOGDEBUG) -> None:
         xbmc.log(msg='This is a test string.', level=xbmc.LOGDEBUG);
         ..
     """
+    # for MythTV, simply send debugging messages to stderr
+    import sys
+    print("debug=%s %s" % (level, msg), file=sys.stderr)
     pass
 
 
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py
index d4c7803fbbf..cc6b92bf4a4 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcaddon.py
@@ -58,7 +58,11 @@ def getLocalizedString(self, id: int) -> str:
             locstr = self.Addon.`getLocalizedString`(32000)
             ..
         """
-        return ""
+        # for MythTV, testall/scrapertest needs only 1 message from
+        # resources/language/resource.language.en_us/strings.po
+        if (id == 32163):
+            return "Testing: %s"
+        return "(%s)" % id
     
     def getSettings(self) -> 'Settings':
         """
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py
index e63c3f8287d..53c451ca635 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcgui.py
@@ -9,6 +9,9 @@
 """
 from typing import Union, List, Dict, Tuple, Optional
 
+# for MythtTV, show "dialog" on stderr
+import sys
+
 __kodistubs__ = True
 
 ACTION_ANALOG_FORWARD = 113
@@ -2935,6 +2938,7 @@ def create(self, heading: str, message: str = "") -> None:
             pDialog.create('Kodi', 'Initializing script...')
             ..
         """
+        print("\tDIALOG created: ", heading, " : ", message, file=sys.stderr)
         pass
     
     def update(self, percent: int, message: str = "") -> None:
@@ -2956,6 +2960,7 @@ def update(self, percent: int, message: str = "") -> None:
             pDialog.update(25, 'Importing modules...')
             ..
         """
+        print("\tDIALOG updated %s: " % percent, message, file=sys.stderr)
         pass
     
     def close(self) -> None:
@@ -2982,7 +2987,8 @@ def iscanceled(self) -> bool:
             if (pDialog.iscanceled()): return
             ..
         """
-        return True
+        # for MythTV, not cancelled is needed to continue the scrapertest.py
+        return False
     
 
 class DialogProgressBG:
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py
index bd68cdda33b..2604f5bd508 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/Kodistubs/xbmcvfs.py
@@ -43,7 +43,11 @@ class File:
     """
     
     def __init__(self, filepath: str, mode: Optional[str] = None) -> None:
-        pass
+        self.filename = filepath
+        if mode:
+            self.fh = open(filepath, mode)
+        else:
+            self.fh = open(filepath, "rb")
 
     def __enter__(self) -> 'File':  # Required for context manager
         return self
@@ -73,7 +77,9 @@ def read(self, numBytes: int = 0) -> str:
                 b = f.read()
                 ..
         """
-        return ""
+        if numBytes:
+            return self.fh.read(numBytes)
+        return self.fh.read()
     
     def readBytes(self, numBytes: int = 0) -> bytearray:
         """
@@ -97,7 +103,9 @@ def readBytes(self, numBytes: int = 0) -> bytearray:
                 b = f.readBytes()
                 ..
         """
-        return bytearray()
+        if numBytes:
+            return bytearray(self.fh.read(numBytes))
+        return bytearray(self.fh.read())
     
     def write(self, buffer: Union[str,  bytes,  bytearray]) -> bool:
         """
@@ -171,7 +179,7 @@ def seek(self, seekBytes: int, iWhence: int = 0) -> int:
                 result = f.seek(8129, 0)
                 ..
         """
-        return 0
+        return self.fh.seek(seekBytes, iWhence);
     
     def tell(self) -> int:
         """
@@ -196,7 +204,7 @@ def tell(self) -> int:
                 s = f.tell()
                 ..
         """
-        return 0
+        return self.fh.tell()
     
     def close(self) -> None:
         """
@@ -216,6 +224,7 @@ def close(self) -> None:
                 ..
                 ..
         """
+        self.fh.close()
         pass
     
 
@@ -396,7 +405,8 @@ def exists(path: str) -> bool:
         success = xbmcvfs.exists(path)
         ..
     """
-    return True
+    # for musixmatchlrc.py the test must work or return False
+    return False
 
 
 def makeLegalFilename(filename: str) -> str:
From 00c2467914f91b28e09760f902ec5dad4fed12a6 Mon Sep 17 00:00:00 2001
From: Timothy D Witham <twitham@sbcglobal.net>
Date: Fri, 12 Jan 2024 01:02:16 -0600
Subject: [PATCH] MythMusic: wrap CU LRC grabbers to MythMusic interface

./common/main.py implements the CLI needed for MythTV via a slightly
modified ./Kodistubs.  So only 20 lines of metadata per grabber is
needed in the top directory.  These files then import only a
LyricsFetcher from ./lib/culrcscrapers or from ./common for any
additional grabbers like filelyrics.py.

Result: all of CU LRC can be used unmodified!
---
 .../scripts/metadata/Music/lyrics/README      |  48 ++-
 .../scripts/metadata/Music/lyrics/azlyrics.py |  22 ++
 .../lyrics/{ => broken-scrapers}/alsong.py    |   0
 .../lyrics/{ => broken-scrapers}/baidu.py     |   2 +-
 .../lyrics/{ => broken-scrapers}/gomaudio.py  |   2 +-
 .../{ => broken-scrapers}/lyricswiki.py       |   0
 .../lyrics/{ => broken-scrapers}/ttplayer.py  |   0
 .../metadata/Music/lyrics/common/__init__.py  |   6 +-
 .../metadata/Music/lyrics/common/audiofile.py |   2 +-
 .../Music/lyrics/common/filelyrics.py         |  46 +++
 .../metadata/Music/lyrics/common/main.py      | 143 ++++++++
 .../metadata/Music/lyrics/common/testall.py   |  15 +
 .../metadata/Music/lyrics/darklyrics.py       | 264 ++-------------
 .../scripts/metadata/Music/lyrics/embedlrc.py | 314 +++---------------
 .../metadata/Music/lyrics/filelyrics.py       | 182 ++--------
 .../scripts/metadata/Music/lyrics/genius.py   | 220 ++----------
 .../scripts/metadata/Music/lyrics/lrclib.py   |  22 ++
 .../metadata/Music/lyrics/lyricscom.py        | 216 ++----------
 .../metadata/Music/lyrics/lyricsify.py        |  22 ++
 .../metadata/Music/lyrics/lyricsmode.py       | 219 ++----------
 .../metadata/Music/lyrics/megalobiz.py        |  25 ++
 .../scripts/metadata/Music/lyrics/music163.py |  25 ++
 .../metadata/Music/lyrics/musixmatch.py       |  22 ++
 .../metadata/Music/lyrics/musixmatchlrc.py    |  25 ++
 .../metadata/Music/lyrics/supermusic.py       |  22 ++
 25 files changed, 582 insertions(+), 1282 deletions(-)
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/azlyrics.py
 rename mythtv/programs/scripts/metadata/Music/lyrics/{ => broken-scrapers}/alsong.py (100%)
 rename mythtv/programs/scripts/metadata/Music/lyrics/{ => broken-scrapers}/baidu.py (98%)
 rename mythtv/programs/scripts/metadata/Music/lyrics/{ => broken-scrapers}/gomaudio.py (99%)
 rename mythtv/programs/scripts/metadata/Music/lyrics/{ => broken-scrapers}/lyricswiki.py (100%)
 rename mythtv/programs/scripts/metadata/Music/lyrics/{ => broken-scrapers}/ttplayer.py (100%)
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/common/filelyrics.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/common/main.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/common/testall.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lrclib.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/lyricsify.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/megalobiz.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/music163.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/musixmatch.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/musixmatchlrc.py
 create mode 100644 mythtv/programs/scripts/metadata/Music/lyrics/supermusic.py

diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/README b/mythtv/programs/scripts/metadata/Music/lyrics/README
index b1b5d6d9dc4..a25af4af3ad 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/README
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/README
@@ -1,10 +1,20 @@
-Lyrics Grabbers
-===============
+Lyrics Grabbers for MythMusic of MythTV
+=======================================
 
 You can add your own grabbers to this directory and MythMusic will
 automatically use them so long as they comply with the other grabbers.
 
-The grabber should support these command line options :-
+The included grabbers are sourced from the CU LRC Kodi addon:
+
+        https://gitlab.com/ronie/script.cu.lrclyrics
+
+./common/main.py implements the below CLI translation to MythTV via a
+slightly modified ./Kodistubs.  So only 20 lines of metadata per
+grabber is needed in this directory.  These files then import only a
+LyricsFetcher from ./lib/culrcscrapers or from ./common for any
+additional grabbers like filelyrics.py.
+
+The grabber should support these command line options:
 
 Options:
   -h, --help            show this help message and exit
@@ -87,18 +97,34 @@ Options:
 
 
 
-Current Grabbers, Their Priority And Whether Synchronized
-=========================================================
+Grabbers as/of 2024/01, Their Priority And Whether Synchronized
+===============================================================
+
+        Local
+
+EmbeddedLyrics   50    Yes/No
+FileLyrics       90    Yes/No
+
+        CU LRC
+
+musixmatchlrc   100     Yes     NEW in v34
+lrclib          110     Yes     NEW in v34
+lyricsify       130     Yes     NEW in v34
+genius          200     No
+musixmatch      210     No      NEW in v34
+lyricsmode      220     No
+azlyrics        230     No      NEW in v34
+lyricscom       240     No
+supermusic      250     No      NEW in v34
+darklyrics      260     No
+megalobiz       400     Yes     (too slow to be earlier, was 140)
+music163        500     Yes     (returns incomplete results, was 120)
+
+        old/non-working grabbers are moved to ./broken-scrapers
 
-EmbeddedLyrics 100  Yes/No
-FileLyrics     105  Yes/No
 TTPlayer       110  Yes
 Alsong         120  Yes
 LetsSingIt     130  No
-LyricsCom      140  No
 LyricsWiki     150  No
-Genius         160  No
-LyricsMode     170  No
-DarkLyrics     180  No
 GomAudio       200  Yes
 Baidu          210  Yes
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/azlyrics.py b/mythtv/programs/scripts/metadata/Music/lyrics/azlyrics.py
new file mode 100644
index 00000000000..245da48886e
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/azlyrics.py
@@ -0,0 +1,22 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.azlyrics.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'azlyrics.py'
+
+info['name']        = 'AZLyrics'
+info['description'] = 'Search https://azlyrics.com for lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '230'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = False
+
+info['artist']      = 'La Dispute'
+info['title']       = 'Such Small Hands'
+info['album']       = ''
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/alsong.py b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/alsong.py
similarity index 100%
rename from mythtv/programs/scripts/metadata/Music/lyrics/alsong.py
rename to mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/alsong.py
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/baidu.py b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/baidu.py
similarity index 98%
rename from mythtv/programs/scripts/metadata/Music/lyrics/baidu.py
rename to mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/baidu.py
index 1efe23ae3d6..ab4af70a587 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/baidu.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/baidu.py
@@ -104,7 +104,7 @@ def buildVersion():
     etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
 
     utilities.log(True, etree.tostring(version, encoding='UTF-8', pretty_print=True,
-                                    xml_declaration=True))
+                                       xml_declaration=True).decode())
     sys.exit(0)
 
 def main():
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/gomaudio.py b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/gomaudio.py
similarity index 99%
rename from mythtv/programs/scripts/metadata/Music/lyrics/gomaudio.py
rename to mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/gomaudio.py
index b1277a3cbe6..f98eb6523f8 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/gomaudio.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/gomaudio.py
@@ -148,7 +148,7 @@ def buildVersion():
     etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
 
     utilities.log(True, etree.tostring(version, encoding='UTF-8', pretty_print=True,
-                                       xml_declaration=True))
+                                       xml_declaration=True).decode())
     sys.exit(0)
 
 def main():
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lyricswiki.py b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/lyricswiki.py
similarity index 100%
rename from mythtv/programs/scripts/metadata/Music/lyrics/lyricswiki.py
rename to mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/lyricswiki.py
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/ttplayer.py b/mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/ttplayer.py
similarity index 100%
rename from mythtv/programs/scripts/metadata/Music/lyrics/ttplayer.py
rename to mythtv/programs/scripts/metadata/Music/lyrics/broken-scrapers/ttplayer.py
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/common/__init__.py b/mythtv/programs/scripts/metadata/Music/lyrics/common/__init__.py
index 391fdc6bbe8..ba5eaabaf30 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/common/__init__.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/common/__init__.py
@@ -1,4 +1,4 @@
-__version__ = "1.0.0"
-
-from . import utilities, audiofile
+__version__ = "2.0.0"
 
+# not used in 2024/01? -twitham
+# from . import utilities, audiofile
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/common/audiofile.py b/mythtv/programs/scripts/metadata/Music/lyrics/common/audiofile.py
index 43d12c06ecc..e9af10bf069 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/common/audiofile.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/common/audiofile.py
@@ -1,4 +1,4 @@
-# -*- Mode: python; coding: utf-8; tab-width: 8; indent-tabs-mode: t; -*-
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
 """
 read audio stream from audio file
 """
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/common/filelyrics.py b/mythtv/programs/scripts/metadata/Music/lyrics/common/filelyrics.py
new file mode 100644
index 00000000000..4ed827c4c37
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/common/filelyrics.py
@@ -0,0 +1,46 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+"""
+Scraper for file lyrics
+"""
+
+import sys, os, re, chardet
+from optparse import OptionParser
+from lib.utils import *
+from common import *
+
+__title__       = "FileLyrics"
+__description__ = "Search the same directory as the track for lyrics"
+__author__      = "Paul Harrison"
+__version__     = "2.0"
+__priority__    = "90"
+__lrc__         = True
+
+class LyricsFetcher:
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s - %s" % (__title__, song.artist, song.album, song.title), debug=self.DEBUG)
+        lyrics = Lyrics(settings=self.settings)
+        lyrics.song = song
+        lyrics.source = __title__
+        lyrics.lrc = __lrc__
+
+        filename = song.filepath
+        filename = os.path.splitext(filename)[0]
+
+        # look for a file ending in .lrc with the same filename as the track minus the extension
+        lyricFile = filename + '.lrc'
+        log("%s: searching for lyrics file: %s " % (__title__, lyricFile), debug=self.DEBUG)
+        if os.path.exists(lyricFile) and os.path.isfile(lyricFile):
+            #load the text file
+            with open (lyricFile, "r") as f:
+                lines = f.readlines()
+
+            for line in lines:
+                lyrics.lyrics += line
+
+            return lyrics
+
+        return False
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/common/main.py b/mythtv/programs/scripts/metadata/Music/lyrics/common/main.py
new file mode 100644
index 00000000000..67f1122c57d
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/common/main.py
@@ -0,0 +1,143 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+"""
+Wrapper for using CU LRC scrapers with MythMusic of MythTV
+
+ronie, Paul Harrison, Tim Witham
+"""
+
+# simulate kodi/xbmc via slightly modified Kodistubs.
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)) + '/../Kodistubs')
+from lib.utils import *
+from optparse import OptionParser
+
+debug = False
+
+lyricssettings = {}
+lyricssettings['debug'] = ADDON.getSettingBool('log_enabled')
+lyricssettings['save_filename_format'] = ADDON.getSettingInt('save_filename_format')
+lyricssettings['save_lyrics_path'] = ADDON.getSettingString('save_lyrics_path')
+lyricssettings['save_subfolder'] = ADDON.getSettingBool('save_subfolder')
+lyricssettings['save_subfolder_path'] = ADDON.getSettingString('save_subfolder_path')
+
+def performSelfTest():
+    try:
+        from bs4 import BeautifulSoup
+    except:
+        log("Failed to import BeautifulSoup. This grabber requires python-bs4", debug=True)
+        sys.exit(1)
+
+    found = False
+    song = Song(opt=lyricssettings)
+    song.artist = about.get('artist')
+    song.title = about.get('title')
+    song.album = about.get('album')
+    song.filepath = about.get('filename')
+
+    fetcher = LyricsFetcher(settings=lyricssettings, debug=True)
+    lyrics = fetcher.get_lyrics(song)
+
+    if lyrics:
+        if debug:
+            print(lyrics.lyrics)
+        try:
+            buildLyrics(song, lyrics)
+        except:
+            log("Failed to build lyrics xml file. "
+                "Maybe you don't have lxml installed?", debug=True)
+            sys.exit(1)
+
+        log("Everything appears in order.", debug=True)
+        sys.exit(0)
+
+    log("Failed to find the lyrics for the test search!", debug=True)
+    sys.exit(1)
+
+def buildLyrics(song, lyrics):
+    from lxml import etree
+    xml = etree.XML(u'<lyrics></lyrics>')
+    etree.SubElement(xml, "artist").text = song.artist
+    etree.SubElement(xml, "album").text = song.album
+    etree.SubElement(xml, "title").text = song.title
+    etree.SubElement(xml, "syncronized").text = 'True' if about['syncronized'] else 'False'
+    etree.SubElement(xml, "grabber").text = about['name']
+
+    lines = lyrics.lyrics.splitlines()
+    for line in lines:
+        etree.SubElement(xml, "lyric").text = line
+    
+    print(etree.tostring(xml, encoding='UTF-8',
+                         pretty_print=True, xml_declaration=True).decode())
+
+def buildVersion():
+    from lxml import etree
+    xml = etree.XML(u'<grabber></grabber>')
+    etree.SubElement(xml, "name").text = about['name']
+    etree.SubElement(xml, "author").text = about['author']
+    etree.SubElement(xml, "command").text = about['command']
+    etree.SubElement(xml, "type").text = 'lyrics'
+    etree.SubElement(xml, "description").text = about['description']
+    etree.SubElement(xml, "priority").text = about['priority']
+    etree.SubElement(xml, "syncronized").text = 'True' if about['syncronized'] else 'False'
+
+    print(etree.tostring(xml, encoding='UTF-8',
+                         pretty_print=True, xml_declaration=True).decode())
+    sys.exit(0)
+
+def main(info, fetcher):
+    global debug
+    global about
+    about = info
+    global LyricsFetcher
+    LyricsFetcher = fetcher
+
+    parser = OptionParser()
+
+    parser.add_option('-v', "--version", action="store_true", default=False,
+                      dest="version", help="Display version and author")
+    parser.add_option('-t', "--test", action="store_true", default=False,
+                      dest="test", help="Test grabber with a known good search")
+    parser.add_option('-s', "--search", action="store_true", default=False,
+                      dest="search", help="Search for lyrics.")
+    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
+                      dest="artist", help="Artist of track.")
+    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
+                      dest="album", help="Album of track.")
+    parser.add_option('-n', "--title", metavar="TITLE", default=None,
+                      dest="title", help="Title of track.")
+    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
+                      dest="filename", help="Filename of track.")
+    parser.add_option('-d', '--debug', action="store_true", default=False,
+                      dest="debug", help=("Show debug messages"))
+
+    opts, args = parser.parse_args()
+
+    song = Song(opt=lyricssettings)
+
+    if opts.debug:
+        debug = True
+
+    if opts.version:
+        buildVersion()
+
+    if opts.test:
+        performSelfTest()
+
+    if opts.artist:
+        song.artist = opts.artist
+    if opts.album:
+        song.album = opts.album
+    if opts.title:
+        song.title = opts.title
+    if opts.filename:
+        song.filepath = opts.filename
+
+    fetcher = LyricsFetcher(settings=lyricssettings, debug=debug)
+    lyrics = fetcher.get_lyrics(song)
+    if lyrics:
+        buildLyrics(song, lyrics)
+        sys.exit(0)
+    else:
+        log("No lyrics found for this track", debug=True)
+        sys.exit(1)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/common/testall.py b/mythtv/programs/scripts/metadata/Music/lyrics/common/testall.py
new file mode 100644
index 00000000000..3d9b871c9d6
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/common/testall.py
@@ -0,0 +1,15 @@
+#-*- coding: utf-8 -*-
+
+# simulate kodi/xbmc via slightly modified Kodistubs.
+import os
+import sys
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)) + '/../Kodistubs')
+sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)) + '/..')
+
+from lib.scrapertest import *
+
+def main():
+    test_scrapers();
+        
+if __name__ == '__main__':
+    main()
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/darklyrics.py b/mythtv/programs/scripts/metadata/Music/lyrics/darklyrics.py
index e2c6bc94550..789dd5fd5ca 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/darklyrics.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/darklyrics.py
@@ -1,246 +1,22 @@
-#-*- coding: UTF-8 -*-
-"""
-Scraper for http://www.darklyrics.com/ - the largest metal lyrics archive on the Web.
-
-scraper by smory
-"""
-
-import hashlib
-import math
-from urllib.request import Request, urlopen
-from urllib.parse import quote
-import re
-import time
-import chardet
-import sys
-from optparse import OptionParser
-from common import utilities
-
-__author__      = "Paul Harrison and smory'"
-__title__       = "DarkLyrics"
-__description__ = "Search http://www.darklyrics.com/ - the largest metal lyrics archive on the Web"
-__priority__    = "180"
-__version__     = "0.2"
-__syncronized__ = False
-
-debug = False
-
-class LyricsFetcher:
-
-    def __init__( self ):
-        self.base_url = "http://www.darklyrics.com/"
-        self.searchUrl = "http://www.darklyrics.com/search?q=%term%"
-        self.cookie = self.getCookie()
-
-    def getCookie(self):
-         # http://www.darklyrics.com/tban.js
-         lastvisitts = str(int(math.ceil(time.time() * 1000 / (60 * 60 * 6 * 1000))))
-         lastvisittscookie = 0
-         for i in range(len(lastvisitts)):
-             lastvisittscookie = ((lastvisittscookie << 5) - lastvisittscookie) + ord(lastvisitts[i])
-             lastvisittscookie = lastvisittscookie & lastvisittscookie
-         return str(lastvisittscookie)
-
-    def search(self, artist, title):
-        term = quote((artist if artist else "") + " " + (title if title else ""))
-
-        try:
-            headers = {'user-agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0'}
-            cookies={'lastvisitts': self.cookie}
-            request = Request(self.searchUrl.replace("%term%", term))
-            request.add_header('User-Agent', headers['user-agent'])
-            request.add_header("Cookie", "lastvisitts=%s"% self.cookie)
-            content = urlopen(request, timeout=10)
-            searchResponse = content.read()
-        except:
-            return None
-
-        searchResult = re.findall(rb"<h2><a\shref=\"(.*?#([0-9]+))\".*?>(.*?)</a></h2>", searchResponse)
-
-        if len(searchResult) == 0:
-            return None
-
-        links = []
-
-        i = 0
-        for result in searchResult:
-            a = []
-            a.append(result[2] + ( b" " + self.getAlbumName(self.base_url + result[0].decode('utf-8') )if i < 6 else b"")) # title from server + album nane
-            a.append(self.base_url + result[0].decode('utf-8'))  # url with lyrics
-            a.append(artist)
-            a.append(title)
-            a.append(result[1]) # id of the side part containing this song lyrics
-            links.append(a)
-            i += 1
-
-        return links
-
-    def findLyrics(self, url, index):
-        try:
-            request = urlopen(url)
-            res = request.read()
-        except:
-            return None
-
-        pattern = rb"<a\sname=\"%index%\">(.*?)(?:<h3>|<div)"  # require multi line and dot all mode
-        pattern = pattern.replace(b"%index%", index)
-
-        match = re.search(pattern, res, re.MULTILINE | re.DOTALL)
-        if match:
-            s = match.group(1)
-            s = s.replace(b"<br />", b"")
-            s = s.replace(b"<i>", b"")
-            s = s.replace(b"</i>", b"")
-            s = s.replace(b"</a>", b"")
-            s = s.replace(b"</h3>", b"")
-            return s
-        else:
-            return None
-
-    def getAlbumName(self, url):
-        try:
-            request = urlopen(url)
-            res = request.read()
-        except:
-            return b""
-
-        match = re.search(rb"<h2>(?:album|single|ep|live):?\s?(.*?)</h2>", res, re.IGNORECASE)
-
-        if match:
-            ret = (b"(" + match.group(1) + b")").replace(b"\"", b"")
-        else:
-            ret = b""
-        return(ret)
-
-
-    def get_lyrics(self, lyrics):
-        utilities.log(debug, "%s: searching lyrics for %s - %s - %s" % (__title__, lyrics.artist, lyrics.album, lyrics.title))
-        links = self.search(lyrics.artist, lyrics.title)
-
-        if(links == None or len(links) == 0):
-            return False
-        elif len(links) > 1:
-            lyrics.list = links
-
-        lyr = self.get_lyrics_from_list(links[0])
-        if not lyr:
-            return False
-
-        enc = chardet.detect(lyr)
-        lyr = lyr.decode(enc['encoding'], 'ignore')
-        lyrics.lyrics = lyr
-        return True
-
-    def get_lyrics_from_list(self, link):
-        title, url, artist, song, index = link
-        return self.findLyrics(url, index)
-
-def performSelfTest():
-    found = False
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-    lyrics.artist = 'Dagon'
-    lyrics.album = 'Terraphobic'
-    lyrics.title = 'Cut To The Heart'
-
-    fetcher = LyricsFetcher()
-    found = fetcher.get_lyrics(lyrics)
-
-    if found:
-        utilities.log(True, "Everything appears in order.")
-        buildLyrics(lyrics)
-        sys.exit(0)
-
-    utilities.log(True, "The lyrics for the test search failed!")
-    sys.exit(1)
-
-def buildLyrics(lyrics):
-    from lxml import etree
-    xml = etree.XML(u'<lyrics></lyrics>')
-    etree.SubElement(xml, "artist").text = lyrics.artist
-    etree.SubElement(xml, "album").text = lyrics.album
-    etree.SubElement(xml, "title").text = lyrics.title
-    etree.SubElement(xml, "syncronized").text = 'True' if __syncronized__ else 'False'
-    etree.SubElement(xml, "grabber").text = lyrics.source
-
-    lines = lyrics.lyrics.splitlines()
-    for line in lines:
-        line2 = re.sub(u'[^\u0020-\uD7FF\u0009\u000A\u000D\uE000-\uFFFD\u10000-\u10FFFF]+', '', line)
-        etree.SubElement(xml, "lyric").text = line2
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(xml, encoding='UTF-8',
-                                      pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def buildVersion():
-    from lxml import etree
-    version = etree.XML(u'<grabber></grabber>')
-    etree.SubElement(version, "name").text = __title__
-    etree.SubElement(version, "author").text = __author__
-    etree.SubElement(version, "command").text = 'darklyrics.py'
-    etree.SubElement(version, "type").text = 'lyrics'
-    etree.SubElement(version, "description").text = __description__
-    etree.SubElement(version, "version").text = __version__
-    etree.SubElement(version, "priority").text = __priority__
-    etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(version, encoding='UTF-8',
-                                      pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def main():
-    global debug
-
-    parser = OptionParser()
-
-    parser.add_option('-v', "--version", action="store_true", default=False,
-                      dest="version", help="Display version and author")
-    parser.add_option('-t', "--test", action="store_true", default=False,
-                      dest="test", help="Test grabber with a know good search")
-    parser.add_option('-s', "--search", action="store_true", default=False,
-                      dest="search", help="Search for lyrics.")
-    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
-                      dest="artist", help="Artist of track.")
-    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
-                      dest="album", help="Album of track.")
-    parser.add_option('-n', "--title", metavar="TITLE", default=None,
-                      dest="title", help="Title of track.")
-    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
-                      dest="filename", help="Filename of track.")
-    parser.add_option('-d', '--debug', action="store_true", default=False,
-                      dest="debug", help=("Show debug messages"))
-    opts, args = parser.parse_args()
-
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-
-    if opts.debug:
-        debug = True
-
-    if opts.version:
-        buildVersion()
-
-    if opts.test:
-        performSelfTest()
-
-    if opts.artist:
-        lyrics.artist = opts.artist
-    if opts.album:
-        lyrics.album = opts.album
-    if opts.title:
-        lyrics.title = opts.title
-    if opts.filename:
-        lyrics.filename = opts.filename
-
-    fetcher = LyricsFetcher()
-    if fetcher.get_lyrics(lyrics):
-        buildLyrics(lyrics)
-        sys.exit(0)
-    else:
-        utilities.log(True, "No lyrics found for this track")
-        sys.exit(1)
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.darklyrics.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'darklyrics.py'
+
+info['name']        = 'DarkLyrics'
+info['description'] = "Search http://www.darklyrics.com/ - the largest metal lyrics archive on the Web"
+info['author']      = "Paul Harrison and smory"
+info['priority']    = '260'     # 180 in v33-
+info['version']     = '2.0'
+info['syncronized'] = False
+
+info['artist']      = 'Neurosis'
+info['title']       = 'Lost'
+info['album']       = ''
 
 if __name__ == '__main__':
-    main()
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/embedlrc.py b/mythtv/programs/scripts/metadata/Music/lyrics/embedlrc.py
index d80e028aa57..a946b5899ee 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/embedlrc.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/embedlrc.py
@@ -1,271 +1,49 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-# ----------------------
-"""
-Scraper for embedded lyrics
-"""
-
-import sys, os, re, chardet
-import xml.dom.minidom as xml
-from optparse import OptionParser
-from common import utilities
-
-__author__      = "Paul Harrison and 'ronin'"
-__title__       = "EmbeddedLyrics"
-__description__ = "Search tracks tag for embedded lyrics"
-__version__     = "0.2"
-__priority__    = "100"
-__syncronized__ = True
-
-debug = False
-
-def getLyrics3(filename):
-    #Get lyrics embed with Lyrics3/Lyrics3V2 format
-    #See: http://id3.org/Lyrics3
-    #http://id3.org/Lyrics3v2
-
-    utilities.log(debug, "%s: trying %s" % (__title__, "lyrics embed with Lyrics3/Lyrics3V2 format"))
-
-    f = File(filename)
-    f.seek(-128-9, os.SEEK_END)
-    buf = f.read(9)
-    if (buf != "LYRICS200" and buf != "LYRICSEND"):
-        f.seek(-9, os.SEEK_END)
-        buf = f.read(9)
-    if (buf == "LYRICSEND"):
-        """ Find Lyrics3v1 """
-        f.seek(-5100-9-11, os.SEEK_CUR)
-        buf = f.read(5100+11)
-        f.close();
-        start = buf.find("LYRICSBEGIN")
-    elif (buf == "LYRICS200"):
-        """ Find Lyrics3v2 """
-        f.seek(-9-6, os.SEEK_CUR)
-        size = int(f.read(6))
-        f.seek(-size-6, os.SEEK_CUR)
-        buf = f.read(11)
-        if(buf == "LYRICSBEGIN"):
-            buf = f.read(size-11)
-            tags=[]
-            while buf!= '':
-                tag = buf[:3]
-                length = int(buf[3:8])
-                content = buf[8:8+length]
-                if (tag == 'LYR'):
-                    return content
-                buf = buf[8+length:]
-    f.close();
-    return None
-
-def endOfString(string, utf16=False):
-    if (utf16):
-        pos = 0
-        while True:
-            pos += string[pos:].find('\x00\x00') + 1
-            if (pos % 2 == 1):
-                return pos - 1
-    else:
-        return string.find('\x00')
-
-def ms2timestamp(ms):
-    mins = "0%s" % int(ms/1000/60)
-    sec = "0%s" % int((ms/1000)%60)
-    msec = "0%s" % int((ms%1000)/10)
-    timestamp = "[%s:%s.%s]" % (mins[-2:],sec[-2:],msec[-2:])
-    return timestamp
-
-# Uses the high level interface in taglib to find the lyrics
-# should work with all the tag formats supported by taglib that can have lyrics
-def getLyricsGeneric(filename):
-    try:
-        import taglib
-    except:
-        utilities.log(True, "Failed to import taglib. This grabber requires "
-                            "pytaglib TagLib bindings for Python. "
-                            "https://github.com/supermihi/pytaglib")
-        return None
-
-    try:
-        utilities.log(debug, "%s: trying to open %s" % (__title__, filename))
-        f = taglib.File(filename)
-
-        # see if we can find a lyrics tag
-        for tag in f.tags:
-            if tag.startswith('LYRICS'):
-                return f.tags[tag][0]
-
-        return None
-    except:
-        return None
-
-# Get USLT/SYLT/TXXX lyrics embed with ID3v2 format
-# See: http://id3.org/id3v2.3.0
-def getID3Lyrics(filename):
-    utilities.log(debug, "%s: trying %s" % (__title__, "lyrics embed with ID3v2 format"))
-
-    # just use the generic taglib method for now
-    return getLyricsGeneric(filename)
-
-def getFlacLyrics(filename):
-    utilities.log(debug, "%s: trying %s" % (__title__, "lyrics embed with Flac format"))
-
-    # just use the generic taglib method for now
-    return getLyricsGeneric(filename)
-
-def getMP4Lyrics(filename):
-    utilities.log(debug, "%s: trying %s" % (__title__, "lyrics embed with MP4 format"))
-
-    # just use the generic taglib method for now
-    return getLyricsGeneric(filename)
-
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+import os
+from common import main
+from               lib.embedlrc import *
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'embedlrc.py'
+
+info['name']        = '*EmbeddedLyrics'
+info['description'] = 'Search track tags for embedded lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '50'      # first, before filelyrics
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'Robb Benson'
+info['title']       = 'Lone Rock'
+info['album']       = 'Demo Tracks'
+info['filename']    = os.path.dirname(os.path.abspath(__file__)) + '/examples/taglyrics.mp3'
+
+#  lib/embedlrc.py has no LyricsFetcher, so we create it here:
 class LyricsFetcher:
-
-
-    def get_lyrics(self, lyrics):
-        utilities.log(debug, "%s: searching lyrics for %s - %s - %s" % (__title__, lyrics.artist, lyrics.album, lyrics.title))
-
-        filename = lyrics.filename
-
-        ext = os.path.splitext(filename)[1].lower()
-        lry = None
-
-        try:
-            if ext == '.mp3':
-                lry = getLyrics3(filename)
-        except:
-            pass
-
-        if lry:
-            enc = chardet.detect(lry)
-            lyrics.lyrics = lry.decode(enc['encoding'])
-        else:
-            if ext == '.mp3':
-                lry = getID3Lyrics(filename)
-            elif  ext == '.flac':
-                lry = getFlacLyrics(filename)
-            elif  ext == '.m4a':
-                lry = getMP4Lyrics(filename)
-            if not lry:
-                return False
-            lyrics.lyrics = lry
-
-        return True
-
-
-def performSelfTest():
-    try:
-        import taglib
-    except:
-        utilities.log(True, "Failed to import taglib. This grabber requires "
-                            "pytaglib ? TagLib bindings for Python. "
-                            "https://github.com/supermihi/pytaglib")
-        sys.exit(1)
-
-    found = False
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-    lyrics.artist = 'Robb Benson'
-    lyrics.album = 'Demo Tracks'
-    lyrics.title = 'Lone Rock'
-    lyrics.filename = os.path.dirname(os.path.abspath(__file__)) + '/examples/taglyrics.mp3'
-    fetcher = LyricsFetcher()
-    found = fetcher.get_lyrics(lyrics)
-
-    if found:
-        utilities.log(True, "Everything appears in order.")
-        buildLyrics(lyrics)
-        sys.exit(0)
-
-    utilities.log(True, "The lyrics for the test search failed!")
-    sys.exit(1)
-
-def buildLyrics(lyrics):
-    from lxml import etree
-    xml = etree.XML(u'<lyrics></lyrics>')
-    etree.SubElement(xml, "artist").text = lyrics.artist
-    etree.SubElement(xml, "album").text = lyrics.album
-    etree.SubElement(xml, "title").text = lyrics.title
-    etree.SubElement(xml, "syncronized").text = 'True' if __syncronized__ else 'False'
-    etree.SubElement(xml, "grabber").text = lyrics.source
-
-    lines = lyrics.lyrics.splitlines()
-    for line in lines:
-        etree.SubElement(xml, "lyric").text = line
-
-    utilities.log(True,  utilities.convert_etree(etree.tostring(xml, encoding='UTF-8',
-                                                 pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def buildVersion():
-    from lxml import etree
-    version = etree.XML(u'<grabber></grabber>')
-    etree.SubElement(version, "name").text = __title__
-    etree.SubElement(version, "author").text = __author__
-    etree.SubElement(version, "command").text = 'alsong.py'
-    etree.SubElement(version, "type").text = 'lyrics'
-    etree.SubElement(version, "description").text = __description__
-    etree.SubElement(version, "version").text = __version__
-    etree.SubElement(version, "priority").text = __priority__
-    etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
-
-    utilities.log(True,  utilities.convert_etree(etree.tostring(version, encoding='UTF-8',
-                                                 pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def main():
-    global debug
-
-    parser = OptionParser()
-
-    parser.add_option('-v', "--version", action="store_true", default=False,
-                      dest="version", help="Display version and author")
-    parser.add_option('-t', "--test", action="store_true", default=False,
-                      dest="test", help="Perform self-test for dependencies.")
-    parser.add_option('-s', "--search", action="store_true", default=False,
-                      dest="search", help="Search for lyrics.")
-    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
-                      dest="artist", help="Artist of track.")
-    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
-                      dest="album", help="Album of track.")
-    parser.add_option('-n', "--title", metavar="TITLE", default=None,
-                      dest="title", help="Title of track.")
-    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
-                      dest="filename", help="Filename of track.")
-    parser.add_option('-d', '--debug', action="store_true", default=False,
-                      dest="debug", help=("Show debug messages"))
-
-    opts, args = parser.parse_args()
-
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-
-    if opts.debug:
-        debug = True
-
-    if opts.version:
-        buildVersion()
-
-    if opts.test:
-        performSelfTest()
-
-    if opts.artist:
-        lyrics.artist = opts.artist
-    if opts.album:
-        lyrics.album = opts.album
-    if opts.title:
-        lyrics.title = opts.title
-    if opts.filename:
-        lyrics.filename = opts.filename
-
-    fetcher = LyricsFetcher()
-    if fetcher.get_lyrics(lyrics):
-        buildLyrics(lyrics)
-        sys.exit(0)
-    else:
-        utilities.log(True, "No lyrics found for this track")
-        sys.exit(1)
+    def __init__(self, *args, **kwargs):
+        self.DEBUG = kwargs['debug']
+        self.settings = kwargs['settings']
+
+    def get_lyrics(self, song):
+        log("%s: searching lyrics for %s - %s"
+            % (info['name'], song.artist, song.title), debug=self.DEBUG)
+        log("%s: searching file %s"
+            % (info['name'], song.filepath), debug=self.DEBUG)
+        log("%s: searching for SYNCHRONIZED lyrics"
+            % info['name'], debug=self.DEBUG)
+        lrc = getEmbedLyrics(song, True, main.lyricssettings)
+        if lrc:
+            return lrc
+        log("%s: searching for NON-synchronized lyrics"
+            % info['name'], debug=self.DEBUG)
+        lrc = getEmbedLyrics(song, False, main.lyricssettings)
+        if lrc:
+            return lrc
+        return None
 
 if __name__ == '__main__':
-    main()
+    main.main(info, LyricsFetcher)
+
+# most of the code moved to lib/embedlrc.py and common/main.py
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/filelyrics.py b/mythtv/programs/scripts/metadata/Music/lyrics/filelyrics.py
index 5d24df3d773..9e6a53b40fb 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/filelyrics.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/filelyrics.py
@@ -1,160 +1,26 @@
-#!/usr/bin/env python
-# -*- coding: UTF-8 -*-
-# ----------------------
-"""
-Scraper for file lyrics
-"""
-
-import sys, os, re, chardet
-import xml.dom.minidom as xml
-from optparse import OptionParser
-from common import *
-
-__author__      = "Paul Harrison"
-__title__       = "FileLyrics"
-__description__ = "Search the same directory as the track for lyrics"
-__version__     = "0.1"
-__priority__    = "105"
-__syncronized__ = True
-
-debug = False
-
-
-class LyricsFetcher:
-
-
-    def get_lyrics(self, lyrics):
-        utilities.log(debug, "%s: searching lyrics for %s - %s - %s" % (__title__, lyrics.artist, lyrics.album, lyrics.title))
-
-        filename = lyrics.filename
-        filename = os.path.splitext(filename)[0]
-
-        # look for a file ending in .lrc with the same filename as the track minus the extension
-        lyricFile = filename + '.lrc'
-        utilities.log(debug, "%s: searching for lyrics file: %s " % (__title__, lyricFile))
-        if os.path.exists(lyricFile) and os.path.isfile(lyricFile):
-            #load the text file
-            with open (lyricFile, "r") as f:
-                lines = f.readlines()
-
-            for line in lines:
-                lyrics.lyrics += line
-
-            return True
-
-        return False;
-
-def performSelfTest():
-    found = False
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-    lyrics.artist = 'Robb Benson'
-    lyrics.album = 'Demo Tracks'
-    lyrics.title = 'Lone Rock'
-    lyrics.filename = os.path.dirname(os.path.abspath(__file__)) + '/examples/filelyrics.mp3'
-    fetcher = LyricsFetcher()
-    found = fetcher.get_lyrics(lyrics)
-
-    if found:
-        try:
-            buildLyrics(lyrics)
-        except:
-            utilities.log(True, "Failed to build lyrics xml file. "
-                                "Maybe you don't have lxml installed?")
-            sys.exit(1)
-
-        utilities.log(True, "Everything appears in order.")
-        sys.exit(0)
-
-    utilities.log(True, "Failed to find the lyrics for the test search!")
-    sys.exit(1)
-
-def buildLyrics(lyrics):
-    from lxml import etree
-    xml = etree.XML(u'<lyrics></lyrics>')
-    etree.SubElement(xml, "artist").text = lyrics.artist
-    etree.SubElement(xml, "album").text = lyrics.album
-    etree.SubElement(xml, "title").text = lyrics.title
-    etree.SubElement(xml, "syncronized").text = 'True' if __syncronized__ else 'False'
-    etree.SubElement(xml, "grabber").text = lyrics.source
-
-    lines = lyrics.lyrics.splitlines()
-    for line in lines:
-        etree.SubElement(xml, "lyric").text = line
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(xml, encoding='UTF-8',
-                                      pretty_print=True, xml_declaration=True)))
-
-def buildVersion():
-    from lxml import etree
-    version = etree.XML(u'<grabber></grabber>')
-    etree.SubElement(version, "name").text = __title__
-    etree.SubElement(version, "author").text = __author__
-    etree.SubElement(version, "command").text = 'alsong.py'
-    etree.SubElement(version, "type").text = 'lyrics'
-    etree.SubElement(version, "description").text = __description__
-    etree.SubElement(version, "version").text = __version__
-    etree.SubElement(version, "priority").text = __priority__
-    etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(version, encoding='UTF-8',
-                                      pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def main():
-    global debug
-
-    parser = OptionParser()
-
-    parser.add_option('-v', "--version", action="store_true", default=False,
-                      dest="version", help="Display version and author")
-    parser.add_option('-t', "--test", action="store_true", default=False,
-                      dest="test", help="Perform self-test for dependencies.")
-    parser.add_option('-s', "--search", action="store_true", default=False,
-                      dest="search", help="Search for lyrics.")
-    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
-                      dest="artist", help="Artist of track.")
-    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
-                      dest="album", help="Album of track.")
-    parser.add_option('-n', "--title", metavar="TITLE", default=None,
-                      dest="title", help="Title of track.")
-    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
-                      dest="filename", help="Filename of track.")
-    parser.add_option('-d', '--debug', action="store_true", default=False,
-                      dest="debug", help=("Show debug messages"))
-
-    opts, args = parser.parse_args()
-
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-
-    if opts.debug:
-        debug = True
-
-    if opts.version:
-        buildVersion()
-
-    if opts.test:
-        performSelfTest()
-
-    if opts.artist:
-        lyrics.artist = opts.artist
-    if opts.album:
-        lyrics.album = opts.album
-    if opts.title:
-        lyrics.title = opts.title
-    if opts.filename:
-        lyrics.filename = opts.filename
-
-    fetcher = LyricsFetcher()
-    if fetcher.get_lyrics(lyrics):
-        buildLyrics(lyrics)
-        sys.exit(0)
-    else:
-        utilities.log(True, "No lyrics found for this track")
-        sys.exit(1)
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+import os
+from common import main
+from            common.filelyrics import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'filelyrics.py'
+
+info['name']        = '*FileLyrics'
+info['description'] = 'Search the same directory as the track for lyrics'
+info['author']      = "Paul Harrison"
+info['priority']    = '90'	# before all remote web scrapers 100+
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'Robb Benson'
+info['title']       = 'Lone Rock'
+info['album']       = 'Demo Tracks'
+info['filename']    = os.path.dirname(os.path.abspath(__file__)) + '/examples/filelyrics.mp3'
 
 if __name__ == '__main__':
-    main()
+    main.main(info, LyricsFetcher)
+
+# most of the code moved to common/filelyrics.py and common/main.py
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/genius.py b/mythtv/programs/scripts/metadata/Music/lyrics/genius.py
index fa212aad872..df83882c350 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/genius.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/genius.py
@@ -1,200 +1,24 @@
-#-*- coding: UTF-8 -*-
-"""
-Scraper for http://www.genius.com
-
-taxigps
-"""
-import sys
-from urllib.request import urlopen, Request
-from urllib.parse import quote
-from html import parser as html_parser
-try:
-    # may be necessary for python 3.10
-    import html
-except:
-    pass
-import socket
-import re
-from hashlib import md5
-import difflib
-from optparse import OptionParser
-from common import utilities
-
-import json
-
-__author__      = "Paul Harrison and ronie'"
-__title__       = "Genius"
-__description__ = "Search http://www.genius.com for lyrics"
-__priority__    = "160"
-__version__     = "0.1"
-__syncronized__ = False
-
-
-debug = False
-
-socket.setdefaulttimeout(10)
-
-class LyricsFetcher:
-    def __init__( self ):
-        self.url = 'http://api.genius.com/search?q=%s%s%s&access_token=7pTrhwtmyQmccHoJX8HjXpYmyAdkbe19x5sjvwkf1UEIQTrPeXEm6LgylJi9GiPO'
-
-    def get_lyrics(self, lyrics):
-        utilities.log(debug, "%s: searching lyrics for %s - %s - %s" % (__title__, lyrics.artist, lyrics.album, lyrics.title))
-
-        try:
-            request = Request(self.url % (quote(lyrics.artist), '%20', quote(lyrics.title)))
-            request.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; rv:77.0) Gecko/20100101 Firefox/77.0')
-            req = urlopen(request)
-            response = req.read().decode('utf-8')
-        except:
-            return False
-
-        req.close()
-        data = json.loads(response)
-
-        try:
-            name = data['response']['hits'][0]['result']['primary_artist']['name']
-            track = data['response']['hits'][0]['result']['title']
-            if (difflib.SequenceMatcher(None, lyrics.artist.lower(), name.lower()).ratio() > 0.8) and (difflib.SequenceMatcher(None, lyrics.title.lower(), track.lower()).ratio() > 0.8):
-                self.page = data['response']['hits'][0]['result']['url']
-            else:
-                return None
-        except:
-            return False
-
-        utilities.log(debug, "%s: search url: %s" % (__title__, self.page))
-
-        try:
-            request = Request(self.page)
-            request.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; rv:77.0) Gecko/20100101 Firefox/77.0')
-            req = urlopen(request)
-            response = req.read()
-        except:
-            return False
-
-        req.close()
-        try:
-            htmlparser = html_parser.HTMLParser()
-            response = htmlparser.unescape(response.decode('utf-8'))
-        except:
-            # may be necessary for python 3.10
-            response = html.unescape(response.decode('utf-8'))
-        matchcode = re.search(u'<div class="[lL]yrics.*?">(.*?)</div>', response, flags=re.DOTALL)
-        try:
-            lyricscode = (matchcode.group(1))
-            lyr = re.sub('<[^<]+?>', '', lyricscode)
-            lyrics.lyrics = lyr.replace('\\n','\n').strip()
-            return True
-        except:
-            return False
-
-
-def performSelfTest():
-    found = False
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-    lyrics.artist = 'Dire Straits'
-    lyrics.album = 'Brothers In Arms'
-    lyrics.title = 'Money For Nothing'
-
-    fetcher = LyricsFetcher()
-    found = fetcher.get_lyrics(lyrics)
-
-    if found:
-        utilities.log(True, "Everything appears in order.")
-        buildLyrics(lyrics)
-        sys.exit(0)
-
-    utilities.log(True, "The lyrics for the test search failed!")
-    sys.exit(1)
-
-def buildLyrics(lyrics):
-    from lxml import etree
-    xml = etree.XML(u'<lyrics></lyrics>')
-    etree.SubElement(xml, "artist").text = lyrics.artist
-    etree.SubElement(xml, "album").text = lyrics.album
-    etree.SubElement(xml, "title").text = lyrics.title
-    etree.SubElement(xml, "syncronized").text = 'True' if __syncronized__ else 'False'
-    etree.SubElement(xml, "grabber").text = lyrics.source
-
-    lines = lyrics.lyrics.splitlines()
-    for line in lines:
-        etree.SubElement(xml, "lyric").text = line
-
-    utilities.log(True,  utilities.convert_etree(etree.tostring(xml, encoding='UTF-8',
-                                                 pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def buildVersion():
-    from lxml import etree
-    version = etree.XML(u'<grabber></grabber>')
-    etree.SubElement(version, "name").text = __title__
-    etree.SubElement(version, "author").text = __author__
-    etree.SubElement(version, "command").text = 'minilyrics.py'
-    etree.SubElement(version, "type").text = 'lyrics'
-    etree.SubElement(version, "description").text = __description__
-    etree.SubElement(version, "version").text = __version__
-    etree.SubElement(version, "priority").text = __priority__
-    etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(version, encoding='UTF-8',
-                                                pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def main():
-    global debug
-
-    parser = OptionParser()
-
-    parser.add_option('-v', "--version", action="store_true", default=False,
-                      dest="version", help="Display version and author")
-    parser.add_option('-t', "--test", action="store_true", default=False,
-                      dest="test", help="Test grabber with a know good search")
-    parser.add_option('-s', "--search", action="store_true", default=False,
-                      dest="search", help="Search for lyrics.")
-    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
-                      dest="artist", help="Artist of track.")
-    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
-                      dest="album", help="Album of track.")
-    parser.add_option('-n', "--title", metavar="TITLE", default=None,
-                      dest="title", help="Title of track.")
-    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
-                      dest="filename", help="Filename of track.")
-    parser.add_option('-d', '--debug', action="store_true", default=False,
-                      dest="debug", help=("Show debug messages"))
-
-    opts, args = parser.parse_args()
-
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-
-    if opts.debug:
-        debug = True
-
-    if opts.version:
-        buildVersion()
-
-    if opts.test:
-        performSelfTest()
-
-    if opts.artist:
-        lyrics.artist = opts.artist
-    if opts.album:
-        lyrics.album = opts.album
-    if opts.title:
-        lyrics.title = opts.title
-    if opts.filename:
-        lyrics.filename = opts.filename
-
-    fetcher = LyricsFetcher()
-    if fetcher.get_lyrics(lyrics):
-        buildLyrics(lyrics)
-        sys.exit(0)
-    else:
-        utilities.log(True, "No lyrics found for this track")
-        sys.exit(1)
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.genius.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'genius.py'
+
+info['name']        = 'Genius'
+info['description'] = 'Search http://www.genius.com for lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '200'	# 160 in v33-
+info['version']     = '2.0'
+info['syncronized'] = False
+
+info['artist']      = 'Dire Straits' # v33-
+info['title']       = 'Money For Nothing'
+info['album']       = ''
+info['artist']      = 'Maren Morris' # v34+
+info['title']       = 'My Church'
 
 if __name__ == '__main__':
-    main()
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lrclib.py b/mythtv/programs/scripts/metadata/Music/lyrics/lrclib.py
new file mode 100644
index 00000000000..e3c13c9ce57
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lrclib.py
@@ -0,0 +1,22 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.lrclib.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'lrclib.py'
+
+info['name']        = '*LrcLib'
+info['description'] = 'Search https://lrclib.net for synchronized lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '110'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'CHVRCHES'
+info['title']       = 'Clearest Blue'
+info['album']       = ''
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lyricscom.py b/mythtv/programs/scripts/metadata/Music/lyrics/lyricscom.py
index 793c7919151..41b0dc9719f 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/lyricscom.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lyricscom.py
@@ -1,203 +1,25 @@
-# -*- Mode: python; coding: utf-8; tab-width: 8; indent-tabs-mode: t; -*-
-"""
-Scraper for http://www.lyrdb.com/
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
 
-ronie
-"""
+info = {}
+from common import main
+from lib.culrcscrapers.lyricscom.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'lyricscom.py'
 
-import sys
-import re
-from urllib.parse import quote_plus
-from urllib.request import urlopen
+info['name']        = 'Lyrics.Com'
+info['description'] = 'Search https://lyrics.com for lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '240'
+info['version']     = '2.0'
+info['syncronized'] = False
 
-import socket
-import difflib
-from optparse import OptionParser
-from common import utilities
+info['artist']      = 'Dire Straits' # v33-
+info['title']       = 'Money For Nothing'
+info['album']       = ''
 
-__author__      = "Paul Harrison and 'ronie'"
-__title__       = "Lyrics.Com"
-__description__ = "Search http://www.lyrics.com for lyrics"
-__priority__    = "240"
-__version__     = "0.1"
-__syncronized__ = False
-
-debug = False
-
-socket.setdefaulttimeout(10)
-
-class LyricsFetcher:
-    def __init__( self ):
-        self.url = 'http://www.lyrics.com/serp.php?st=%s&qtype=2'
-
-    def get_lyrics(self, lyrics):
-        utilities.log(debug, "%s: searching lyrics for %s - %s - %s" % (__title__, lyrics.artist, lyrics.album, lyrics.title))
-
-        try:
-            from bs4 import BeautifulSoup
-        except:
-            utilities.log(True, "Failed to import BeautifulSoup. This grabber requires python-bs4")
-            return False
-
-        try:
-            request = urlopen(self.url % quote_plus(lyrics.artist))
-            response = request.read()
-        except:
-            return False
-
-        request.close()
-        soup = BeautifulSoup(response, 'html.parser')
-        url = ''
-        for link in soup.find_all('a'):
-            if link.string and link.get('href').startswith('artist/'):
-                url = 'http://www.lyrics.com/' + link.get('href')
-                break
-        if url:
-            utilities.log(debug, "%s: Artist url is %s"  % (__title__, url))
-            try:
-                req = urlopen(url)
-                resp = req.read().decode('utf-8')
-            except:
-                return False
-            req.close()
-            soup = BeautifulSoup(resp, 'html.parser')
-            url = ''
-            for link in soup.find_all('a'):
-                if link.string and link.get('href').startswith('/lyric/') and (difflib.SequenceMatcher(None, link.string.lower(), lyrics.title.lower()).ratio() > 0.8):
-                    url = 'http://www.lyrics.com' + link.get('href')
-                    break
-
-            if url:
-                utilities.log(debug, "%s: Song url is %s"  % (__title__, url))
-
-                try:
-                    req2 = urlopen(url)
-                    resp2 = req2.read().decode('utf-8')
-                except:
-                    return False
-                req2.close()
-
-                matchcode = re.search(u'<pre.*?>(.*?)</pre>', resp2, flags=re.DOTALL)
-                if matchcode:
-                    lyricscode = (matchcode.group(1))
-                    lyr = re.sub(u'<[^<]+?>', '', lyricscode)
-                    lyrics.lyrics = lyr.replace('\\n','\n')
-                    return True
-
-            return False
-
-def performSelfTest():
-    try:
-        from bs4 import BeautifulSoup
-    except:
-        utilities.log(True, "Failed to import BeautifulSoup. This grabber requires python-bs4")
-        sys.exit(1)
-
-    found = False
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-    lyrics.artist = 'Dire Straits'
-    lyrics.album = 'Brothers In Arms'
-    lyrics.title = 'Money For Nothing'
-
-    fetcher = LyricsFetcher()
-    found = fetcher.get_lyrics(lyrics)
-
-    if found:
-        utilities.log(True, "Everything appears in order.")
-        buildLyrics(lyrics)
-        sys.exit(0)
-
-    utilities.log(True, "The lyrics for the test search failed!")
-    sys.exit(1)
-
-def buildLyrics(lyrics):
-    from lxml import etree
-    xml = etree.XML(u'<lyrics></lyrics>')
-    etree.SubElement(xml, "artist").text = lyrics.artist
-    etree.SubElement(xml, "album").text = lyrics.album
-    etree.SubElement(xml, "title").text = lyrics.title
-    etree.SubElement(xml, "syncronized").text = 'True' if __syncronized__ else 'False'
-    etree.SubElement(xml, "grabber").text = lyrics.source
-
-    lines = lyrics.lyrics.splitlines()
-    for line in lines:
-        etree.SubElement(xml, "lyric").text = line
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(xml, encoding='UTF-8',
-                                                pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def buildVersion():
-    from lxml import etree
-    version = etree.XML(u'<grabber></grabber>')
-    etree.SubElement(version, "name").text = __title__
-    etree.SubElement(version, "author").text = __author__
-    etree.SubElement(version, "command").text = 'lyricscom.py'
-    etree.SubElement(version, "type").text = 'lyrics'
-    etree.SubElement(version, "description").text = __description__
-    etree.SubElement(version, "version").text = __version__
-    etree.SubElement(version, "priority").text = __priority__
-    etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
-
-    utilities.log(True, utilities.convert_etree(etree.tostring(version, encoding='UTF-8',
-                                                pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def main():
-    global debug
-
-    parser = OptionParser()
-
-    parser.add_option('-v', "--version", action="store_true", default=False,
-                      dest="version", help="Display version and author")
-    parser.add_option('-t', "--test", action="store_true", default=False,
-                      dest="test", help="Test grabber with a know good search")
-    parser.add_option('-s', "--search", action="store_true", default=False,
-                      dest="search", help="Search for lyrics.")
-    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
-                      dest="artist", help="Artist of track.")
-    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
-                      dest="album", help="Album of track.")
-    parser.add_option('-n', "--title", metavar="TITLE", default=None,
-                      dest="title", help="Title of track.")
-    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
-                      dest="filename", help="Filename of track.")
-    parser.add_option('-d', '--debug', action="store_true", default=False,
-                      dest="debug", help=("Show debug messages"))
-
-    opts, args = parser.parse_args()
-
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-
-    if opts.debug:
-        debug = True
-
-    if opts.version:
-        buildVersion()
-
-    if opts.test:
-        performSelfTest()
-
-    if opts.artist:
-        lyrics.artist = opts.artist
-    if opts.album:
-        lyrics.album = opts.album
-    if opts.title:
-        lyrics.title = opts.title
-    if opts.filename:
-        lyrics.filename = opts.filename
-
-    fetcher = LyricsFetcher()
-    if fetcher.get_lyrics(lyrics):
-        buildLyrics(lyrics)
-        sys.exit(0)
-    else:
-        utilities.log(True, "No lyrics found for this track")
-        sys.exit(1)
+info['artist']      = 'Blur' # v34+
+info['title']       = "You're so Great"
 
 if __name__ == '__main__':
-    main()
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lyricsify.py b/mythtv/programs/scripts/metadata/Music/lyrics/lyricsify.py
new file mode 100644
index 00000000000..a4b5acd2cf3
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lyricsify.py
@@ -0,0 +1,22 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.lyricsify.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'lyricsify.py'
+
+info['name']        = '*Lyricsify'
+info['description'] = 'Search https://lyricsify.com for synchronized lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '130'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'Madonna'
+info['title']       = 'Crazy For You'
+info['album']       = ''
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/lyricsmode.py b/mythtv/programs/scripts/metadata/Music/lyrics/lyricsmode.py
index b8c6f1a7358..3c0f3e05572 100644
--- a/mythtv/programs/scripts/metadata/Music/lyrics/lyricsmode.py
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/lyricsmode.py
@@ -1,206 +1,25 @@
-#-*- coding: UTF-8 -*-
-import sys
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
 
-try:
-    from urllib import urlopen, quote_plus
-except ImportError:
-    from urllib.request import urlopen
-    from urllib.parse import quote_plus
+info = {}
+from common import main
+from lib.culrcscrapers.lyricsmode.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'lyricsmode.py'
 
-import re
-from optparse import OptionParser
-from common import utilities
+info['name']        = 'LyricsMode'
+info['description'] = 'Search http://www.lyricsmode.com for lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '220'     # 240 in v33-
+info['version']     = '2.0'
+info['syncronized'] = False
 
-__author__      = "Paul Harrison and ronie'"
-__title__       = "LyricsMode"
-__description__ = "Search http://www.lyricsmode.com for lyrics"
-__priority__    = "170"
-__version__     = "0.1"
-__syncronized__ = False
-
-debug = False
-
-class LyricsFetcher:
-    def __init__( self ):
-        self.clean_lyrics_regex = re.compile( "<.+?>" )
-        self.normalize_lyrics_regex = re.compile( "&#[x]*(?P<name>[0-9]+);*" )
-        self.clean_br_regex = re.compile( r"<br[ /]*>[\s]*", re.IGNORECASE )
-        self.search_results_regex = re.compile("<a href=\"[^\"]+\">([^<]+)</a></td>[^<]+<td><a href=\"([^\"]+)\" class=\"b\">[^<]+</a></td>", re.IGNORECASE)
-        self.next_results_regex = re.compile("<A href=\"([^\"]+)\" class=\"pages\">next .</A>", re.IGNORECASE)
-
-    def get_lyrics(self, lyrics):
-        utilities.log(debug, "%s: searching lyrics for %s - %s - %s" % (__title__, lyrics.artist, lyrics.album, lyrics.title))
-
-        artist = utilities.deAccent(lyrics.artist)
-        title = utilities.deAccent(lyrics.title)
-        try: # below is borowed from XBMC Lyrics
-            url = "http://www.lyricsmode.com/lyrics/%s/%s/%s.html" % (artist.lower()[:1], artist.lower().replace("&","and").replace(" ","_"), title.lower().replace("&","and").replace(" ","_"))
-            lyrics_found = False
-            while True:
-                utilities.log(debug, "%s: search url: %s" % (__title__, url))
-                song_search = urlopen(url).read()
-                if song_search.find("<p id=\"lyrics_text\" class=\"ui-annotatable\">") >= 0:
-                    break
-
-                if lyrics_found:
-                    # if we're here, we found the lyrics page but it didn't
-                    # contains the lyrics part (licensing issue or some bug)
-                    return False
-
-                # Let's try to use the research box if we didn't yet
-                if not 'search' in url:
-                    url = "http://www.lyricsmode.com/search.php?what=songs&s=" + quote_plus(title.lower())
-                else:
-                    # the search gave more than on result, let's try to find our song
-                    url = ""
-                    start = song_search.find('<!--output-->')
-                    end = song_search.find('<!--/output-->', start)
-                    results = self.search_results_regex.findall(song_search, start, end)
-
-                    for result in results:
-                        if result[0].lower() in artist.lower():
-                            url = "http://www.lyricsmode.com" + result[1]
-                            lyrics_found = True
-                            break
-
-                    if not url:
-                        # Is there a next page of results ?
-                        match = self.next_results_regex.search(song_search[end:])
-                        if match:
-                            url = "http://www.lyricsmode.com/search.php" + match.group(1)
-                        else:
-                            return False
-
-            lyr = song_search.split("<p id=\"lyrics_text\" class=\"ui-annotatable\">")[1].split('</p><p id=\"lyrics_text_selected\">')[0]
-            lyr = self.clean_br_regex.sub( "\n", lyr ).strip()
-            lyr = self.clean_lyrics_regex.sub( "", lyr ).strip()
-            lyr = self.normalize_lyrics_regex.sub( lambda m: unichr( int( m.group( 1 ) ) ), lyr.decode("ISO-8859-1") )
-            lir = []
-            for line in lyr.splitlines():
-                line.strip()
-                if line.find("Lyrics from:") < 0:
-                    lir.append(line)
-            lyr = u"\n".join( lir )
-            if lyr.startswith('These lyrics are missing'):
-                return False
-            lyrics.lyrics = lyr
-            return True
-        except:
-            utilities.log(True, "%s: %s::%s (%d) [%s]" % (
-                   __title__, self.__class__.__name__,
-                   sys.exc_info()[ 2 ].tb_frame.f_code.co_name,
-                   sys.exc_info()[ 2 ].tb_lineno,
-                   sys.exc_info()[ 1 ]
-                   ))
-            return False
-
-def performSelfTest():
-    found = False
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-    lyrics.artist = 'Dire Straits'
-    lyrics.album = 'Brothers In Arms'
-    lyrics.title = 'Money For Nothing'
-
-    fetcher = LyricsFetcher()
-    found = fetcher.get_lyrics(lyrics)
-
-    if found:
-        utilities.log(True, "Everything appears in order.")
-        buildLyrics(lyrics)
-        sys.exit(0)
-
-    utilities.log(True, "The lyrics for the test search failed!")
-    sys.exit(1)
-
-def buildLyrics(lyrics):
-    from lxml import etree
-    xml = etree.XML(u'<lyrics></lyrics>')
-    etree.SubElement(xml, "artist").text = lyrics.artist
-    etree.SubElement(xml, "album").text = lyrics.album
-    etree.SubElement(xml, "title").text = lyrics.title
-    etree.SubElement(xml, "syncronized").text = 'True' if __syncronized__ else 'False'
-    etree.SubElement(xml, "grabber").text = lyrics.source
-
-    lines = lyrics.lyrics.splitlines()
-    for line in lines:
-        etree.SubElement(xml, "lyric").text = line
-
-    utilities.log(True,  utilities.convert_etree(etree.tostring(xml, encoding='UTF-8',
-                                                 pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def buildVersion():
-    from lxml import etree
-    version = etree.XML(u'<grabber></grabber>')
-    etree.SubElement(version, "name").text = __title__
-    etree.SubElement(version, "author").text = __author__
-    etree.SubElement(version, "command").text = 'lyricsmode.py'
-    etree.SubElement(version, "type").text = 'lyrics'
-    etree.SubElement(version, "description").text = __description__
-    etree.SubElement(version, "version").text = __version__
-    etree.SubElement(version, "priority").text = __priority__
-    etree.SubElement(version, "syncronized").text = 'True' if __syncronized__ else 'False'
-
-    utilities.log(True,  utilities.convert_etree(etree.tostring(version, encoding='UTF-8',
-                                                 pretty_print=True, xml_declaration=True)))
-    sys.exit(0)
-
-def main():
-    global debug
-
-    parser = OptionParser()
-
-    parser.add_option('-v', "--version", action="store_true", default=False,
-                      dest="version", help="Display version and author")
-    parser.add_option('-t', "--test", action="store_true", default=False,
-                      dest="test", help="Test grabber with a know good search")
-    parser.add_option('-s', "--search", action="store_true", default=False,
-                      dest="search", help="Search for lyrics.")
-    parser.add_option('-a', "--artist", metavar="ARTIST", default=None,
-                      dest="artist", help="Artist of track.")
-    parser.add_option('-b', "--album", metavar="ALBUM", default=None,
-                      dest="album", help="Album of track.")
-    parser.add_option('-n', "--title", metavar="TITLE", default=None,
-                      dest="title", help="Title of track.")
-    parser.add_option('-f', "--filename", metavar="FILENAME", default=None,
-                      dest="filename", help="Filename of track.")
-    parser.add_option('-d', '--debug', action="store_true", default=False,
-                      dest="debug", help=("Show debug messages"))
-
-    opts, args = parser.parse_args()
-
-    lyrics = utilities.Lyrics()
-    lyrics.source = __title__
-    lyrics.syncronized = __syncronized__
-
-    if opts.debug:
-        debug = True
-
-    if opts.version:
-        buildVersion()
-
-    if opts.test:
-        performSelfTest()
-
-    if opts.artist:
-        lyrics.artist = opts.artist
-    if opts.album:
-        lyrics.album = opts.album
-    if opts.title:
-        lyrics.title = opts.title
-    if opts.filename:
-        lyrics.filename = opts.filename
-
-    fetcher = LyricsFetcher()
-    if fetcher.get_lyrics(lyrics):
-        buildLyrics(lyrics)
-        sys.exit(0)
-    else:
-        utilities.log(True, "No lyrics found for this track")
-        sys.exit(1)
+info['artist']      = 'Dire Straits' # v33-
+info['title']       = 'Money For Nothing'
+info['album']       = ''
 
+info['artist']      = 'Maren Morris' # v34+
+info['title']       = 'My Church'
 
 if __name__ == '__main__':
-    main()
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/megalobiz.py b/mythtv/programs/scripts/metadata/Music/lyrics/megalobiz.py
new file mode 100644
index 00000000000..6948d6dcf53
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/megalobiz.py
@@ -0,0 +1,25 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.megalobiz.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv too
+info['command']     = 'megalobiz.py'
+
+info['name']        = '*Megalobiz'
+info['description'] = 'Search https://megalobiz.com for synchronized lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '140'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'Michael Jackson'
+info['title']       = 'Beat It'
+info['album']       = ''
+
+# it takes 8 seconds, have to move to the end -twitham, 2024/01
+info['priority']    = '400'
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/music163.py b/mythtv/programs/scripts/metadata/Music/lyrics/music163.py
new file mode 100644
index 00000000000..13637c5edca
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/music163.py
@@ -0,0 +1,25 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.music163.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'music163.py'
+
+info['name']        = '*Music163'
+info['description'] = 'Search http://music.163.com for synchronized lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '120'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'Madonna'
+info['title']       = 'Vogue'
+info['album']       = ''
+
+# its reporting author only so I need move it last -twitham, 2024/01
+info['priority']    = '500'
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/musixmatch.py b/mythtv/programs/scripts/metadata/Music/lyrics/musixmatch.py
new file mode 100644
index 00000000000..3e28ade4863
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/musixmatch.py
@@ -0,0 +1,22 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.musixmatch.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'musixmatch.py'
+
+info['name']        = 'Musixmatch'
+info['description'] = 'Search https://musixmatch.com for lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '210'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = False
+
+info['artist']      = 'Kate Bush'
+info['title']       = 'Wuthering Heights'
+info['album']       = ''
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/musixmatchlrc.py b/mythtv/programs/scripts/metadata/Music/lyrics/musixmatchlrc.py
new file mode 100644
index 00000000000..5e190a185cd
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/musixmatchlrc.py
@@ -0,0 +1,25 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.musixmatchlrc.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'musixmatchlrc.py'
+
+info['name']        = '*Musixmatchlrc'
+info['description'] = 'Search https://musixmatch.com for synchronized lyrics'
+info['author']      = "Paul Harrison and ronie"
+info['priority']    = '100'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = True
+
+info['artist']      = 'Kate Bush'
+info['title']       = 'Wuthering Heights'
+info['album']       = ''
+
+# import os
+# LyricsFetcher.get_token.PROFILE = os.path.join(os.environ.get('HOME', '/tmp'), '.mythtv')
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
diff --git a/mythtv/programs/scripts/metadata/Music/lyrics/supermusic.py b/mythtv/programs/scripts/metadata/Music/lyrics/supermusic.py
new file mode 100644
index 00000000000..48c319f2f81
--- /dev/null
+++ b/mythtv/programs/scripts/metadata/Music/lyrics/supermusic.py
@@ -0,0 +1,22 @@
+# -*- Mode: python; coding: utf-8; indent-tabs-mode: nil; -*-
+
+info = {}
+from common import main
+from lib.culrcscrapers.supermusic.lyricsScraper import LyricsFetcher
+# make sure this-------^^^^^^^^^ matches this file's basename
+#       and this-------vvvvvvvvv one too:
+info['command']     = 'supermusic.py'
+
+info['name']        = 'Supermusic'
+info['description'] = 'Search https://supermusic.cz for lyrics'
+info['author']      = 'Jose Riha'
+info['priority']    = '250'	# not in v33-
+info['version']     = '2.0'
+info['syncronized'] = False
+
+info['artist']      = 'Karel Gott'
+info['title']       = 'Trezor'
+info['album']       = ''
+
+if __name__ == '__main__':
+    main.main(info, LyricsFetcher)
