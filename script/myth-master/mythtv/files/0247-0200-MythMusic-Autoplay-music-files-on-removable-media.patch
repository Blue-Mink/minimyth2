From 526a44c2bfa37a8561b0bec2259b93a941c21fa5 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Wed, 15 Jan 2014 19:35:22 +0000
Subject: [PATCH 200/333] MythMusic: Autoplay music files on removable media

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythplugins/mythmusic/mythmusic/main.cpp |  208 ++++++++++++++++++++++++++++--
 1 file changed, 200 insertions(+), 8 deletions(-)

diff --git a/mythplugins/mythmusic/mythmusic/main.cpp b/mythplugins/mythmusic/mythmusic/main.cpp
index bc14624..e0e6c79 100644
--- a/mythplugins/mythmusic/mythmusic/main.cpp
+++ b/mythplugins/mythmusic/mythmusic/main.cpp
@@ -8,6 +8,7 @@
 #include <QDir>
 #include <QApplication>
 #include <QRegExp>
+#include <QScopedPointer>
 
 // MythTV headers
 #include <mythcontext.h>
@@ -44,6 +45,7 @@
 #include "importsettings.h"
 #include "ratingsettings.h"
 #include "importmusic.h"
+#include "metaio.h"
 
 #ifdef HAVE_CDIO
 #include "cdrip.h"
@@ -450,15 +452,198 @@ static void showMiniPlayer(void)
         gPlayer->showMiniPlayer();
 }
 
+static QStringList GetMusicFilter()
+{
+    QStringList ret;
+    ret << "*.mp3" << "*.mp2" << "*.ogg" << "*.oga" << "*.flac";
+    ret << "*.wma" << "*.wav" << "*.ac3" << "*.oma" << "*.omg";
+    ret << "*.atp" << "*.ra"  << "*.dts" << "*.aac" << "*.m4a";
+    ret << "*.aa3" << "*.tta" << "*.mka" << "*.aiff" << "*.swa" << "*.wv";
+    return ret;
+}
+
+static QStringList BuildFileList(const QString &dir, const QStringList &filters)
+{
+    QStringList ret;
+
+    QDir d(dir);
+    if (!d.exists())
+        return ret;
+
+    d.setNameFilters(filters);
+    d.setFilter(QDir::Files       | QDir::AllDirs |
+                QDir::NoSymLinks  | QDir::Readable |
+                QDir::NoDotAndDotDot);
+    d.setSorting(QDir::Name | QDir::DirsLast);
+
+    QFileInfoList list = d.entryInfoList();
+    if (list.isEmpty())
+        return ret;
+
+    for(QFileInfoList::const_iterator it = list.begin(); it != list.end(); ++it)
+    {
+        const QFileInfo &fi = *it;
+        if (fi.isDir())
+        {
+            ret += BuildFileList(fi.absoluteFilePath(), filters);
+            qApp->processEvents();
+        }
+        else
+        {
+            ret << fi.absoluteFilePath();
+        }
+    }
+    return ret;
+}
+
 static void handleMedia(MythMediaDevice *cd)
 {
+    static QString s_mountPath;
+
     if (!cd)
         return;
 
-    // Note that we should deal with other disks that may contain music.
-    // e.g. MEDIATYPE_MMUSIC or MEDIATYPE_MIXED
-    LOG(VB_MEDIA, LOG_NOTICE, QString("Ignoring changed media event of type: %1")
-        .arg(MythMediaDevice::MediaTypeString(cd->getMediaType())));
+    if (MEDIASTAT_MOUNTED != cd->getStatus())
+    {
+        if (s_mountPath != cd->getMountPath())
+            return;
+
+        LOG(VB_MEDIA, LOG_INFO, QString(
+            "MythMusic: '%1' unmounted, clearing data").arg(cd->getVolumeID()));
+
+        if (gPlayer->isPlaying() && gPlayer->getCurrentMetadata()
+            && gPlayer->getCurrentMetadata()->isCDTrack())
+        {
+            // Now playing a track which is no longer available so stop playback
+            gPlayer->stop(true);
+        }
+
+        // device is not usable so remove any existing CD tracks
+        if (gMusicData->all_music)
+        {
+            gMusicData->all_music->clearCDData();
+            gMusicData->all_playlists->getActive()->removeAllCDTracks();
+        }
+
+        gPlayer->activePlaylistChanged(-1, false);
+        gPlayer->sendCDChangedEvent();
+
+        return;
+    }
+
+    LOG(VB_MEDIA, LOG_NOTICE, QString("MythMusic: '%1' mounted on '%2'")
+        .arg(cd->getVolumeID()).arg(cd->getMountPath()) );
+
+    s_mountPath.clear();
+
+    // don't show the music screen if AutoPlayCD is off
+    if (!gCoreContext->GetNumSetting("AutoPlayCD", 0))
+        return;
+
+    if (!gMusicData->initialized)
+        gMusicData->loadMusic();
+
+    // remove any existing CD tracks
+    if (gMusicData->all_music)
+    {
+        gMusicData->all_music->clearCDData();
+        gMusicData->all_playlists->getActive()->removeAllCDTracks();
+    }
+
+    gPlayer->sendCDChangedEvent();
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+
+    QString message = qApp->translate("(MythMusicMain)",
+                                      "Searching for music files...");
+    MythUIBusyDialog *busy = new MythUIBusyDialog( message, popupStack,
+                                                    "musicscanbusydialog");
+    if (busy->Create())
+        popupStack->AddScreen(busy, false);
+    else
+    {
+        delete busy;
+        busy = NULL;
+    }
+
+    // Search for music files
+    QStringList trackList = BuildFileList(cd->getMountPath(), GetMusicFilter());
+    LOG(VB_MEDIA, LOG_INFO, QString("MythMusic: %1 music files found")
+                                .arg(trackList.count()));
+
+    if (busy)
+        busy->Close();
+
+    if (trackList.isEmpty())
+        return;
+
+    message = qApp->translate("(MythMusicMain)", "Loading music tracks");
+    MythUIProgressDialog *progress = new MythUIProgressDialog( message,
+                                        popupStack, "scalingprogressdialog");
+    if (progress->Create())
+    {
+        popupStack->AddScreen(progress, false);
+        progress->SetTotal(trackList.count());
+    }
+    else
+    {
+        delete progress;
+        progress = NULL;
+    }
+
+    // Read track metadata and add to all_music
+    int track = 0;
+    for (QStringList::const_iterator it = trackList.begin();
+            it != trackList.end(); ++it)
+    {
+        QScopedPointer<MusicMetadata> meta(MetaIO::readMetadata(*it));
+        if (meta)
+        {
+            meta->setTrack(++track);
+            gMusicData->all_music->addCDTrack(*meta);
+        }
+        if (progress)
+        {
+            progress->SetProgress(track);
+            qApp->processEvents();
+        }
+    }
+    LOG(VB_MEDIA, LOG_INFO, QString("MythMusic: %1 tracks scanned").arg(track));
+
+    if (progress)
+        progress->Close();
+
+    // Remove all tracks from the playlist
+    gMusicData->all_playlists->getActive()->removeAllTracks();
+
+    // Create list of new tracks
+    QList<int> songList;
+    const int tracks = gMusicData->all_music->getCDTrackCount();
+    for (track = 1; track <= tracks; track++)
+    {
+        MusicMetadata *mdata = gMusicData->all_music->getCDMetadata(track);
+        if (mdata)
+            songList.append(mdata->ID());
+    }
+    if (songList.isEmpty())
+        return;
+
+    s_mountPath = cd->getMountPath();
+
+    // Add new tracks to playlist
+    gMusicData->all_playlists->getActive()->fillSonglistFromList(
+            songList, true, PL_REPLACE, 0);
+    gPlayer->setCurrentTrackPos(0);
+
+    // if there is no music screen showing then show the Playlist view
+    if (!gPlayer->hasClient())
+    {
+        // make sure we start playing from the first track
+        gCoreContext->SaveSetting("MusicBookmark", 0);
+        gCoreContext->SaveSetting("MusicBookmarkPosition", 0);
+
+        runMusicPlayback();
+    }
 }
 
 #ifdef HAVE_CDIO
@@ -468,7 +653,7 @@ static void handleCDMedia(MythMediaDevice *cd)
     if (!cd)
         return;
 
-    LOG(VB_MEDIA, LOG_NOTICE, "Got a media changed event");
+    LOG(VB_MEDIA, LOG_NOTICE, "Got a CD media changed event");
 
     QString newDevice;
 
@@ -692,11 +877,18 @@ static void setupKeys(void)
     REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
         "MythMusic Media Handler 1/2"), "", "", handleCDMedia,
         MEDIATYPE_AUDIO | MEDIATYPE_MIXED, QString::null);
+    QString filt;
+    Q_FOREACH(QString format, GetMusicFilter())
+    {
+        format.remove(0,2); // Remove "*."
+        if (filt.isEmpty())
+            filt = format;
+        else
+            filt += "," + format;
+    }
     REG_MEDIA_HANDLER(QT_TRANSLATE_NOOP("MythControls",
         "MythMusic Media Handler 2/2"), "", "", handleMedia,
-        MEDIATYPE_MMUSIC, "mp3,mp2,ogg,oga,flac,wma,wav,ac3,"
-                          "oma,omg,atp,ra,dts,aac,m4a,aa3,tta,"
-                          "mka,aiff,swa,wv");
+        MEDIATYPE_MMUSIC, filt);
 }
 
 int mythplugin_init(const char *libversion)
-- 
1.7.9.5

