From 56350fa349c3840c82318bf422cd7af3906c80d2 Mon Sep 17 00:00:00 2001
From: Lawrence Rust <lvr@softsystem.co.uk>
Date: Mon, 29 Feb 2016 19:32:30 +0000
Subject: [PATCH 310/348] MythMusic: Enable the CD ripper to run in the
 background

The user may exit the ripper status screen and return to the main UI
while the rip continues.  To check on progress select 'Import CD'
again and the ripper status screen is restored.

If the rip completes in the background then a UI notification is
shown.

Also optimise CDIO device open calls to minimise delays starting
and between tracks.

Signed-off-by: Lawrence Rust <lvr@softsystem.co.uk>
---
 mythplugins/mythmusic/mythmusic/cdrip.cpp | 1098 +++++++++++++++++------------
 mythplugins/mythmusic/mythmusic/cdrip.h   |   71 +-
 mythplugins/mythmusic/mythmusic/main.cpp  |    4 +
 3 files changed, 696 insertions(+), 477 deletions(-)

diff --git a/mythplugins/mythmusic/mythmusic/cdrip.cpp b/mythplugins/mythmusic/mythmusic/cdrip.cpp
index 3ce1b5a..69555a8 100644
--- a/mythplugins/mythmusic/mythmusic/cdrip.cpp
+++ b/mythplugins/mythmusic/mythmusic/cdrip.cpp
@@ -1,6 +1,4 @@
-// ANSI C includes
-#include <cstdio>
-#include <cstring>
+#include "cdrip.h"
 
 // Unix C includes
 #include <sys/types.h>
@@ -13,11 +11,6 @@
 # undef HAVE_SLEEP // prevent redefinition warning
 #endif //def HAVE_CDIO
 
-// C++ includes
-#include <iostream>
-#include <memory>
-using namespace std;
-
 // Qt includes
 #include <QApplication>
 #include <QDir>
@@ -27,6 +20,7 @@ using namespace std;
 #include <QFile>
 #include <QUrl>
 #include <QTimer>
+#include <QScopedPointer>
 
 // MythTV plugin includes
 #include <mythcontext.h>
@@ -50,9 +44,9 @@ using namespace std;
 // MythUI headers
 #include <mythtv/libmythui/mythscreenstack.h>
 #include <mythtv/libmythui/mythprogressdialog.h>
+#include <mythtv/libmythui/mythmainwindow.h>
 
 // MythMusic includes
-#include "cdrip.h"
 #ifdef HAVE_CDIO
 #include "cddecoder.h"
 #endif // HAVE_CDIO
@@ -64,6 +58,7 @@ using namespace std;
 #include "editmetadata.h"
 #include "mythlogging.h"
 #include "musicutils.h"
+#include "musicdata.h"
 
 #ifdef HAVE_CDIO
 // libparanoia compatibility
@@ -131,63 +126,137 @@ void CDEjectorThread::run()
 
 ///////////////////////////////////////////////////////////////////////////////
 
-static long int getSectorCount (QString &cddevice, int tracknum)
+class MediaMonDisabler
 {
-#ifdef HAVE_CDIO
-    QByteArray devname = cddevice.toLatin1();
-    cdrom_drive *device = cdda_identify(devname.constData(), 0, NULL);
+    Q_DISABLE_COPY(MediaMonDisabler)
+
+  public:
+    MediaMonDisabler() : m_count(0), m_mediaMonitorActive(false) { }
 
-    if (!device)
+    int stop()
     {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("Error: %1('%2',track=%3) failed at cdda_identify()").
-            arg(__func__).arg(cddevice).arg(tracknum));
-        return -1;
+        int n = ++m_count;
+        if (n == 1)
+        {
+#ifndef _WIN32
+            // if the MediaMonitor is running stop it
+            if (MediaMonitor *mon = MediaMonitor::GetMediaMonitor())
+            {
+                if ((m_mediaMonitorActive = mon->IsActive()))
+                    mon->StopMonitoring();
+            }
+#endif // _WIN32
+        }
+        return n;
     }
 
-    if (cdda_open(device))
+    int start()
+    {
+        int n = --m_count;
+        if (n == 0)
+        {
+#ifndef _WIN32
+            // if the MediaMonitor was active then restart it
+            if (m_mediaMonitorActive)
+            {
+                m_mediaMonitorActive = false;
+                if (MediaMonitor *mon = MediaMonitor::GetMediaMonitor())
+                    mon->StartMonitoring();
+            }
+#endif // _WIN32
+        }
+        return n;
+    }
+
+  private:
+    int m_count;
+    bool m_mediaMonitorActive;
+};
+static MediaMonDisabler s_monitor;
+
+///////////////////////////////////////////////////////////////////////////////
+
+class CDIOdevice
+{
+    Q_DISABLE_COPY(CDIOdevice)
+
+  public:
+    CDIOdevice(const QString &dev);
+    ~CDIOdevice();
+
+    const QString &name() const { return m_name; }
+    bool isOpen() const { return m_isOpen; }
+#ifdef HAVE_CDIO
+    operator cdrom_drive*() const { return m_device; }
+#endif
+
+  private:
+    QString const m_name;
+    bool m_isOpen;
+#ifdef HAVE_CDIO
+    cdrom_drive * const m_device;
+#endif
+};
+
+CDIOdevice::CDIOdevice(const QString &dev) :
+    m_name(dev), m_isOpen(false),
+#ifdef HAVE_CDIO
+    m_device(cdda_identify(qPrintable(dev), 0, NULL))
+#endif
+{
+#ifdef HAVE_CDIO
+    if (!m_device)
     {
         LOG(VB_GENERAL, LOG_ERR,
-            QString("Error: %1('%2',track=%3) failed at cdda_open() - cdda not supported").
-            arg(__func__).arg(cddevice).arg(tracknum));
-        cdda_close(device);
-        return -1;
+            QString("Error: %1('%2') cdda_identify failed")
+                .arg(__func__).arg(dev));
+        return;
     }
 
-    // we only care about audio tracks
-    if (cdda_track_audiop (device, tracknum))
+    LOG(VB_MEDIA, LOG_INFO, QString("%1 - cdda_open(%2)...")
+        .arg(__func__).arg(dev));
+
+    if (cdda_open(m_device))
     {
-        cdda_verbose_set(device, CDDA_MESSAGE_FORGETIT, CDDA_MESSAGE_FORGETIT);
-        long int start = cdda_track_firstsector(device, tracknum);
-        long int end   = cdda_track_lastsector( device, tracknum);
-        cdda_close(device);
-        return end - start + 1;
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Error: %1('%2') cdda_open failed")
+                .arg(__func__).arg(dev));
+        return;
     }
-    LOG(VB_GENERAL, LOG_ERR,
-        QString("Error: cdrip - cdda_track_audiop(%1) returned 0").arg(cddevice));
+    m_isOpen = true;
 
-    cdda_close(device);
-#else
-    (void)cddevice; (void)tracknum;
-#endif // HAVE_CDIO
-    return 0;
+    LOG(VB_MEDIA, LOG_INFO, QString("%1 - cdda_open(%2) OK")
+        .arg(__func__).arg(dev));
+
+    cdda_verbose_set(m_device, CDDA_MESSAGE_FORGETIT, CDDA_MESSAGE_FORGETIT);
+#endif
+}
+
+inline CDIOdevice::~CDIOdevice()
+{
+#ifdef HAVE_CDIO
+    if (m_device)
+        cdda_close(m_device);
+#endif
 }
 
+///////////////////////////////////////////////////////////////////////////////
+
 #ifdef HAVE_CDIO
 static void paranoia_cb(long, paranoia_cb_mode_t)
 {
 }
 #endif // HAVE_CDIO
 
-CDRipperThread::CDRipperThread(RipStatus *parent,  QString device,
-                               QVector<RipTrack*> *tracks, int quality) :
+CDRipperThread::CDRipperThread(RipStatus *parent, const QString &device,
+                                const trackList_t &tracks, int quality) :
     MThread("CDRipper"),
     m_parent(parent),   m_quit(false),
     m_CDdevice(device), m_quality(quality),
     m_tracks(tracks), m_totalSectors(0),
-    m_totalSectorsDone(0), m_lastTrackPct(0),
-    m_lastOverallPct(0), m_musicStorageDir("")
-
+    m_totalSectorsDone(0), m_currentTrack(0),
+    m_lastTrackPct(0), m_lastOverallPct(0),
+    m_musicStorageDir("")
 {
 #ifdef WIN32 // libcdio needs the drive letter with no path
     if (m_CDdevice.endsWith('\\'))
@@ -206,6 +275,49 @@ CDRipperThread::~CDRipperThread(void)
     wait();
 }
 
+void CDRipperThread::continueInBackground()
+{
+    m_parent = NULL;
+}
+
+void CDRipperThread::bringToForeground(RipStatus *parent)
+{
+    m_parent = parent;
+
+    QString tots;
+    MusicMetadata *meta = m_tracks.size() ? m_tracks[0].metadata.data() : NULL;
+    if (!meta)
+        ;
+    else if (meta->Compilation())
+        tots = meta->CompilationArtist() + " ~ " + meta->Album();
+    else
+        tots = meta->Artist() + " ~ " + meta->Album();
+
+    QApplication::postEvent(eventTarget(),
+        new RipStatusEvent(RipStatusEvent::kOverallTextEvent, tots));
+    QApplication::postEvent(eventTarget(),
+        new RipStatusEvent(RipStatusEvent::kOverallProgressEvent, 0));
+    QApplication::postEvent(eventTarget(),
+        new RipStatusEvent(RipStatusEvent::kOverallStartEvent, m_totalSectors));
+    QApplication::postEvent(eventTarget(),
+        new RipStatusEvent(RipStatusEvent::kStatusTextEvent,
+                           tr("Track %1 of %2")
+                           .arg(m_currentTrack).arg(m_tracks.size())));
+    QApplication::postEvent(eventTarget(),
+        new RipStatusEvent(RipStatusEvent::kTrackTextEvent, m_textstatus));
+    QApplication::postEvent(eventTarget(),
+        new RipStatusEvent(RipStatusEvent::kTrackProgressEvent, 0));
+
+    m_lastTrackPct = -1;
+    m_lastOverallPct = -1;
+}
+
+QObject *CDRipperThread::eventTarget() const
+{
+    return m_parent ? static_cast<QObject*>(m_parent) :
+                      static_cast<QObject*>(GetMythMainWindow());
+}
+
 void CDRipperThread::cancel(void)
 {
     m_quit = true;
@@ -216,56 +328,96 @@ bool CDRipperThread::isCancelled(void)
     return m_quit;
 }
 
-void CDRipperThread::run(void)
+long int CDRipperThread::getTotalSectors(const CDIOdevice &device)
 {
-    RunProlog();
+    long int ret = 0;
+#ifdef HAVE_CDIO
+    for (int trackno = 0; trackno < m_tracks.size(); ++trackno)
+    {
+        if (!m_tracks[trackno].active)
+            continue;
 
-    if (!m_tracks->size() > 0)
+        // we only care about audio tracks
+        int tracknum = trackno + 1;
+        if (cdda_track_audiop(device, tracknum))
+        {
+            long int start = cdda_track_firstsector(device, tracknum);
+            long int end   = cdda_track_lastsector( device, tracknum);
+            ret += end - start + 1;
+        }
+        else
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("Error: %1('%2') failed at cdda_track_audiop(%3)")
+                    .arg(__func__).arg(m_CDdevice).arg(tracknum));
+            ret = -1;
+            break;
+        }
+    }
+#else
+    (void)device;
+#endif // HAVE_CDIO
+    return ret;
+}
+
+void CDRipperThread::run(void)
+{
+    struct PrePost
     {
-        RunEpilog();
+        CDRipperThread &thread;
+        PrePost(CDRipperThread &t) : thread(t)
+        {
+            thread.RunProlog();
+            s_monitor.stop();
+        }
+        ~PrePost()
+        {
+            s_monitor.start();
+            thread.RunEpilog();
+        }
+    };
+    PrePost first(*this);
+
+    if (m_tracks.isEmpty())
+        return;
+
+    CDIOdevice device(m_CDdevice);
+    if (!device.isOpen())
         return;
-    }
 
-    m_totalSectors = 0;
     m_totalSectorsDone = 0;
-    for (int trackno = 0; trackno < m_tracks->size(); trackno++)
+    m_totalSectors = getTotalSectors(device);
+    if (m_totalSectors < 0)
     {
-        m_totalSectors += getSectorCount(m_CDdevice, trackno + 1);
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kEncoderErrorEvent,
+                               "Failed to get sector count"));
+        return;
     }
-
     if (!m_totalSectors)
-    {
-        RunEpilog();
         return;
-    }
 
-    MusicMetadata *track = m_tracks->at(0)->metadata;
+    MusicMetadata *meta = m_tracks[0].metadata.data();
     QString tots;
 
-    if (track->Compilation())
-    {
-        tots = track->CompilationArtist() + " ~ " + track->Album();
-    }
+    if (!meta)
+        ;
+    else if (meta->Compilation())
+        tots = meta->CompilationArtist() + " ~ " + meta->Album();
     else
-    {
-        tots = track->Artist() + " ~ " + track->Album();
-    }
+        tots = meta->Artist() + " ~ " + meta->Album();
 
-    QApplication::postEvent(
-        m_parent,
+    QApplication::postEvent(eventTarget(),
         new RipStatusEvent(RipStatusEvent::kOverallTextEvent, tots));
-    QApplication::postEvent(
-        m_parent,
+    QApplication::postEvent(eventTarget(),
         new RipStatusEvent(RipStatusEvent::kOverallProgressEvent, 0));
-    QApplication::postEvent(
-        m_parent,
+    QApplication::postEvent(eventTarget(),
         new RipStatusEvent(RipStatusEvent::kTrackProgressEvent, 0));
 
-    QString textstatus;
     QString encodertype = gCoreContext->GetSetting("EncoderType");
     bool mp3usevbr = gCoreContext->GetNumSetting("Mp3UseVBR", 0);
 
-    QApplication::postEvent(m_parent,
+    QApplication::postEvent(eventTarget(),
         new RipStatusEvent(RipStatusEvent::kOverallStartEvent, m_totalSectors));
 
     if (LCD *lcd = LCD::Get())
@@ -277,128 +429,126 @@ void CDRipperThread::run(void)
         lcd->switchToGeneric(textItems);
     }
 
-    MusicMetadata *titleTrack = NULL;
     QString saveDir = GetConfDir() + "/tmp/RipTemp/";
-    QString outfile;
-
-    std::auto_ptr<Encoder> encoder;
+    QScopedPointer<Encoder> encoder;
 
-    for (int trackno = 0; trackno < m_tracks->size(); trackno++)
+    for (int trackno = 0; trackno < m_tracks.size(); ++trackno)
     {
         if (isCancelled())
-            break;
+            return;
 
-        QApplication::postEvent(
-            m_parent,
-            new RipStatusEvent(RipStatusEvent::kStatusTextEvent,
-                               QString("Track %1 of %2")
-                               .arg(trackno + 1).arg(m_tracks->size())));
+        m_currentTrack = trackno + 1;
 
-        QApplication::postEvent(
-            m_parent,
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kStatusTextEvent,
+                               tr("Track %1 of %2")
+                               .arg(m_currentTrack).arg(m_tracks.size())));
+        QApplication::postEvent(eventTarget(),
             new RipStatusEvent(RipStatusEvent::kTrackProgressEvent, 0));
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kTrackPercentEvent, 0));
+
+        const RipTrack &track = m_tracks[trackno];
+        if (!track.active)
+            continue;
+
+        meta = track.metadata.data();
+        if (!meta)
+            continue;
 
-        track = m_tracks->at(trackno)->metadata;
+        m_textstatus = meta->Title();
 
-        if (track)
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kTrackTextEvent, m_textstatus));
+
+        QString outfile;
+
+        if (m_quality < 3)
         {
-            textstatus = track->Title();
-            QApplication::postEvent(
-                m_parent,
-                new RipStatusEvent(
-                    RipStatusEvent::kTrackTextEvent, textstatus));
-            QApplication::postEvent(
-                m_parent,
-                new RipStatusEvent(RipStatusEvent::kTrackProgressEvent, 0));
-            QApplication::postEvent(
-                m_parent,
-                new RipStatusEvent(RipStatusEvent::kTrackPercentEvent, 0));
-
-            // do we need to start a new file?
-            if (m_tracks->at(trackno)->active)
+            if (encodertype == "mp3")
             {
-                titleTrack = track;
-                titleTrack->setLength(m_tracks->at(trackno)->length);
+                outfile = QString("track%1.mp3").arg(trackno);
+                encoder.reset(new LameEncoder(saveDir + outfile, m_quality,
+                                              meta, mp3usevbr));
+            }
+            else // ogg
+            {
+                outfile = QString("track%1.ogg").arg(trackno);
+                encoder.reset(new VorbisEncoder(saveDir + outfile, m_quality,
+                                                meta));
+            }
+        }
+        else
+        {
+            outfile = QString("track%1.flac").arg(trackno);
+            encoder.reset(new FlacEncoder(saveDir + outfile, m_quality,
+                                          meta));
+        }
 
-                if (m_quality < 3)
-                {
-                    if (encodertype == "mp3")
-                    {
-                        outfile = QString("track%1.mp3").arg(trackno);
-                        encoder.reset(new LameEncoder(saveDir + outfile, m_quality,
-                                                      titleTrack, mp3usevbr));
-                    }
-                    else // ogg
-                    {
-                        outfile = QString("track%1.ogg").arg(trackno);
-                        encoder.reset(new VorbisEncoder(saveDir + outfile, m_quality,
-                                                        titleTrack));
-                    }
-                }
-                else
-                {
-                    outfile = QString("track%1.flac").arg(trackno);
-                    encoder.reset(new FlacEncoder(saveDir + outfile, m_quality,
-                                                  titleTrack));
-                }
+        if (encoder.isNull())
+        {
+            // This should never happen.
+            QApplication::postEvent(eventTarget(),
+                new RipStatusEvent(RipStatusEvent::kEncoderErrorEvent,
+                                   "Failed to create encoder"));
+            LOG(VB_GENERAL, LOG_ERR, "MythMusic: No encoder, failing");
+            return;
+        }
 
-                if (!encoder->isValid())
-                {
-                    QApplication::postEvent(
-                        m_parent,
-                        new RipStatusEvent(
-                            RipStatusEvent::kEncoderErrorEvent,
-                            "Encoder failed to open file for writing"));
-                    LOG(VB_GENERAL, LOG_ERR, "MythMusic: Encoder failed"
-                                             " to open file for writing");
-
-                    RunEpilog();
-                    return;
-                }
-            }
+        if (!encoder->isValid())
+        {
+            QApplication::postEvent(eventTarget(),
+                new RipStatusEvent(RipStatusEvent::kEncoderErrorEvent,
+                    "Encoder failed to open file for writing"));
+            LOG(VB_GENERAL, LOG_ERR, "MythMusic: Encoder failed"
+                                     " to open file for writing");
+            return;
+        }
+
+        if (ripTrack(device, encoder.data(), m_currentTrack) < 0)
+        {
+            QString msg = tr("Rip failed at track %1.").arg(m_currentTrack);
+            LOG(VB_GENERAL, LOG_ERR, msg);
 
-            if (!encoder.get())
+            if (m_parent)
             {
-                // This should never happen.
-                QApplication::postEvent(
-                    m_parent,
-                    new RipStatusEvent(RipStatusEvent::kEncoderErrorEvent,
-                                       "Failed to create encoder"));
-                LOG(VB_GENERAL, LOG_ERR, "MythMusic: No encoder, failing");
-                RunEpilog();
-                return;
+                QApplication::postEvent(eventTarget(),
+                    new RipStatusEvent(RipStatusEvent::kEncoderErrorEvent, msg));
             }
-            ripTrack(m_CDdevice, encoder.get(), trackno + 1);
-
-            if (isCancelled())
+            else
             {
-                RunEpilog();
-                return;
+                MythErrorNotification n(tots, "MythMusic", msg);
+                GetNotificationCenter()->Queue(n);
             }
+            return;
+        }
 
-            if (m_tracks->at(trackno)->active)
-            {
-                QString ext = QFileInfo(outfile).suffix();
-                QString destFile = filenameFromMetadata(titleTrack) + '.' + ext;
-                QUrl url(m_musicStorageDir);
+        if (isCancelled())
+            return;
+
+        QString ext = QFileInfo(outfile).suffix();
+        QString destFile = filenameFromMetadata(meta) + '.' + ext;
+        QUrl url(m_musicStorageDir);
 
-                // save the metadata to the DB
-                titleTrack->setFilename(destFile);
-                titleTrack->setHostname(url.host());
-                titleTrack->setFileSize((quint64)QFileInfo(outfile).size());
-                titleTrack->dumpToDatabase();
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kCopyStartEvent, 0));
 
-                // this will delete the encoder which will write the metadata in it's dtor
-                encoder.reset();
+        // this will delete the encoder which will write the metadata in it's dtor
+        encoder.reset();
 
-                // copy track to the BE
-                destFile = gCoreContext->GenMythURL(url.host(), 0, destFile, "Music");
+        // copy track to the BE
+        destFile = gCoreContext->GenMythURL(url.host(), 0, destFile, "Music");
 
-                QApplication::postEvent(m_parent, new RipStatusEvent(RipStatusEvent::kCopyStartEvent, 0));
-                RemoteFile::CopyFile(saveDir + outfile, destFile, true);
-                QApplication::postEvent(m_parent, new RipStatusEvent(RipStatusEvent::kCopyEndEvent, 0));
-            }
-        }
+        RemoteFile::CopyFile(saveDir + outfile, destFile, true);
+
+        // save the metadata to the DB
+        meta->setFilename(destFile);
+        meta->setHostname(url.host());
+        meta->setFileSize((quint64)QFileInfo(outfile).size());
+        meta->dumpToDatabase();
+
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kCopyEndEvent, 0));
     }
 
     QString PostRipCDScript = gCoreContext->GetSetting("PostCDRipScript");
@@ -406,43 +556,37 @@ void CDRipperThread::run(void)
     if (!PostRipCDScript.isEmpty())
         myth_system(PostRipCDScript);
 
-    QApplication::postEvent(
-        m_parent, new RipStatusEvent(RipStatusEvent::kFinishedEvent, ""));
-
-    RunEpilog();
-}
-
-int CDRipperThread::ripTrack(QString &cddevice, Encoder *encoder, int tracknum)
-{
-#ifdef HAVE_CDIO
-    QByteArray devname = cddevice.toLatin1();
-    cdrom_drive *device = cdda_identify(devname.constData(), 0, NULL);
-
-    if (!device)
+    if (m_parent)
     {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("cdda_identify failed for device '%1', "
-                    "CDRipperThread::ripTrack(tracknum = %2) exiting.")
-                .arg(cddevice).arg(tracknum));
-        return -1;
+        QApplication::postEvent(m_parent,
+            new RipStatusEvent(RipStatusEvent::kFinishedEvent, ""));
     }
-
-    if (cdda_open(device))
+    else
     {
-        LOG(VB_MEDIA, LOG_INFO,
-            QString("Error: %1('%2',track=%3) failed at cdda_open() - cdda not supported")
-            .arg(__func__).arg(cddevice).arg(tracknum));
-        cdda_close(device);
-        return -1;
+        MythCheckNotification n(tots, "MythMusic", tr("Rip completed successfully."));
+        GetNotificationCenter()->Queue(n);
+
+        QMetaObject::invokeMethod(gMusicData, "reloadMusic");
+        Ripper::ejectCD(m_CDdevice);
     }
+}
 
-    cdda_verbose_set(device, CDDA_MESSAGE_FORGETIT, CDDA_MESSAGE_FORGETIT);
+int CDRipperThread::ripTrack(const CDIOdevice &device, Encoder *encoder, int tracknum)
+{
+#ifdef HAVE_CDIO
     long int start = cdda_track_firstsector(device, tracknum);
     long int end = cdda_track_lastsector(device, tracknum);
     LOG(VB_MEDIA, LOG_INFO, QString("%1(%2,track=%3) start=%4 end=%5")
-        .arg(__func__).arg(cddevice).arg(tracknum).arg(start).arg(end));
+        .arg(__func__).arg(device.name()).arg(tracknum).arg(start).arg(end));
+
+    struct Paranoia
+    {
+        Paranoia(cdrom_drive *d) : m_paranoia(paranoia_init(d)) { }
+        ~Paranoia() { paranoia_free(m_paranoia); }
+        operator cdrom_paranoia*() const { return m_paranoia; }
+        cdrom_paranoia * const m_paranoia;
+    } paranoia(device);
 
-    cdrom_paranoia *paranoia = paranoia_init(device);
     if (gCoreContext->GetSetting("ParanoiaLevel") == "full")
         paranoia_modeset(paranoia, PARANOIA_MODE_FULL |
                 PARANOIA_MODE_NEVERSKIP);
@@ -454,9 +598,6 @@ int CDRipperThread::ripTrack(QString &cddevice, Encoder *encoder, int tracknum)
     long int curpos = start;
     int16_t *buffer;
 
-    QApplication::postEvent(
-        m_parent,
-        new RipStatusEvent(RipStatusEvent::kTrackStartEvent, end - start + 1));
     m_lastTrackPct = -1;
     m_lastOverallPct = -1;
 
@@ -464,9 +605,11 @@ int CDRipperThread::ripTrack(QString &cddevice, Encoder *encoder, int tracknum)
     while (curpos < end)
     {
         buffer = paranoia_read(paranoia, paranoia_cb);
+        if (!buffer)
+            return -1;
 
         if (encoder->addSamples(buffer, CD_FRAMESIZE_RAW))
-            break;
+            return -1;
 
         curpos++;
 
@@ -482,12 +625,10 @@ int CDRipperThread::ripTrack(QString &cddevice, Encoder *encoder, int tracknum)
             if (newOverallPct != m_lastOverallPct)
             {
                 m_lastOverallPct = newOverallPct;
-                QApplication::postEvent(
-                    m_parent,
+                QApplication::postEvent(eventTarget(),
                     new RipStatusEvent(RipStatusEvent::kOverallPercentEvent,
                                        newOverallPct));
-                QApplication::postEvent(
-                    m_parent,
+                QApplication::postEvent(eventTarget(),
                     new RipStatusEvent(RipStatusEvent::kOverallProgressEvent,
                                        m_totalSectorsDone + curpos - start));
             }
@@ -497,12 +638,13 @@ int CDRipperThread::ripTrack(QString &cddevice, Encoder *encoder, int tracknum)
             if (newTrackPct != m_lastTrackPct)
             {
                 m_lastTrackPct = newTrackPct;
-                QApplication::postEvent(
-                    m_parent,
+                QApplication::postEvent(eventTarget(),
+                    new RipStatusEvent(RipStatusEvent::kTrackStartEvent,
+                                        end - start + 1));
+                QApplication::postEvent(eventTarget(),
                     new RipStatusEvent(RipStatusEvent::kTrackPercentEvent,
                                        newTrackPct));
-                QApplication::postEvent(
-                    m_parent,
+                QApplication::postEvent(eventTarget(),
                     new RipStatusEvent(RipStatusEvent::kTrackProgressEvent,
                                        curpos - start));
             }
@@ -521,21 +663,31 @@ int CDRipperThread::ripTrack(QString &cddevice, Encoder *encoder, int tracknum)
         }
     }
 
-    m_totalSectorsDone += end - start + 1;
+    if (!isCancelled())
+    {
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kTrackPercentEvent,
+                               100));
+        QApplication::postEvent(eventTarget(),
+            new RipStatusEvent(RipStatusEvent::kTrackProgressEvent,
+                               curpos - start + 1));
+    }
 
-    paranoia_free(paranoia);
-    cdda_close(device);
+    m_totalSectorsDone += end - start + 1;
 
-    return (curpos - start + 1) * CD_FRAMESIZE_RAW;
+    int bytes = (curpos - start + 1) * CD_FRAMESIZE_RAW;
+    LOG(VB_MEDIA, LOG_INFO, QString("%1(%2,track=%3) read %4 bytes")
+        .arg(__func__).arg(device.name()).arg(tracknum).arg(bytes) );
+    return bytes;
 #else
-    (void)cddevice; (void)encoder; (void)tracknum;
+    (void)device; (void)encoder; (void)tracknum;
     return 0;
 #endif // HAVE_CDIO
 }
 
 ///////////////////////////////////////////////////////////////////////////////
 
-Ripper::Ripper(MythScreenStack *parent, QString device) :
+Ripper::Ripper(MythScreenStack *parent, const QString &device) :
     MythScreenType(parent, "ripcd"),
     m_musicStorageDir(""),
 
@@ -558,26 +710,13 @@ Ripper::Ripper(MythScreenStack *parent, QString device) :
     m_searchAlbumButton(NULL),
     m_searchGenreButton(NULL),
 
-    m_tracks(new QVector<RipTrack*>),
-
-    m_isCompilation(false),
     m_somethingwasripped(false),
-    m_mediaMonitorActive(false),
 
     m_CDdevice(device),
 
     m_ejectThread(NULL), m_scanThread(NULL)
 {
-#ifndef _WIN32
-    // if the MediaMonitor is running stop it
-    m_mediaMonitorActive = false;
-    MediaMonitor *mon = MediaMonitor::GetMediaMonitor();
-    if (mon && mon->IsActive())
-    {
-        m_mediaMonitorActive = true;
-        mon->StopMonitoring();
-    }
-#endif // _WIN32
+    s_monitor.stop();
 
     // make sure the directory where we temporarily save the rips is present
     QDir dir;
@@ -615,15 +754,7 @@ Ripper::~Ripper(void)
     if (m_decoder)
         delete m_decoder;
 
-#ifndef _WIN32
-    // if the MediaMonitor was active when we started then restart it
-    if (m_mediaMonitorActive)
-    {
-        MediaMonitor *mon = MediaMonitor::GetMediaMonitor();
-        if (mon)
-            mon->StartMonitoring();
-    }
-#endif // _WIN32
+    s_monitor.start();
 
     if (m_somethingwasripped)
         emit ripFinished();
@@ -679,18 +810,31 @@ bool Ripper::Create(void)
     connect(m_searchAlbumButton, SIGNAL(Clicked()), SLOT(searchAlbum()));
 
     // Populate Quality List
-    new MythUIButtonListItem(m_qualityList, tr("Low"), qVariantFromValue(0));
-    new MythUIButtonListItem(m_qualityList, tr("Medium"), qVariantFromValue(1));
-    new MythUIButtonListItem(m_qualityList, tr("High"), qVariantFromValue(2));
-    new MythUIButtonListItem(m_qualityList, tr("Perfect"), qVariantFromValue(3));
-    m_qualityList->SetValueByData(qVariantFromValue(
+    new MythUIButtonListItem(m_qualityList, tr("Low"), QVariant::fromValue(0));
+    new MythUIButtonListItem(m_qualityList, tr("Medium"), QVariant::fromValue(1));
+    new MythUIButtonListItem(m_qualityList, tr("High"), QVariant::fromValue(2));
+    new MythUIButtonListItem(m_qualityList, tr("Perfect"), QVariant::fromValue(3));
+    m_qualityList->SetValueByData(QVariant::fromValue(
                         gCoreContext->GetNumSetting("DefaultRipQuality", 1)));
 
-    QTimer::singleShot(50, this, SLOT(startScanCD()));
+    if (RipStatus::isRipping())
+    {
+        m_tracks = RipStatus::getRipperTracks();
+        updateAlbumInfo();
+        updateTrackList();
+        QTimer::singleShot(0, this, SLOT(startRipper()));
+    }
 
     return true;
 }
 
+void Ripper::Load(void)
+{
+    ScreenLoadCompletionEvent *slce =
+        new ScreenLoadCompletionEvent(objectName());
+    QCoreApplication::postEvent(this, slce);
+}
+
 bool Ripper::keyPressEvent(QKeyEvent *event)
 {
     if (GetFocusWidget() && GetFocusWidget()->keyPressEvent(event))
@@ -721,7 +865,7 @@ bool Ripper::keyPressEvent(QKeyEvent *event)
 
 void Ripper::ShowMenu()
 {
-    if (m_tracks->empty())
+    if (m_tracks.empty())
         return;
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
@@ -801,15 +945,12 @@ void Ripper::startScanCD(void)
     if (m_scanThread)
         return;
 
+    if (RipStatus::isRipping())
+        return;
+
     QString message = tr("Scanning CD. Please Wait ...");
     OpenBusyPopup(message);
 
-    m_artistName.clear();
-    m_albumName.clear();
-    m_genreName.clear();
-    m_year.clear();
-    m_isCompilation = false;
-
     m_scanThread = new CDScannerThread(this);
     connect(m_scanThread->qthread(), SIGNAL(finished()), SLOT(ScanFinished()));
     m_scanThread->start();
@@ -821,18 +962,7 @@ void Ripper::ScanFinished()
     delete m_scanThread;
     m_scanThread = NULL;
 
-    m_artistEdit->SetText(m_artistName);
-    m_albumEdit->SetText(m_albumName);
-    m_genreEdit->SetText(m_genreName);
-    m_yearEdit->SetText(m_year);
-    m_compilationCheck->SetCheckState(m_isCompilation);
-
-    if (!m_isCompilation)
-        m_switchTitleArtist->SetVisible(false);
-    else
-        m_switchTitleArtist->SetVisible(true);
-
-    BuildFocusList();
+    updateAlbumInfo();
     updateTrackList();
 
     CloseBusyPopup();
@@ -840,12 +970,11 @@ void Ripper::ScanFinished()
 
 void Ripper::scanCD(void)
 {
-#ifdef HAVE_CDIO
-    {
-    LOG(VB_MEDIA, LOG_INFO, QString("Ripper::%1 CD='%2'").
+    LOG(VB_MEDIA, LOG_INFO, QString("Ripper::%1 '%2'").
         arg(__func__).arg(m_CDdevice));
-    (void)cdio_close_tray(m_CDdevice.toLatin1().constData(), NULL);
-    }
+
+#ifdef HAVE_CDIO
+    (void)cdio_close_tray(qPrintable(m_CDdevice), NULL);
 #endif // HAVE_CDIO
 
     delete m_decoder;
@@ -855,68 +984,94 @@ void Ripper::scanCD(void)
 
     m_decoder->setDevice(m_CDdevice);
 
-    m_tracks->clear();
+    QString albumName, artistName;
+
+    m_tracks.clear();
     for (int trk = 0, trks = m_decoder->getNumTracks(); trk < trks; ++trk)
     {
         MusicMetadata *metadata = m_decoder->getMetadata(trk + 1);
+        RipTrack ripTrack(metadata);
+
         if (metadata)
-        {
-            RipTrack *ripTrack = new RipTrack;
-            ripTrack->metadata = metadata;
-            ripTrack->length = metadata->Length();
+            ripTrack.length = metadata->Length();
+
+        m_tracks.push_back(ripTrack);
+    }
+
+    LOG(VB_MEDIA, LOG_INFO, QString("Ripper::%1 complete").
+        arg(__func__));
+}
+
+void Ripper::updateAlbumInfo()
+{
+    QString albumName, artistName, genreName, year;
+    bool isCompilation = false;
 
+    for (trackList_t::iterator it = m_tracks.begin();
+        it < m_tracks.end(); ++it)
+    {
+        RipTrack &track = *it;
+        MusicMetadata *metadata = track.metadata.data();
+        if (metadata)
+        {
             if (metadata->Compilation())
             {
-                m_isCompilation = true;
-                m_artistName = metadata->CompilationArtist();
+                isCompilation = true;
+                artistName = metadata->CompilationArtist();
             }
-            else if (m_artistName.isEmpty())
+            else if (artistName.isEmpty())
             {
-                m_artistName = metadata->Artist();
+                artistName = metadata->Artist();
             }
 
-            if (m_albumName.isEmpty())
-                m_albumName = metadata->Album();
+            if (albumName.isEmpty())
+                albumName = metadata->Album();
 
-            if (m_genreName.isEmpty() && !metadata->Genre().isEmpty())
-                m_genreName = metadata->Genre();
+            if (genreName.isEmpty() && !metadata->Genre().isEmpty())
+                genreName = metadata->Genre();
 
-            if (m_year.isEmpty() && metadata->Year() > 0)
-                m_year = QString::number(metadata->Year());
+            if (year.isEmpty() && metadata->Year() > 0)
+                year = QString::number(metadata->Year());
 
             QString title = metadata->Title();
-            ripTrack->isNew = isNewTune(m_artistName, m_albumName, title);
-
-            ripTrack->active = ripTrack->isNew;
+            track.isNew = isNewTune(artistName, albumName, title);
 
-            m_tracks->push_back(ripTrack);
+            track.active = track.isNew;
         }
     }
+
+    m_artistEdit->SetText(artistName);
+    m_albumEdit->SetText(albumName);
+    m_genreEdit->SetText(genreName);
+    m_yearEdit->SetText(year);
+    m_compilationCheck->SetCheckState(isCompilation);
+
+    if (!isCompilation)
+        m_switchTitleArtist->SetVisible(false);
+    else
+        m_switchTitleArtist->SetVisible(true);
 }
 
 void Ripper::deleteAllExistingTracks(void)
 {
-    QVector<RipTrack*>::iterator it;
-    for (it = m_tracks->begin(); it < m_tracks->end(); ++it)
+    trackList_t::iterator it;
+    for (it = m_tracks.begin(); it < m_tracks.end(); ++it)
     {
-        RipTrack *track = (*it);
-        if (track && !track->isNew)
+        RipTrack &track = (*it);
+        if (!track.isNew)
         {
             if (deleteExistingTrack(track))
             {
-                track->isNew = true;
+                track.isNew = true;
                 toggleTrackActive(track);
             }
         }
     }
 }
 
-bool Ripper::deleteExistingTrack(RipTrack *track)
+bool Ripper::deleteExistingTrack(const RipTrack &track)
 {
-    if (!track)
-        return false;
-
-    MusicMetadata *metadata = track->metadata;
+    MusicMetadata *metadata = track.metadata.data();
 
     if (!metadata)
         return false;
@@ -999,13 +1154,13 @@ bool Ripper::somethingWasRipped()
 void Ripper::artistChanged()
 {
     QString newartist = m_artistEdit->GetText();
-    MusicMetadata *data;
 
-    if (m_tracks->size() > 0)
+    if (m_tracks.size() > 0)
     {
-        for (int trackno = 0; trackno < m_tracks->size(); ++trackno)
+        for (trackList_t::const_iterator it = m_tracks.begin();
+            it < m_tracks.end(); ++it)
         {
-            data = m_tracks->at(trackno)->metadata;
+            MusicMetadata *data = (*it).metadata.data();
 
             if (data)
             {
@@ -1023,86 +1178,67 @@ void Ripper::artistChanged()
 
         updateTrackList();
     }
-
-    m_artistName = newartist;
 }
 
 void Ripper::albumChanged()
 {
     QString newalbum = m_albumEdit->GetText();
-    MusicMetadata *data;
 
-    if (m_tracks->size() > 0)
+    for (trackList_t::const_iterator it = m_tracks.begin();
+        it < m_tracks.end(); ++it)
     {
-        for (int trackno = 0; trackno < m_tracks->size(); ++trackno)
-        {
-            data = m_tracks->at(trackno)->metadata;
+        MusicMetadata *data = (*it).metadata.data();
 
-            if (data)
-                data->setAlbum(newalbum);
-        }
+        if (data)
+            data->setAlbum(newalbum);
     }
-
-    m_albumName = newalbum;
 }
 
 void Ripper::genreChanged()
 {
     QString newgenre = m_genreEdit->GetText();
-    MusicMetadata *data;
 
-    if (m_tracks->size() > 0)
+    for (trackList_t::const_iterator it = m_tracks.begin();
+        it < m_tracks.end(); ++it)
     {
-        for (int trackno = 0; trackno < m_tracks->size(); ++trackno)
-        {
-            data = m_tracks->at(trackno)->metadata;
+        MusicMetadata *data = (*it).metadata.data();
 
-            if (data)
-                data->setGenre(newgenre);
-        }
+        if (data)
+            data->setGenre(newgenre);
     }
-
-    m_genreName = newgenre;
 }
 
 void Ripper::yearChanged()
 {
     QString newyear = m_yearEdit->GetText();
 
-    MusicMetadata *data;
-
-    if (m_tracks->size() > 0)
+    for (trackList_t::const_iterator it = m_tracks.begin();
+        it < m_tracks.end(); ++it)
     {
-        for (int trackno = 0; trackno < m_tracks->size(); ++trackno)
-        {
-            data = m_tracks->at(trackno)->metadata;
+        MusicMetadata *data = (*it).metadata.data();
 
-            if (data)
-                data->setYear(newyear.toInt());
-        }
+        if (data)
+            data->setYear(newyear.toInt());
     }
-
-    m_year = newyear;
 }
 
 void Ripper::compilationChanged(bool state)
 {
+    QString artist = m_artistEdit->GetText();
+
     if (!state)
     {
-        MusicMetadata *data;
-        if (m_tracks->size() > 0)
+        // Update artist MetaData of each track on the ablum...
+        for (trackList_t::const_iterator it = m_tracks.begin();
+            it < m_tracks.end(); ++it)
         {
-            // Update artist MetaData of each track on the ablum...
-            for (int trackno = 0; trackno < m_tracks->size(); ++trackno)
-            {
-                data = m_tracks->at(trackno)->metadata;
+            MusicMetadata *data = (*it).metadata.data();
 
-                if (data)
-                {
-                    data->setCompilationArtist("");
-                    data->setArtist(m_artistName);
-                    data->setCompilation(false);
-                }
+            if (data)
+            {
+                data->setCompilationArtist("");
+                data->setArtist(artist);
+                data->setCompilation(false);
             }
         }
 
@@ -1110,26 +1246,22 @@ void Ripper::compilationChanged(bool state)
     }
     else
     {
-        if (m_tracks->size() > 0)
+        // Update artist MetaData of each track on the album...
+        for (trackList_t::const_iterator it = m_tracks.begin();
+            it < m_tracks.end(); ++it)
         {
-            // Update artist MetaData of each track on the album...
-            for (int trackno = 0; trackno < m_tracks->size(); ++trackno)
-            {
-                MusicMetadata *data;
-                data = m_tracks->at(trackno)->metadata;
+            MusicMetadata *data = (*it).metadata.data();
 
-                if (data)
-                {
-                    data->setCompilationArtist(m_artistName);
-                    data->setCompilation(true);
-                }
+            if (data)
+            {
+                data->setCompilationArtist(artist);
+                data->setCompilation(true);
             }
         }
 
         m_switchTitleArtist->SetVisible(true);
     }
 
-    BuildFocusList();
     updateTrackList();
 }
 
@@ -1138,15 +1270,14 @@ void Ripper::switchTitlesAndArtists()
     if (!m_compilationCheck->GetBooleanCheckState())
         return;
 
-    MusicMetadata *data;
-
     // Switch title and artist for each track
     QString tmp;
-    if (m_tracks->size() > 0)
+    if (m_tracks.size() > 0)
     {
-        for (int track = 0; track < m_tracks->size(); ++track)
+        for (trackList_t::const_iterator it = m_tracks.begin();
+            it < m_tracks.end(); ++it)
         {
-            data = m_tracks->at(track)->metadata;
+            MusicMetadata *data = (*it).metadata.data();
 
             if (data)
             {
@@ -1162,7 +1293,17 @@ void Ripper::switchTitlesAndArtists()
 
 void Ripper::startRipper(void)
 {
-    if (m_tracks->isEmpty())
+    int active = 0;
+    for (trackList_t::const_iterator it = m_tracks.begin();
+        it < m_tracks.end(); ++it)
+    {
+        if ((*it).active)
+        {
+            ++active;
+            break;
+        }
+    }
+    if (!active)
     {
         ShowOkPopup(tr("There are no tracks to rip?"));
         return;
@@ -1186,6 +1327,10 @@ void Ripper::startRipper(void)
 
 void Ripper::RipComplete(bool result)
 {
+    // De-select all sucessfully ripped tracks
+    updateAlbumInfo();
+    updateTrackList();
+
     if (result == true)
     {
         bool EjectCD = gCoreContext->GetNumSetting("EjectCDAfterRipping", 1);
@@ -1196,6 +1341,10 @@ void Ripper::RipComplete(bool result)
 
         m_somethingwasripped = true;
     }
+    else if (RipStatus::isRipping())
+    {
+        Close();
+    }
 
     if (LCD *lcd = LCD::Get())
         lcd->switchToTime();
@@ -1228,33 +1377,37 @@ void Ripper::EjectFinished()
 
 void Ripper::ejectCD()
 {
-    LOG(VB_MEDIA, LOG_INFO, __PRETTY_FUNCTION__);
+    ejectCD(m_CDdevice);
+}
+
+// static
+void Ripper::ejectCD(const QString &device)
+{
     bool bEjectCD = gCoreContext->GetNumSetting("EjectCDAfterRipping",1);
     if (bEjectCD)
     {
-#ifdef HAVE_CDIO
         LOG(VB_MEDIA, LOG_INFO, QString("Ripper::%1 '%2'").
-            arg(__func__).arg(m_CDdevice));
-        (void)cdio_eject_media_drive(m_CDdevice.toLatin1().constData());
-#else
-        MediaMonitor *mon = MediaMonitor::GetMediaMonitor();
-        if (mon)
+            arg(__func__).arg(device));
+#ifdef HAVE_CDIO
+        if (DRIVER_OP_SUCCESS == cdio_eject_media_drive(qPrintable(device)))
+            return;
+#endif // HAVE_CDIO
+
+        if (MediaMonitor *mon = MediaMonitor::GetMediaMonitor())
         {
-            QByteArray devname = m_CDdevice.toLatin1();
-            MythMediaDevice *pMedia = mon->GetMedia(devname.constData());
+            MythMediaDevice *pMedia = mon->GetMedia(qPrintable(device));
             if (pMedia && mon->ValidateAndLock(pMedia))
             {
                 pMedia->eject();
                 mon->Unlock(pMedia);
             }
         }
-#endif // HAVE_CDIO
     }
 }
 
 void Ripper::updateTrackList(void)
 {
-    if (m_tracks->isEmpty())
+    if (m_tracks.isEmpty())
         return;
 
     if (m_trackList)
@@ -1262,26 +1415,25 @@ void Ripper::updateTrackList(void)
         m_trackList->Reset();
 
         int i;
-        for (i = 0; i < (int)m_tracks->size(); i++)
+        for (i = 0; i < (int)m_tracks.size(); i++)
         {
-            if (i >= m_tracks->size())
-                break;
-
-            RipTrack *track = m_tracks->at(i);
-            MusicMetadata *metadata = track->metadata;
+            RipTrack &track = m_tracks[i];
+            MusicMetadata *metadata = track.metadata.data();
+            if (!metadata)
+                continue;
 
             MythUIButtonListItem *item = new MythUIButtonListItem(m_trackList,"");
 
             item->setCheckable(true);
 
-            item->SetData(qVariantFromValue(track));
+            item->SetData(QVariant::fromValue(&track));
 
-            if (track->isNew)
+            if (track.isNew)
                 item->DisplayState("new", "yes");
             else
                 item->DisplayState("new", "no");
 
-            if (track->active)
+            if (track.active)
                 item->setChecked(MythUIButtonListItem::FullChecked);
             else
                 item->setChecked(MythUIButtonListItem::NotChecked);
@@ -1290,7 +1442,7 @@ void Ripper::updateTrackList(void)
             item->SetText(metadata->Title(), "title");
             item->SetText(metadata->Artist(), "artist");
 
-            int length = track->length / 1000;
+            int length = track.length / 1000;
             if (length > 0)
             {
                 int min, sec;
@@ -1315,7 +1467,8 @@ void Ripper::searchArtist()
     QStringList searchList = MusicMetadata::fillFieldList("artist");
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg, searchList, false, "");
+    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg,
+                                                        searchList, false, "");
 
     if (!searchDlg->Create())
     {
@@ -1323,12 +1476,12 @@ void Ripper::searchArtist()
         return;
     }
 
-    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setArtist(QString)));
+    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setArtist(const QString &)));
 
     popupStack->AddScreen(searchDlg);
 }
 
-void Ripper::setArtist(QString artist)
+void Ripper::setArtist(const QString &artist)
 {
     m_artistEdit->SetText(artist);
 }
@@ -1339,7 +1492,8 @@ void Ripper::searchAlbum()
     QStringList searchList = MusicMetadata::fillFieldList("album");
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg, searchList, false, "");
+    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg,
+                                                        searchList, false, "");
 
     if (!searchDlg->Create())
     {
@@ -1347,12 +1501,12 @@ void Ripper::searchAlbum()
         return;
     }
 
-    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setAlbum(QString)));
+    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setAlbum(const QString &)));
 
     popupStack->AddScreen(searchDlg);
 }
 
-void Ripper::setAlbum(QString album)
+void Ripper::setAlbum(const QString &album)
 {
     m_albumEdit->SetText(album);
 }
@@ -1368,7 +1522,8 @@ void Ripper::searchGenre()
     m_searchList.sort();
 
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg, searchList, false, "");
+    MythUISearchDialog *searchDlg = new MythUISearchDialog(popupStack, msg,
+                                                        searchList, false, "");
 
     if (!searchDlg->Create())
     {
@@ -1376,19 +1531,19 @@ void Ripper::searchGenre()
         return;
     }
 
-    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setGenre(QString)));
+    connect(searchDlg, SIGNAL(haveResult(QString)), SLOT(setGenre(const QString&)));
 
     popupStack->AddScreen(searchDlg);
 }
 
-void Ripper::setGenre(QString genre)
+void Ripper::setGenre(const QString &genre)
 {
     m_genreEdit->SetText(genre);
 }
 
 void Ripper::showEditMetadataDialog(MythUIButtonListItem *item)
 {
-    if (!item || m_tracks->isEmpty())
+    if (!item || m_tracks.isEmpty())
         return;
 
     RipTrack *track = item->GetData().value<RipTrack *>();
@@ -1396,7 +1551,7 @@ void Ripper::showEditMetadataDialog(MythUIButtonListItem *item)
     if (!track)
         return;
 
-    MusicMetadata *editMeta = track->metadata;
+    MusicMetadata *editMeta = track->metadata.data();
 
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
 
@@ -1419,9 +1574,9 @@ void Ripper::metadataChanged(void)
     updateTrackList();
 }
 
-void Ripper::toggleTrackActive(RipTrack* track)
+void Ripper::toggleTrackActive(RipTrack &track)
 {
-    QVariant data = QVariant::fromValue(track);
+    QVariant data = QVariant::fromValue(&track);
     MythUIButtonListItem *item = m_trackList->GetItemByData(data);
     if (item)
     {
@@ -1431,34 +1586,32 @@ void Ripper::toggleTrackActive(RipTrack* track)
 
 void Ripper::toggleTrackActive(MythUIButtonListItem *item)
 {
-    if (m_tracks->isEmpty() || !item)
+    if (m_tracks.isEmpty() || !item)
         return;
 
     int pos = m_trackList->GetItemPos(item);
 
     // sanity check item position
-    if (pos < 0 || pos > m_tracks->count() - 1)
+    if (pos < 0 || pos > m_tracks.count() - 1)
         return;
 
-    RipTrack *track = m_tracks->at(pos);
+    RipTrack &track = m_tracks[pos];
 
-    if (!track->active && !track->isNew)
+    if (!track.active && !track.isNew)
     {
         ShowConflictMenu(track);
         return;
     }
 
-    track->active = !track->active;
+    track.active = !track.active;
 
-    if (track->active)
+    if (track.active)
         item->setChecked(MythUIButtonListItem::FullChecked);
     else
         item->setChecked(MythUIButtonListItem::NotChecked);
-
-    updateTrackLengths();
 }
 
-void Ripper::ShowConflictMenu(RipTrack* track)
+void Ripper::ShowConflictMenu(RipTrack &track)
 {
     MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
 
@@ -1479,32 +1632,10 @@ void Ripper::ShowConflictMenu(RipTrack* track)
 
     menu->SetReturnEvent(this, "conflictmenu");
     menu->AddButton(tr("No, Cancel"));
-    menu->AddButton(tr("Yes, Delete"), QVariant::fromValue(track));
+    menu->AddButton(tr("Yes, Delete"), QVariant::fromValue(&track));
     menu->AddButton(tr("Yes, Delete All"));
 }
 
-void Ripper::updateTrackLengths()
-{
-    QVector<RipTrack*>::iterator it;
-    RipTrack *track;
-    int length = 0;
-
-    for (it = m_tracks->end() - 1; it == m_tracks->begin(); --it)
-    {
-        track = *it;
-        if (track->active)
-        {
-            track->length = length + track->metadata->Length();
-            length = 0;
-        }
-        else
-        {
-            track->length = 0;
-            length += track->metadata->Length();
-        }
-    }
-}
-
 void Ripper::customEvent(QEvent* event)
 {
     if (event->type() == DialogCompletionEvent::kEventType)
@@ -1522,10 +1653,10 @@ void Ripper::customEvent(QEvent* event)
                     // Do nothing
                     break;
                 case 1:
-                    if (deleteExistingTrack(track))
+                    if (deleteExistingTrack(*track))
                     {
                         track->isNew = true;
-                        toggleTrackActive(track);
+                        toggleTrackActive(*track);
                     }
                     break;
                 case 2:
@@ -1538,6 +1669,20 @@ void Ripper::customEvent(QEvent* event)
 
         return;
     }
+    else if (event->type() == ScreenLoadCompletionEvent::kEventType)
+    {
+        ScreenLoadCompletionEvent *slce = static_cast<ScreenLoadCompletionEvent*>(event);
+        QString id = slce->GetId();
+
+        if (id == objectName())
+        {
+            if (!RipStatus::isRipping())
+            {
+                CloseBusyPopup(); // opened by LoadInBackground()
+                startScanCD();
+            }
+        }
+    }
 
     MythUIType::customEvent(event);
 }
@@ -1545,22 +1690,25 @@ void Ripper::customEvent(QEvent* event)
 
 ///////////////////////////////////////////////////////////////////////////////
 
+CDRipperThread *RipStatus::s_ripperThread;
+
 RipStatus::RipStatus(MythScreenStack *parent, const QString &device,
-                     QVector<RipTrack*> *tracks, int quality)
+                     const trackList_t &tracks, int quality)
     : MythScreenType(parent, "ripstatus"),
     m_tracks(tracks),           m_quality(quality),
     m_CDdevice(device),         m_overallText(NULL),
     m_trackText(NULL),          m_statusText(NULL),
     m_overallPctText(NULL),     m_trackPctText(NULL),
-    m_overallProgress(NULL),    m_trackProgress(NULL),
-    m_ripperThread(NULL)
+    m_overallProgress(NULL),    m_trackProgress(NULL)
 {
 }
 
 RipStatus::~RipStatus(void)
 {
-    if (m_ripperThread)
-        delete m_ripperThread;
+    if (isRipping())
+        s_ripperThread->continueInBackground();
+    else
+        delete s_ripperThread, s_ripperThread = NULL;
 
     if (LCD *lcd = LCD::Get())
         lcd->switchToTime();
@@ -1602,13 +1750,26 @@ bool RipStatus::keyPressEvent(QKeyEvent *event)
         handled = true;
 
 
-        if (action == "ESCAPE" &&
-            m_ripperThread && m_ripperThread->isRunning())
+        if (action == "ESCAPE")
         {
-            MythConfirmationDialog *dialog =
-                ShowOkPopup(tr("Cancel ripping the CD?"), this, NULL, true);
-            if (dialog)
-                dialog->SetReturnEvent(this, "stop_ripping");
+            QString label = tr("Exiting CD Ripper.\n\n"
+                        "Do you want to continue ripping in the background?");
+
+            MythScreenStack *stk = GetMythMainWindow()->GetStack("popup stack");
+
+            MythDialogBox *dlg = new MythDialogBox(label, stk, "stop_ripping");
+            if (!dlg->Create())
+                delete dlg;
+            else
+            {
+                dlg->SetReturnEvent(this, "stop_ripping");
+
+                dlg->AddButton(tr("No - Exit, Stop Ripping"));
+                dlg->AddButton(tr("Yes - Exit, Continue Ripping"));
+                dlg->AddButton(tr("Cancel"));
+
+                stk->AddScreen(dlg);
+            }
         }
         else
             handled = false;
@@ -1626,13 +1787,23 @@ void RipStatus::customEvent(QEvent *event)
     {
         DialogCompletionEvent *dce = static_cast<DialogCompletionEvent *>(event);
 
-        if (dce->GetId() == "stop_ripping" && dce->GetResult())
+        if (dce->GetId() == "stop_ripping")
         {
-            m_ripperThread->cancel();
-            m_ripperThread->wait();
-            Close();
-        }
+            QString resulttext = dce->GetResultText();
 
+            if (resulttext == tr("No - Exit, Stop Ripping"))
+            {
+                s_ripperThread->cancel();
+                s_ripperThread->wait();
+                emit Result(false);
+                Close();
+            }
+            else if (resulttext == tr("Yes - Exit, Continue Ripping"))
+            {
+                emit Result(false);
+                Close();
+            }
+        }
         return;
     }
 
@@ -1706,6 +1877,7 @@ void RipStatus::customEvent(QEvent *event)
         ShowOkPopup(tr("The encoder failed to create the file.\n"
                        "Do you have write permissions"
                        " for the music directory?"));
+        emit Result(false);
         Close();
     }
     else
@@ -1716,9 +1888,31 @@ void RipStatus::customEvent(QEvent *event)
 
 void RipStatus::startRip(void)
 {
-    if (m_ripperThread)
-        delete m_ripperThread;
+    if (isRipping())
+        s_ripperThread->bringToForeground(this);
+    else
+    {
+        delete s_ripperThread;
+        s_ripperThread = new CDRipperThread(this, m_CDdevice, m_tracks, m_quality);
+        s_ripperThread->start();
+    }
+}
+
+// static
+bool RipStatus::isRipping()
+{
+    return s_ripperThread && s_ripperThread->isRunning();
+}
 
-    m_ripperThread = new CDRipperThread(this, m_CDdevice, m_tracks, m_quality);
-    m_ripperThread->start();
+// static
+const trackList_t &RipStatus::getRipperTracks()
+{
+    static const trackList_t kNone;
+    return s_ripperThread ? s_ripperThread->getTracks() : kNone;
+}
+
+// static
+void RipStatus::stopRipping()
+{
+    delete s_ripperThread, s_ripperThread = NULL;
 }
diff --git a/mythplugins/mythmusic/mythmusic/cdrip.h b/mythplugins/mythmusic/mythmusic/cdrip.h
index b65d5f1..ea6773a 100644
--- a/mythplugins/mythmusic/mythmusic/cdrip.h
+++ b/mythplugins/mythmusic/mythmusic/cdrip.h
@@ -2,9 +2,11 @@
 #define CDRIP_H_
 
 // qt
+#include <QStringList>
 #include <QEvent>
 #include <QVector>
 #include <QCoreApplication>
+#include <QSharedPointer>
 
 // mythtv
 #include <musicmetadata.h>
@@ -17,6 +19,7 @@ class MythUITextEdit;
 class MythUIImage;
 class MythUIButton;
 class MythUIButtonList;
+class MythUIButtonListItem;
 class MythUICheckBox;
 
 class CdDecoder;
@@ -43,57 +46,70 @@ class CDEjectorThread: public MThread
         Ripper            *m_parent;
 };
 
-typedef struct
+struct RipTrack
 {
-    MusicMetadata *metadata;
+    QSharedPointer<MusicMetadata> metadata;
     bool           active;
     int            length;
     bool           isNew;
-} RipTrack;
+
+    RipTrack(MusicMetadata *meta = 0) : metadata(meta), active(false),
+        length(0), isNew(false) {}
+};
 
 Q_DECLARE_METATYPE(RipTrack *)
+typedef QVector<RipTrack> trackList_t;
 
 class RipStatus;
+class CDIOdevice;
 
 class CDRipperThread: public MThread
 {
     Q_DECLARE_TR_FUNCTIONS(CDRipperThread)
 
     public:
-        CDRipperThread(RipStatus *parent,  QString device,
-                       QVector<RipTrack*> *tracks, int quality);
+        CDRipperThread(RipStatus *parent, const QString &device,
+                        const trackList_t &tracks, int quality);
         ~CDRipperThread();
 
         void cancel(void);
 
+        void continueInBackground();
+        void bringToForeground(RipStatus *);
+        const trackList_t &getTracks() const { return m_tracks; }
+
     private:
         virtual void run(void);
-        int ripTrack(QString &cddevice, Encoder *encoder, int tracknum);
+
+        int ripTrack(const CDIOdevice &, Encoder *encoder, int tracknum);
+        long int getTotalSectors(const CDIOdevice &);
 
         bool isCancelled(void);
+        QObject *eventTarget() const;
 
         RipStatus         *m_parent;
         bool               m_quit;
         QString            m_CDdevice;
         int                m_quality;
-        QVector<RipTrack*> *m_tracks;
+        trackList_t        m_tracks;
 
         long int           m_totalSectors;
         long int           m_totalSectorsDone;
 
+        int                m_currentTrack;
         int                m_lastTrackPct;
         int                m_lastOverallPct;
 
         QString            m_musicStorageDir;
-
+        QString            m_textstatus;
 };
 
 class Ripper : public MythScreenType
 {
     Q_OBJECT
   public:
-    Ripper(MythScreenStack *parent, QString device);
-   ~Ripper(void);
+    Ripper(MythScreenStack *parent, const QString &device);
+   ~Ripper();
 
     bool Create(void);
     bool keyPressEvent(QKeyEvent *);
@@ -102,9 +118,13 @@ class Ripper : public MythScreenType
     bool somethingWasRipped();
     void scanCD(void);
     void ejectCD(void);
+    static void ejectCD(const QString &);
 
     virtual void ShowMenu(void);
 
+  protected:
+    virtual void Load(void);
+
   protected slots:
     void startRipper(void);
     void startScanCD(void);
@@ -118,9 +138,9 @@ class Ripper : public MythScreenType
     void searchArtist(void);
     void searchAlbum(void);
     void searchGenre(void);
-    void setArtist(QString artist);
-    void setAlbum(QString album);
-    void setGenre(QString genre);
+    void setArtist(const QString &artist);
+    void setAlbum(const QString &album);
+    void setGenre(const QString &genre);
     void RipComplete(bool result);
     void toggleTrackActive(MythUIButtonListItem *);
     void showEditMetadataDialog(MythUIButtonListItem *);
@@ -135,12 +155,12 @@ class Ripper : public MythScreenType
     void ripFinished(void);
 
   private:
-    bool deleteExistingTrack(RipTrack *track);
+    bool deleteExistingTrack(const RipTrack &track);
     void deleteAllExistingTracks(void);
     void updateTrackList(void);
-    void updateTrackLengths(void);
-    void toggleTrackActive(RipTrack *);
-    void ShowConflictMenu(RipTrack *);
+    void toggleTrackActive(RipTrack &);
+    void ShowConflictMenu(RipTrack &);
+    void updateAlbumInfo();
 
     QString    m_musicStorageDir;
 
@@ -163,13 +183,10 @@ class Ripper : public MythScreenType
     MythUIButton  *m_searchAlbumButton;
     MythUIButton  *m_searchGenreButton;
 
-    QVector<RipTrack*> *m_tracks;
+    trackList_t        m_tracks;
 
-    QString            m_albumName, m_artistName, m_genreName, m_year;
-    bool               m_isCompilation;
     QStringList        m_searchList;
     bool               m_somethingwasripped;
-    bool               m_mediaMonitorActive;
 
     QString            m_CDdevice;
 
@@ -210,12 +227,16 @@ class RipStatus : public MythScreenType
   Q_OBJECT
   public:
     RipStatus(MythScreenStack *parent, const QString &device,
-              QVector<RipTrack*> *tracks, int quality);
-    ~RipStatus(void);
+              const trackList_t &tracks, int quality);
+    ~RipStatus();
 
     bool Create(void);
     bool keyPressEvent(QKeyEvent *);
 
+    static bool isRipping();
+    static const trackList_t &getRipperTracks();
+    static void stopRipping();
+
   signals:
     void Result(bool);
 
@@ -225,7 +246,7 @@ class RipStatus : public MythScreenType
   private:
     void customEvent(QEvent *event);
 
-    QVector<RipTrack*> *m_tracks;
+    const trackList_t &m_tracks;
     int                m_quality;
     QString            m_CDdevice;
 
@@ -237,7 +258,7 @@ class RipStatus : public MythScreenType
     MythUIProgressBar *m_overallProgress;
     MythUIProgressBar *m_trackProgress;
 
-    CDRipperThread    *m_ripperThread;
+    static CDRipperThread *s_ripperThread;
 };
 
 #endif
diff --git a/mythplugins/mythmusic/mythmusic/main.cpp b/mythplugins/mythmusic/mythmusic/main.cpp
index bd6d67e..c0ed6ed 100644
--- a/mythplugins/mythmusic/mythmusic/main.cpp
+++ b/mythplugins/mythmusic/mythmusic/main.cpp
@@ -934,4 +934,8 @@ void mythplugin_destroy(void)
     delete gPlayer;
 
     delete gMusicData;
+
+#ifdef HAVE_CDIO
+    RipStatus::stopRipping();
+#endif
 }
-- 
1.7.9.5

