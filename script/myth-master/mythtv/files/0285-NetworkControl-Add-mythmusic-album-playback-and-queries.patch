diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/musicdata.cpp mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/musicdata.cpp
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/musicdata.cpp	2019-04-08 14:45:45.093333334 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/musicdata.cpp	2019-04-08 14:45:46.273333333 +0200
@@ -14,7 +14,10 @@
 #include "musicdata.h"
 #include "musicplayer.h"
 
-#include <unistd.h> // for usleep()
+//#include <unistd.h> // for usleep()
+
+#include <chrono> // for milliseconds
+#include <thread> // for sleep_for
 
 // this is the global MusicData object shared thoughout MythMusic
 MusicData  *gMusicData = nullptr;
@@ -84,7 +87,7 @@
     while (!m_all_music->doneLoading())
     {
         qApp->processEvents();
-        usleep(50000);
+        std::this_thread::sleep_for(std::chrono::milliseconds(50));
     }
 
     m_all_playlists->resync();
@@ -96,46 +99,39 @@
         gPlayer->restorePosition();
 }
 
-void MusicData::loadMusic(void)
+bool MusicData::loadMusic(void)
 {
-    // only do this once
-    if (m_initialized)
-        return;
-
-    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
-    QString message = qApp->translate("(MythMusicMain)",
-                                      "Loading Music. Please wait ...");
-
-    auto *busy = new MythUIBusyDialog(message, popupStack, "musicscanbusydialog");
-    if (busy->Create())
-        popupStack->AddScreen(busy, false);
-    else
-        busy = nullptr;
-
-    // Set the various track formatting modes
-    MusicMetadata::setArtistAndTrackFormats();
-
-    auto *all_music = new AllMusic();
-
-    //  Load all playlists into RAM (once!)
-    auto *all_playlists = new PlaylistContainer(all_music);
-
-    gMusicData->m_all_music = all_music;
-    gMusicData->m_all_streams = new AllStream();
-    gMusicData->m_all_playlists = all_playlists;
-
-    gMusicData->m_initialized = true;
-
-    while (!gMusicData->m_all_playlists->doneLoading()
-           || !gMusicData->m_all_music->doneLoading())
+    if (!initialized.fetchAndStoreAcquire(1))
     {
-        qApp->processEvents();
-        usleep(50000);
-    }
+        MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+        QString message = qApp->translate("(MythMusicMain)",
+                                          "Loading Music. Please wait ...");
+
+        auto *busy = new MythUIBusyDialog(message, popupStack, "musicscanbusydialog");
+
+        if (busy->Create())
+            popupStack->AddScreen(busy, false);
+        else
+            busy = nullptr;
+
+        // Set the various track formatting modes
+        MusicMetadata::setArtistAndTrackFormats();
+
+        m_all_music = new AllMusic();
+        m_all_playlists = new PlaylistContainer(m_all_music);
+        m_all_streams = new AllStream();
+
+        while (!m_all_playlists->doneLoading() || !m_all_music->doneLoading())
+        {
+            qApp->processEvents();
+            std::this_thread::sleep_for(std::chrono::milliseconds(50));
+        }
 
     gPlayer->loadStreamPlaylist();
     gPlayer->loadPlaylist();
 
     if (busy)
         busy->Close();
+    }
+    return m_all_music && m_all_playlists && m_all_streams;
 }
diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/musicdata.h mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/musicdata.h
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/musicdata.h	2019-04-08 14:45:45.093333334 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/musicdata.h	2019-04-08 14:45:46.273333333 +0200
@@ -1,9 +1,9 @@
 #ifndef MUSICDATA_H_
 #define MUSICDATA_H_
 
-
 // qt
 #include <QRunnable>
+#include <QAtomicInt>
 
 // myth
 #include <mythexp.h>
@@ -44,7 +44,7 @@
     ~MusicData();
 
     static void scanMusic(void);
-    void loadMusic(void);
+    bool loadMusic(void);
 
   public slots:
     void reloadMusic(void);
@@ -54,6 +54,7 @@
     AllMusic           *m_all_music     {nullptr};
     AllStream          *m_all_streams   {nullptr};
     bool                m_initialized   {false};
+    QAtomicInt         initialized;
 };
 
 // This global variable contains the MusicData instance for the application
diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/musicplayer.cpp mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/musicplayer.cpp
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/musicplayer.cpp	2019-04-08 14:45:45.126666667 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/musicplayer.cpp	2019-04-08 14:45:46.276666667 +0200
@@ -603,8 +603,11 @@
         if (!me)
             return;
 
+        static QString const kSep("//");
+
         if (me->Message().left(13) == "MUSIC_COMMAND")
         {
+
             QStringList list = me->Message().simplified().split(' ');
 
             if (list.size() >= 3 && list[1] == gCoreContext->GetHostName())
@@ -771,6 +774,171 @@
                         sendMetadataChangedEvent(songID);
                     }
                 }
+                else if (list[2] == "GET_ARTISTS")
+                {
+                    QString artist;
+                    if (list.size() >= 4)
+                        artist = QStringList(list.mid(3)).join(" ");
+
+                    QRegExp reArtist(!artist.isEmpty() ? artist : QString("*"),
+                        Qt::CaseInsensitive, QRegExp::WildcardUnix);
+
+                    QStringList matching;
+                    if (gMusicData && gMusicData->loadMusic())
+                    {
+                        MetadataPtrList *mlist = gMusicData->m_all_music->
+                                                    getAllMetadata();
+                        for ( MetadataPtrList::const_iterator it = mlist->begin();
+                            it != mlist->end(); ++it)
+                        {
+                            MusicMetadata *meta = *it;
+                            if (reArtist.exactMatch(meta->Artist()) )
+                            {
+                                if (!matching.contains(meta->Artist(),
+                                                        Qt::CaseInsensitive))
+                                    matching << meta->Artist();
+                            }
+                        }
+                        if (!matching.isEmpty())
+                            matching.sort();
+                        else
+                            matching << "<None>";
+                    }
+                    else
+                        matching << "<Uninitialised>";
+
+                    QString message = QString("MUSIC_CONTROL ANSWER %1 %2")
+                            .arg(gCoreContext->GetHostName())
+                            .arg(matching.join("\n"));
+                    MythEvent me(message);
+                    gCoreContext->dispatch(me);
+                }
+                else if (list[2] == "GET_ALBUMS")
+                {
+                    QString album, artist;
+                    if (list.size() >= 4)
+                    {
+                        album = QStringList(list.mid(3)).join(" ");
+                        artist = album.section(kSep,1);
+                        album = album.section(kSep,0,0);
+                    }
+
+                    QRegExp reAlbum(!album.isEmpty() ? album : QString("*"),
+                        Qt::CaseInsensitive, QRegExp::WildcardUnix);
+                    QRegExp reArtist(!artist.isEmpty() ? artist : QString("*"),
+                        Qt::CaseInsensitive, QRegExp::WildcardUnix);
+
+                    QStringList matching;
+                    if (gMusicData && gMusicData->loadMusic())
+                    {
+                        MetadataPtrList *mlist = gMusicData->m_all_music->
+                                                    getAllMetadata();
+                        for ( MetadataPtrList::const_iterator it = mlist->begin();
+                            it != mlist->end(); ++it)
+                        {
+                            MusicMetadata *meta = *it;
+                            if (reAlbum.exactMatch(meta->Album()) &&
+                                reArtist.exactMatch(meta->Artist()) )
+                            {
+                                QString match = meta->Album() + kSep + meta->Artist();
+                                if (!matching.contains(match, Qt::CaseInsensitive))
+                                    matching << match;
+                            }
+                        }
+                        if (!matching.isEmpty())
+                            matching.sort();
+                        else
+                            matching << "<None>";
+                    }
+                    else
+                        matching << "<Uninitialised>";
+
+                    QString message = QString("MUSIC_CONTROL ANSWER %1 %2")
+                            .arg(gCoreContext->GetHostName())
+                            .arg(matching.join("\n"));
+                    MythEvent me(message);
+                    gCoreContext->dispatch(me);
+                }
+                else if (list[2] == "GET_TRACKS")
+                {
+                    QString album, artist, title, playlist;
+                    if (list.size() >= 4)
+                    {
+                        artist = QStringList(list.mid(3)).join(" ");
+                        if (artist.startsWith("@"))
+                        {
+                            playlist = artist.section(kSep,0,0);
+                            album = artist.section(kSep,1,1);
+                            title = artist.section(kSep,3);
+                            artist = artist.section(kSep,2,2);
+                        }
+                        else
+                        {
+                            album = artist.section(kSep,0,0);
+                            title = artist.section(kSep,2);
+                            artist = artist.section(kSep,1,1);
+                        }
+                    }
+
+                    QStringList matching;
+                    if (gMusicData && gMusicData->loadMusic())
+                    {
+                        const MetadataPtrList *mlist;
+                        MetadataPtrList songs;
+
+                        if (!playlist.isEmpty())
+                        {
+                            playlist = playlist.mid(1); // strip leading @
+                            Playlist *plist = playlist.isEmpty() ?
+                                gMusicData->m_all_playlists->getActive() :
+                                gMusicData->m_all_playlists->getPlaylist(playlist);
+                            if (plist)
+                            {
+                                songs = plist->getSongs();
+                                mlist = &songs;
+                            }
+                            else
+                                mlist = nullptr;
+                        }
+                        else
+                            mlist = gMusicData->m_all_music->getAllMetadata();
+
+                        if (mlist)
+                        {
+                            QRegExp reAlbum(!album.isEmpty() ? album : QString("*"),
+                                Qt::CaseInsensitive, QRegExp::WildcardUnix);
+                            QRegExp reArtist(!artist.isEmpty() ? artist : QString("*"),
+                                Qt::CaseInsensitive, QRegExp::WildcardUnix);
+                            QRegExp reTitle(!title.isEmpty() ? title : QString("*"),
+                                Qt::CaseInsensitive, QRegExp::WildcardUnix);
+
+                            for (MetadataPtrList::const_iterator it = mlist->begin();
+                                it != mlist->end(); ++it)
+                            {
+                                MusicMetadata *meta = *it;
+                                if (reAlbum.exactMatch(meta->Album()) &&
+                                    reArtist.exactMatch(meta->Artist()) &&
+                                    reTitle.exactMatch(meta->Title()) )
+                                {
+                                    matching << meta->Artist() + kSep +
+                                                meta->Album() + kSep +
+                                                meta->Title() + kSep +
+                                                QString::number(meta->ID());
+                                }
+                            }
+                        }
+                        if (matching.isEmpty())
+                            matching << "<None>";
+                    }
+                    else
+                        matching << "<Uninitialised>";
+
+                    QString message = QString("MUSIC_CONTROL ANSWER %1 %2")
+                            .arg(gCoreContext->GetHostName())
+                            .arg(matching.join("\n"));
+                    MythEvent me(message);
+                    gCoreContext->dispatch(me);
+                }
             }
         }
         else if (me->Message().startsWith("MUSIC_SCANNER_STARTED"))
diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp	2019-04-08 14:45:45.093333334 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/playlistcontainer.cpp	2019-04-08 14:45:46.276666667 +0200
@@ -164,7 +164,7 @@
     QList<Playlist*>::iterator it = m_allPlaylists->begin();
     for (; it != m_allPlaylists->end(); ++it)
     {
-        if ((*it)->getName() == name)
+        if (0 == name.compare((*it)->getName(), Qt::CaseInsensitive))
             return *it;
     }
 
diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/playlist.cpp mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/playlist.cpp
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/playlist.cpp	2019-04-08 14:45:45.096666666 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/playlist.cpp	2019-04-08 14:45:46.276666667 +0200
@@ -1447,3 +1447,20 @@
     return -1;
 }
 #endif
+
+MetadataPtrList Playlist::getSongs() const
+{
+    MetadataPtrList list;
+    for ( SongList::const_iterator it = m_shuffledSongs.begin();
+        it != m_shuffledSongs.end(); ++it)
+    {
+        MusicMetadata::IdType id = *it;
+        int repo = ID_TO_REPO(id);
+
+        if (repo == RT_Radio)
+            list << gMusicData->m_all_streams->getMetadata(id);
+        else
+            list << gMusicData->m_all_music->getMetadata(id);
+    }
+    return list;
+}
diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/playlist.h mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/playlist.h
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/playlist.h	2019-04-08 14:45:45.096666666 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/playlist.h	2019-04-08 14:45:46.276666667 +0200
@@ -75,6 +75,7 @@
 
 
     MusicMetadata* getSongAt(int pos) const;
+    MetadataPtrList getSongs() const;
 
     int getTrackCount(void) { return m_songs.count(); }
 
diff -Naur mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/streamview.cpp mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/streamview.cpp
--- mythtv-master-20190408-g038e171-old/mythplugins/mythmusic/mythmusic/streamview.cpp	2019-04-08 14:45:45.093333334 +0200
+++ mythtv-master-20190408-g038e171-new/mythplugins/mythmusic/mythmusic/streamview.cpp	2019-04-08 14:45:46.276666667 +0200
@@ -66,6 +66,7 @@
     connect(m_streamList, SIGNAL(itemVisible(MythUIButtonListItem*)),
             this, SLOT(streamItemVisible(MythUIButtonListItem*)));
 
+    gPlayer->loadStreamPlaylist();
     gPlayer->setPlayMode(MusicPlayer::PLAYMODE_RADIO);
 
     updateStreamList();
diff -Naur mythtv-master-20190408-g038e171-old/mythtv/programs/mythfrontend/networkcontrol.cpp mythtv-master-20190408-g038e171-new/mythtv/programs/mythfrontend/networkcontrol.cpp
--- mythtv-master-20190408-g038e171-old/mythtv/programs/mythfrontend/networkcontrol.cpp	2019-04-08 14:45:45.126666667 +0200
+++ mythtv-master-20190408-g038e171-new/mythtv/programs/mythfrontend/networkcontrol.cpp	2019-04-08 14:45:46.276666667 +0200
@@ -1186,6 +1186,72 @@
 
         return result;
     }
+    else if (is_abbrev("artists", nc->getArg(1)))
+    {
+        gotAnswer = false;
+
+        MythEvent me(QString("MUSIC_COMMAND %1 GET_ARTISTS %2")
+                        .arg(gCoreContext->GetHostName())
+                        .arg(nc->getArgCount() >= 3 ? nc->getFrom(2) : "") );
+        gCoreContext->dispatch(me);
+
+        QTime timer;
+        timer.start();
+        while (timer.elapsed() < FE_SHORT_TO && !gotAnswer)
+        {
+            qApp->processEvents();
+            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+
+        if (gotAnswer)
+            return answer;
+
+        return "unknown";
+    }
+    else if (is_abbrev("albums", nc->getArg(1)))
+    {
+        gotAnswer = false;
+
+        MythEvent me(QString("MUSIC_COMMAND %1 GET_ALBUMS %2")
+                        .arg(gCoreContext->GetHostName())
+                        .arg(nc->getArgCount() >= 3 ? nc->getFrom(2) : "") );
+        gCoreContext->dispatch(me);
+
+        QTime timer;
+        timer.start();
+        while (timer.elapsed() < FE_SHORT_TO && !gotAnswer)
+        {
+            qApp->processEvents();
+            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+
+        if (gotAnswer)
+            return answer;
+
+        return "unknown";
+    }
+    else if (is_abbrev("tracks", nc->getArg(1)))
+    {
+        gotAnswer = false;
+
+        MythEvent me(QString("MUSIC_COMMAND %1 GET_TRACKS %2")
+                        .arg(gCoreContext->GetHostName())
+                        .arg(nc->getArgCount() >= 3 ? nc->getFrom(2) : "") );
+        gCoreContext->dispatch(me);
+
+        QTime timer;
+        timer.start();
+        while (timer.elapsed() < FE_SHORT_TO && !gotAnswer)
+        {
+            qApp->processEvents();
+            std::this_thread::sleep_for(std::chrono::milliseconds(10));
+        }
+
+        if (gotAnswer)
+            return answer;
+
+        return "unknown";
+    }
     else if (is_abbrev("events", nc->getArg(1)))
     {
         QString res = "OK";
@@ -1694,9 +1760,7 @@
                 (tokens[1] == "ANSWER") &&
                 (tokens[2] == gCoreContext->GetHostName()))
             {
-                answer = tokens[3];
-                for (int i = 4; i < tokens.size(); i++)
-                    answer += QString(" ") + tokens[i];
+                answer = message.section(' ', 3);
                 gotAnswer = true;
             }
 
