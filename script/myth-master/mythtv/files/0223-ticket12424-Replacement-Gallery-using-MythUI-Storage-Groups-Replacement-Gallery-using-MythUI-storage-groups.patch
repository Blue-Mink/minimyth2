diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagemetadata.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagemetadata.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagemetadata.cpp	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagemetadata.cpp	2015-04-30 11:17:45.408893215 +0200
@@ -1,216 +1,474 @@
-#include "mythcontext.h"
-
 #include "imagemetadata.h"
 
+#include <QRegExp>
+#include <QMap>
+#include <QPair>
+#include <QDateTime>
+#include <QMutexLocker>
+#include <QByteArray>
+
+// libexiv2 for Exif metadata
+#include <exiv2/exiv2.hpp>
+// Note: Older versions of Exiv2 don't have the exiv2.hpp include
+// file.  Using image.hpp instead seems to work.
+#ifdef _MSC_VER
+#include <exiv2/src/image.hpp>
+#else
+#include <exiv2/image.hpp>
+#endif
+
+#include <mythlogging.h>
+
+
+/*!
+ \brief Convert degree rotation into orientation code
+ \param degrees Rotation required to show video correctly
+ \return QString Code as per Exif spec.
+*/
+QString ExifOrientation::FromRotation(QString degrees)
+{
+    if      (degrees ==   "0") return "1";
+    else if (degrees ==  "90") return "6";
+    else if (degrees == "180") return "3";
+    else if (degrees == "270") return "8";
+    return "0";
+}
 
 
-/** \fn     ImageMetadata::ImageMetadata()
- *  \brief  Constructor
- *  \return void
- */
-ImageMetadata::ImageMetadata()
+/*!
+ \brief Converts orientation code to text description
+ \param orientation Exif code
+ \return QString Description text
+*/
+QString ExifOrientation::Description(QString orientation)
 {
-    m_id = 0;
-    m_fileName = "";
-    m_name = "";
-    m_path = "";
-    m_parentId = 0;
-    m_dirCount = 0;
-    m_fileCount = 0;
-    m_type = 0;
-    m_modTime = 0;
-    m_size = 0;
-    m_extension = "";
-    m_angle = 0;
-    m_orientation = 0;
-    m_date = 0;
-    m_zoom = 100;
-    m_isHidden = false;
-
-    m_selected = false;
-
-    m_thumbPath = "";
-    m_thumbFileNameList = new QList<QString>();
-
-    // Initialize the lists to avoid assertions.
-    for (int i = 0; i < kMaxFolderThumbnails; ++i)
-        m_thumbFileNameList->append(QString(""));
+    if      (orientation == "0") return tr("0 - Unset");
+    else if (orientation == "1") return tr("1 - Normal");
+    else if (orientation == "2") return tr("2 - Horizontally Reflected");
+    else if (orientation == "3") return tr("3 - Rotated 180°");
+    else if (orientation == "4") return tr("4 - Vertically Reflected");
+    else if (orientation == "5") return tr("5 - Rotated 90°, Horizontally Reflected");
+    else if (orientation == "6") return tr("6 - Rotated 270°");
+    else if (orientation == "7") return tr("7 - Rotated 90°, Vertically Reflected");
+    else if (orientation == "8") return tr("8 - Rotated 90°");
+    return orientation;
 }
 
 
-
-/** \fn     ImageMetadata::~ImageMetadata()
- *  \brief  Destructor
- *  \return void
+/*!
+ * \brief Determines effect of applying a transform to an image
+ * \sa http://jpegclub.org/exif_orientation.html
+ * \details These transforms are not intuitive!
+ * For rotations the orientation is adjusted in the opposite direction.
+ * The transform is applied from the user perspective (as the image will be displayed),
+ * not the current orientation. When rotated 90° horizontal/vertical flips are
+ * reversed, and when flipped rotations are reversed.
+ * \param im Image
+ * \param transform Rotation/flip
+ * \return int New orientation after applying transform
  */
-ImageMetadata::~ImageMetadata()
+int ExifOrientation::Transformed(int orientation, int transform)
 {
-    if (m_thumbFileNameList)
-        delete m_thumbFileNameList;
-}
+    switch (orientation)
+    {
+    case 0: // The image has no orientation info
+    case 1: // The image is in its original state
+        switch (transform)
+        {
+        case kRotateCW:       return 6;
+        case kRotateCCW:      return 8;
+        case kFlipHorizontal: return 2;
+        case kFlipVertical:   return 4;
+        default:              return orientation;
+        }
 
+    case 2: // The image is horizontally flipped
+        switch (transform)
+        {
+        case kRotateCW:       return 7;
+        case kRotateCCW:      return 5;
+        case kFlipHorizontal: return 1;
+        case kFlipVertical:   return 3;
+        default:              return orientation;
+        }
 
+    case 3: // The image is rotated 180°
+        switch (transform)
+        {
+        case kRotateCW:       return 8;
+        case kRotateCCW:      return 6;
+        case kFlipHorizontal: return 4;
+        case kFlipVertical:   return 2;
+        default:              return orientation;
+        }
 
-/** \fn     ImageMetadata::SetAngle(int)
- *  \brief  Sets the angle within the allowed range
- *  \param  angle The angle that shall be saved
- *  \return void
- */
-void ImageMetadata::SetAngle(int angle)
-{
-    m_angle += angle;
+    case 4: // The image is vertically flipped
+        switch (transform)
+        {
+        case kRotateCW:       return 5;
+        case kRotateCCW:      return 7;
+        case kFlipHorizontal: return 3;
+        case kFlipVertical:   return 1;
+        default:              return orientation;
+        }
 
-    if (m_angle >= 360)
-        m_angle -= 360;
+    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
+        switch (transform)
+        {
+        case kRotateCW:       return 2;
+        case kRotateCCW:      return 4;
+        case kFlipHorizontal: return 6;
+        case kFlipVertical:   return 8;
+        default:              return orientation;
+        }
 
-    if (m_angle < 0)
-        m_angle += 360;
-}
+    case 6: // The image is rotated 90° CCW
+        switch (transform)
+        {
+        case kRotateCW:       return 3;
+        case kRotateCCW:      return 1;
+        case kFlipHorizontal: return 5;
+        case kFlipVertical:   return 7;
+        default:              return orientation;
+        }
+
+    case 7: // The image is transversed  (rotated 90° CW and flipped
+        // vertically)
+        switch (transform)
+        {
+        case kRotateCW:       return 4;
+        case kRotateCCW:      return 2;
+        case kFlipHorizontal: return 8;
+        case kFlipVertical:   return 6;
+        default:              return orientation;
+        }
 
+    case 8: // The image is rotated 90° CW
+        switch (transform)
+        {
+        case kRotateCW:       return 1;
+        case kRotateCCW:      return 3;
+        case kFlipHorizontal: return 7;
+        case kFlipVertical:   return 5;
+        default:              return orientation;
+        }
 
+    default: return orientation;
+    }
+}
 
-/** \fn     ImageMetadata::SetZoom(int)
- *  \brief  Sets the zoom within the allowed range
- *  \param  zoom The zoom value that shall be saved
- *  \return void
- */
-void ImageMetadata::SetZoom(int zoom, bool replace)
+
+/*!
+ \brief Sets orientation, datestamp & comment from file metadata
+ \details Reads Exif for pictures, metadata tags from FFMPEG for videos
+ \param im The image item to set
+ \return bool True if metadata found
+*/
+bool ImageMetaData::PopulateMetaValues(ImageItem *im)
 {
-    if (replace)
+    QString absPath = ImageSg::getInstance()->GetFilePath(im);
+    TagMap tags;
+
+    // Only require orientation, date, comment
+    QPair<QString, QString> toBeFilled = qMakePair(QString(), QString());
+    tags.insert(EXIF_TAG_ORIENTATION, toBeFilled);
+    tags.insert(EXIF_TAG_DATETIME, toBeFilled);
+    tags.insert(EXIF_TAG_USERCOMMENT, toBeFilled);
+    tags.insert(EXIF_TAG_IMAGEDESCRIPTION, toBeFilled);
+
+    bool ok = false;
+    if (im->m_type == kImageFile)
     {
-        m_zoom = zoom;
-        return;
+        ok = ReadExifTags(absPath, tags);
+    }
+    else if (im->m_type == kVideoFile)
+    {
+        ok = ReadVideoTags(absPath, tags);
     }
 
-    m_zoom += zoom;
-
-    if (m_zoom > 300)
-        m_zoom = 300;
+    if (ok)
+    {
+        // Extract orientation
+        if (tags.contains(EXIF_TAG_ORIENTATION))
+        {
+            QString orient = tags.value(EXIF_TAG_ORIENTATION).first;
+            bool valid;
+            int orientation = orient.toInt(&valid);
+            im->m_orientation = (valid ? orientation : 0);
+        }
+        else
+        {
+            im->m_orientation = 0;
+            LOG(VB_FILE, LOG_DEBUG,
+                QString("Image: No Orientation metadata in %1").arg(im->m_name));
+        }
+
+        // Extract Datetime
+        if (tags.contains(EXIF_TAG_DATETIME))
+        {
+            QString date = tags.value(EXIF_TAG_DATETIME).first;
+            // Exif time has no timezone
+            QDateTime dateTime = QDateTime::fromString(date, "yyyy:MM:dd hh:mm:ss");
+            if (dateTime.isValid())
+                im->m_date = dateTime.toTime_t();
+        }
+        else
+        {
+            im->m_date = 0;
+            LOG(VB_FILE, LOG_DEBUG,
+                QString("Image: No DateStamp metadata in %1").arg(im->m_name));
+        }
+
+        // Extract User Comment or else Image Description
+        QString comment = "";
+        if (tags.contains(EXIF_TAG_USERCOMMENT))
+        {
+            comment = tags.value(EXIF_TAG_USERCOMMENT).first;
+        }
+        else if (tags.contains(EXIF_TAG_IMAGEDESCRIPTION))
+        {
+            comment = tags.value(EXIF_TAG_IMAGEDESCRIPTION).first;
+        }
+        else
+        {
+            LOG(VB_FILE, LOG_DEBUG, QString("Image: No Comment metadata in %1")
+                .arg(im->m_name));
+        }
+        im->m_comment = comment.simplified();
+    }
 
-    if (m_zoom < 20)
-        m_zoom = 20;
+    return ok;
 }
 
 
-
-/** \fn     ImageMetadata::GetOrientation()
- *  \brief  Gets the orientation of the image (rotated, vertically and/or
- *          horizontally flipped) depending on the old state.
- *  \return The new orientation
- */
-int ImageMetadata::GetOrientation()
+/*!
+ \brief Reads all metadata for an image
+ \param im The image
+ \param tags Map of metadata tags. Map values = Pair< camera value, camera tag label >
+For pictures: key = Exif standard tag name; for videos: key = Exif tag name for
+orientation, date & comment only and an arbitrary, unique int for all other tags.
+ \return bool True if metadata exists & could be read
+*/
+bool ImageMetaData::GetMetaData(ImageItem *im, TagMap &tags)
 {
-    return m_orientation;
-}
+    QString absPath = ImageSg::getInstance()->GetFilePath(im);
 
+    if (absPath.isEmpty())
+        return false;
 
+    //
+    bool ok = false;
+    if (im->m_type == kImageFile)
+    {
+        ok = ReadExifTags(absPath, tags);
+    }
+    else if (im->m_type == kVideoFile)
+    {
+        ok = ReadVideoTags(absPath, tags);
+    }
 
-/** \fn     ImageMetadata::SetOrientation(int)
- *  \brief  Sets the orientation of the image (rotated, vertically and/or
- *          horizontally flipped) depending on the old state.
- *  \param  orientation The orientation value that shall be set
- *  \return void
- */
-void ImageMetadata::SetOrientation(int orientation, bool replace = false)
-{
-    if (replace)
+    if (ok && tags.contains(EXIF_TAG_ORIENTATION))
     {
-        m_orientation = orientation;
-        return;
+        TagPair val = tags.value(EXIF_TAG_ORIENTATION);
+        tags.insert(EXIF_TAG_ORIENTATION,
+                    qMakePair(ExifOrientation::Description(val.first), val.second));
     }
+    return ok;
+}
 
-    switch (m_orientation)
-    {
-    case 0: // The image has no orientation saved
-    case 1: // If the image is in its original state
-        if (orientation == kFileRotateCW)
-            m_orientation = 8;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 6;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 2;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 4;
-        break;
 
-    case 2: // The image is horizontally flipped
-        if (orientation == kFileRotateCW)
-            m_orientation = 7;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 5;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 1;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 3;
-        break;
-
-    case 3: // The image is rotated 180°
-        if (orientation == kFileRotateCW)
-            m_orientation = 6;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 8;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 4;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 2;
-        break;
+/*!
+ \brief Get Exif tags for an image
+ \param filePath Image file
+ \param exif Map of exif tags & values requested and/or returned.
+ For each key the corresponding exif value is populated.
+ If empty it is populated with all exif key/values from the image.
+ \return bool False on exif error
+*/
+bool ImageMetaData::ReadExifTags(QString filePath, TagMap &tags)
+{
+    try
+    {
+        Exiv2::Image::AutoPtr image =
+            Exiv2::ImageFactory::open(filePath.toLocal8Bit().constData());
 
-    case 4: // The image is vertically flipped
-        if (orientation == kFileRotateCW)
-            m_orientation = 5;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 7;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 3;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 1;
-        break;
+        if (!image.get())
+        {
+            LOG(VB_GENERAL, LOG_ERR,
+                QString("Image: Exiv2 error: Could not open file %1").arg(
+                    filePath));
+            return false;
+        }
+
+        image->readMetadata();
+        Exiv2::ExifData &exifData = image->exifData();
+
+        if (exifData.empty())
+        {
+            LOG(VB_FILE, LOG_NOTICE,
+                QString("Image: Exiv2 error: No exif data for file %1").arg(filePath));
+            return false;
+        }
+
+        if (tags.isEmpty())
+        {
+            // No specific tags requested - extract all exif data
+            LOG(VB_FILE, LOG_DEBUG,
+                QString("Image: Found %1 tag(s) for file %2")
+                .arg(exifData.count())
+                .arg(filePath));
+
+            Exiv2::ExifData::const_iterator i;
+            for (i = exifData.begin(); i != exifData.end(); ++i)
+            {
+                QString label = QString::fromStdString(i->tagLabel());
+
+                // Ignore empty labels
+                if (!label.isEmpty())
+                {
+                    QString key   = QString::fromStdString(i->key());
+                    std::string rawValue = i->value().toString();
+                    QString value;
+
+                    if (key == EXIF_TAG_USERCOMMENT)
+                    {
+                        // Decode charset
+                        Exiv2::CommentValue comVal = Exiv2::CommentValue(rawValue);
+                        value = QString::fromStdString(comVal.comment());
+                    }
+                    else
+                        value = QString::fromStdString(rawValue);
+
+                    // Remove control chars from malformed exif values.
+                    // They can pervert the myth message response mechanism
+                    value.replace(QRegExp("[\\0000-\\0037]"), "");
+
+#if 0
+                    LOG(VB_FILE, LOG_DEBUG,
+                        QString("Image: Exif %1/\"%2\" (Type %3) : %4")
+                        .arg(key, label, i->typeName(), value));
+#endif
+                    tags.insert(key, qMakePair(value, label));
+                }
+            }
+        }
+        else
+        {
+            // Extract requested tags only
+            QMap<QString, QPair<QString, QString> >::iterator it;
+            for (it = tags.begin(); it != tags.end(); ++it)
+            {
+                Exiv2::ExifKey            key =
+                        Exiv2::ExifKey(it.key().toLocal8Bit().constData());
+                Exiv2::ExifData::iterator exifIt = exifData.findKey(key);
+
+                if (exifIt != exifData.end())
+                {
+                    QString value;
+                    std::string rawValue = exifIt->value().toString();
+                    if (key.key() == EXIF_TAG_USERCOMMENT)
+                    {
+                        // Decode charset
+                        Exiv2::CommentValue comVal = Exiv2::CommentValue(rawValue);
+                        value = QString::fromStdString(comVal.comment());
+                    }
+                    else
+                        value = QString::fromStdString(rawValue);
+
+                    it.value() = qMakePair(value, QString());
+                }
+            }
+        }
+        return true;
+    }
+    catch (Exiv2::Error &e)
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("Image: Exiv2 exception %1").arg(e.what()));
+    }
+    return false;
+}
 
-    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
-        if (orientation == kFileRotateCW)
-            m_orientation = 2;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 4;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 8;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 6;
-        break;
 
-    case 6: // The image is rotated 90° CCW
-        if (orientation == kFileRotateCW)
-            m_orientation = 1;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 3;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 7;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 5;
-        break;
-
-    case 7: // The image is transversed  (rotated 90° CW and flipped vertically)
-        if (orientation == kFileRotateCW)
-            m_orientation = 4;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 2;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 6;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 8;
-        break;
+/*!
+ \brief Extract metadata tags from FFMPEG dict
+ \param[in,out] tags Extracted tags
+ \param[in,out] arbKey Used as a map key for tags other than Orientation or Date
+ \param dict    FFMPEG metdata dict containing video metadata
+*/
+void ImageMetaData::ExtractVideoTags(TagMap &tags, int &arbKey, AVDictionary *dict)
+{
+    AVDictionaryEntry *avTag = av_dict_get(dict, "\0", NULL, AV_DICT_IGNORE_SUFFIX);
+    while (avTag)
+    {
+        QString key;
+        QString label = QString(avTag->key);
+        QString value = QString::fromUtf8(avTag->value);
+
+        if (label == "rotate")
+        {
+            // Flag orientation & convert to Exif code
+            key   = EXIF_TAG_ORIENTATION;
+            label = "Orientation";
+            value = ExifOrientation::FromRotation(value);
+        }
+        else if (label == "creation_time")
+        {
+            // Flag date & convert to Exif date format "YYYY:MM:DD"
+            key   = EXIF_TAG_DATETIME;
+            label = "Date and Time";
+            value.replace("-", ":");
+        }
+        else
+            key = QString::number(arbKey++);
+
+        tags.insert(key, qMakePair(value, label));
+#if 0
+        LOG(VB_FILE, LOG_DEBUG,
+            QString("Image: Video %1/\"%2\" : %3").arg(key, avTag->key, value));
+#endif
+        avTag = av_dict_get(dict, "\0", avTag, AV_DICT_IGNORE_SUFFIX);
+    }
+}
 
-    case 8: // The image is rotated 90° CW
-        if (orientation == kFileRotateCW)
-            m_orientation = 3;
-        else if (orientation == kFileRotateCCW)
-            m_orientation = 1;
-        else if (orientation == kFileFlipHorizontal)
-            m_orientation = 5;
-        else if (orientation == kFileFlipVertical)
-            m_orientation = 7;
-        break;
 
-    default:
-        break;
+/*!
+ \brief Get metadata tags from a video file
+ \param filePath Video file
+ \param[in,out] tags Map of extracted tags
+ \return bool True if metadata exists and could be read
+*/
+bool ImageMetaData::ReadVideoTags(QString filePath, TagMap &tags)
+{
+    {
+        QMutexLocker locker(avcodeclock);
+        av_register_all();
     }
+
+    AVFormatContext* p_context = NULL;
+    AVInputFormat* p_inputformat = NULL;
+    QByteArray local8bit = filePath.toLocal8Bit();
+
+    // Open file
+    if ((avformat_open_input(&p_context, local8bit.constData(),
+                             p_inputformat, NULL) < 0))
+        return false;
+
+    // Locate video stream
+    int vidStream = av_find_best_stream(p_context, AVMEDIA_TYPE_VIDEO, -1, -1, NULL, 0);
+    if (vidStream < 0)
+        return false;
+
+    // Cannot search tags so must extract them all
+    // No tag classification for video so use arbitrary, unique keys
+
+    int arbKey = 1;
+    // Extract file tags
+    ExtractVideoTags(tags, arbKey, p_context->metadata);
+    // Extract video tags
+    ExtractVideoTags(tags, arbKey, p_context->streams[vidStream]->metadata);
+
+    avformat_close_input(&p_context);
+
+    return true;
 }
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagemetadata.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagemetadata.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagemetadata.h	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagemetadata.h	2015-04-30 11:17:45.408893215 +0200
@@ -1,95 +1,64 @@
+//! \file
+//! \brief Reads metadata (Exif & video tags) from an image file
+
 #ifndef IMAGEMETADATA_H
 #define IMAGEMETADATA_H
 
-// Qt headers
-#include <QFileInfo>
-#include <QString>
-#include <QImage>
-#include <QList>
-
-// MythTV headers
-#include "mythmetaexp.h"
+#include <QCoreApplication>
+#include <QMap>
+#include <QPair>
 
+#include <mythmetaexp.h>
 
+// FFMPEG Metadata
+extern "C" {
+#include <libavformat/avformat.h>
+}
 
-// We need to use other names to avoid
-// getting coflicts with the videolist.h file
-enum ImageTreeNodeType {
-    kUnknown        = 0,
-    kBaseDirectory  = 1,
-    kSubDirectory   = 2,
-    kUpDirectory    = 3,
-    kImageFile      = 4,
-    kVideoFile      = 5
-};
+#include "imageutils.h"
+
+
+// Exif 2.2 standard tag names, see http://www.exiv2.org/tags.html
+#define EXIF_TAG_ORIENTATION      "Exif.Image.Orientation"
+#define EXIF_TAG_DATETIME         "Exif.Image.DateTime"
+#define EXIF_TAG_IMAGEDESCRIPTION "Exif.Image.ImageDescription"
+#define EXIF_TAG_USERCOMMENT      "Exif.Photo.UserComment"
 
-enum ImageFileOrientationState {
-    kFileRotateCW       = 0,
-    kFileRotateCCW      = 1,
-    kFileFlipHorizontal = 2,
-    kFileFlipVertical   = 3,
-    kFileZoomIn         = 4,
-    kFileZoomOut        = 5
-};
 
-enum ImageFileSortOrder {
-    kSortByNameAsc     = 0,
-    kSortByNameDesc    = 1,
-    kSortByModTimeAsc  = 2,
-    kSortByModTimeDesc = 3,
-    kSortByExtAsc      = 4,
-    kSortByExtDesc     = 5,
-    kSortBySizeAsc     = 6,
-    kSortBySizeDesc    = 7,
-    kSortByDateAsc     = 8,
-    kSortByDateDesc    = 9
+enum ImageFileTransform {
+    kResetExif      = 0, //!< Reset to Exif value
+    kRotateCW       = 1, //!< Rotate clockwise
+    kRotateCCW      = 2, //!< Rotate anti-clockwise
+    kFlipHorizontal = 3, //!< Reflect about vertical axis
+    kFlipVertical   = 4  //!< Reflect about horizontal axis
 };
 
-const static int kMaxFolderThumbnails = 4;
 
+//! Manages Exif orientation code
+class META_PUBLIC ExifOrientation
+{
+    Q_DECLARE_TR_FUNCTIONS(ExifOrientation)
+public:
+    static QString FromRotation(QString);
+    static QString Description(QString);
+    static int     Transformed(int, int);
+};
 
-class META_PUBLIC ImageMetadata
+
+//! Reads metadata from image files
+class META_PUBLIC ImageMetaData
 {
 public:
-    ImageMetadata();
-    ~ImageMetadata();
+    typedef QPair<QString, QString> TagPair;
+    typedef QMap<QString, TagPair>  TagMap;
 
-    // Database fields
-    int         m_id;
-    QString     m_fileName;
-    QString     m_name;
-    QString     m_path;
-    int         m_parentId;
-    int         m_dirCount;
-    int         m_fileCount;
-    int         m_type;
-    int         m_modTime;
-    int         m_size;
-    QString     m_extension;
-    double      m_date;
-    int         m_isHidden;
-
-    // Internal information
-    bool        m_selected;
-
-    int         GetAngle()  const   { return m_angle; }
-    int         GetZoom()   const   { return m_zoom; }
-    int         GetOrientation();
-    void        SetAngle(int);
-    void        SetZoom(int, bool);
-    void        SetOrientation(int, bool);
-
-    // Internal thumbnail information
-    QString         m_thumbPath;
-    QList<QString> *m_thumbFileNameList;
-    QList<int>      m_thumbFileIdList;
+    static bool PopulateMetaValues(ImageItem *);
+    static bool GetMetaData(ImageItem *, TagMap &);
 
 private:
-    int         m_zoom;
-    int         m_angle;
-    int         m_orientation;
+    static bool ReadExifTags(QString, TagMap &);
+    static bool ReadVideoTags(QString, TagMap &);
+    static void ExtractVideoTags(TagMap &tags, int &arbKey, AVDictionary *dict);
 };
 
-Q_DECLARE_METATYPE(ImageMetadata*)
-
 #endif // IMAGEMETADATA_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescan.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescan.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescan.cpp	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescan.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-// Qt headers
-
-// MythTV headers
-#include "mythcontext.h"
-#include "imagescan.h"
-
-
-
-ImageScan* ImageScan::m_instance = NULL;
-
-ImageScan::ImageScan()
-{
-    m_imageScanThread = new ImageScanThread();
-}
-
-
-
-ImageScan::~ImageScan()
-{
-    if (m_imageScanThread)
-    {
-        delete m_imageScanThread;
-        m_imageScanThread = NULL;
-    }
-}
-
-
-
-ImageScan* ImageScan::getInstance()
-{
-    if (!m_instance)
-        m_instance = new ImageScan();
-
-    return m_instance;
-}
-
-
-
-void ImageScan::StartSync()
-{
-    if (m_imageScanThread && !m_imageScanThread->isRunning())
-    {
-        m_imageScanThread->m_continue = true;
-        m_imageScanThread->start();
-    }
-}
-
-
-
-void ImageScan::StopSync()
-{
-    if (m_imageScanThread && m_imageScanThread->isRunning())
-        m_imageScanThread->m_continue = false;
-}
-
-
-
-bool ImageScan::SyncIsRunning()
-{
-    if (m_imageScanThread)
-        return m_imageScanThread->isRunning();
-
-    return false;
-}
-
-
-
-int ImageScan::GetCurrent()
-{
-    if (m_imageScanThread)
-        return m_imageScanThread->m_progressCount;
-
-    return 0;
-}
-
-
-
-int ImageScan::GetTotal()
-{
-    if (m_imageScanThread)
-        return m_imageScanThread->m_progressTotalCount;
-
-    return 0;
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescan.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescan.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescan.h	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescan.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-#ifndef IMAGESCAN_H
-#define IMAGESCAN_H
-
-// Qt headers
-
-// MythTV headers
-#include "imagescanthread.h"
-#include "mythmetaexp.h"
-
-
-
-class META_PUBLIC ImageScan
-{
-public:
-    static ImageScan*    getInstance();
-
-    void StartSync();
-    void StopSync();
-    bool SyncIsRunning();
-
-    int  GetCurrent();
-    int  GetTotal();
-
-private:
-    ImageScan();
-    ~ImageScan();
-    static ImageScan    *m_instance;
-
-    ImageScanThread     *m_imageScanThread;
-};
-
-#endif // IMAGESCAN_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanner.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanner.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanner.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanner.cpp	2015-04-30 11:17:45.412226535 +0200
@@ -0,0 +1,643 @@
+#include "imagescanner.h"
+
+#include <QtAlgorithms>
+
+#include <imagethumbs.h>
+#include <imagemetadata.h>
+#include <imageutils.h>
+
+/*!
+ \brief  Constructor
+*/
+ImageScanThread::ImageScanThread() :
+    MThread("ImageScanner"),
+    m_db(),
+    m_sg(ImageSg::getInstance()),
+    m_progressCount(0),
+    m_progressTotalCount(0),
+    m_dir(ImageSg::getInstance()->GetImageFilters()),
+    m_exclusions()
+{
+    QMutexLocker locker(&m_mutexState);
+    m_state = kDormant;
+}
+
+
+/*!
+ \brief  Destructor
+*/
+ImageScanThread::~ImageScanThread()
+{
+    cancel();
+    wait();
+}
+
+
+/*!
+ \brief  Clears the thumbnail list so that the thread can exit.
+*/
+void ImageScanThread::cancel()
+{
+    QMutexLocker locker(&m_mutexState);
+    m_state = kInterrupt;
+}
+
+
+/*!
+ \brief Return current scanner status
+ \return ScannerState
+*/
+ScannerState ImageScanThread::GetState()
+{
+    QMutexLocker locker(&m_mutexState);
+    return m_state;
+}
+
+
+/*!
+ \brief Request scan start/stop, clear Db
+ \param to New state
+*/
+void ImageScanThread::ChangeState(ScannerState to)
+{
+    QMutexLocker locker(&m_mutexState);
+    m_state = to;
+
+    // Restart thread if not already running
+    if (!this->isRunning())
+        this->start();
+}
+
+
+/*!
+ \brief Returns number of images scanned & total number to scan
+ \return QStringList "done/total"
+*/
+QStringList ImageScanThread::GetProgress()
+{
+    QMutexLocker locker(&m_mutexProgress);
+    return QStringList() << QString::number(m_progressCount)
+                         << QString::number(m_progressTotalCount);
+}
+
+
+/*!
+ \brief Notify listeners of mode & progress
+ \param mode Mode to broadcast
+*/
+void ImageScanThread::BroadcastStatus(QString mode)
+{
+    QStringList status;
+
+    { // Release lock before sending message
+        QMutexLocker locker(&m_mutexProgress);
+
+        status << mode
+               << QString::number(m_progressCount)
+               << QString::number(m_progressTotalCount);
+    }
+
+    MythEvent me = MythEvent("IMAGE_SCAN_STATUS", status);
+    gCoreContext->SendEvent(me);
+}
+
+
+/*!
+ \brief Counts images in a dir subtree
+ \details Ignores files/dirs that match exclusions regexp
+ \param dir Parent of subtree
+*/
+void ImageScanThread::CountTree(QDir &dir)
+{
+    QFileInfoList files = dir.entryInfoList();
+
+    foreach(const QFileInfo &fileInfo, files)
+    {
+        if (fileInfo.isFile())
+            ++m_progressTotalCount;
+        else if (m_exclusions.exactMatch(fileInfo.fileName()))
+            LOG(VB_GENERAL, LOG_INFO, QString("%1: Excluding %2")
+                .arg(objectName(), fileInfo.filePath()));
+        else
+        {
+            dir.cd(fileInfo.fileName());
+            CountTree(dir);
+            dir.cdUp();
+        }
+    }
+}
+
+
+/*!
+ \brief Counts images in a list of subtrees
+ \param paths List of dirs
+*/
+void ImageScanThread::CountFiles(QStringList paths)
+{
+    // Get exclusions as comma-seperated list using glob chars * and ?
+    QString excPattern = gCoreContext->GetSetting("GalleryIgnoreFilter", "");
+
+    // Combine into a single regexp
+    excPattern.replace(".", "\\."); // Preserve "."
+    excPattern.replace("*", ".*");  // Convert glob wildcard "*"
+    excPattern.replace("?", ".");  // Convert glob wildcard "?"
+    excPattern.replace(",", "|");   // Convert list to OR's
+
+    QString pattern = QString("^(%1)$").arg(excPattern);
+    m_exclusions = QRegExp(pattern);
+
+    LOG(VB_FILE, LOG_DEBUG, QString("%1: Exclude regexp is \"%2\"")
+        .arg(objectName(), pattern));
+
+    QMutexLocker locker(&m_mutexProgress);
+    m_progressCount       = 0;
+    m_progressTotalCount  = 0;
+
+    // Release lock to broadcast
+    locker.unlock();
+    BroadcastStatus("SCANNING");
+    locker.relock();
+
+    // Use global image filters
+    QDir dir = m_dir;
+    foreach(const QString &sgDir, paths)
+    {
+        dir.cd(sgDir);
+        CountTree(dir);
+    }
+}
+
+
+/*!
+ \brief Synchronises database to the storage group
+ \details Reads all dirs and files in storage group and populates database with
+ metadata for each. Broadcasts progress events whilst scanning and initiates
+ thumbnail generation when finished.
+*/
+void ImageScanThread::run()
+{
+    RunProlog();
+
+    setPriority(QThread::LowPriority);
+
+    QStringList removed;
+
+    // Scan requested ?
+    if (m_state == kScan)
+    {
+        LOG(VB_GENERAL, LOG_INFO, objectName() + ": Starting scan");
+
+        // Known files/dirs in the Db. Objects are either;
+        // - deleted explicitly (when matched to the filesystem),
+        // - or passed to the Thumbnail Generator (old dirs/files that have disappeared)
+        m_dbDirMap = new ImageMap();
+        m_dbFileMap = new ImageMap();
+
+        // Scan all SG dirs
+        QStringList paths = m_sg->GetStorageDirs();
+
+        CountFiles(paths);
+
+        // Load all available directories and files from the database so that
+        // they can be compared against the ones on the filesystem.
+        // Ignore root dir, which is notional
+        m_db.ReadDbItems(*m_dbFileMap, *m_dbDirMap,
+                           QString("file_id != %1").arg(ROOT_DB_ID));
+
+        // Ensure Root dir exists as first db entry and update last scan time
+        ImageItem root;
+        root.m_id            = ROOT_DB_ID;
+        root.m_name          = QString("");
+        root.m_parentId      = 0;
+        root.m_type          = kBaseDirectory;
+        root.m_modTime       = QDateTime::currentMSecsSinceEpoch() / 1000;
+
+        m_db.UpdateDbFile(&root);
+
+        // Now start the actual syncronization
+        foreach(const QString &path, paths)
+        {
+            QString base = path;
+            if (!base.endsWith('/'))
+                base.append('/');
+
+            LOG(VB_FILE, LOG_INFO,
+                QString("%1: Syncing from SG dir %2").arg(objectName(), path));
+
+            SyncFilesFromDir(path, ROOT_DB_ID, base);
+        }
+
+        // Adding or updating directories has been completed.
+        // The maps now only contain old directories & files that are not
+        // in the filesystem anymore. Remove them from the database
+        ImageList files = m_dbDirMap->values() + m_dbFileMap->values();
+        m_db.RemoveFromDB(files);
+
+        // Cleanup thumbnails
+        removed = ImageThumb::getInstance()->DeleteThumbs(m_dbFileMap->values(),
+                                                          m_dbDirMap->values());
+
+        LOG(VB_GENERAL, LOG_INFO, objectName() + ": Finished scan");
+
+        // Clean up containers & contents
+        delete m_dbFileMap;
+        delete m_dbDirMap;
+
+        // Wait for 'urgent' thumbs to be generated before notifying clients.
+        // Otherwise they'd have nothing to draw...
+        WaitForThumbs();
+    }
+
+    // Scan has completed or been interrupted. Now process any Clear request
+    if (m_state == kClear)
+    {
+        LOG(VB_GENERAL, LOG_INFO, objectName() + ": Clearing Database");
+
+        m_db.ClearDb();
+        ImageThumb::getInstance()->ClearAllThumbs();
+
+        removed = QStringList("ALL");
+    }
+
+    ChangeState(kDormant);
+
+    // Notify scan has finished
+    BroadcastStatus("");
+
+    // Notify clients of Db update
+    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", removed));
+
+    RunEpilog();
+}
+
+
+/*!
+ \brief Blocks until all urgent thumbnails have been generated. Time-outs after
+ 10 secs
+*/
+void ImageScanThread::WaitForThumbs()
+{
+    // Wait up to 10s for queue to empty.
+    int remaining = ImageThumb::getInstance()->GetQueueSize(kScannerUrgentPriority);
+
+    { // Counts now represent pending thumbnails
+        QMutexLocker locker(&m_mutexProgress);
+        m_progressCount       = 0;
+        m_progressTotalCount  = remaining;
+    }
+
+    int timeout = 100;
+    while (remaining > 0 && --timeout > 0)
+    {
+        BroadcastStatus("THUMBNAILS");
+        msleep(1000);
+        remaining = ImageThumb::getInstance()->GetQueueSize(kScannerUrgentPriority);
+        QMutexLocker locker(&m_mutexProgress);
+        m_progressCount = std::max(m_progressTotalCount - remaining, 0);
+    }
+    BroadcastStatus("THUMBNAILS");
+}
+
+
+/*!
+ \brief Scans a dir subtree and updates/populates db metadata to match filesystem
+ \details Detects all files that match image/video filters. Files/dirs that
+ match exclusions regexp are ignored.
+ \param path Dir that is subtree root
+ \param parentId Db id of the dir's parent dir
+ \param baseDirectory The storage group root dir path
+*/
+void ImageScanThread::SyncFilesFromDir(QString path,
+                                       int parentId,
+                                       QString baseDirectory)
+{
+    // Use global image filters
+    QDir dir = m_dir;
+    dir.cd(path);
+    QFileInfoList list = dir.entryInfoList();
+
+    foreach(const QFileInfo &fileInfo, list)
+    {
+        // Ignore excluded files
+        if (m_exclusions.exactMatch(fileInfo.fileName()))
+            continue;
+
+        { // Release lock before continuing
+            QMutexLocker locker(&m_mutexState);
+            if (m_state != kScan)
+            {
+                LOG(VB_GENERAL, LOG_INFO,
+                    QString("%1: Scan interrupted in %2").arg(objectName(), path));
+                return;
+            }
+        }
+
+        if (fileInfo.isDir())
+        {
+            // Get the id. This will be new parent id
+            // when we traverse down the current directory.
+            int id = SyncDirectory(fileInfo, parentId, baseDirectory);
+
+            // Get new files within this directory
+            QString fileName = fileInfo.absoluteFilePath();
+            SyncFilesFromDir(fileName, id, baseDirectory);
+        }
+        else
+        {
+            SyncFile(fileInfo, parentId, baseDirectory);
+
+            // Update progress count
+            { // Release lock quickly
+                QMutexLocker locker(&m_mutexProgress);
+                ++m_progressCount;
+            }
+            // report status on completion of every dir
+            BroadcastStatus("SCANNING");
+        }
+    }
+}
+
+
+/*!
+ \brief Updates/populates db for a dir
+ \details Dir is updated if dir modified time has changed since last scan.
+ \param fileInfo Dir info
+ \param parentId Db id of the dir's parent dir
+ \param baseDirectory The storage group root dir path
+ \return int Db id of this dir in db
+*/
+int ImageScanThread::SyncDirectory(QFileInfo fileInfo,
+                                   int parentId,
+                                   QString baseDirectory)
+{
+    LOG(VB_FILE, LOG_DEBUG, QString("%1: Syncing directory %2")
+        .arg(objectName(), fileInfo.absoluteFilePath()));
+
+    // Load all required information of the directory
+    ImageItem *dir = LoadDirectoryData(fileInfo, parentId, baseDirectory);
+
+    ImageItem *dbDir = m_dbDirMap->value(dir->m_fileName);
+    int id;
+
+    if (dbDir)
+    {
+        // The directory already exists in the db. Retain its id
+        id = dir->m_id = dbDir->m_id;
+
+        // Check for change of contents
+        if (dir->m_modTime != dbDir->m_modTime)
+        {
+            LOG(VB_FILE, LOG_INFO, QString("%1: Changed directory %2")
+                .arg(objectName(), fileInfo.absoluteFilePath()));
+            m_db.UpdateDbFile(dir);
+        }
+
+        // Remove the entry from the dbList
+        m_dbDirMap->remove(dir->m_fileName);
+        delete dbDir;
+    }
+    else
+    {
+        LOG(VB_FILE, LOG_INFO, QString("%1: New directory %2")
+            .arg(objectName(), fileInfo.absoluteFilePath()));
+
+        // The directory is not in the database list
+        // add it to the database and get the new id. This
+        // will be the new parent id for the subdirectories
+        id = m_db.InsertDbDirectory(*dir);
+    }
+    delete dir;
+    return id;
+}
+
+
+
+/*!
+ \brief Updates/populates db for an image/video file
+ \details Image is updated if file modified time has changed since last scan.
+Extracts orientation, date and 2 comments from exif data
+ \param fileInfo File info
+ \param parentId Db id of the file's parent dir
+ \param baseDirectory The storage group root dir path
+*/
+void ImageScanThread::SyncFile(QFileInfo fileInfo,
+                               int parentId,
+                               QString baseDirectory)
+{
+    // Load all required information of the file
+    ImageItem *im = LoadFileData(fileInfo, baseDirectory);
+
+    if (!im)
+    {
+        LOG(VB_FILE, LOG_DEBUG, QString("%1: Ignoring unknown file %2")
+            .arg(objectName(), fileInfo.absoluteFilePath()));
+        return;
+    }
+
+    // get db version of this file
+    ImageItem* oldim = m_dbFileMap->value(im->m_fileName);
+
+    if (oldim && oldim->m_modTime == im->m_modTime)
+    {
+        // File already known & hasn't changed
+        // Remove the entry from the dbList
+        m_dbFileMap->remove(im->m_fileName);
+        delete oldim;
+        delete im;
+        return;
+    }
+
+    if (oldim)
+    {
+        LOG(VB_FILE, LOG_INFO, QString("%1: Modified file %2")
+            .arg(objectName(), fileInfo.absoluteFilePath()));
+
+        // changed images retain their existing id
+        im->m_id = oldim->m_id;
+
+        // Remove the entry from the dbList
+        m_dbFileMap->remove(oldim->m_fileName);
+        delete oldim;
+    }
+    else
+    {
+        LOG(VB_FILE, LOG_INFO, QString("%1: New file %2")
+            .arg(objectName(), fileInfo.absoluteFilePath()));
+
+        // new images will be assigned an id by the db AUTO-INCREMENT
+        im->m_id = 0;
+    }
+
+    // Set the parent.
+    im->m_parentId = parentId;
+
+    // Set orientation, date, comment from file meta data
+    ImageMetaData::PopulateMetaValues(im);
+
+    // Update db
+    m_db.UpdateDbFile(im);
+
+    // Ensure thumbnail exists.
+    // Do all top level images asap (they may be needed when scan finishes)
+    // Thumb generator now owns image
+    ImageThumbPriority thumbPriority = (parentId == ROOT_DB_ID
+                         ? kScannerUrgentPriority : kBackgroundPriority);
+
+    ImageThumb::getInstance()->CreateThumbnail(im, thumbPriority);
+}
+
+
+/*!
+ \brief Creates metadata from directory info
+ \param fileInfo Dir info
+ \param parentId Db id of the dir's parent dir
+ \param baseDirectory The storage group root dir path
+ \return ImageItem New metadata object
+*/
+ImageItem* ImageScanThread::LoadDirectoryData(QFileInfo fileInfo,
+                                              int parentId,
+                                              QString baseDirectory)
+{
+    ImageItem *dirIm = new ImageItem();
+
+    QDir dir(baseDirectory);
+    dirIm->m_parentId    = parentId;
+    dirIm->m_fileName    = dir.relativeFilePath(fileInfo.absoluteFilePath());
+    dirIm->m_name        = fileInfo.fileName();
+    dirIm->m_path        = dir.relativeFilePath(fileInfo.absolutePath());
+    if (dirIm->m_path.isNull())
+        dirIm->m_path = "";
+    dirIm->m_modTime     = fileInfo.lastModified().toTime_t();
+    dirIm->m_type        = kSubDirectory;
+
+    return dirIm;
+}
+
+
+/*!
+ \brief Creates an item for an image file
+ \param fileInfo File info
+ \param parentId Db id of the file's parent dir
+ \param baseDirectory The storage group root dir path
+ \return ImageItem New metadata object
+*/
+ImageItem* ImageScanThread::LoadFileData(QFileInfo fileInfo,
+                                         QString baseDirectory)
+{
+    QString extension = fileInfo.suffix().toLower();
+    int type = m_sg->GetImageType(extension);
+    if (type == kUnknown)
+        return NULL;
+
+    ImageItem *image = new ImageItem();
+
+    QDir baseDir(baseDirectory);
+    image->m_fileName  = baseDir.relativeFilePath(fileInfo.absoluteFilePath());
+    image->m_name      = fileInfo.fileName();
+    image->m_path      = baseDir.relativeFilePath(fileInfo.absolutePath());
+    image->m_modTime   = fileInfo.lastModified().toTime_t();
+    image->m_size      = fileInfo.size();
+    image->m_type      = type;
+    image->m_extension = extension;
+    image->m_thumbPath = ImageUtils::ThumbPathOf(image);
+
+    return image;
+}
+
+
+ImageScan* ImageScan::m_instance = NULL;
+
+/*!
+ \brief Constructor
+*/
+ImageScan::ImageScan()
+{
+    m_imageScanThread = new ImageScanThread();
+}
+
+
+/*!
+ \brief Destructor
+*/
+ImageScan::~ImageScan()
+{
+    if (m_imageScanThread)
+    {
+        delete m_imageScanThread;
+        m_imageScanThread = NULL;
+    }
+}
+
+
+/*!
+ \brief Get singleton
+ \return ImageScan Scanner object
+*/
+ImageScan* ImageScan::getInstance()
+{
+    if (!m_instance)
+        m_instance = new ImageScan();
+
+    return m_instance;
+}
+
+
+/*!
+ \brief Process client requests for start scan, stop scan, clear Db and scan
+  progress queries
+ \param command Start, stop, clear or query
+ \return QStringList ("ERROR", Error message) or
+("OK", "SCANNING" | "", "done/total")
+*/
+QStringList ImageScan::HandleScanRequest(QStringList command)
+{
+    // Expects command & a single qualifier
+    if (command.size() != 2)
+        return QStringList("ERROR") << "Bad IMAGE_SCAN";
+
+    if (!m_imageScanThread)
+        // Should never happen
+        return QStringList("ERROR") << "Scanner is missing";
+
+    if (command[1] == "START")
+    {
+        // Must be dormant to start a scan
+        bool valid = (m_imageScanThread->GetState() == kDormant);
+
+        if (valid)
+            m_imageScanThread->ChangeState(kScan);
+
+        return valid ? QStringList("OK") : QStringList("ERROR") << "Scanner is busy";
+    }
+    else if (command[1] == "STOP")
+    {
+        // Must be scanning to interrupt
+        bool valid = (m_imageScanThread->GetState() == kScan);
+
+        if (valid)
+            m_imageScanThread->ChangeState(kInterrupt);
+
+        return valid ? QStringList("OK") : QStringList("ERROR") << "Scan not in progress";
+    }
+    else if (command[1] == "CLEAR")
+    {
+        // Must not be already clearing
+        bool valid = (m_imageScanThread->GetState() != kClear);
+
+        if (valid)
+            m_imageScanThread->ChangeState(kClear);
+
+        return valid ? QStringList("OK") : QStringList("ERROR") << "Clear already in progress";
+
+    }
+    else if (command[1] == "QUERY")
+    {
+        QStringList reply;
+        reply << "OK"
+              << (m_imageScanThread->isRunning() ? "SCANNING" : "")
+              << m_imageScanThread->GetProgress();
+        return reply;
+    }
+    LOG(VB_GENERAL, LOG_ERR, "ImageScanner: Unknown command");
+    return QStringList("ERROR") << "Unknown command";
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanner.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanner.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanner.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanner.h	2015-04-30 11:17:45.412226535 +0200
@@ -0,0 +1,110 @@
+//! \file
+//! \brief Synchronises image database to storage group
+//! \details Detects supported pictures and videos within storage group and populates
+//! the image database with metadata for each, including directory structure.
+//! After a scan completes, a background task then creates thumbnails for each new image
+//! to improve client performance.
+
+#ifndef IMAGESCAN_H
+#define IMAGESCAN_H
+
+#include <QFileInfo>
+#include <QMap>
+#include <QDir>
+#include <QRegExp>
+#include <QMutex>
+
+#include <mthread.h>
+#include <imageutils.h>
+
+
+//! \brief Current/last requested scanner state
+//! \details Valid state transitions are:
+//!  Scan -> Dormant : Scan requested
+//!  Clear -> Dormant : Clear db requested
+//!  Scan -> Interrupt -> Dormant : Scan requested, then interrupted
+//!  Scan -> Clear -> Dormant : Clear db requested during scan
+//!  Scan -> Interrupt -> Clear -> Dormant : Scan interrupted, then Clear Db requested
+enum ScannerState
+{
+    kScan,      //!< sync is pending/in effect
+    kInterrupt, //!< cancelled sync is pending/in effect
+    kClear,     //!< clear db is pending/in effect
+    kDormant    //!< doing nothing
+};
+
+
+//! Scanner worker thread
+class META_PUBLIC ImageScanThread : public MThread
+{
+public:
+    ImageScanThread();
+    ~ImageScanThread();
+
+    void cancel();
+    QStringList GetProgress();
+    ScannerState GetState();
+    void ChangeState(ScannerState to);
+
+protected:
+    void run();
+
+private:
+    ImageItem* LoadDirectoryData(QFileInfo, int, QString);
+    ImageItem* LoadFileData(QFileInfo, QString);
+
+    void SyncFilesFromDir(QString, int, QString);
+    int  SyncDirectory(QFileInfo, int, QString);
+    void SyncFile(QFileInfo, int, QString);
+    void WaitForThumbs();
+    void BroadcastStatus(QString);
+    void CountFiles(QStringList paths);
+    void CountTree(QDir &);
+
+    //! The latest state from all clients.
+    ScannerState m_state;
+    //! Mutex protecting state
+    QMutex m_mutexState;
+
+    // Global working vars
+    ImageDbWriter  m_db;
+    ImageSg       *m_sg;
+
+    //! Maps dir paths (relative to SG) to dir metadata
+    ImageMap *m_dbDirMap;
+    //! Maps file paths (relative to SG) to file metadata
+    ImageMap *m_dbFileMap;
+
+    //! Number of images scanned
+    int  m_progressCount;
+    //! Total number of images to scan
+    int  m_progressTotalCount;
+    //! Progress counts mutex
+    QMutex m_mutexProgress;
+
+    //! Global working dir for file detection
+    QDir m_dir;
+    //! Pattern of dir names to ignore whilst scanning
+    QRegExp m_exclusions;
+};
+
+
+//! Synchronises database to the filesystem
+class META_PUBLIC ImageScan
+{
+public:
+    static ImageScan*    getInstance();
+
+    QStringList HandleScanRequest(QStringList);
+
+private:
+    ImageScan();
+    ~ImageScan();
+
+    //! Scanner singleton
+    static ImageScan    *m_instance;
+    //! Internal thread
+    ImageScanThread     *m_imageScanThread;
+};
+
+#endif // IMAGESCAN_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanthread.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanthread.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanthread.cpp	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanthread.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,294 +0,0 @@
-// Qt headers
-
-// MythTV headers
-#include "mythcontext.h"
-#include "storagegroup.h"
-#include "imagescanthread.h"
-#include "imageutils.h"
-
-
-/** \fn     ImageScanThread::ImageScanThread()
- *  \brief  Constructor
- *  \return void
- */
-ImageScanThread::ImageScanThread() : MThread("ImageScanThread")
-{
-    // initialize all required data structures
-    m_dbDirList   = new QMap<QString, ImageMetadata *>;
-    m_dbFileList  = new QMap<QString, ImageMetadata *>;
-    m_continue = false;
-
-    m_progressCount       = 0;
-    m_progressTotalCount  = 0;
-}
-
-
-
-/** \fn     ImageScanThread::~ImageScanThread()
- *  \brief  Destructor
- *  \return void
- */
-ImageScanThread::~ImageScanThread()
-{
-    if (m_dbDirList)
-    {
-        delete m_dbDirList;
-        m_dbDirList = NULL;
-    }
-
-    if (m_dbFileList)
-    {
-        delete m_dbFileList;
-        m_dbFileList = NULL;
-    }
-}
-
-
-
-/** \fn     ImageScanThread::run()
- *  \brief  Called when the thread is started. Loads all storage groups files
- *          and directories and also from the database and syncronizes them.
- *  \return void
- */
-void ImageScanThread::run()
-{
-    RunProlog();
-
-    if (!m_continue)
-    {
-        LOG(VB_GENERAL, LOG_DEBUG,
-            QString("Image scanning thread not allowed to start."));
-        return;
-    }
-
-    LOG(VB_GENERAL, LOG_DEBUG, "Syncronisation started");
-
-    m_progressCount       = 0;
-    m_progressTotalCount  = 0;
-    
-    // Load all available directories and files from the database so that
-    // they can be compared against the ones on the filesystem.
-    ImageUtils *iu = ImageUtils::getInstance();
-    iu->LoadDirectoriesFromDB(m_dbDirList);
-    iu->LoadFilesFromDB(m_dbFileList);
-
-    QStringList paths = iu->GetStorageDirs();
-
-    // Get the total list of directories that will be synced.
-    // This is only an additional information that the themer can show.
-    for (int i = 0; i < paths.size(); ++i)
-    {
-        QString path = paths.at(i);
-        QDirIterator it(path, QDirIterator::Subdirectories);
-
-        while(it.hasNext())
-        {
-            it.next();
-            ++m_progressTotalCount;
-        }
-    }
-
-    // Now start the actual syncronization
-    for (int i = 0; i < paths.size(); ++i)
-    {
-        QString path = paths.at(i);
-        QString base = path;
-        if (!base.endsWith('/'))
-            base.append('/');
-        SyncFilesFromDir(path, 0, base);
-    }
-
-    // Adding or updating directories have been completed.
-    // The directory list still contains the remaining directories
-    // that are not in the filesystem anymore. Remove them from the database
-    QMap<QString, ImageMetadata *>::iterator i;
-    for (i = m_dbDirList->begin(); i != m_dbDirList->end(); ++i)
-    {
-        iu->RemoveDirectoryFromDB(m_dbDirList->value(i.key()));
-    }
-
-    // Repeat the same for the file list.
-    for (i = m_dbFileList->begin(); i != m_dbFileList->end(); ++i)
-    {
-        iu->RemoveFileFromDB(m_dbFileList->value(i.key()));
-    }
-
-    m_continue = false;
-    m_progressCount       = 0;
-    m_progressTotalCount  = 0;
-
-    LOG(VB_GENERAL, LOG_DEBUG, "Syncronisation complete");
-
-    RunEpilog();
-}
-
-
-
-/** \fn     ImageScanThread::SyncFilesFromDir(QString &, int)
- *  \brief  Loads all available files from the path on the
- *          backend and syncs depending if they are a directory or file
- *  \param  path The current directory with the files that shall be scanned syncronized
- *  \param  parentId The id of the parent directory which is required for possible subdirectories
- *  \param  baseDirectory The current root storage group path, this will be stripped before insertion into the database
- *  \return void
- */
-void ImageScanThread::SyncFilesFromDir(QString &path, int parentId,
-                                       const QString &baseDirectory)
-{
-    if (!m_continue)
-    {
-        LOG(VB_FILE, LOG_DEBUG,
-            QString("Syncing from SG dir %1 interrupted").arg(path));
-        return;
-    }
-
-    LOG(VB_FILE, LOG_DEBUG,
-        QString("Syncing from SG dir %1").arg(path));
-
-    QDir dir(path);
-    if (!dir.exists())
-        return;
-
-    // Only get files and dirs, no special and hidden stuff
-    dir.setFilter(QDir::Dirs | QDir::Files |
-                  QDir::NoDotAndDotDot | QDir::NoSymLinks);
-    QFileInfoList list = dir.entryInfoList();
-    if (list.isEmpty())
-        return;
-
-    for (QFileInfoList::iterator it = list.begin(); it != list.end(); ++it)
-    {
-        if (!m_continue)
-        {
-            LOG(VB_FILE, LOG_DEBUG,
-                QString("Syncing from SG dir %1 interrupted").arg(path));
-            return;
-        }
-
-        QFileInfo fileInfo = *it;
-        if (fileInfo.isDir())
-        {
-            // Get the id. This will be new parent id
-            // when we traverse down the current directory.
-            int id = SyncDirectory(fileInfo, parentId, baseDirectory);
-
-            // Get new files within this directory
-            QString fileName = fileInfo.absoluteFilePath();
-            SyncFilesFromDir(fileName, id, baseDirectory);
-        }
-        else
-        {
-            SyncFile(fileInfo, parentId, baseDirectory);
-        }
-
-        // Increase the current progress count in case a
-        // progressbar is used to show the sync progress
-        if (m_progressTotalCount > m_progressCount)
-            ++m_progressCount;
-    }
-}
-
-
-
-/** \fn     ImageScanThread::SyncDirectory(QFileInfo &, int)
- *  \brief  Syncronizes a directory with the database.
- *          Either inserts or deletes the information in the database.
- *  \param  fileInfo The information of the directory
- *  \param  parentId The parent directory which will be saved with the file
- *  \param  baseDirectory The current root storage group path, this will be stripped before insertion into the database
- *  \return void
- */
-int ImageScanThread::SyncDirectory(QFileInfo &fileInfo, int parentId, const QString &baseDirectory)
-{
-
-    LOG(VB_FILE, LOG_DEBUG, QString("Syncing directory %1")
-        .arg(fileInfo.absoluteFilePath()));
-
-    ImageMetadata *im = new ImageMetadata();
-
-    if (!m_dbDirList->contains(fileInfo.absoluteFilePath()))
-    {
-        // Load all required information of the directory
-        ImageUtils *iu = ImageUtils::getInstance();
-        iu->LoadDirectoryData(fileInfo, im, parentId, baseDirectory);
-
-        // The directory is not in the database list
-        // add it to the database and get the new id. This
-        // will be the new parent id for the subdirectories
-        im->m_id = iu->InsertDirectoryIntoDB(im);
-    }
-    else
-    {
-        // The directory exists in the db list
-        // Get the id which will be the new
-        // parent id for the subdirectories
-        im->m_id = m_dbDirList->value(fileInfo.absoluteFilePath())->m_id;
-
-        // Remove the entry from the dbList
-        // so we don't need to search again
-        m_dbDirList->remove(fileInfo.absoluteFilePath());
-    }
-
-    int id = im->m_id;
-    delete im;
-
-    return id;
-}
-
-
-
-/** \fn     ImageScanThread::SyncFile(QFileInfo &, int)
- *  \brief  Syncronizes a file with the database. Either inserts,
- *          updates or deletes the information in the database.
- *  \param  fileInfo The information of the file
- *  \param  parentId The parent directory which will be saved with the file
- *  \return void
- */
-void ImageScanThread::SyncFile(QFileInfo &fileInfo, int parentId,
-                               const QString &baseDirectory)
-{
-    LOG(VB_FILE, LOG_DEBUG, QString("Syncing file %1")
-        .arg(fileInfo.absoluteFilePath()));
-
-    if (!m_dbFileList->contains(fileInfo.absoluteFilePath()))
-    {
-        ImageMetadata *im = new ImageMetadata();
-
-        // Load all required information of the file
-        ImageUtils *iu = ImageUtils::getInstance();
-        iu->LoadFileData(fileInfo, im, baseDirectory);
-
-        // Only load the file if contains a valid file extension
-        LOG(VB_FILE, LOG_DEBUG, QString("Type of file %1 is %2, extension %3").arg(im->m_fileName).arg(im->m_type).arg(im->m_extension));
-        if (im->m_type != kUnknown)
-        {
-            // Load any required exif information if the file is an image
-            if (im->m_type == kImageFile)
-            {
-                bool ok;
-
-                int exifOrientation = iu->GetExifOrientation(fileInfo.absoluteFilePath(), &ok);
-                if (ok)
-                    im->SetOrientation(exifOrientation, true);
-
-                int exifDate = iu->GetExifDate(fileInfo.absoluteFilePath(), &ok);
-                if (ok)
-                    im->m_date = exifDate;
-            }
-
-            // Load the parent id. This is the id of the file's path
-            im->m_parentId = parentId;
-
-            // The file is not in the database list
-            // add it to the database.
-            im->m_id = iu->InsertFileIntoDB(im);
-        }
-        delete im;
-    }
-    else
-    {
-        // Remove the entry from the dbList
-        // so we don't need to search again
-        m_dbFileList->remove(fileInfo.absoluteFilePath());
-    }
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanthread.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanthread.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagescanthread.h	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagescanthread.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-#ifndef IMAGESCANTHREAD_H
-#define IMAGESCANTHREAD_H
-
-// Qt headers
-#include <QApplication>
-#include <QFileInfo>
-#include <QMap>
-
-// MythTV headers
-#include "mthread.h"
-#include "imagemetadata.h"
-
-class ImageScanThread : public MThread
-{
-public:
-    ImageScanThread();
-    ~ImageScanThread();
-
-    bool m_continue;
-    int  m_progressCount;
-    int  m_progressTotalCount;
-
-protected:
-    void run();
-
-private slots:
-
-private:
-    void SyncFilesFromDir(QString &path, int parentId, const QString &baseDirectory);
-    int  SyncDirectory(QFileInfo &fileInfo, int parentId, const QString &baseDirectory);
-    void SyncFile(QFileInfo &fileInfo, int parentId, const QString &baseDirectory);
-
-    QMap<QString, ImageMetadata *> *m_dbDirList;
-    QMap<QString, ImageMetadata *> *m_dbFileList;
-};
-
-#endif // IMAGESCANTHREAD_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,393 +0,0 @@
-// Qt headers
-#include <QPainter>
-#include <QFile>
-
-// MythTV headers
-#include "mythcontext.h"
-#include "mythdirs.h"
-#include "mythuihelper.h"
-#include "mythsystemlegacy.h"
-#include "exitcodes.h"
-
-#include "imagemetadata.h"
-#include "imageutils.h"
-#include "imagethumbgenthread.h"
-
-/** \fn     ImageThumbGenThread::ImageThumbGenThread()
- *  \brief  Constructor
- *  \return void
- */
-ImageThumbGenThread::ImageThumbGenThread()
-        :   m_progressCount(0), m_progressTotalCount(0),
-            m_width(400), m_height(300),
-            m_pause(false), m_fileListSize(0)
-{
-    QString sgName = IMAGE_STORAGE_GROUP;
-    m_storageGroup = StorageGroup(sgName, gCoreContext->GetHostName());
-
-    if (!gCoreContext->IsMasterBackend())
-        LOG(VB_GENERAL, LOG_ERR, "ImageThumbGenThread MUST be run on the master backend");
-}
-
-
-
-/** \fn     ImageThumbGenThread::~ImageThumbGenThread()
- *  \brief  Destructor
- *  \return void
- */
-ImageThumbGenThread::~ImageThumbGenThread()
-{
-    cancel();
-    wait();
-}
-
-
-
-/** \fn     ImageThumbGenThread::run()
- *  \brief  Called when the thread starts. Tries to generate
- *          thumbnails from the file list until its empty or aborted.
- *  \return void
- */
-void ImageThumbGenThread::run()
-{
-    volatile bool exit = false;
-
-    m_mutex.lock();
-    m_fileListSize = m_fileList.size();
-    m_mutex.unlock();
-
-    while (!exit)
-    {
-        ImageMetadata *im = NULL;
-
-        m_mutex.lock();
-        if (!m_fileList.isEmpty())
-            im = m_fileList.takeFirst();
-
-        // Update the progressbar even if the thumbnail will not be created
-        emit UpdateThumbnailProgress(m_fileList.size(), m_fileListSize);
-        m_mutex.unlock();
-
-        if (im)
-        {
-            if (im->m_type == kImageFile)
-            {
-                CreateImageThumbnail(im);
-            }
-            else if (im->m_type == kVideoFile)
-            {
-                CreateVideoThumbnail(im);
-            }
-        }
-
-        delete im;
-
-        m_mutex.lock();
-        exit = m_fileList.isEmpty();
-        m_mutex.unlock();
-
-        // Allows the thread to be paused when Pause() was called
-        m_mutex.lock();
-        if (m_pause)
-            m_condition.wait(&m_mutex);
-        m_mutex.unlock();
-    }
-}
-
-
-
-/** \fn     ImageThumbGenThread::CreateImageThumbnail(ImageMetadata *, int)
- *  \brief  Creates a thumbnail with the correct size and rotation
- *  \param  im The thumbnail details
- *  \param  dataid The id of the thumbnail
- *  \return void
- */
-void ImageThumbGenThread::CreateImageThumbnail(ImageMetadata *im)
-{
-    if (QFile(im->m_thumbFileNameList->at(0)).exists())
-        return;
-
-    QDir dir;
-    if (!dir.exists(im->m_thumbPath))
-        dir.mkpath(im->m_thumbPath);
-
-    QString imageFileName = m_storageGroup.FindFile(im->m_fileName);
-
-    QImage image;
-    if (!image.load(imageFileName))
-    {
-        LOG(VB_FILE, LOG_ERR, QString("Failed to create pic thumbnail for %1").arg(imageFileName));
-        return;
-    }
-
-    Resize(image);
-
-    QMatrix matrix;
-    switch (im->GetOrientation())
-    {
-    case 1: // If the image is in its original state
-        break;
-
-    case 2: // The image is horizontally flipped
-        image = image.mirrored(true, false);
-        break;
-
-    case 3: // The image is rotated 180°
-        matrix.rotate(180);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        break;
-
-    case 4: // The image is vertically flipped
-        image = image.mirrored(false, true);
-        break;
-
-    case 5: // The image is transposed (rotated 90° CW flipped horizontally)
-        matrix.rotate(90);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        image = image.mirrored(true, false);
-        break;
-
-    case 6: // The image is rotated 90° CCW
-        matrix.rotate(270);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        break;
-
-    case 7: // The image is transversed  (rotated 90° CW and flipped vertically)
-        matrix.rotate(90);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        image = image.mirrored(false, true);
-        break;
-
-    case 8: // The image is rotated 90° CW
-        matrix.rotate(90);
-        image = image.transformed(matrix, Qt::SmoothTransformation);
-        break;
-
-    default:
-        break;
-    }
-
-    // save the image in the thumbnail directory
-    if (image.save(im->m_thumbFileNameList->at(0)))
-    {
-        LOG(VB_FILE, LOG_DEBUG, QString("Created pic thumbnail for %1").arg(imageFileName));
-        QString msg = "IMAGE_THUMB_CREATED %1";
-        gCoreContext->SendMessage(msg.arg(im->m_id));
-    }
-}
-
-
-
-/** \fn     ImageThumbGenThread::CreateVideoThumbnail(ImageMetadata *)
- *  \brief  Creates a video preview image with the correct size
- *  \param  im The thumbnail details
- *  \return void
- */
-void ImageThumbGenThread::CreateVideoThumbnail(ImageMetadata *im)
-{
-    if (QFile(im->m_thumbFileNameList->at(0)).exists())
-        return;
-
-    QDir dir;
-    if (!dir.exists(im->m_thumbPath))
-        dir.mkpath(im->m_thumbPath);
-
-    QString videoFileName = m_storageGroup.FindFile(im->m_fileName);
-
-    QString cmd = "mythpreviewgen";
-    QStringList args;
-    args << logPropagateArgs.split(" ", QString::SkipEmptyParts);
-    args << "--infile"  << '"' + videoFileName + '"';
-    args << "--outfile" << '"' + im->m_thumbFileNameList->at(0) + '"';
-
-    MythSystemLegacy ms(cmd, args, kMSRunShell);
-    ms.SetDirectory(im->m_thumbPath);
-    ms.Run();
-
-    // If the process exited successful
-    // then try to load the thumbnail
-    if (ms.Wait() == GENERIC_EXIT_OK)
-    {
-        QImage image;
-        if (!image.load(im->m_thumbFileNameList->at(0)))
-            return;
-
-        Resize(image);
-
-        // save the default image in the thumbnail directory
-        if (image.save(im->m_thumbFileNameList->at(0)))
-        {
-            emit ThumbnailCreated(im, 0);
-            QString msg = "IMAGE_THUMB_CREATED %1";
-            gCoreContext->SendMessage(msg.arg(im->m_id));
-        }
-    }
-}
-
-
-
-/** \fn     ImageThumbGenThread::Resize(QImage)
- *  \brief  Resizes the thumbnail to prevent black areas 
- *          around the image when its shown in a widget.
- *  \param  The image that shall be resized
- *  \return void
- */
-void ImageThumbGenThread::Resize(QImage &image)
-{
-    QSize size = QSize(m_width, m_height);
-
-    image = image.scaled(size, Qt::KeepAspectRatio, Qt::SmoothTransformation);
-}
-
-
-
-/** \fn     ImageThumbGenThread::AddToThumbnailList(ImageMetadata *)
- *  \brief  Adds a file to the thumbnail list
- *  \param  im The file information
- *  \param  recreate Force thumbnail regeneration even if it already exists
- *  \return void
- */
-void ImageThumbGenThread::AddToThumbnailList(ImageMetadata *im,
-                                             bool recreate)
-{
-    if (!im)
-        return;
-
-    if (recreate)
-        // remove any existing thumbnail to force its regeneration
-        QFile::remove(im->m_thumbFileNameList->at(0));
-
-    m_mutex.lock();
-    m_fileList.append(im);
-    m_fileListSize = m_fileList.size();
-    m_mutex.unlock();
-}
-
-
-
-/** \fn     ImageThumbGenThread::cancel()
- *  \brief  Clears the thumbnail list so that the thread can exit.
- *  \return void
- */
-void ImageThumbGenThread::cancel()
-{
-    m_mutex.lock();
-    while (!m_fileList.isEmpty())
-        delete m_fileList.takeFirst();
-    m_fileListSize = 0;
-    m_mutex.unlock();
-
-    emit UpdateThumbnailProgress(0, 0);
-}
-
-
-
-/** \fn     ImageThumbGenThread::Pause()
- *  \brief  Pauses the thumbnail generation
- *  \return void
- */
-void ImageThumbGenThread::Pause()
-{
-    m_pause = true;
-}
-
-
-
-/** \fn     ImageThumbGenThread::Resume()
- *  \brief  Resumes the thumbnail generation
- *  \return void
- */
-void ImageThumbGenThread::Resume()
-{
-    m_condition.wakeAll();
-    m_pause = false;
-}
-
-
-
-//////////////////////////////////////////////////////////////////////////
-
-
-ImageThumbGen* ImageThumbGen::m_instance = NULL;
-
-ImageThumbGen::ImageThumbGen()
-{
-    m_imageThumbGenThread = new ImageThumbGenThread();
-}
-
-
-
-ImageThumbGen::~ImageThumbGen()
-{
-    delete m_imageThumbGenThread;
-    m_imageThumbGenThread = NULL;
-}
-
-
-
-ImageThumbGen* ImageThumbGen::getInstance()
-{
-    if (!m_instance)
-        m_instance = new ImageThumbGen();
-
-    return m_instance;
-}
-
-
-
-void ImageThumbGen::StartThumbGen()
-{
-    if (m_imageThumbGenThread && !m_imageThumbGenThread->isRunning())
-        m_imageThumbGenThread->start();
-}
-
-
-
-void ImageThumbGen::StopThumbGen()
-{
-    if (m_imageThumbGenThread && m_imageThumbGenThread->isRunning())
-        m_imageThumbGenThread->cancel();
-}
-
-
-
-bool ImageThumbGen::ThumbGenIsRunning()
-{
-    if (m_imageThumbGenThread)
-        return m_imageThumbGenThread->isRunning();
-
-    return false;
-}
-
-
-
-int ImageThumbGen::GetCurrent()
-{
-    if (m_imageThumbGenThread)
-        return m_imageThumbGenThread->m_progressCount;
-
-    return 0;
-}
-
-
-
-int ImageThumbGen::GetTotal()
-{
-    if (m_imageThumbGenThread)
-        return m_imageThumbGenThread->m_progressTotalCount;
-
-    return 0;
-}
-
-
-
-bool ImageThumbGen::AddToThumbnailList(ImageMetadata *im,
-                                       bool recreate)
-{
-    if (!m_imageThumbGenThread)
-        return false;
-
-    m_imageThumbGenThread->AddToThumbnailList(im, recreate);
-
-    return true;
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbgenthread.h	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbgenthread.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
-#ifndef GALLERYTHUMBGENTHREAD_H
-#define GALLERYTHUMBGENTHREAD_H
-
-// Qt headers
-#include <QThread>
-#include <QMutex>
-#include <QWaitCondition>
-
-// MythTV headers
-#include "mythuibuttontree.h"
-#include "imagemetadata.h"
-#include "storagegroup.h"
-#include "mythmetaexp.h"
-
-class META_PUBLIC ImageThumbGenThread : public QThread
-{
-    Q_OBJECT
-
-  public:
-    ImageThumbGenThread();
-    ~ImageThumbGenThread();
-
-    void cancel();
-    void Pause();
-    void Resume();
-    void AddToThumbnailList(ImageMetadata *, bool);
-    void SetThumbnailSize(int, int);
-
-    int m_progressCount;
-    int m_progressTotalCount;
-
-  signals:
-    void ThumbnailCreated(ImageMetadata *, int);
-    void UpdateThumbnailProgress(int, int);
-
-  protected:
-    void run();
-
-  private:
-    void CreateImageThumbnail(ImageMetadata *);
-    void CreateVideoThumbnail(ImageMetadata *);
-
-    void Resize(QImage &);
-    void Rotate(QImage &);
-    void Combine(QImage &, QImage &, QPoint);
-    void DrawBorder(QImage &);
-
-    QList<ImageMetadata *>    m_fileList;
-    QMutex              m_mutex;
-
-    int m_width;
-    int m_height;
-    bool m_pause;
-    int m_fileListSize;
-
-    QWaitCondition      m_condition;
-    StorageGroup        m_storageGroup;
-};
-
-class META_PUBLIC ImageThumbGen
-{
-  public:
-    static ImageThumbGen*    getInstance();
-
-    void StartThumbGen();
-    void StopThumbGen();
-    bool ThumbGenIsRunning();
-
-    bool AddToThumbnailList(ImageMetadata *, bool);
-
-    bool SetThumbnailSize(int width, int height);
-
-    int  GetCurrent();
-    int  GetTotal();
-
-  private:
-    ImageThumbGen();
-    ~ImageThumbGen();
-    static ImageThumbGen    *m_instance;
-
-    ImageThumbGenThread     *m_imageThumbGenThread;
-};
-
-#endif // GALLERYTHUMBGENTHREAD_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbs.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbs.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbs.cpp	2015-04-30 11:17:45.415559854 +0200
@@ -0,0 +1,608 @@
+#include "imagethumbs.h"
+
+#include <exitcodes.h> // for previewgen
+
+#include <QFile>
+#include <QDir>
+#include <QtAlgorithms>
+#include <QImage>
+#include <QThread>
+#include <QMutexLocker>
+#include <QMatrix>
+
+#include <mythdirs.h>
+#include <mythsystemlegacy.h>
+
+
+/*!
+ \brief Contstruct request for a single image
+ \param action Request action
+ \param im Image object that will be deleted.
+ \param priority Request priority
+ \param notify If true a 'thumbnail exists' event will be broadcast when done.
+*/
+ThumbTask::ThumbTask(QString action, ImageItem *im,
+                     ImageThumbPriority priority, bool notify)
+    : m_action(action),
+      m_priority(priority),
+      m_notify(notify)
+{
+    append(im);
+}
+
+
+/*!
+ \brief Contstruct request for a list of images/dirs
+ \param action Request action
+ \param list Image objects that will be deleted.
+ \param priority Request priority
+ \param notify If true a 'thumbnail exists' event will be broadcast when done.
+*/
+ThumbTask::ThumbTask(QString action, ImageList &list,
+                     ImageThumbPriority priority, bool notify)
+    : ImageList(list),
+      m_action(action),
+      m_priority(priority),
+      m_notify(notify)
+{
+    // Assume ownership of list contents
+    list.clear();
+}
+
+
+/*!
+ \brief  Construct worker thread
+*/
+ThumbThread::ThumbThread(QString name)
+    : MThread(name), m_sg(ImageSg::getInstance())
+{
+    m_tempDir = QString("%1/%2").arg(GetConfDir(), TEMP_DIR);
+    m_thumbDir = m_tempDir.absoluteFilePath(THUMBNAIL_DIR);
+    m_tempDir.mkdir(THUMBNAIL_DIR);
+
+    // Use priorities: 0 = image requests, 1 = video requests, 2 = urgent, 3 = background
+    for (int i = 0; i <= kBackgroundPriority; ++i)
+        m_thumbQueue.insert(static_cast<ImageThumbPriority>(i), new ThumbQueue());
+
+    if (!gCoreContext->IsBackend())
+        LOG(VB_GENERAL, LOG_ERR, "Thumbnail Generators MUST be run on a backend");
+}
+
+
+/*!
+ \brief  Destructor
+*/
+ThumbThread::~ThumbThread()
+{
+    cancel();
+    wait();
+    qDeleteAll(m_thumbQueue);
+}
+
+
+/*!
+ \brief  Handles thumbnail requests by priority
+ \details Repeatedly processes next request from highest priority queue until all
+ queues are empty, then quits. For Create requests an event is broadcast once the
+ thumbnail exists. Dirs are only deleted if empty
+ */
+void ThumbThread::run()
+{
+    RunProlog();
+
+    setPriority(QThread::LowestPriority);
+
+    while (true)
+    {
+        // process next highest-priority task
+        ThumbTask *task = NULL;
+        {
+            QMutexLocker locker(&m_mutex);
+            foreach(ThumbQueue *q, m_thumbQueue)
+                if (!q->isEmpty())
+                {
+                    task = q->takeFirst();
+                    break;
+                }
+        }
+        // quit when all queues exhausted
+        if (!task)
+            break;
+
+        // Shouldn't receive empty requests
+        if (task->isEmpty())
+            continue;
+
+        if (task->m_action == "CREATE")
+        {
+            ImageItem *im = task->at(0);
+
+            LOG(VB_FILE, LOG_DEBUG, objectName()
+                + QString(": Creating %1 (Id %2, priority %3)")
+                .arg(im->m_fileName).arg(im->m_id).arg(task->m_priority));
+
+            // Shouldn't receive any dirs or empty thumb lists
+            if (im->m_thumbPath.isEmpty())
+                continue;
+
+            if (m_tempDir.exists(im->m_thumbPath))
+
+                LOG(VB_FILE, LOG_DEBUG, objectName()
+                    + QString(": Thumbnail %1 already exists")
+                    .arg(im->m_thumbPath));
+
+            else if (im->m_type == kImageFile)
+
+                CreateImageThumbnail(im);
+
+            else if (im->m_type == kVideoFile)
+
+                CreateVideoThumbnail(im);
+
+            else
+                LOG(VB_FILE, LOG_ERR, objectName()
+                    + QString(": Can't create thumbnail for type %1 : image %2")
+                    .arg(im->m_type).arg(im->m_fileName));
+
+            // notify clients when done
+            if (task->m_notify)
+            {
+                QString id = QString::number(im->m_id);
+
+                // Return requested thumbnails - FE uses it as a message signature
+                MythEvent me = MythEvent("THUMB_AVAILABLE", id);
+                gCoreContext->SendEvent(me);
+            }
+        }
+        else if (task->m_action == "DELETE")
+        {
+            foreach(const ImageItem *im, *task)
+            {
+                if (m_tempDir.remove(im->m_thumbPath))
+
+                    LOG(VB_FILE, LOG_DEBUG, objectName()
+                        + QString(": Deleted thumbnail %1")
+                        .arg(im->m_fileName));
+                else
+                    LOG(VB_FILE, LOG_WARNING, objectName()
+                        + QString(": Couldn't delete thumbnail %1")
+                        .arg(im->m_thumbPath));
+            }
+        }
+        else if (task->m_action == "DELETE_DIR")
+        {
+            ImageList::const_iterator it = (*task).constEnd();
+            while (it != (*task).constBegin())
+            {
+                ImageItem *im = *(--it);
+
+                if (m_tempDir.rmdir(im->m_thumbPath))
+
+                    LOG(VB_FILE, LOG_DEBUG, objectName()
+                        + QString(": Deleted thumbdir %1")
+                        .arg(im->m_fileName));
+                else
+                    LOG(VB_FILE, LOG_WARNING, objectName()
+                        + QString(": Couldn't delete thumbdir %1")
+                        .arg(im->m_thumbPath));
+            }
+        }
+        else
+            LOG(VB_FILE, LOG_ERR, objectName() + QString(": Unknown task %1")
+                .arg(task->m_action));
+
+        qDeleteAll(*task);
+        delete task;
+    }
+
+    RunEpilog();
+}
+
+
+/*!
+ \brief Rotates/reflects an image iaw its orientation
+ \note Duplicates MythImage::Orientation
+ \param im Image details
+ \param image Image to be transformed
+*/
+void ThumbThread::Orientate(ImageItem *im, QImage &image)
+{
+    QMatrix matrix;
+    switch (im->m_orientation)
+    {
+    case 1: // If the image is in its original state
+        break;
+
+    case 2: // The image is horizontally flipped
+        image = image.mirrored(true, false);
+        break;
+
+    case 3: // The image is rotated 180°
+        matrix.rotate(180);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        break;
+
+    case 4: // The image is vertically flipped
+        image = image.mirrored(false, true);
+        break;
+
+    case 5: // The image is transposed (flipped horizontally, then rotated 90° CCW)
+        matrix.rotate(90);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        image = image.mirrored(true, false);
+        break;
+
+    case 6: // The image is rotated 90° CCW
+        matrix.rotate(90);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        break;
+
+    case 7: // The image is transversed (flipped horizontally, then rotated 90° CW)
+        matrix.rotate(270);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        image = image.mirrored(true, false);
+        break;
+
+    case 8: // The image is rotated 90° CW
+        matrix.rotate(270);
+        image = image.transformed(matrix, Qt::SmoothTransformation);
+        break;
+
+    default:
+        break;
+    }
+}
+
+/*!
+ \brief  Creates a picture thumbnail with the correct size and rotation
+ \param  im The image
+*/
+void ThumbThread::CreateImageThumbnail(ImageItem *im)
+{
+    QString imagePath = m_sg->GetFilePath(im);
+
+    if (!im->m_path.isEmpty())
+        m_thumbDir.mkpath(im->m_path);
+
+    // Absolute path of the BE thumbnail
+    QString thumbPath = m_tempDir.absoluteFilePath(im->m_thumbPath);
+
+    QImage image;
+    if (!image.load(imagePath))
+    {
+        LOG(VB_FILE, LOG_ERR, QString("%1: Failed to open image %2")
+            .arg(objectName(), imagePath));
+        return;
+    }
+
+    // Resize & orientate now to optimise load/display time by FE's
+    image = image.scaled(QSize(240,180), Qt::KeepAspectRatio, Qt::SmoothTransformation);
+    Orientate(im, image);
+
+    // create the thumbnail
+    if (image.save(thumbPath))
+
+        LOG(VB_FILE, LOG_INFO, QString("%1: Created thumbnail for %2")
+            .arg(objectName(), imagePath));
+    else
+        LOG(VB_FILE, LOG_ERR, QString("%1: Failed to create thumbnail for %2")
+            .arg(objectName(), imagePath));
+}
+
+
+/*!
+ \brief  Creates a video preview image with the correct size using mythpreviewgen
+ \param  im The image
+*/
+void ThumbThread::CreateVideoThumbnail(ImageItem *im)
+{
+    QString videoPath = m_sg->GetFilePath(im);
+
+    if (!im->m_path.isEmpty())
+        m_thumbDir.mkpath(im->m_path);
+
+    // Absolute path of the BE thumbnail
+    QString thumbPath = m_tempDir.absoluteFilePath(im->m_thumbPath);
+
+    QString cmd = "mythpreviewgen";
+    QStringList args;
+    args << logPropagateArgs.split(" ", QString::SkipEmptyParts);
+    args << "--size 320x240"; // Video thumbnails are shown in slideshow
+    args << "--infile"  << QString("\"%1\"").arg(videoPath);
+    args << "--outfile" << QString("\"%1\"").arg(thumbPath);
+
+    MythSystemLegacy ms(cmd, args, kMSRunShell);
+    ms.SetDirectory(m_thumbDir.absolutePath());
+    ms.Run();
+
+    // If the process exited successful
+    // then try to load the thumbnail
+    if (ms.Wait() != GENERIC_EXIT_OK)
+    {
+        LOG(VB_FILE, LOG_ERR, QString("%1: Preview Generator failed for %2")
+            .arg(objectName(), videoPath));
+        return;
+    }
+
+    QImage image;
+    if (image.load(thumbPath))
+    {
+        Orientate(im, image);
+
+        image.save(thumbPath);
+
+        LOG(VB_FILE, LOG_INFO, QString("%1: Created thumbnail for %2")
+            .arg(objectName(), videoPath));
+    }
+    else
+        LOG(VB_FILE, LOG_ERR, QString("%1: Failed to create thumbnail for %2")
+            .arg(objectName(), videoPath));
+}
+
+
+/*!
+ \brief Queues a Create request
+ \param task The request
+ */
+void ThumbThread::QueueThumbnails(ThumbTask *task)
+{
+    // null tasks will terminate the thread prematurely
+    if (task)
+    {
+        QMutexLocker locker(&m_mutex);
+        m_thumbQueue.value(task->m_priority)->append(task);
+
+        // restart if not already running
+        if (!this->isRunning())
+            this->start();
+    }
+}
+
+
+/*!
+ \brief Return size of a specific queue
+ \param priority The queue of interest
+ \return int Number of requests pending
+*/
+int ThumbThread::GetQueueSize(ImageThumbPriority priority)
+{
+    QMap<int,int> result;
+
+    QMutexLocker locker(&m_mutex);
+    return m_thumbQueue.value(priority)->size();
+}
+
+
+/*!
+ \brief Clears thumbnail cache
+*/
+void ThumbThread::ClearThumbnails()
+{
+    LOG(VB_FILE, LOG_INFO, objectName() + ": Removing all thumbnails");
+
+    // Clear all queues & wait for generator thread to terminate
+    cancel();
+    wait();
+
+    // Remove all thumbnails
+    RemoveDirContents(m_thumbDir.absolutePath());
+}
+
+
+/*!
+ \brief Clears all files and sub-dirs within a directory
+ \param dirName Dir to clear
+ \return bool True on success
+*/
+bool ThumbThread::RemoveDirContents(QString dirName)
+{
+    // Delete all files
+    QDir dir = QDir(dirName);
+    bool result = true;
+
+    foreach(const QFileInfo &info, dir.entryInfoList(QDir::AllEntries
+                                                     | QDir::NoDotAndDotDot))
+    {
+        if (info.isDir())
+        {
+            RemoveDirContents(info.absoluteFilePath());
+            result = dir.rmdir(info.absoluteFilePath());
+        }
+        else
+            result = QFile::remove(info.absoluteFilePath());
+
+        if (!result)
+            LOG(VB_FILE, LOG_ERR, QString("%1: Can't delete %2")
+                .arg(objectName(), info.absoluteFilePath()));
+    }
+    return result;
+}
+
+
+/*!
+ \brief Clears all queues so that the thread can terminate.
+*/
+void ThumbThread::cancel()
+{
+    // Clear all queues
+    QMutexLocker locker(&m_mutex);
+    foreach(ThumbQueue *q, m_thumbQueue)
+    {
+        qDeleteAll(*q);
+        q->clear();
+    }
+}
+
+
+//////////////////////////////////////////////////////////////////////////
+
+
+//! Thumbnail generator singleton
+ImageThumb* ImageThumb::m_instance = NULL;
+
+
+/*!
+ \brief Constructor
+*/
+ImageThumb::ImageThumb()
+{
+    m_imageThumbThread = new ThumbThread("ImageThumbGen");
+    m_videoThumbThread = new ThumbThread("VideoThumbGen");
+}
+
+
+/*!
+ \brief Destructor
+*/
+ImageThumb::~ImageThumb()
+{
+    delete m_imageThumbThread;
+    m_imageThumbThread = NULL;
+    delete m_videoThumbThread;
+    m_videoThumbThread = NULL;
+}
+
+
+/*!
+ \brief Get generator
+ \return ImageThumb Generator singleton
+*/
+ImageThumb* ImageThumb::getInstance()
+{
+    if (!m_instance)
+        m_instance = new ImageThumb();
+
+    return m_instance;
+}
+
+
+/*!
+ \brief Return size of specific queue
+ \param priority Queue of interest
+ \return int Number of requests pending
+*/
+int ImageThumb::GetQueueSize(ImageThumbPriority priority)
+{
+    // Ignore video thread
+    if (m_imageThumbThread)
+        return m_imageThumbThread->GetQueueSize(priority);
+    return 0;
+}
+
+
+/*!
+ \brief Clears thumbnail cache, blocking until generator thread terminates
+*/
+void ImageThumb::ClearAllThumbs()
+{
+    // Image task will clear videos as well
+    if (m_imageThumbThread)
+        m_imageThumbThread->ClearThumbnails();
+}
+
+
+/*!
+ \brief Creates thumbnails on-demand from clients
+ \details Display requests are the highest priority. Thumbnails required for an image
+node will be created before those that are part of a directory thumbnail.
+A THUMBNAIL_CREATED event is broadcast for each image.
+ \param imList List of images requiring thumbnails
+*/
+void ImageThumb::HandleCreateThumbnails(QStringList imList)
+{
+    if (imList.size() != 2)
+        return;
+
+    bool isForFolder = imList[1].toInt();
+
+    // get specific image details from db
+    ImageList images;
+    ImageDbWriter db;
+    db.ReadDbItemsById(images, imList[0]);
+
+    foreach (ImageItem *im, images)
+    {
+        ImageThumbPriority priority = isForFolder
+                ? kFolderRequestPriority : kPicRequestPriority;
+
+        // notify clients when done; highest priority
+        ThumbTask *task = new ThumbTask("CREATE", im, priority, true);
+
+        if (im->m_type == kVideoFile)
+        {
+            if (m_videoThumbThread)
+                m_videoThumbThread->QueueThumbnails(task);
+        }
+        else if (im->m_type == kImageFile)
+        {
+            if (m_imageThumbThread)
+                m_imageThumbThread->QueueThumbnails(task);
+        }
+    }
+}
+
+
+/*!
+ \brief Remove thumbnails from cache
+ \param images List of obselete images
+ \param dirs List of obselete dirs
+ \return QStringList Csv list of deleted ids, empty (no modified ids), csv list of
+ deleted thumbnail and image urls (compatible with FE cache)
+*/
+QStringList ImageThumb::DeleteThumbs(ImageList images, ImageList dirs)
+{
+    // Determine affected images and redundant images/thumbnails
+    QStringList mesg = QStringList(""); // Empty item (no modified ids)
+    QStringList ids;
+    ImageSg *isg = ImageSg::getInstance();
+
+    foreach (const ImageItem *im, images)
+    {
+        ids << QString::number(im->m_id);
+        // Remove thumbnail
+        mesg << isg->GenerateThumbUrl(im->m_thumbPath);
+        // Remove cached image
+        mesg << isg->GenerateUrl(im->m_fileName);
+    }
+    // Insert deleted ids at front
+    mesg.insert(0, ids.join(","));
+
+    if (!m_imageThumbThread)
+        return QStringList();
+
+    // FIXME: Video thread could be affected
+    if (!images.isEmpty())
+        // Delete BE thumbs with high priority to prevent future client
+        // requests from usurping the Delete and using the old thumbs.
+        // Thumb generator now owns the image objects
+        m_imageThumbThread->QueueThumbnails(new ThumbTask("DELETE",
+                                                          images,
+                                                          kPicRequestPriority));
+    if (!dirs.isEmpty())
+        // Clean up thumbdirs as low priority
+        m_imageThumbThread->QueueThumbnails(new ThumbTask("DELETE_DIR", dirs));
+
+    return mesg;
+}
+
+
+/*!
+ \brief Creates thumbnails for new images/dirs detected by scanner
+ \param im Image
+ \param priority Request priority
+*/
+void ImageThumb::CreateThumbnail(ImageItem *im, ImageThumbPriority priority)
+{
+    ThumbTask *task = new ThumbTask("CREATE", im, priority);
+
+    if (im->m_type == kVideoFile)
+    {
+        if (m_videoThumbThread)
+            m_videoThumbThread->QueueThumbnails(task);
+    }
+    else if (im->m_type == kImageFile)
+    {
+        if (m_imageThumbThread)
+            m_imageThumbThread->QueueThumbnails(task);
+    }
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbs.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbs.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imagethumbs.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imagethumbs.h	2015-04-30 11:17:45.415559854 +0200
@@ -0,0 +1,125 @@
+//! \file
+//! \brief Creates and manages thumbnails in the cache
+//! \details Uses two worker threads to process thumbnail requests that are queued.
+//! One for pictures and a one for videos, which are off-loaded to previewgenerator,
+//! and time-consuming. Both background threads are low-priority to avoid recording issues.
+//! Requests are handled by client-assigned priority so that on-demand display requests
+//! are serviced before background pre-generation requests.
+//! When images are removed, their thumbnails are also deleted (thumbnail cache is
+//! synchronised to database). Obselete thumbnails are broadcast to enable clients to
+//! also manage/synchronise their caches.
+
+#ifndef IMAGETHUMBGEN_H
+#define IMAGETHUMBGEN_H
+
+// Qt headers
+#include <QMutex>
+#include <QList>
+#include <QMap>
+#include <QDir>
+#include <QImage>
+
+// MythTV headers
+#include <mthread.h>
+#include <imageutils.h>
+
+
+//! \brief Priority of a thumbnail request. First/lowest are handled before later/higher
+//! \details Ordered to optimise perceived client performance, ie. pictures will be
+//! displayed before directories (4 thumbnails), then videos (slow to generate) are filled
+//! in last.
+typedef enum priorities {
+    kPicRequestPriority    = 0, //!< Client request to display an image thumbnail
+    kFolderRequestPriority = 1, //!< Client request to display a directory thumbnail
+    kVideoRequestPriority  = 2, //!< Client request to display a video preview
+    kScannerUrgentPriority = 3, //!< Scanner request needed to complete a scan
+    kBackgroundPriority    = 4  //!< Scanner background request
+} ImageThumbPriority;
+
+
+//! A generator request that is queued
+class META_PUBLIC ThumbTask : public ImageList
+{
+public:
+    ThumbTask(const QString &,
+              ImageThumbPriority = kBackgroundPriority, bool = false);
+    ThumbTask(QString, ImageItem*,
+              ImageThumbPriority = kBackgroundPriority, bool = false);
+    ThumbTask(const QString &, ImageMap&,
+              ImageThumbPriority = kBackgroundPriority, bool = false);
+    ThumbTask(QString, ImageList&,
+              ImageThumbPriority = kBackgroundPriority, bool = false);
+
+    //! Request action: Create, delete etc.
+    QString m_action;
+    //! Request reason/priority
+    ImageThumbPriority m_priority;
+    //! If true, a "THUMBNAIL_CREATED" event is broadcast
+    bool m_notify;
+};
+
+
+//! A generator worker thread
+class META_PUBLIC ThumbThread : public MThread
+{
+  public:
+    ThumbThread(QString name);
+    ~ThumbThread();
+
+    void QueueThumbnails(ThumbTask *);
+    void ClearThumbnails();
+    int GetQueueSize(ImageThumbPriority);
+
+  protected:
+    void run();
+    void cancel();
+
+  private:
+    void CreateImageThumbnail(ImageItem *);
+    void CreateVideoThumbnail(ImageItem *);
+    bool RemoveDirContents(QString);
+    void Orientate(ImageItem *im, QImage &image);
+
+    //! A queue of generator requests
+    typedef QList<ThumbTask *> ThumbQueue;
+    //! A priority queue where 0 is highest priority
+    QMap<ImageThumbPriority, ThumbQueue *> m_thumbQueue;
+    //! Queue protection
+    QMutex m_mutex;
+
+    //! Storage Group accessor
+    ImageSg *m_sg;
+
+    //! Path of backend thumbnail cache
+    QDir m_thumbDir;
+    //! Path of backend temp
+    QDir m_tempDir;
+};
+
+
+//! Singleton creating/managing image thumbnails
+class META_PUBLIC ImageThumb
+{
+  public:
+    static ImageThumb* getInstance();
+
+    void        CreateThumbnail(ImageItem *, ImageThumbPriority);
+    void        HandleCreateThumbnails(QStringList imlist);
+    int         GetQueueSize(ImageThumbPriority);
+    void        ClearAllThumbs();
+    QStringList DeleteThumbs(ImageList, ImageList);
+
+  private:
+    ImageThumb();
+    ~ImageThumb();
+
+    //! Singleton
+    static ImageThumb *m_instance;
+
+    //! Worker thread generating picture thumbnails
+    ThumbThread       *m_imageThumbThread;
+    //! Worker thread generating video previews
+    ThumbThread       *m_videoThumbThread;
+};
+
+#endif // IMAGETHUMBGEN_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imageutils.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imageutils.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imageutils.cpp	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imageutils.cpp	2015-04-30 11:17:45.415559854 +0200
@@ -1,908 +1,655 @@
-// Qt headers
-
-// MythTV headers
-#include "mythcontext.h"
-#include "mythdirs.h"
-#include "storagegroup.h"
 #include "imageutils.h"
 
+#include <QByteArray>
+#include <QMutableListIterator>
+#include <QImageReader>
 
-// The maximum possible value of the utc time
-#define MAX_UTCTIME 2147483646;
-
-ImageUtils* ImageUtils::m_instance = NULL;
-
-ImageUtils::ImageUtils()
-{
-    m_imageFileExt = QString("jpg,jpeg,png,tif,tiff,bmp,gif").split(",");
-    m_videoFileExt = QString("avi,mpg,mp4,mpeg,mov,wmv,3gp").split(",");
-}
-
-
-
-ImageUtils::~ImageUtils()
-{
-
-}
-
+#include <dbaccess.h>
+#include <mythdirs.h>
 
 
-ImageUtils* ImageUtils::getInstance()
+/**
+ *  \brief  Constructor
+ */
+ImageItem::ImageItem() :
+    m_id(0),
+    m_name(""),
+    m_path(""),
+    m_parentId(0),
+    m_type(0),
+    m_modTime(0),
+    m_size(0),
+    m_extension(""),
+    m_date(0),
+    m_orientation(0),
+    m_comment(""),
+    m_isHidden(false),
+    m_userThumbnail(0),
+    m_fileName(""),
+    m_thumbPath(""),
+    m_dirCount(0),
+    m_fileCount(0)
+{
+}
+
+
+ImageItem::ImageItem(const ImageItem &im) :
+    m_id(im.m_id),
+    m_name(im.m_name),
+    m_path(im.m_path),
+    m_parentId(im.m_parentId),
+    m_type(im.m_type),
+    m_modTime(im.m_modTime),
+    m_size(im.m_size),
+    m_extension(im.m_extension),
+    m_date(im.m_date),
+    m_orientation(im.m_orientation),
+    m_comment(im.m_comment),
+    m_isHidden(im.m_isHidden),
+    m_userThumbnail(im.m_userThumbnail),
+    m_fileName(im.m_fileName),
+    m_thumbPath(im.m_thumbPath),
+    m_thumbNails(im.m_thumbNails),
+    m_thumbIds(im.m_thumbIds),
+    m_dirCount(im.m_dirCount),
+    m_fileCount(im.m_fileCount)
+{
+}
+
+
+/*!
+ * \brief Get path for an image thumbnail
+ * \param im The image
+ * \return QString Thumbnail path
+ */
+QString ImageUtils::ThumbPathOf(ImageItem *im)
+{
+    // Thumbnails of videos are a JPEG snapshot with jpg suffix appended
+    QString ext = im->m_type == kVideoFile ? ".jpg" : "";
+
+    // Create the relative path and filename to the thumbnail image or thumbdir
+    return QString("%1/%2%3").arg(THUMBNAIL_DIR, im->m_fileName, ext);
+}
+
+
+/*!
+ \brief Return a timestamp/datestamp for an image or dir
+ \details Uses exif timestamp if defined, otherwise file modified date
+ \param im Image or dir
+ \return QString Exif Timestamp text for images, file modified datestamp text
+ for dirs and images with no exif
+*/
+QString ImageUtils::ImageDateOf(ImageItem *im)
+{
+    return im->m_date > 0
+            ? QDateTime::fromTime_t(im->m_date)
+              .toString(Qt::DefaultLocaleShortDate)
+            : QDateTime::fromTime_t(im->m_modTime).date()
+              .toString(Qt::DefaultLocaleShortDate);
+}
+
+
+/*!
+ \brief Constructor
+*/
+ImageSg::ImageSg()
+    : m_hostname(gCoreContext->GetMasterHostName()),
+      m_hostport(gCoreContext->GetMasterServerPort())
+{
+    m_sgImages = StorageGroup(IMAGE_STORAGE_GROUP, m_hostname, false);
+}
+
+
+//! Storage Group singleton
+ImageSg* ImageSg::m_instance = NULL;
+
+
+/*!
+ \brief Return singleton
+ \return ImageSg Images SG object
+*/
+ImageSg* ImageSg::getInstance()
 {
     if (!m_instance)
-        m_instance = new ImageUtils();
-
+        m_instance = new ImageSg();
     return m_instance;
 }
 
 
-
-/** \fn     ImageUtils::LoadDirectoryFromDB(QMap<QString, ImageMetadata *>*)
- *  \brief  Loads all directory information from the database
- *  \param  dbList The list where the results are stored
- *  \return void
+/*!
+ * \brief Get filters for detecting recognised images/videos
+ * \details Supported pictures are determined by QImage; supported videos
+ * are determined from the mythplayer settings (Video Associations)
+ * \sa http://qt-project.org/doc/qt-4.8/qimagereader.html#supportedImageFormats
+ * \return QDir A QDir initialised with filters for detecting images/videos
  */
-void ImageUtils::LoadDirectoriesFromDB(QMap<QString, ImageMetadata *>* dbList)
+QDir ImageSg::GetImageFilters()
 {
-    dbList->clear();
+    QStringList glob;
 
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("SELECT "
-                        "dir_id, filename, name, path, parent_id, "
-                        "dir_count, file_count, "
-                        "hidden "
-                        "FROM gallery_directories"));
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    if (query.size() > 0)
+    // Determine supported picture formats
+    m_imageFileExt.clear();
+    foreach (const QByteArray &ext, QImageReader::supportedImageFormats())
     {
-        while (query.next())
-        {
-            ImageMetadata *im = new ImageMetadata();
-            LoadDirectoryValues(query, im);
-            dbList->insert(im->m_fileName, im);
-        }
+        m_imageFileExt << QString(ext);
+        glob << "*." + ext;
     }
-}
-
-
-
-/** \fn     ImageUtils::LoadFilesFromDB(QMap<QString, ImageMetadata *>*)
- *  \brief  Loads all file information from the database
- *  \param  dbList The list where the results are stored
- *  \return void
- */
-void ImageUtils::LoadFilesFromDB(QMap<QString, ImageMetadata *>* dbList)
-{
-    dbList->clear();
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("SELECT "
-                        "file_id, CONCAT_WS('/', path, filename), name, path, "
-                        "dir_id, type, modtime, size, extension, "
-                        "angle, date, zoom, "
-                        "hidden, orientation "
-                        "FROM gallery_files"));
 
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    if (query.size() > 0)
-    {
-        while (query.next())
-        {
-            ImageMetadata *im = new ImageMetadata();
-            LoadFileValues(query, im);
-            dbList->insert(im->m_fileName, im);
-        }
-    }
-}
-
-
-
-/** \fn     ImageUtils::LoadFileFromDB(ImageMetadata *, int)
- *  \brief  Load the file information from the database given by the id
- *  \param  im The image metadata which holds the information
- *  \return void
- */
-void ImageUtils::LoadFileFromDB(ImageMetadata * im, int id)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("SELECT "
-                        "file_id, CONCAT_WS('/', path, filename), name, path, dir_id, "
-                        "type, modtime, size, extension, "
-                        "angle, date, zoom, "
-                        "hidden, orientation "
-                        "FROM gallery_files "
-                        "WHERE file_id = :FILE_ID;"));
-    query.bindValue(":FILE_ID", id);
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    if (query.size() > 0)
+    // Determine supported video formats
+    m_videoFileExt.clear();
+    const FileAssociations::association_list faList =
+        FileAssociations::getFileAssociation().getList();
+    for (FileAssociations::association_list::const_iterator p =
+             faList.begin(); p != faList.end(); ++p)
     {
-        while (query.next())
+        if (!p->use_default && p->playcommand == "Internal")
         {
-            LoadFileValues(query, im);
+            m_videoFileExt << QString(p->extension);
+            glob << "*." + p->extension;
         }
     }
-}
-
-
-
-/** \fn     ImageUtils::InsertDirectoryIntoDB(ImageMetadata *)
- *  \brief  Saves information about a given directory in the database
- *  \param  dm Information of the directory
- *  \return void
- */
-int ImageUtils::InsertDirectoryIntoDB(ImageMetadata *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("INSERT INTO gallery_directories ("
-                        "filename, name, path, parent_id, "
-                        "dir_count, file_count, "
-                        "hidden "
-                        ") VALUES ("
-                        ":FILENAME, :NAME, :PATH, :PARENT_ID, "
-                        ":DIRCOUNT, :FILECOUNT, "
-                        ":HIDDEN);"));
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":PARENT_ID",   im->m_parentId);
-    query.bindValue(":DIRCOUNT" ,   im->m_dirCount);
-    query.bindValue(":FILECOUNT",   im->m_fileCount);
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-
-    if (!query.exec())
-        MythDB::DBError("Error inserting, query: ", query);
-
-    return query.lastInsertId().toInt();
-}
-
 
+    QDir dir;
 
-/** \fn     ImageUtils::InsertFileIntoDB(ImageMetadata *)
- *  \brief  Saves information about a given file in the database
- *  \param  dm Information of the file
- *  \return void
- */
-int ImageUtils::InsertFileIntoDB(ImageMetadata *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("INSERT INTO gallery_files ("
-                        "filename, name, path, dir_id, "
-                        "type, modtime, size, extension, "
-                        "angle, date, zoom, "
-                        "hidden, orientation "
-                        ") VALUES ("
-                        ":FILENAME, :NAME, :PATH, :DIR_ID, "
-                        ":TYPE, :MODTIME, :SIZE, :EXTENSION, "
-                        ":ANGLE, :DATE, :ZOOM, "
-                        ":HIDDEN, :ORIENT)"));
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":DIR_ID",      im->m_parentId);
-    query.bindValue(":TYPE",        im->m_type);
-    query.bindValue(":MODTIME",     im->m_modTime);
-    query.bindValue(":SIZE",        im->m_size);
-    query.bindValue(":EXTENSION",   im->m_extension);
-    query.bindValue(":ANGLE",       im->GetAngle());
-    query.bindValue(":DATE",        im->m_date);
-    query.bindValue(":ZOOM",        im->GetZoom());
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-    query.bindValue(":ORIENT",      im->GetOrientation());
+    // Apply filters to only detect image files
+    dir.setNameFilters(glob);
+    dir.setFilter(QDir::AllDirs | QDir::Files | QDir::Readable |
+                  QDir::NoDotAndDotDot | QDir::NoSymLinks);
 
-    if (!query.exec())
-        MythDB::DBError("Error inserting, query: ", query);
+    // Sync files before dirs to improve thumb generation response
+    // Order by time (oldest first) - this determines the order thumbs appear
+    dir.setSorting(QDir::DirsLast | QDir::Time | QDir::Reversed);
 
-    return query.lastInsertId().toInt();
+    return dir;
 }
 
 
-
-/** \fn     ImageUtils::UpdateDirectoryInDB(ImageMetadata *)
- *  \brief  Updates the information about a given directory in the database
- *  \param  dm Information of the directory
- *  \return void
+/*!
+ * \brief Get paths for a list of images
+ * \param images List of images
+ * \return ImagePaths Map of image names & their paths
  */
-bool ImageUtils::UpdateDirectoryInDB(ImageMetadata *im)
+QString ImageSg::GetFilePath(ImageItem *im)
 {
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("UPDATE gallery_directories SET "
-                        "filename =     :FILENAME, "
-                        "name =         :NAME, "
-                        "path =         :PATH, "
-                        "parent_id =    :PARENT_ID, "
-                        "dir_count =    :DIR_COUNT, "
-                        "file_count =   :FILE_COUNT, "
-                        "hidden =       :HIDDEN "
-                        "WHERE dir_id = :ID;"));
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":PARENT_ID",   im->m_parentId);
-    query.bindValue(":DIR_COUNT",   im->m_dirCount);
-    query.bindValue(":FILE_COUNT",  im->m_fileCount);
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-    query.bindValue(":ID",          im->m_id);
-
-    return query.exec();
+    QString path = m_sgImages.FindFile(im->m_fileName);
+    if (path.isEmpty())
+        LOG(VB_FILE, LOG_NOTICE,
+            QString("Image: File %1 not found in Storage Group %2")
+            .arg(im->m_fileName).arg(IMAGE_STORAGE_GROUP));
+    return path;
 }
 
 
-
-/** \fn     ImageUtils::UpdateFileInDB(ImageMetadata *)
- *  \brief  Updates the information about a given file in the database
- *  \param  dm Information of the file
- *  \return void
- */
-bool ImageUtils::UpdateFileInDB(ImageMetadata *im)
+/*!
+ \brief Moves images and dirs within the storage group (filesystem)
+ \details Uses renaming. Files never move filesystems within the Storage Group
+ \param images List of images/dirs to move
+ \param parent New parent directory
+ \return bool True if at least 1 file was moved
+*/
+bool ImageSg::MoveFiles(ImageList &images, ImageItem *parent)
 {
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("UPDATE gallery_files SET "
-                        "filename       = :FILENAME, "
-                        "name           = :NAME, "
-                        "path           = :PATH, "
-                        "dir_id         = :DIR_ID, "
-                        "type           = :TYPE, "
-                        "modtime        = :MODTIME, "
-                        "size           = :SIZE, "
-                        "extension      = :EXTENSION, "
-                        "angle          = :ANGLE, "
-                        "date           = :DATE, "
-                        "zoom           = :ZOOM, "
-                        "hidden         = :HIDDEN, "
-                        "orientation    = :ORIENT "
-                        "WHERE file_id  = :ID;"));
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":DIR_ID",      im->m_parentId);
-    query.bindValue(":TYPE",        im->m_type);
-    query.bindValue(":MODTIME",     im->m_modTime);
-    query.bindValue(":SIZE",        im->m_size);
-    query.bindValue(":EXTENSION",   im->m_extension);
-    query.bindValue(":ANGLE",       im->GetAngle());
-    query.bindValue(":DATE",        im->m_date);
-    query.bindValue(":ZOOM",        im->GetZoom());
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-    query.bindValue(":ORIENT",      im->GetOrientation());
-    query.bindValue(":ID",          im->m_id);
-
-    return query.exec();
-}
-
-
-
-/** \fn     ImageUtils::RemoveFromDB(ImageMetadata *im)
- *  \brief  Deletes either a directory or file from the database
- *  \param  im Information of the given item
- *  \return void
- */
-bool ImageUtils::RemoveFromDB(ImageMetadata *im)
-{
-    if (!im)
-        return false;
-
-    if (im->m_type == kSubDirectory || im->m_type == kUpDirectory)
-        return RemoveDirectoryFromDB(im);
+    bool changed = false;
+    foreach (const ImageItem * im, images)
+    {
+        // Get SG dir of this file
+        QString sgDir = m_sgImages.FindFileDir(im->m_fileName);
+        if (sgDir.isEmpty())
+        {
+            LOG(VB_FILE, LOG_NOTICE,
+                QString("Image: File %1 not found in Storage Group %2")
+                .arg(im->m_fileName).arg(IMAGE_STORAGE_GROUP));
+            continue;
+        }
 
-    if (im->m_type == kImageFile || im->m_type == kVideoFile)
-        return RemoveFileFromDB(im);
+        // Use existing fs & name with destination path
+        QString oldPath = QString("%1/%2").arg(sgDir, im->m_fileName);
+        QString newPath = QString("%1/%2/%3").arg(sgDir, parent->m_fileName, im->m_name);
 
-    return false;
+        // Move file
+        if (QFile::rename(oldPath, newPath))
+        {
+            changed = true;
+            LOG(VB_FILE, LOG_DEBUG, QString("Image: Moved %1 -> %2")
+                .arg(oldPath, newPath));
+        }
+        else
+            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to move %1 to %2")
+                .arg(oldPath, newPath));
+    }
+    return changed;
 }
 
 
-
-/** \fn     ImageUtils::RemoveDirectoryFromDB(ImageMetadata *)
- *  \brief  Deletes the information about a given directory in the database
- *  \param  im Information of the directory
- *  \return void
+/*!
+ * \brief Deletes images and dirs from the storage group (filesystem)
+ * \details Dirs will only be deleted if empty. Files/dirs that failed
+ * to delete will be removed from the list.
+ * \param[in,out] images List of images/dirs to delete. On return the files that
+ * were successfully deleted.
  */
-bool ImageUtils::RemoveDirectoryFromDB(ImageMetadata *im)
+void ImageSg::RemoveFiles(ImageList &images)
 {
-    if (!im)
-        return false;
-
-    return RemoveDirectoryFromDB(im->m_id);
-}
-
+    QMutableListIterator<ImageItem *> it(images);
+    it.toBack();
+    while (it.hasPrevious())
+    {
+        ImageItem *im = it.previous();
 
+        // Find file
+        QString absFilename = m_sgImages.FindFile(im->m_fileName);
 
-bool ImageUtils::RemoveDirectoryFromDB(int id)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("DELETE from gallery_directories "
-                        "WHERE dir_id = :ID;"));
-    query.bindValue(":ID", id);
+        if (absFilename.isEmpty())
+        {
+            LOG(VB_FILE, LOG_ERR,
+                QString("Image: File %1 not found in Storage Group %2")
+                .arg(im->m_fileName).arg(IMAGE_STORAGE_GROUP));
+            it.remove();
+            delete im;
+            continue;
+        }
 
-    return query.exec();
+        // Remove file
+        bool ok;
+        if (im->IsFile())
+            ok = QFile::remove(absFilename);
+        else
+        {
+            QDir dir;
+            ok = dir.rmdir(absFilename);
+        }
+        if (!ok)
+        {
+            LOG(VB_FILE, LOG_ERR, QString("Can't delete %1").arg(im->m_fileName));
+            // Remove from list
+            it.remove();
+            delete im;
+        }
+    }
 }
 
 
-
-/** \fn     ImageUtils::RemoveFileFromDB(ImageMetadata *)
- *  \brief  Deletes the information about a given file in the database
- *  \param  im Information of the directory
- *  \return void
+// Standard query to be parsed by CreateImage
+const QString dbQuery =
+    "SELECT "
+    "file_id, name, path, dir_id, type, modtime, size, extension, "
+    "date, hidden, orientation, angle, filename FROM gallery_files "
+    "WHERE %1 %2 %3";
+
+
+//! Initialise static constant
+QMap<int, QString> ImageDbReader::InitQueries()
+{
+    QMap<int, QString> map;
+    map.insert(kPicOnly,     QString("type = %1").arg(kImageFile));
+    map.insert(kVideoOnly,   QString("type = %1").arg(kVideoFile));
+    map.insert(kPicAndVideo, QString("type > %1").arg(kSubDirectory));
+    return map;
+}
+
+
+// Db query clauses to distinguish between pictures, videos & dirs
+const QMap<int, QString> ImageDbReader::queryFiles = ImageDbReader::InitQueries();
+const QString ImageDbReader::queryDirs = QString("type <= %1").arg(kSubDirectory);
+
+
+/*!
+ * \brief Generate Db query clause for sort order
+ * \return QString Db clause
+ */
+void ImageDbReader::SetSortOrder(int order)
+{
+    m_order = order;
+
+    // prepare the sorting statement
+    switch (order)
+    {
+        case kSortByNameAsc:
+            m_orderSelector = "ORDER BY name ASC"; break;
+        case kSortByNameDesc:
+            m_orderSelector = "ORDER BY name DESC"; break;
+        case kSortByModTimeAsc:
+            m_orderSelector = "ORDER BY modtime ASC, name ASC"; break;
+        case kSortByModTimeDesc:
+            m_orderSelector = "ORDER BY modtime DESC, name ASC"; break;
+        case kSortByExtAsc:
+            m_orderSelector = "ORDER BY extension ASC, name ASC"; break;
+        case kSortByExtDesc:
+            m_orderSelector = "ORDER BY extension DESC, name ASC"; break;
+        case kSortBySizeAsc:
+            m_orderSelector = "ORDER BY size ASC, name ASC"; break;
+        case kSortBySizeDesc:
+            m_orderSelector = "ORDER BY size DESC, name ASC"; break;
+        case kSortByDateAsc:
+            m_orderSelector = "ORDER BY date ASC, name ASC"; break;
+        case kSortByDateDesc:
+            m_orderSelector = "ORDER BY date DESC, name ASC"; break;
+        case kSortByNone:
+        default:
+            m_orderSelector = "";
+    }
+}
+
+
+/*!
+ * \brief Create image metadata
+ * \param query Db query result
+ * \return ImageItem An image
+ */
+ImageItem *ImageDbReader::CreateImage(MSqlQuery &query)
+{
+    ImageItem *im = new ImageItem();
+
+    im->m_id            = query.value(0).toInt();
+    im->m_name          = query.value(1).toString();
+    im->m_path          = query.value(2).toString();
+    im->m_parentId      = query.value(3).toInt();
+    im->m_type          = query.value(4).toInt();
+    im->m_modTime       = query.value(5).toInt();
+    im->m_size          = query.value(6).toInt();
+    im->m_extension     = query.value(7).toString();
+    im->m_date          = query.value(8).toUInt();
+    im->m_isHidden      = query.value(9).toInt();
+    im->m_orientation   = query.value(10).toInt();
+    im->m_userThumbnail = query.value(11).toInt();
+    im->m_comment       = query.value(12).toString();
+    im->m_fileName      =
+        QDir::cleanPath(QDir(im->m_path).filePath(im->m_name));
+
+    im->m_thumbPath = ImageUtils::ThumbPathOf(im);
+
+    return im;
+}
+
+
+/*!
+ * \brief Read database images/dirs as list
+ * \details Get selected database items (mixed files/dirs) in prescribed order,
+ * optionally including currently hidden items.
+ * \param[out] images List of images/dirs from Db
+ * \param[in] selector Db selection query clause
+ * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+ * the visibility filter are returned
+ * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+ * setting. Otherwise they are in undefined (database) order.
+ * \return int Number of items matching query.
  */
-bool ImageUtils::RemoveFileFromDB(ImageMetadata *im)
+int ImageDbReader::ReadDbItems(ImageList &images, QString selector,
+                               bool showAll, bool ordered)
 {
-    if (!im)
-        return false;
-
-    return RemoveFileFromDB(im->m_id);
-}
-
+    QString   orderSelect  = ordered ? m_orderSelector : "";
+    QString   hiddenSelect = showAll || m_showHidden ? "" : "AND hidden = 0";
 
-
-bool ImageUtils::RemoveFileFromDB(int id)
-{
     MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(
-                QString("DELETE from gallery_files "
-                        "WHERE file_id = :ID;"));
-    query.bindValue(":ID", id);
-
-    return query.exec();
-}
-
-
-
-/** \fn     ImageUtils::LoadDirectoryValues(MSqlQuery &, ImageMetadata *)
- *  \brief  Loads the directory information from the database into the dataMap
- *  \param  query Information from the database
- *  \param  dm Holds the loaded information
- *  \return void
- */
-void ImageUtils::LoadDirectoryValues(MSqlQuery &query, ImageMetadata *dm)
-{
-    dm->m_id            = query.value(0).toInt();
-    dm->m_name          = query.value(2).toString();
-    dm->m_path          = query.value(3).toString();
-    dm->m_fileName      = QDir::cleanPath(QDir(dm->m_path).filePath(dm->m_name));
-    dm->m_parentId      = query.value(4).toInt();
-    dm->m_dirCount      = query.value(5).toInt();
-    dm->m_fileCount     = query.value(6).toInt();
-    dm->m_isHidden      = query.value(7).toInt();
-
-    // preset all directories as subfolders
-    dm->m_type          = kSubDirectory;
-
-    LoadDirectoryThumbnailValues(dm);
-}
-
-
-
-/** \fn     ImageUtils::LoadFileValues(MSqlQuery &, ImageMetadata *)
- *  \brief  Loads the file information from the database into the dataMap
- *  \param  query Information from the database
- *  \param  dm Holds the loaded information
- *  \return void
- */
-void ImageUtils::LoadFileValues(MSqlQuery &query, ImageMetadata *dm)
-{
-    dm->m_id            = query.value(0).toInt();
-    dm->m_name          = query.value(2).toString();
-    dm->m_path          = query.value(3).toString();
-    dm->m_fileName      = QDir::cleanPath(QDir(dm->m_path).filePath(dm->m_name));
-    dm->m_parentId      = query.value(4).toInt();
-    dm->m_type          = query.value(5).toInt();
-    dm->m_modTime       = query.value(6).toInt();
-    dm->m_size          = query.value(7).toInt();
-    dm->m_extension     = query.value(8).toString();
-    dm->SetAngle(         query.value(9).toInt());
-    dm->m_date          = query.value(10).toInt();
-    dm->SetZoom(          query.value(11).toInt(), true);
-    dm->m_isHidden      = query.value(12).toInt();
-    dm->SetOrientation(   query.value(13).toInt(), true);
-
-    LoadFileThumbnailValues(dm);
-}
-
-
-
-/** \fn     ImageUtils::GetStorageDirs()
- *  \brief  Gets the available storage groups
- *  \return List of all available storage groups
- */
-QStringList ImageUtils::GetStorageDirs()
-{
-    QStringList sgDirList;
-
-    QString sgName = IMAGE_STORAGE_GROUP;
-
-    if (!sgName.isEmpty())
+    query.prepare(dbQuery.arg(selector, hiddenSelect, orderSelect));
+    if (!query.exec())
     {
-        QString host = gCoreContext->GetHostName();
-
-        // Search for the specified dirs in the defined storage group.
-        // If there is no such storage group then don't use the fallback
-        // and don't get the default storage group name of "/mnt/store".
-        // The list will be empty. The user has to check the settings.
-        StorageGroup sg;
-        sg.Init(sgName, host, false);
-        sgDirList = sg.GetDirList();
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+        return 0;
     }
 
-    return sgDirList;
-}
-
-
-
-/** \fn     ImageUtils::LoadDirectoryData(QFileInfo &, DataMap *, int)
- *  \brief  Loads the information from the fileInfo into the dataMap object
- *  \param  fileInfo Holds the information about the file
- *  \param  data Holds the loaded information about a file
- *  \param  parentId The parent directory
- *  \return void
- */
-void ImageUtils::LoadDirectoryData(QFileInfo &fileInfo,
-                                   ImageMetadata *data,
-                                   int parentId,
-                                   const QString &baseDirectory)
-{
-    QDir dir(baseDirectory);
-    data->m_parentId    = parentId;
-    data->m_fileName    = dir.relativeFilePath(fileInfo.absoluteFilePath());
-    data->m_name        = fileInfo.fileName();
-    data->m_path        = dir.relativeFilePath(fileInfo.absolutePath());
-    data->m_isHidden    = fileInfo.isHidden();
-
-    dir.cd(data->m_fileName);
-    data->m_dirCount = dir.entryList(QDir::Dirs |
-                                     QDir::NoSymLinks |
-                                     QDir::NoDotAndDotDot |
-                                     QDir::Readable).count();
+    while (query.next())
+    {
+        ImageItem *im = CreateImage(query);
 
-    data->m_fileCount = dir.entryList(QDir::Files |
-                                      QDir::NoSymLinks |
-                                      QDir::NoDotAndDotDot |
-                                      QDir::Readable).count();
+        // Initialise image thumbnail
+        if (im->IsFile())
+        {
+            im->m_thumbNails.append(im->m_thumbPath);
+            im->m_thumbIds.append(im->m_id);
+        }
+        images.append(im);
+    }
+    return query.size();
 }
 
 
-/** \fn     ImageUtils::LoadFileData(QFileInfo &, DataMap *)
- *  \brief  Loads the information from the fileInfo into the dataMap object
- *  \param  fileInfo Holds the information about the file
- *  \param  data Holds the loaded information about a file
- *  \return void
- */
-void ImageUtils::LoadFileData(QFileInfo &fileInfo,
-                              ImageMetadata *data,
-                              const QString &baseDirectory)
-{
-    QDir baseDir(baseDirectory);
-    data->m_fileName    = baseDir.relativeFilePath(fileInfo.absoluteFilePath());
-    data->m_name        = fileInfo.fileName();
-    data->m_path        = baseDir.relativeFilePath(fileInfo.absolutePath());
-    data->m_modTime     = fileInfo.lastModified().toTime_t();
-    data->m_size        = fileInfo.size();
-    data->m_isHidden    = fileInfo.isHidden();
-    data->m_extension   = fileInfo.completeSuffix().toLower();
-
-    // Set defaults, the data will be loaded later
-    data->SetAngle(0);
-    data->m_date = MAX_UTCTIME;
-
-    if (m_imageFileExt.contains(data->m_extension))
-    {
-        data->m_type = kImageFile;
-    }
-    else if (m_videoFileExt.contains(data->m_extension))
-    {
-        data->m_type = kVideoFile;
-    }
-    else
-    {
-        data->m_type = kUnknown;
+/*!
+ * \brief Read sub-tree of database images and dirs as lists
+ * \details Returns database files and dirs contained in the sub-tree of
+ * specific dirs. Optionally ordered and including currently hidden items.
+ * \param[out] files List of images within sub-tree
+ * \param[out] dirs List of dirs within sub-tree
+ * \param[in] idList Comma-separated list of parent dir ids
+ * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+ * the visibility filter are returned
+ * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+ * setting. Otherwise they are in undefined (database) order.
+ */
+void ImageDbReader::ReadDbTree(ImageList &files,
+                            ImageList &dirs,
+                            QStringList idList,
+                            bool showAll,
+                            bool ordered)
+{
+    // Load starting files
+    QString ids = idList.join(",");
+    ReadDbFilesById(files, ids, showAll, ordered);
+    ReadDbDirsById(dirs, ids, showAll, ordered);
+
+    // Add all descendants
+    ImageList subdirs;
+    while (!idList.isEmpty())
+    {
+        QString selector =
+            QString("dir_id IN (%1) AND %2").arg(idList.join(","));
+        ReadDbItems(files, selector.arg(queryFiles[m_showType]), showAll, ordered);
+        ReadDbItems(subdirs, selector.arg(queryDirs), showAll, ordered);
+        dirs += subdirs;
+        idList.clear();
+        foreach (const ImageItem * im, subdirs)
+        {
+            if (im->IsDirectory())
+                idList.append(QString::number(im->m_id));
+        }
+        subdirs.clear();
     }
 }
 
 
-
-/** \fn     ImageUtils::GetExifOrientation(const QString &fileName, bool *ok)
- *  \brief  Reads and returns the orientation value
- *  \param  fileName The filename that holds the exif data
- *  \param  ok Will be set to true if the reading was ok, otherwise false
- *  \return The orientation value
+/*!
+ * \brief Read database images and dirs as map
+ * \details Returns selected database items, separated into files and dirs. Results contain
+ * no thumbnails (paths nor urls) and are mapped to item name and thus unordered.
+ * \param[out] files Map of image names and metadata from Db
+ * \param[out] dirs Map of dir names and metadata from Db
+ * \param[in] selector Db selection query
  */
-int ImageUtils::GetExifOrientation(const QString &fileName, bool *ok)
+void ImageDbWriter::ReadDbItems(ImageMap &files, ImageMap &dirs,
+                                const QString &selector)
 {
-    QString tag = "Exif.Image.Orientation";
-    QString value = GetExifValue(fileName, tag, ok);
-
-    // The orientation of the image. Only return the value if its valid
-    // See http://jpegclub.org/exif_orientation.html for details
-    bool valid;
-    int orientation = QString(value).toInt(&valid);
-    return (valid) ? orientation : 1;
-}
-
-
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(dbQuery.arg(selector, "", ""));
 
-/** \fn     ImageUtils::SetExifOrientation(const QString &, const long , bool *)
- *  \brief  Saves the given value in the orientation exif tag
- *  \param  fileName The filename that holds the exif data
- *  \param  orientation The value that shall be saved in the exif data
- *  \param  ok Will be set to true if the update was ok, otherwise false
- *  \return void
- */
-void ImageUtils::SetExifOrientation(const QString &fileName,
-                                    const int orientation, bool *ok)
-{
-    // the orientation of the image.
-    // See http://jpegclub.org/exif_orientation.html for details
-    if (orientation >= 1 && orientation <= 8)
+    if (!query.exec())
     {
-        QString tag = "Exif.Image.Orientation";
-        SetExifValue(fileName, tag, QString::number(orientation), ok);
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
+        return;
     }
-}
 
-
-
-/** \fn     ImageUtils::GetExifDate(const QString &, bool *)
- *  \brief  Reads and returns the exif date
- *  \param  fileName The filename that holds the exif data
- *  \param  ok Will be set to true if the reading was ok, otherwise false
- *  \return The date in utc time
- */
-long ImageUtils::GetExifDate(const QString &fileName, bool *ok)
-{
-    long utcTime = MAX_UTCTIME;
-
-    QString tag = "Exif.Image.DateTime";
-    QString value = GetExifValue(fileName, tag, ok);
-
-    // convert the string into the UTC time. We need to split
-    // the exif time format, which is this: "2006:07:21 18:54:58"
-    if (!value.isEmpty())
+    while (query.next())
     {
-        bool ok;
-        QDateTime dateTime =
-                QDateTime(QDate(value.mid(0,4).toInt(&ok, 10),
-                                value.mid(5,2).toInt(&ok, 10),
-                                value.mid(8,2).toInt(&ok, 10)),
-                          QTime(value.mid(11,2).toInt(&ok, 10),
-                                value.mid(14,2).toInt(&ok, 10),
-                                value.mid(17,2).toInt(&ok, 10), 0));
+        ImageItem *im = CreateImage(query);
 
-        // convert it to the utc time so
-        // we can easily compare it later.
-        utcTime = dateTime.toTime_t();
+        if (im->IsDirectory())
+            dirs.insert(im->m_fileName, im);
+        else
+            files.insert(im->m_fileName, im);
     }
-
-    return utcTime;
 }
 
 
-
-/** \fn     ImageUtils::SetExifDate(const QString &, const long , bool *)
- *  \brief  Saves the given date in the date exif tag
- *  \param  fileName The filename that holds the exif data
- *  \param  date The date that shall be saved in the exif data
- *  \param  ok Will be set to true if the update was ok, otherwise false
- *  \return void
+/*!
+ * \brief Clear image database
+ * \note Only backends should modify the database
  */
-void ImageUtils::SetExifDate(const QString &fileName,
-                             const long date, bool *ok)
+void ImageDbWriter::ClearDb()
 {
-    QString value;
-
-    // Convert the date number into the UTC time and then
-    // into the string with the format "2006:07:21 18:54:58".
-    QDateTime dateTime;
-    dateTime.setTime_t(date);
-    value = dateTime.toString("yyyy:MM:dd hh:mm:ss");
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("TRUNCATE gallery_files;"));
 
-    if (!value.isEmpty())
-    {
-        QString tag = "Exif.Image.DateTime";
-        SetExifValue(fileName, tag, value, ok);
-    }
+    if (!query.exec())
+        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
 }
 
 
-
-/** \fn     ImageUtils::GetAllExifValues(const QString &)
- *  \brief  Reads and returns all non empty tags from the given file
- *  \param  fileName The filename that holds the exif data
- *  \return The list of exif tag names and values
+/*!
+ * \brief Adds new dir to database.
+ * \details Dir should not already exist.
+ * \param im Image data for dir
+ * \return int Database id for new dir
+ * \note Only backends should modify the database
  */
-QList<QStringList> ImageUtils::GetAllExifValues(const QString &fileName)
+int ImageDbWriter::InsertDbDirectory(ImageItem &im)
 {
-    // default value, an empty list means no
-    // exif tags were found or an error occured
-    QList<QStringList> valueList;
-
-    try
-    {
-        Exiv2::Image::AutoPtr image =
-                Exiv2::ImageFactory::open(fileName.toLocal8Bit().constData());
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("INSERT INTO gallery_files ("
+                  "name, path, dir_id, type, modtime, hidden "
+                  ") VALUES ("
+                  ":NAME, :PATH, :PARENT_ID, :TYPE, :MODTIME, :HIDDEN);");
+    query.bindValue(":NAME", im.m_name);
+    query.bindValue(":PATH", im.m_path);
+    query.bindValue(":PARENT_ID", im.m_parentId);
+    query.bindValue(":TYPE", im.m_type);
+    query.bindValue(":MODTIME", im.m_modTime);
+    query.bindValue(":HIDDEN", im.m_isHidden);
 
-        if (image.get())
-        {
-            image->readMetadata();
-            Exiv2::ExifData &exifData = image->exifData();
-            if (!exifData.empty())
-            {
-                LOG(VB_FILE, LOG_DEBUG,
-                    QString("Found %1 tag(s) for file %2")
-                    .arg(exifData.count())
-                    .arg(fileName));
-
-                Exiv2::ExifData::const_iterator end = exifData.end();
-                Exiv2::ExifData::const_iterator i = exifData.begin();
-                for (; i != end; ++i)
-                {
-                    QString value = QString::fromStdString(i->value().toString());
-
-                    // Do not add empty tags to the list
-                    if (!value.isEmpty())
-                    {
-                        QStringList values;
-
-                        // These three are the same as i->key()
-                        values.append(QString::fromStdString(i->familyName()));
-                        values.append(QString::fromStdString(i->groupName()));
-                        values.append(QString::fromStdString(i->tagName()));
-                        values.append(QString::fromStdString(i->key()));
-                        values.append(QString::fromStdString(i->tagLabel()));
-                        values.append(QString::fromStdString(i->value().toString()));
-
-                        LOG(VB_FILE, LOG_DEBUG, QString("%1 (Type %2)")
-                            .arg(values.join(" : "))
-                            .arg(i->typeName()));
-
-                        // Add the exif information to the list, ignoring empty labels
-                        if (!values.at(4).isEmpty())
-                            valueList.append(values);
-                    }
-                }
-            }
-            else
-            {
-                LOG(VB_FILE, LOG_DEBUG,
-                    QString("Exiv2 error: No header, file %1")
-                    .arg(fileName));
-            }
-        }
-        else
-        {
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("Exiv2 error: Could not open file, file %1")
-                .arg(fileName));
-        }
-    }
-    catch (Exiv2::Error& e)
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("Exiv2 exception %1, file %2")
-            .arg(e.what()).arg(fileName));
-    }
+    if (!query.exec())
+        MythDB::DBError("Error inserting, query: ", query);
 
-    return valueList;
+    return query.lastInsertId().toInt();
 }
 
 
-
-/** \fn     ImageUtils::GetExifValue(const QString &, const QString &, bool *)
- *  \brief  Reads and returns the value of an exif tag in a file
- *  \param  fileName The filename that holds the exif data
- *  \param  exifTag The key that shall be updated
- *  \param  ok Will be set to true if the reading was ok, otherwise false
- *  \return The value of the exif tag or an empty string
+/*!
+ * \brief Updates or creates database image or dir
+ * \details Item does not need to pre-exist
+ * \sa ImageUtils::InsertDbDirectory
+ * \param im Image or dir
+ * \return bool False if db update failed
+ * \note Only backends should modify the database
  */
-QString ImageUtils::GetExifValue(const QString &fileName,
-                                 const QString &exifTag,
-                                 bool *ok)
+bool ImageDbWriter::UpdateDbFile(ImageItem *im)
 {
-    // Assume the exif reading fails
-    *ok = false;
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare(QString("REPLACE INTO gallery_files ("
+                          "file_id, name, path, dir_id, type, "
+                          "modtime, size, extension, date, orientation, filename) "
+                          "VALUES ("
+                          ":ID, :NAME, :PATH, :DIR, :TYPE, :MODTIME, "
+                          ":SIZE, :EXT, :DATE, :ORIENT, :COMMENT )"));
+    query.bindValue(":ID", im->m_id);
+    query.bindValue(":NAME", im->m_name);
+    query.bindValue(":PATH", im->m_path.isNull() ? "" : im->m_path);
+    query.bindValue(":DIR", im->m_parentId);
+    query.bindValue(":TYPE", im->m_type);
+    query.bindValue(":MODTIME", im->m_modTime);
+    query.bindValue(":SIZE", im->m_size);
+    query.bindValue(":EXT", im->m_extension);
+    query.bindValue(":DATE", im->m_date);
+    query.bindValue(":ORIENT", im->m_orientation);
+    query.bindValue(":COMMENT", im->m_comment.isNull() ? "" : im->m_comment);
+    // hidden & user thumb will be preserved for existing files
+    // & initialised using db defaults (0/false/not set) for new files
+
+    bool ok = query.exec();
+    if (!ok)
+        MythDB::DBError("Error updating, query: ", query);
+    return ok;
+}
 
-    // default value
-    QString value("");
 
-    try
-    {
-        Exiv2::Image::AutoPtr image =
-                Exiv2::ImageFactory::open(fileName.toLocal8Bit().constData());
+/*!
+ * \brief Remove images/dirs from database
+ * \details Item does not need to exist in db
+ * \param imList List of items to delete
+ * \return QStringList List of item ids that were successfully removed
+ * \note Only backends should modify the database
+ */
+QStringList ImageDbWriter::RemoveFromDB(const ImageList imList)
+{
+    QStringList ids;
+    if (!imList.isEmpty())
+    {
+        foreach (const ImageItem * im, imList)
+            ids << QString::number(im->m_id);
+
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare(QString("DELETE IGNORE FROM gallery_files "
+                              "WHERE file_id IN (%2);")
+                      .arg(ids.join(",")));
 
-        if (image.get())
-        {
-            image->readMetadata();
-            Exiv2::ExifData &exifData = image->exifData();
-            if (!exifData.empty())
-            {
-                Exiv2::Exifdatum &datum =
-                        exifData[exifTag.toLocal8Bit().constData()];
-
-                value = QString::fromStdString(datum.toString());
-                if (!value.isEmpty())
-                {
-                    *ok = true;
-                }
-                else
-                {
-                    LOG(VB_FILE, LOG_DEBUG,
-                        QString("Exiv2 error: No tag found, file %1, tag %2")
-                        .arg(fileName).arg(exifTag));
-                }
-            }
-            else
-            {
-                LOG(VB_FILE, LOG_DEBUG,
-                    QString("Exiv2 error: No header, file %1, tag %2")
-                    .arg(fileName).arg(exifTag));
-            }
-        }
-        else
+        if (!query.exec())
         {
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("Exiv2 error: Could not open file, file %1, tag %2")
-                .arg(fileName).arg(exifTag));
+            MythDB::DBError("Error deleting, query: ", query);
+            return QStringList();
         }
     }
-    catch (Exiv2::Error& e)
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("Exiv2 exception %1, file %2, tag %3")
-            .arg(e.what()).arg(fileName).arg(exifTag));
-    }
-
-    return value;
+    return ids;
 }
 
 
-
-/** \fn     ImageUtils::SetExifValue(const QString &, const QString &, const QString &, bool *)
- *  \brief  Updates the exif tag in a file with the given value
- *  \param  fileName The filename that holds the exif data
- *  \param  exifTag The key that shall be updated
- *  \param  value The new value of the exif tag
- *  \param  ok Will be set to true if the update was ok, otherwise false
- *  \return True if the exif key exists, otherwise false
+/*!
+ * \brief Sets hidden status of an image/dir in database
+ * \param hide True = hidden, False = unhidden
+ * \param ids List of item ids
+ * \return bool False if db update failed
+ * \note Only backends should modify the database
  */
-void ImageUtils::SetExifValue(const QString &fileName,
-                              const QString &exifTag,
-                              const QString &value,
-                              bool *ok)
+bool ImageDbWriter::SetHidden(bool hide, QStringList &ids)
 {
-    // Assume the exif writing fails
-    *ok = false;
+    MSqlQuery query(MSqlQuery::InitCon());
 
-    try
+    if (!ids.isEmpty())
     {
-        Exiv2::Image::AutoPtr image =
-                Exiv2::ImageFactory::open(fileName.toLocal8Bit().constData());
-
-        if (image.get())
+        query.prepare(QString("UPDATE gallery_files SET "
+                              "hidden = :HIDDEN "
+                              "WHERE file_id IN (%1);").arg(ids.join(",")));
+        query.bindValue(":HIDDEN", hide ? 1 : 0);
+\
+        if (!query.exec())
         {
-            image->readMetadata();
-            Exiv2::ExifData &exifData = image->exifData();
-
-            Exiv2::Exifdatum &datum = exifData[exifTag.toLocal8Bit().constData()];
-            datum.setValue(value.toLocal8Bit().constData());
-
-            image->writeMetadata();
-
-            *ok = true;
+            MythDB::DBError("Error updating, query: ", query);
+            return false;
         }
-        else
-        {
-            LOG(VB_GENERAL, LOG_ERR,
-                QString("Exiv2 error: Could not open file, file %1, tag %2")
-                .arg(fileName).arg(exifTag));
-        }
-    }
-    catch (Exiv2::Error& e)
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("Exiv2 exception %1, file %2, tag %3, value %4")
-            .arg(e.what()).arg(fileName).arg(exifTag).arg(value));
     }
+    return true;
 }
 
 
-
-/** \fn     ImageUtils::HasExifKey(Exiv2::ExifData, const QString &)
- *  \brief  Checks if the exif data of the file contains the given key
- *  \param  exifData The entire exif data
- *  \param  exifTag The key that shall be checked
- *  \return True if the exif key exists, otherwise false
+/*!
+ * \brief Assign the thumbnails to be used for a dir in database
+ * \param dir Dir id
+ * \param id Image or dir id to use as cover/thumbnail
+ * \note Only backends should modify the database
  */
-bool ImageUtils::HasExifKey(Exiv2::ExifData exifData,
-                            const QString &exifTag)
+void ImageDbWriter::SetCover(int dir, int id)
 {
-    Exiv2::ExifKey key(exifTag.toLocal8Bit().constData());
-    Exiv2::ExifData::iterator it = exifData.findKey(key);
+    MSqlQuery query(MSqlQuery::InitCon());
 
-    // If the iterator has is the end of the
-    // list then the key has not been found
-    return !(it == exifData.end());
+    query.prepare("UPDATE gallery_files SET "
+                  "angle = :COVER "
+                  "WHERE file_id = :DIR");
+    query.bindValue(":COVER", id);
+    query.bindValue(":DIR", dir);
+    \
+    if (!query.exec())
+        MythDB::DBError("Error updating, query: ", query);
 }
 
-/**
- *  \brief  Gets four images from the directory from the
- *          database which will be used as a folder thumbnail
- *  \param  im Holds the loaded information
- *  \return void
- */
-void ImageUtils::LoadDirectoryThumbnailValues(ImageMetadata *im)
+
+void ImageDbWriter::SetOrientation(ImageItem *im)
 {
-    // Try to get four new thumbnail filenames
-    // from the available images in this folder
     MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("SELECT CONCAT_WS('/', path, name), path FROM gallery_files "
-                          "WHERE path = :PATH "
-                          "AND type = :TYPE "
-                          "AND hidden = '0' LIMIT :LIMIT");
-    query.bindValue(":PATH", im->m_fileName);
-    query.bindValue(":TYPE", kImageFile);
-    query.bindValue(":LIMIT", kMaxFolderThumbnails);
 
+    query.prepare("UPDATE gallery_files SET "
+                  "orientation = :ORIENTATION "
+                  "WHERE file_id = :ID");
+    query.bindValue(":ORIENTATION", im->m_orientation);
+    query.bindValue(":ID", im->m_id);
+    \
     if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    int i = 0;
-    while (query.next())
-    {
-        QString thumbFileName = QString("%1%2")
-                .arg(GetConfDir().append("/tmp/MythImage/"))
-                .arg(query.value(0).toString());
-
-        if (i >= im->m_thumbFileNameList->size())
-            break;
-
-        im->m_thumbFileNameList->replace(i, thumbFileName);
-        im->m_thumbPath = query.value(1).toString();
-        ++i;
-    }
-
-    // Set the path to the thumbnail files. As a default this will be
-    // the path ".mythtv/MythGallery" in the users home directory
-    im->m_thumbPath.prepend(GetConfDir().append("/tmp/MythImage/"));
+        MythDB::DBError("Error updating, query: ", query);
 }
 
 
-
-/**
- *  \brief  Sets the thumbnail information for a file
- *  \param  im Holds the loaded information
- *  \return void
- */
-void ImageUtils::LoadFileThumbnailValues(ImageMetadata *im)
-{
-    // Set the path to the thumbnail files. As a default this will be
-    // the path ".mythtv/MythGallery" in the users home directory
-    im->m_thumbPath = im->m_path;
-    im->m_thumbPath.prepend(GetConfDir().append("/tmp/MythImage/"));
-
-    // Create the full path and filename to the thumbnail image
-    QString thumbFileName = QString("%1%2")
-                                .arg(GetConfDir().append("/tmp/MythImage/"))
-                                .arg(im->m_fileName);
-
-    // If the file is a video then append a png, otherwise the preview
-    // image would not be readable due to the video file extension
-    if (im->m_type == kVideoFile)
-        thumbFileName.append(".png");
-
-    im->m_thumbFileNameList->replace(0, thumbFileName);
-}
-
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imageutils.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imageutils.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/imageutils.h	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/imageutils.h	2015-04-30 11:17:45.415559854 +0200
@@ -1,76 +1,366 @@
+//! \file
+//! \brief Provides access to database and storage group files for images
+//! \details Encapsulates (most) database and storage group dependencies
+
 #ifndef IMAGEUTILS_H
 #define IMAGEUTILS_H
 
 // Qt headers
-#include <QDirIterator>
-
-// Other headers
-// Note: Older versions of Exiv2 don't have the exiv2.hpp include
-// file.  Using image.hpp instead seems to work.
-//#include <exiv2/exiv2.hpp>
-#ifdef _MSC_VER
-#include <exiv2/src/image.hpp>
-#else
-#include <exiv2/image.hpp>
-#endif
+#include <QDir>
+#include <QMap>
 
 // MythTV headers
-#include "mythdbcon.h"
-#include "imagemetadata.h"
-#include "mythmetaexp.h"
+#include <mythcontext.h>
+#include <mythdbcon.h>
+#include <mythmetaexp.h>
+#include <storagegroup.h>
+
+
+// Builtin storage groups
+#define IMAGE_STORAGE_GROUP         "Photographs"
+#define THUMBNAIL_STORAGE_GROUP     "Temp"
+// Filesystem dir used by TEMP SG
+#define TEMP_DIR                    "tmp"
+// Subdir within BE Myth tmp to be used for thumbnails
+#define THUMBNAIL_DIR               IMAGE_STORAGE_GROUP
+
+// Id of the root node representing the Storage Group
+#define ROOT_DB_ID 1
+
+//! Image ordering
+enum ImageSortOrder {
+    kSortByNone        = 0, //!< Undefined order
+    kSortByNameAsc     = 1, //!< Name A-Z
+    kSortByNameDesc    = 2, //!< Name Z-A
+    kSortByModTimeAsc  = 3, //!< File modified time Earliest - Latest
+    kSortByModTimeDesc = 4, //!< File modified time Latest - Earliest
+    kSortByExtAsc      = 5, //!< Extension A-Z
+    kSortByExtDesc     = 6, //!< Extension Z-A
+    kSortBySizeAsc     = 7, //!< File size Smallest - Largest
+    kSortBySizeDesc    = 8, //!< File size Largest - Smallest
+    kSortByDateAsc     = 9, //!< Exif date Earliest - Latest
+    kSortByDateDesc    = 10 //!< Exif date Latest - Earliest
+};
+
+//! Type of image to display
+enum ImageDisplayType {
+    kPicAndVideo = 0, //!< Show Pictures & Videos
+    kPicOnly     = 1, //!< Hide videos
+    kVideoOnly   = 2  //!< Hide pictures
+};
 
-#define IMAGE_STORAGE_GROUP "Photographs";
 
-class META_PUBLIC ImageUtils
+//! Type of image node
+// We need to use other names to avoid getting coflicts with the videolist.h file
+enum ImageNodeType {
+    kUnknown        = 0, //!< Shouldn't occur
+    kBaseDirectory  = 1, //!< "Gallery" root node of all images
+    kUpDirectory    = 2, //!< Dir/Parent currently viewed
+    kSubDirectory   = 3, //!< Child sub-dirs
+    kImageFile      = 4, //!< A picture
+    kVideoFile      = 5  //!< A video
+};
+
+
+//! Represents a picture, video or directory
+class META_PUBLIC ImageItem
 {
 public:
-    static ImageUtils* getInstance();
+    ImageItem();
+    ImageItem(const ImageItem &);
+
+    // Db key
+    int         m_id;            //!< Uniquely identifies an image or dir. Assigned by db
 
-    void LoadDirectoriesFromDB(QMap<QString, ImageMetadata *>*);
-    void LoadFilesFromDB(QMap<QString, ImageMetadata *>*);
-    void LoadFileFromDB(ImageMetadata * im, int id);
+    // Db File attributes
+    QString     m_name;          //!< File/Dir name (no path)
+    QString     m_path;          //!< Path relative to storage group
+    int         m_parentId;      //!< Id of parent dir
+    int         m_type;          //!< Type of node
+    int         m_modTime;       //!< Filesystem modified datestamp
+    int         m_size;          //!< Filesize (images only)
+    QString     m_extension;     //!< File extension (images only)
+    uint32_t    m_date;          //!< Image creation date, from metadata
+    int         m_orientation;   //!< Camera orientation, from metadata
+    QString     m_comment;       //!< User comment, from metadata
+
+    // Db User attributes
+    bool        m_isHidden;      //!< If true, image won't be shown
+    int         m_userThumbnail; //!< Id of an image/dir to use as thumbnail (dirs only)
+
+    // Derived attributes
+    QString     m_fileName;      //!< File path relative to storage group
+    QString     m_thumbPath;     //!< Path of thumbnail, relative to BE cache
+    QStringList m_thumbNails;    //!< BE URLs to use for thumbnails
+    QList<int>  m_thumbIds;      //!< Image ids corresponding to above thumbnails
+    int         m_dirCount;      //!< Number of child sub-dirs (dirs only)
+    int         m_fileCount;     //!< Number of child images (dirs only)
+
+    bool IsDirectory()  const { return m_type <= kSubDirectory; }
+    bool IsFile()       const { return m_type >  kSubDirectory; }
+};
 
-    int  InsertDirectoryIntoDB(ImageMetadata *);
-    int  InsertFileIntoDB(ImageMetadata *);
+Q_DECLARE_METATYPE(ImageItem*)
 
-    bool UpdateDirectoryInDB(ImageMetadata *);
-    bool UpdateFileInDB(ImageMetadata *);
 
-    bool RemoveFromDB(ImageMetadata *);
-    bool RemoveDirectoryFromDB(ImageMetadata *);
-    bool RemoveDirectoryFromDB(int);
-    bool RemoveFileFromDB(ImageMetadata *);
-    bool RemoveFileFromDB(int);
+// Convenience containers
+typedef QMap<QString, ImageItem *>  ImageMap;
+typedef QList<ImageItem *>          ImageList;
+typedef QList<int>                  ImageIdList;
 
-    void LoadDirectoryData(QFileInfo &, ImageMetadata *, int, const QString &);
-    void LoadFileData(QFileInfo &, ImageMetadata *, const QString &);
 
-    QStringList  GetStorageDirs();
+//! General functions
+class META_PUBLIC ImageUtils
+{
+public:
 
-    long                GetExifDate(const QString &, bool *);
-    int                 GetExifOrientation(const QString &, bool *);
-    QString             GetExifValue(const QString &, const QString &, bool *);
-    QList<QStringList>  GetAllExifValues(const QString &fileName);
+    static QString ThumbPathOf(ImageItem *);
+    static QString ImageDateOf(ImageItem *);
+};
 
-    void    SetExifDate(const QString &, const long, bool *);
-    void    SetExifOrientation(const QString &, const int, bool *);
-    void    SetExifValue(const QString &, const QString &, const QString &, bool *);
+
+//! Wrapped Images Storage Group providing filesystem access
+class META_PUBLIC ImageSg
+{
+public:
+    static ImageSg *getInstance();
+    QDir            GetImageFilters();
+    QString         GetFilePath(ImageItem*);
+    QStringList     GetStorageDirs() { return m_sgImages.GetDirList(); }
+
+    //! Generate URL of a thumbnail
+    QString         GenerateThumbUrl(const QString &path)
+    { return gCoreContext->GenMythURL(m_hostname, m_hostport, path, THUMBNAIL_STORAGE_GROUP);}
+
+    //! Generate URL of an image
+    QString         GenerateUrl(const QString &path)
+    { return gCoreContext->GenMythURL(m_hostname, m_hostport, path, IMAGE_STORAGE_GROUP); }
+
+    //! Determine type from an extension
+    ImageNodeType   GetImageType(const QString &ext)
+    {
+        return m_imageFileExt.contains(ext)
+                ? kImageFile
+                : m_videoFileExt.contains(ext) ? kVideoFile : kUnknown;
+    }
+
+    bool MoveFiles(ImageList &, ImageItem *parent);
+    void RemoveFiles(ImageList &);
+
+    //! Images storage group
+    StorageGroup       m_sgImages;
 
 private:
-    ImageUtils();
-    ~ImageUtils();
-    static ImageUtils   *m_instance;
+    // A singleton as creating SGs is laborious
+    ImageSg();
+    static ImageSg *m_instance;
+    QString         m_hostname, m_hostport;
+
+    //! List of file extensions recognised as pictures
+    QStringList    m_imageFileExt;
+    //! List of file extensions recognised as videos
+    QStringList    m_videoFileExt;
+
+};
 
-    QStringList          m_imageFileExt;
-    QStringList          m_videoFileExt;
 
-    void LoadDirectoryValues(MSqlQuery &, ImageMetadata *);
-    void LoadFileValues(MSqlQuery &, ImageMetadata *);
+//! Provides read-only access to image database (for FE/clients).
+//! Returned items are optionally filtered and sorted
+class META_PUBLIC ImageDbReader
+{
+public:
+    ImageDbReader(int order, bool showAll, int showType)
+        : m_showHidden(showAll), m_showType(showType) { SetSortOrder(order); }
+
+    void SetSortOrder(int order);
+    int  GetSortOrder()                 { return m_order; }
+    void SetVisibility(bool showHidden) { m_showHidden = showHidden; }
+    bool GetVisibility()                { return m_showHidden; }
+    void SetType(int showType)          { m_showType = showType; }
+    int  GetType()                      { return m_showType; }
+
+    int ReadDbItems(ImageList &images,
+                    QString selector,
+                    bool showAll = true,
+                    bool ordered = false);
+
+    /*!
+     * \brief Read selected database images/dirs by id
+     * \details Returns database items (mixed files/dirs) selected by id with options
+     * for sort order and including currently hidden items.
+     * \param[out] images List of images/dirs from Db
+     * \param[in] ids Comma-separated list of image ids
+     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+     * the visibility filter are returned
+     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+     * setting. Otherwise they are in undefined (database) order.
+     * \param[in] selector Db selection query clause
+     * \return int Number of items matching query.
+     */
+    int ReadDbItemsById(ImageList &images,
+                        const QString &ids,
+                        bool showAll = true,
+                        bool ordered = false,
+                        const QString &selector = "TRUE")
+    {
+        QString idSelector = QString("file_id IN (%1) AND %2").arg(ids, selector);
+        return ReadDbItems(images, idSelector, showAll, ordered);
+    }
+
+    /*!
+     * \brief Read selected database images (no dirs) by id
+     * \details Returns database images selected by id with options
+     * for sort order and including currently hidden items.
+     * \param[out] files List of images from Db
+     * \param[in] ids Comma-separated list of image ids
+     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+     * the visibility filter are returned
+     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+     * setting. Otherwise they are in undefined (database) order.
+     * \return int Number of items matching query.
+     */
+    int ReadDbFilesById(ImageList &files,
+                        const QString &ids,
+                        bool showAll = true,
+                        bool ordered = false)
+    { return ReadDbItemsById(files, ids, showAll, ordered, queryFiles[m_showType]); }
+
+    /*!
+     * \brief Read selected database dirs (no images) by id
+     * \details Returns database dirs selected by id with options
+     * for sort order and including currently hidden items.
+     * \param[out] dirs List of dirs from Db
+     * \param[in] ids Comma-separated list of image ids
+     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+     * the visibility filter are returned
+     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+     * setting. Otherwise they are in undefined (database) order.
+     * \return int Number of items matching query.
+     */
+    int ReadDbDirsById(ImageList &dirs,
+                       const QString &ids,
+                       bool showAll = true,
+                       bool ordered = false)
+    { return ReadDbItemsById(dirs, ids, showAll, ordered, queryDirs); }
+
+    /*!
+     * \brief Read database images (no dirs) that are children of dirs
+     * \details Returns database images that are direct children of specific dirs with
+     * options for sort order and including currently hidden items.
+     * \param[out] files List of images from Db
+     * \param[in] ids Comma-separated list of parent dir ids
+     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+     * the visibility filter are returned
+     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+     * setting. Otherwise they are in undefined (database) order.
+     * \return int Number of items matching query.
+     */
+    int ReadDbChildFiles(ImageList &files,
+                         const QString &ids,
+                         bool showAll = true,
+                         bool ordered = false)
+    {
+        QString selector = QString("dir_id IN (%1) AND %2").arg(ids, queryFiles[m_showType]);
+        return ReadDbItems(files, selector, showAll, ordered);
+    }
+
+    /*!
+     * \brief Read database dirs (no images) that are children of dirs
+     * \details Returns database dirs that are direct sub-directories of specific dirs with
+     * options for sort order and including currently hidden items.
+     * \param[out] dirs List of sub-dirs from Db
+     * \param[in] ids Comma-separated list of parent dir ids
+     * \param[in] showAll If true, all items are extracted. Otherwise only items matching
+     * the visibility filter are returned
+     * \param[in] ordered If true, returned lists are ordered according to GallerySortOrder
+     * setting. Otherwise they are in undefined (database) order.
+     * \return int Number of items matching query.
+     */
+    int ReadDbChildDirs(ImageList &dirs,
+                        const QString &ids,
+                        bool showAll = true,
+                        bool ordered = false)
+    {
+        QString selector = QString("dir_id IN (%1) AND %2").arg(ids, queryDirs);
+        return ReadDbItems(dirs, selector, showAll, ordered);
+    }
+
+    void ReadDbTree(ImageList &files,
+                    ImageList &dirs,
+                    QStringList ids,
+                    bool showAll = true,
+                    bool ordered = false);
+
+protected:
+    ImageItem *CreateImage(MSqlQuery &query);
+
+    //! Db query clauses to distinguish between images & dirs
+    static const QString queryDirs;
+    static const QMap<int, QString> queryFiles;
+    static QMap<int, QString> InitQueries();
+
+    //! Filter for hidden files
+    bool m_showHidden;
+    //! Filter for pictures/videos
+    int m_showType;
+    //! Sort order for returned items
+    int m_order;
+    //! SQL clause for sort order
+    QString m_orderSelector;
+};
+
+
+//! Provides read-write access to image database (for backends only).
+//! Returned items are not filtered or sorted
+class META_PUBLIC ImageDbWriter : private ImageDbReader
+{
+public:
 
-    void LoadDirectoryThumbnailValues(ImageMetadata *);
-    void LoadFileThumbnailValues(ImageMetadata *);
+    ImageDbWriter() : ImageDbReader(kSortByNone, true, kPicAndVideo) {}
 
-    bool HasExifKey(Exiv2::ExifData, const QString &);
+    void ReadDbItems(ImageMap &files,
+                     ImageMap &dirs,
+                     const QString &selector = "TRUE");
+
+    //! \sa ImageDbReader::ReadDbItems
+    int ReadDbItems(ImageList &images, const QString &selector)
+    { return ImageDbReader::ReadDbItems(images, selector, true, false); }
+
+    //! \sa ImageDbReader::ReadDbItemsById
+    int ReadDbItemsById(ImageList &images,
+                        const QString &ids,
+                        const QString &selector = "TRUE")
+    { return ReadDbItems(images, QString("file_id IN (%1) AND %2").arg(ids, selector)); }
+
+    //! \sa ImageDbReader::ReadDbFilesById
+    int ReadDbFilesById(ImageList &files, const QString &ids)
+    { return ReadDbItemsById(files, ids, queryFiles[kPicAndVideo]); }
+
+    //! \sa ImageDbReader::ReadDbDirsById
+    int ReadDbDirsById(ImageList &dirs, const QString &ids)
+    { return ReadDbItemsById(dirs, ids, queryDirs); }
+
+    //! \sa ImageDbReader::ReadDbChildFiles
+    int ReadDbChildFiles(ImageList &files, const QString &ids)
+    { return ImageDbReader::ReadDbChildFiles(files, ids, true, false); }
+
+    //! \sa ImageDbReader::ReadDbChildDirs
+    int ReadDbChildDirs(ImageList &dirs, const QString &ids)
+    { return ImageDbReader::ReadDbChildDirs(dirs, ids, true, false); }
+
+    //! \sa ImageDbReader::ReadDbTree
+    void ReadDbTree(ImageList &files,
+                    ImageList &dirs,
+                    QStringList ids)
+    { ImageDbReader::ReadDbTree(files, dirs, ids, true, false); }
+
+    void        ClearDb();
+    int         InsertDbDirectory(ImageItem &);
+    bool        UpdateDbFile(ImageItem *);
+    QStringList RemoveFromDB(const ImageList);
+    bool        SetHidden(bool hide, QStringList &);
+    void        SetCover(int dir, int id);
+    void        SetOrientation(ImageItem *im);
 };
 
 #endif // IMAGEUTILS_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/libmythmetadata.pro mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/libmythmetadata.pro
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythmetadata/libmythmetadata.pro	2015-04-30 11:08:30.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythmetadata/libmythmetadata.pro	2015-04-30 11:17:45.415559854 +0200
@@ -25,8 +25,8 @@
 HEADERS += musicmetadata.h musicutils.h metaio.h metaiotaglib.h
 HEADERS += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 HEADERS += metaiowavpack.h metaioid3.h metaiooggvorbis.h
-HEADERS += imagemetadata.h imageutils.h imagescan.h imagescanthread.h
-HEADERS += imagethumbgenthread.h musicfilescanner.h metadatagrabber.h
+HEADERS += imagemetadata.h imageutils.h imagescanner.h
+HEADERS += imagethumbs.h musicfilescanner.h metadatagrabber.h
 
 SOURCES += cleanup.cpp  dbaccess.cpp  dirscan.cpp  globals.cpp
 SOURCES += parentalcontrols.cpp  videoscan.cpp  videoutils.cpp
@@ -37,8 +37,8 @@
 SOURCES += musicmetadata.cpp musicutils.cpp metaio.cpp metaiotaglib.cpp
 SOURCES += metaioflacvorbis.cpp metaioavfcomment.cpp metaiomp4.cpp
 SOURCES += metaiowavpack.cpp metaioid3.cpp metaiooggvorbis.cpp
-SOURCES += imagemetadata.cpp imageutils.cpp imagescan.cpp imagescanthread.cpp
-SOURCES += imagethumbgenthread.cpp musicfilescanner.cpp metadatagrabber.cpp
+SOURCES += imagemetadata.cpp imageutils.cpp imagescanner.cpp
+SOURCES += imagethumbs.cpp musicfilescanner.cpp metadatagrabber.cpp
 
 INCLUDEPATH += ../libmythbase ../libmythtv
 INCLUDEPATH += ../.. ../ ./ ../libmythui
@@ -92,8 +92,8 @@
 inc.files += metaio.h metaiotaglib.h
 inc.files += metaioflacvorbis.h metaioavfcomment.h metaiomp4.h
 inc.files += metaiowavpack.h metaioid3.h metaiooggvorbis.h
-inc.files += imagemetadata.h imageutils.h imagescan.h imagescanthread.h
-inc.files += imagethumbgenthread.h musicfilescanner.h metadatagrabber.h
+inc.files += imagemetadata.h imageutils.h imagescanner.h
+inc.files += imagethumbs.h musicfilescanner.h metadatagrabber.h
 
 INSTALLS += inc
 
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h	2015-04-30 11:08:33.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythservicecontracts/datacontracts/imageMetadataInfo.h	2015-04-30 11:17:45.415559854 +0200
@@ -17,18 +17,18 @@
     Q_CLASSINFO( "version"    , "1.00" )
 
     Q_PROPERTY( int             Number      READ Number         WRITE setNumber     )
-    Q_PROPERTY( QString         Family      READ Family         WRITE setFamily     )
-    Q_PROPERTY( QString         Group       READ Group          WRITE setGroup      )
+//    Q_PROPERTY( QString         Family      READ Family         WRITE setFamily     )
+//    Q_PROPERTY( QString         Group       READ Group          WRITE setGroup      )
     Q_PROPERTY( QString         Tag         READ Tag            WRITE setTag        )
-    Q_PROPERTY( QString         Key         READ Key            WRITE setKey        )
+//    Q_PROPERTY( QString         Key         READ Key            WRITE setKey        )
     Q_PROPERTY( QString         Label       READ Label          WRITE setLabel      )
     Q_PROPERTY( QString         Value       READ Value          WRITE setValue      )
 
     PROPERTYIMP    ( int        , Number       )
-    PROPERTYIMP    ( QString    , Family       )
-    PROPERTYIMP    ( QString    , Group        )
+//    PROPERTYIMP    ( QString    , Family       )
+//    PROPERTYIMP    ( QString    , Group        )
     PROPERTYIMP    ( QString    , Tag          )
-    PROPERTYIMP    ( QString    , Key          )
+//    PROPERTYIMP    ( QString    , Key          )
     PROPERTYIMP    ( QString    , Label        )
     PROPERTYIMP    ( QString    , Value        )
 
@@ -52,10 +52,10 @@
         void Copy( const ImageMetadataInfo &src )
         {
             m_Number    = src.m_Number;
-            m_Family    = src.m_Family;
-            m_Group     = src.m_Group;
+//            m_Family    = src.m_Family;
+//            m_Group     = src.m_Group;
             m_Tag       = src.m_Tag;
-            m_Key       = src.m_Key;
+//            m_Key       = src.m_Key;
             m_Label     = src.m_Label;
             m_Value     = src.m_Value;
         }
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythservicecontracts/services/hackimageServices.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythservicecontracts/services/hackimageServices.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythservicecontracts/services/hackimageServices.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythservicecontracts/services/hackimageServices.h	2015-04-30 11:17:45.415559854 +0200
@@ -0,0 +1,70 @@
+#ifndef IMAGESERVICES_H_
+#define IMAGESERVICES_H_
+
+#include <QFileInfo>
+#include <QStringList>
+
+#include "service.h"
+#include "datacontracts/imageMetadataInfoList.h"
+#include "datacontracts/imageSyncInfo.h"
+
+
+
+class SERVICE_PUBLIC ImageServices : public Service
+{
+    Q_OBJECT
+    Q_CLASSINFO( "version"    , "2.0" )
+//    Q_CLASSINFO( "SetImageInfo_Method",             "POST" )
+    Q_CLASSINFO( "RemoveImageFromDB_Method",        "POST" )
+    Q_CLASSINFO( "RemoveImage_Method",              "POST" )
+    Q_CLASSINFO( "RenameImage_Method",              "POST" )
+    Q_CLASSINFO( "StartSync_Method",                "POST" )
+    Q_CLASSINFO( "StopSync_Method",                 "POST" )
+    Q_CLASSINFO( "CreateThumbnail_Method",          "POST" )
+
+    public:
+
+        // Must call InitializeCustomTypes for each unique
+        // Custom Type used in public slots below.
+        ImageServices( QObject *parent = 0 ) : Service( parent )
+        {
+            // Must call InitializeCustomTypes for each
+            // unique Custom Type used in public slots below.
+            DTC::ImageMetadataInfoList::InitializeCustomTypes();
+            DTC::ImageSyncInfo::InitializeCustomTypes();
+        }
+
+    public slots:
+
+//        virtual bool                        SetImageInfo                ( int   Id,
+//                                                                          const QString &Tag,
+//                                                                          const QString &Value ) = 0;
+
+//        virtual bool                        SetImageInfoByFileName      ( const QString &FileName,
+//                                                                          const QString &Tag,
+//                                                                          const QString &Value ) = 0;
+
+        virtual QString                     GetImageInfo                ( int   Id,
+                                                                          const QString &Tag ) = 0;
+
+//        virtual QString                     GetImageInfoByFileName      ( const QString &FileName,
+//                                                                          const QString &Tag ) = 0;
+
+        virtual DTC::ImageMetadataInfoList* GetImageInfoList            ( int   Id ) = 0;
+
+//        virtual DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName ) = 0;
+
+//        virtual bool                        RemoveImageFromDB  ( int   Id ) = 0;
+        virtual bool                        RemoveImage        ( int   Id ) = 0;
+        virtual bool                        RenameImage        ( int Id,
+                                                                 const QString &NewName ) = 0;
+
+        virtual bool                        StartSync          ( void ) = 0;
+        virtual bool                        StopSync           ( void ) = 0;
+        virtual DTC::ImageSyncInfo*         GetSyncStatus      ( void ) = 0;
+
+        virtual bool                        CreateThumbnail    ( int  Id,
+                                                                 bool Recreate) = 0;
+};
+
+#endif
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythservicecontracts/services/imageServices.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythservicecontracts/services/imageServices.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythservicecontracts/services/imageServices.h	2015-04-30 11:08:33.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythservicecontracts/services/imageServices.h	2015-04-30 11:17:45.415559854 +0200
@@ -15,7 +15,6 @@
     Q_OBJECT
     Q_CLASSINFO( "version"    , "2.0" )
     Q_CLASSINFO( "SetImageInfo_Method",             "POST" )
-    Q_CLASSINFO( "RemoveImageFromDB_Method",        "POST" )
     Q_CLASSINFO( "RemoveImage_Method",              "POST" )
     Q_CLASSINFO( "RenameImage_Method",              "POST" )
     Q_CLASSINFO( "StartSync_Method",                "POST" )
@@ -54,7 +53,6 @@
 
         virtual DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName ) = 0;
 
-        virtual bool                        RemoveImageFromDB  ( int   Id ) = 0;
         virtual bool                        RemoveImage        ( int   Id ) = 0;
         virtual bool                        RenameImage        ( int Id,
                                                                  const QString &NewName ) = 0;
@@ -63,8 +61,7 @@
         virtual bool                        StopSync           ( void ) = 0;
         virtual DTC::ImageSyncInfo*         GetSyncStatus      ( void ) = 0;
 
-        virtual bool                        CreateThumbnail    ( int  Id,
-                                                                 bool Recreate) = 0;
+        virtual bool                        CreateThumbnail    ( int  Id ) = 0;
 };
 
 #endif
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/libmythui.pro mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/libmythui.pro
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/libmythui.pro	2015-04-30 11:08:32.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/libmythui.pro	2015-04-30 11:17:45.415559854 +0200
@@ -43,6 +43,7 @@
 HEADERS += mythuianimation.h mythuiscrollbar.h
 HEADERS += mythnotificationcenter.h mythnotificationcenter_private.h
 HEADERS += mythuicomposite.h mythnotification.h mythuidefines.h
+HEADERS += mythuimultifilebrowser.h
 
 SOURCES  = mythmainwindow.cpp mythpainter.cpp mythimage.cpp mythrect.cpp
 SOURCES += myththemebase.cpp  mythpainter_qimage.cpp mythpainter_yuva.cpp
@@ -63,7 +64,7 @@
 SOURCES += mythuisimpletext.cpp mythuistatetracker.cpp
 SOURCES += mythuianimation.cpp mythuiscrollbar.cpp
 SOURCES += mythnotificationcenter.cpp mythnotification.cpp
-SOURCES += mythuicomposite.cpp
+SOURCES += mythuicomposite.cpp mythuimultifilebrowser.cpp
 SOURCES += mythuiwebbrowser.cpp
 
 inc.path = $${PREFIX}/include/mythtv/libmythui/
@@ -83,6 +84,7 @@
 inc.files += mythuiexp.h mythuisimpletext.h mythuiactions.h
 inc.files += mythuistatetracker.h mythuianimation.h mythuiscrollbar.h
 inc.files += mythnotificationcenter.h mythnotification.h mythuicomposite.h
+inc.files += mythuimultifilebrowser.h
 
 INSTALLS += inc
 
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuifilebrowser.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuifilebrowser.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuifilebrowser.cpp	2015-04-30 11:08:31.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuifilebrowser.cpp	2015-04-30 11:17:45.415559854 +0200
@@ -156,7 +156,7 @@
         m_backButton(NULL),     m_homeButton(NULL),
         m_previewImage(NULL),   m_infoText(NULL),
         m_filenameText(NULL),   m_fullpathText(NULL),
-        m_retObject(NULL)
+        m_retObject(NULL),      m_widgetName("MythFileBrowser")
 {
     SetPath(startPath);
 
@@ -210,7 +210,7 @@
 
 bool MythUIFileBrowser::Create()
 {
-    if (!CopyWindowFromBase("MythFileBrowser", this))
+    if (!CopyWindowFromBase(m_widgetName, this))
         return false;
 
     m_fileList = dynamic_cast<MythUIButtonList *>(GetChild("filelist"));
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuifilebrowser.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuifilebrowser.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuifilebrowser.h	2015-04-30 11:08:31.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuifilebrowser.h	2015-04-30 11:17:45.415559854 +0200
@@ -80,28 +80,28 @@
     MythUIFileBrowser(MythScreenStack *parent, const QString &startPath);
    ~MythUIFileBrowser();
 
-    bool Create(void);
+    virtual bool Create(void);
 
     void SetReturnEvent(QObject *retobject, const QString &resultid);
 
     void SetTypeFilter(QDir::Filters filter) { m_typeFilter = filter; }
     void SetNameFilter(QStringList filter) { m_nameFilter = filter; }
 
-  private slots:
-    void OKPressed(void);
+  protected slots:
+    virtual void OKPressed(void);
     void cancelPressed(void);
-    void backPressed(void);
-    void homePressed(void);
+    virtual void backPressed(void);
+    virtual void homePressed(void);
     void editLostFocus(void);
     void PathSelected(MythUIButtonListItem *item);
-    void PathClicked(MythUIButtonListItem *item);
+    virtual void PathClicked(MythUIButtonListItem *item);
     void LoadPreview(void);
 
-  private:
+  protected:
     void SetPath(const QString &startPath);
     bool GetRemoteFileList(const QString &url, const QString &sgDir,
                            QStringList &list);
-    void updateFileList(void);
+    virtual void updateFileList(void);
     void updateRemoteFileList(void);
     void updateLocalFileList(void);
     void updateSelectedList(void);
@@ -136,6 +136,7 @@
 
     QObject           *m_retObject;
     QString            m_id;
+    QString            m_widgetName;
 };
 
 #endif
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuimultifilebrowser.cpp mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuimultifilebrowser.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuimultifilebrowser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuimultifilebrowser.cpp	2015-04-30 11:17:45.415559854 +0200
@@ -0,0 +1,183 @@
+#include "mythuimultifilebrowser.h"
+
+#include <QCoreApplication>
+
+#include <mythlogging.h>
+#include "mythdialogbox.h"
+#include "mythuibuttonlist.h"
+#include "mythuibutton.h"
+#include "mythuitext.h"
+
+
+/*!
+ \brief Constructor
+ \param parent Parent window
+ \param startPath Dir to start browsing
+*/
+MythUIMultiFileBrowser::MythUIMultiFileBrowser(MythScreenStack *parent,
+                                               const QString &startPath)
+    : MythUIFileBrowser(parent, startPath),
+      m_selectButton(NULL),
+      m_clearButton(NULL),
+      m_selectCount(NULL)
+{
+    m_widgetName = "MythMultiFileBrowser";
+}
+
+
+/*!
+ \brief Create dialog
+ \return bool False if dialog couldn't be created
+*/
+bool MythUIMultiFileBrowser::Create()
+{
+    if (!MythUIFileBrowser::Create())
+        return false;
+
+    // Add selection buttons & selection count
+    m_selectButton = dynamic_cast<MythUIButton *>(GetChild("selectall"));
+    m_clearButton  = dynamic_cast<MythUIButton *>(GetChild("clearall"));
+    m_selectCount  = dynamic_cast<MythUIText *>(GetChild("selectcount"));
+
+    if (!m_selectButton || !m_clearButton)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "MythUIMultiFileBrowser: Your theme is missing"
+            " some UI elements! Bailing out.");
+        return false;
+    }
+
+    connect(m_selectButton, SIGNAL(Clicked()), SLOT(selectPressed()));
+    connect(m_clearButton, SIGNAL(Clicked()), SLOT(clearPressed()));
+
+    return true;
+}
+
+
+/*!
+ \brief Selects/deselects a file
+ \param item Button clicked
+*/
+void MythUIMultiFileBrowser::PathClicked(MythUIButtonListItem *item)
+{
+    if (!item)
+        return;
+
+    MFileInfo finfo = item->GetData().value<MFileInfo>();
+
+    if (finfo.isFile())
+    {
+        QString name = finfo.absoluteFilePath();
+
+        // toggle selected state
+        if (m_selected.remove(name))
+        {
+            item->setChecked(MythUIButtonListItem::NotChecked);
+        }
+        else
+        {
+            m_selected.insert(name);
+            item->setChecked(MythUIButtonListItem::FullChecked);
+        }
+
+        // Update selection stats
+        if (m_selectCount)
+            m_selectCount->SetText(QString::number(m_selected.size()));
+    }
+
+    if (!finfo.isDir())
+        return;
+
+    // clear selections on every directory change
+    m_selected.clear();
+
+    MythUIFileBrowser::PathClicked(item);
+}
+
+
+/*!
+ \brief Handle Back button
+*/
+void MythUIMultiFileBrowser::backPressed()
+{
+    m_selected.clear();
+    MythUIFileBrowser::backPressed();
+}
+
+
+/*!
+ \brief Handle Home button
+*/
+void MythUIMultiFileBrowser::homePressed()
+{
+    m_selected.clear();
+    MythUIFileBrowser::homePressed();
+}
+
+
+/*!
+ \brief Handle Accept button
+*/
+void MythUIMultiFileBrowser::OKPressed()
+{
+    if (m_retObject)
+    {
+        QStringList selectedPaths = m_selected.toList();
+        DialogCompletionEvent *dce = new DialogCompletionEvent(m_id, 0, "",
+                                                               selectedPaths);
+        QCoreApplication::postEvent(m_retObject, dce);
+    }
+    Close();
+}
+
+
+/*!
+ \brief Handle Select All
+*/
+void MythUIMultiFileBrowser::selectPressed()
+{
+    // Select all files
+    for (int i=0; i < m_fileList->GetCount(); ++i)
+    {
+        MythUIButtonListItem *btn = m_fileList->GetItemAt(i);
+        MFileInfo finfo = btn->GetData().value<MFileInfo>();
+
+        if (finfo.isFile())
+            m_selected.insert(finfo.absoluteFilePath());
+    }
+
+    updateFileList();
+}
+
+
+/*!
+ \brief Handle Clear button
+*/
+void MythUIMultiFileBrowser::clearPressed()
+{
+    m_selected.clear();
+    updateFileList();
+}
+
+
+/*!
+ \brief Populates dialog
+*/
+void MythUIMultiFileBrowser::updateFileList()
+{
+    MythUIFileBrowser::updateFileList();
+
+    // Make buttonlist checkable & set selections
+    for (int i=0; i < m_fileList->GetCount(); ++i)
+    {
+        MythUIButtonListItem *btn = m_fileList->GetItemAt(i);
+        MFileInfo finfo = btn->GetData().value<MFileInfo>();
+        btn->setCheckable(true);
+        bool marked = m_selected.contains(finfo.absoluteFilePath());
+        btn->setChecked(marked ? MythUIButtonListItem::FullChecked
+                               : MythUIButtonListItem::NotChecked);
+    }
+
+    // Update selection stats
+    if (m_selectCount)
+        m_selectCount->SetText(QString::number(m_selected.size()));
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuimultifilebrowser.h mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuimultifilebrowser.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/libs/libmythui/mythuimultifilebrowser.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/libs/libmythui/mythuimultifilebrowser.h	2015-04-30 11:17:45.415559854 +0200
@@ -0,0 +1,38 @@
+//! \file
+//! \brief File browser allowing multiple selections
+
+#ifndef MYTHUIMULTIFILEBROWSER_H
+#define MYTHUIMULTIFILEBROWSER_H
+
+#include <QSet>
+
+#include "mythuifilebrowser.h"
+
+
+//! File browser allowing multiple selections
+class MUI_PUBLIC MythUIMultiFileBrowser : public MythUIFileBrowser
+{
+    Q_OBJECT
+public:
+    MythUIMultiFileBrowser(MythScreenStack *parent, const QString &startPath);
+
+    bool Create(void);
+
+protected slots:
+    void OKPressed(void);
+    void backPressed(void);
+    void homePressed(void);
+    void selectPressed(void);
+    void clearPressed(void);
+    void PathClicked(MythUIButtonListItem *item);
+
+protected:
+    void updateFileList(void);
+
+    QSet<QString> m_selected;
+    MythUIButton  *m_selectButton;
+    MythUIButton  *m_clearButton;
+    MythUIText    *m_selectCount;
+};
+
+#endif // MYTHUIMULTIFILEBROWSER_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/imagehandlers.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/imagehandlers.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/imagehandlers.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/imagehandlers.cpp	2015-04-30 11:17:45.418893173 +0200
@@ -0,0 +1,388 @@
+#include "imagehandlers.h"
+
+#include "imageutils.h"
+#include "imagemetadata.h"
+#include "imagescanner.h"
+#include "imagethumbs.h"
+
+
+/*!
+ \brief Change name of an image/dir
+ \details Renames image/dir in Photographs storage group, synchronises image database
+ and thumbnail cache and notifies clients. A new thumbnail will be generated by next client
+ request.
+ \param id File/dir id
+ \param newBase New filename
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleRename(QString id, QString newBase)
+{
+    // Sanity check new name
+    if (newBase.isEmpty() || newBase.contains("/") || newBase.contains("\\"))
+        return QStringList("ERROR") << "Invalid name";
+
+    // Find image in DB
+    ImageDbWriter db;
+    ImageList images, dirs;
+    db.ReadDbItemsById(images, id);
+
+    // Either single id not found or multiple comma-delimited ids received
+    if (images.size() != 1)
+    {
+        LOG(VB_FILE, LOG_NOTICE,
+            QString("Image: Image %1 not found in Db").arg(id));
+        qDeleteAll(images);
+        return QStringList("ERROR") << "Unknown File";
+    }
+
+    // Get filepath for solitary image
+    ImageItem *im = images[0];
+    QString absFilename = ImageSg::getInstance()->GetFilePath(im);
+
+    if (absFilename.isEmpty())
+    {
+        delete im;
+        return QStringList("ERROR") << "File not found";
+    }
+
+    // Rename file
+    QFileInfo info = QFileInfo(absFilename);
+    QDir dir = info.absoluteDir();
+    QString newName = im->IsDirectory()
+            ? newBase : QString("%1.%2").arg(newBase, info.suffix());
+
+    if (!dir.rename(im->m_name, newName))
+    {
+        LOG(VB_FILE, LOG_ERR, QString("Image: Rename of %1 -> %2 failed")
+            .arg(im->m_name, newName));
+        delete im;
+        return QStringList("ERROR") << "Rename failed";
+    }
+
+    LOG(VB_FILE, LOG_DEBUG, QString("Image: Renamed %1 -> %2")
+        .arg(im->m_fileName, newName));
+
+    ImageList dummy;
+
+    if (im->IsDirectory())
+    {
+        // Cleanup thumbdir/thumbnails
+        // Thumb generator now owns the image object
+        QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(dummy, images);
+
+        // Notify clients of deleted ids, images, thumbs
+        gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
+
+        // Dir name change affects path of all sub-dirs & files and their thumbs
+        QStringList scan;
+        scan << "IMAGE_SCAN" << "START";
+        return ImageScan::getInstance()->HandleScanRequest(scan);
+    }
+
+    // Retain old image for cleanup
+    ImageItem *newIm = new ImageItem(*im);
+
+    // Update db
+    newIm->m_name = newName;
+    newIm->m_fileName = QDir::cleanPath(QDir(newIm->m_path).filePath(newName));
+    db.UpdateDbFile(newIm);
+    delete newIm;
+
+    // Clean up thumbnail
+    // Thumb generator now owns the images objects
+    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, dummy);
+    // Item is modified, not deleted
+    mesg.swap(0,1);
+
+    // New thumbnail will be created by client request
+
+    // Notify clients of changed image & thumbnail
+    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
+
+    return QStringList("OK");
+}
+
+
+/*!
+ \brief Deletes images/dirs
+ \details Removes images/dirs from Photographs storage group and image database.
+ Dirs will only be deleted if empty. Synchronises thumbnail cache and broadcasts
+ a 'db changed' event. Only fails if nothing is deleted.
+ \param fileIds Csv list of dir/file ids
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleDelete(QString fileIds)
+{
+    // Get subtree of files
+    ImageDbWriter db;
+    ImageList images, dirs;
+    db.ReadDbTree(images, dirs, fileIds.split(","));
+
+    // Remove files from filesystem first
+    ImageSg::getInstance()->RemoveFiles(images);
+    // ... then dirs, which should now be empty
+    ImageSg::getInstance()->RemoveFiles(dirs);
+
+    // Fail if nothing deleted
+    if (images.isEmpty() && dirs.isEmpty())
+        return QStringList("ERROR") << "Delete failed";
+
+    // Update Db
+    db.RemoveFromDB(images + dirs);
+
+    // Clean up thumbnails & update clients
+    // Thumb generator now owns the image objects
+    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, dirs);
+
+    // Notify clients of deleted ids, images, thumbs
+    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
+
+    return QStringList("OK");
+}
+
+
+/*!
+ \brief Gets meta data for an image
+ \details Reads exif tags from a picture or FFMPEG video tags
+ \param id Image id
+ \return QStringList Error message or "OK", seperator,
+list of <tag name><seperator><tag value>.
+Clients must use the embedded seperator to extract the data.
+*/
+QStringList ImageHandler::HandleGetMetadata(QString id)
+{
+    // Find image in DB
+    ImageDbWriter db;
+    ImageList images;
+    db.ReadDbFilesById(images, id);
+
+    // Either single id not found or multiple comma-delimited ids received
+    if (images.size() != 1)
+    {
+        LOG(VB_FILE, LOG_NOTICE,
+            QString("Image: Image %1 not found in Db").arg(id));
+        qDeleteAll(images);
+        return QStringList("ERROR") << "Unknown File";
+    }
+
+    // Read all metadata tags
+    ImageMetaData::TagMap tags;
+    QStringList result;
+
+    if (ImageMetaData::GetMetaData(images[0], tags))
+    {
+        // Each property is described by a pair of <tagvalue> : <taglabel>
+        // Combine label/value using a (hopefully unique) delimiter
+        // to return 1 string per property.
+        const QString seperator = ":|-|:";
+        result << "OK" << seperator;
+
+        foreach (const ImageMetaData::TagPair value, tags)
+        {
+            result.append(QString("%1%2%3")
+                          .arg(value.second).arg(seperator).arg(value.first));
+        }
+    }
+    else
+    {
+        result = QStringList("ERROR") << QString("No metadata");
+    }
+    qDeleteAll(images);
+
+    return result;
+}
+
+
+/*!
+ \brief Moves image trees
+ \details Moves a list of images/dirs to an existing image dir. Renames files in
+ the Photographs storage group and rescans to synchronise db and thumbnail cache
+ and update clients. Only fails if nothing is moved.
+ \param destId destination dir id
+ \param ids Csv list of dir/file ids
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleMove(QString destId, QString ids)
+{
+    // Validate destination
+    ImageList destDir;
+    ImageDbWriter db;
+    db.ReadDbDirsById(destDir, destId);
+
+    // Either single id not found or multiple comma-delimited ids received
+    if (destDir.size() != 1)
+    {
+        LOG(VB_FILE, LOG_ERR,
+            QString("IMAGE_MOVE: Dir %1 not found in Db").arg(destId));
+        qDeleteAll(destDir);
+        return QStringList("ERROR") << "Missing destination";
+    }
+
+    // Get transferees
+    ImageList images;
+    db.ReadDbItemsById(images, ids);
+
+    bool changed = ImageSg::getInstance()->MoveFiles(images, destDir[0]);
+
+    delete destDir[0];
+    qDeleteAll(images);
+
+    if (!changed)
+        return QStringList("ERROR") << "Move failed";
+
+    // Rescan to update Db & clients
+    QStringList scan;
+    scan << "IMAGE_SCAN" << "START";
+    return ImageScan::getInstance()->HandleScanRequest(scan);
+}
+
+
+/*!
+ \brief Hides/unhides images/dirs
+ \details Updates hidden status in image database and updates clients
+ \param hide hide flag: 0 = Show, 1 = Hide
+ \param fids Csv list of file/dir ids
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleHide(bool hide, QString fids)
+{
+    // Extract ids
+    QStringList fileIds = fids.split(",", QString::SkipEmptyParts);
+
+    ImageDbWriter db;
+    if (!db.SetHidden(hide, fileIds))
+        return QStringList("ERROR") << "Hide failed";
+
+    LOG(VB_FILE, LOG_DEBUG, QString("Image: Nodes %1 now %2hidden")
+        .arg(fids, hide ? "" : "un"));
+
+    // Send changed ids only (none deleted)
+    QStringList mesg = QStringList("") << fids;
+    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
+
+    return QStringList("OK");
+}
+
+/*!
+ \brief Change orientation of pictures by applying a transformation
+ \details Updates picture exif and image database, removes obselete thumbnails and
+ updates clients. New thumbnails will be generated by client request. Only fails if
+ nothing is modified.
+ \param transform transformation id,
+ \param fileIds Csv list of file ids
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleTransform(int transform, QString fileIds)
+{
+    if (transform < kResetExif || transform > kFlipVertical)
+        return QStringList("ERROR") << "Bad IMAGE_TRANSFORM transform";
+
+    if (fileIds.isEmpty())
+        return QStringList("ERROR") << "Empty IMAGE_TRANSFORM";
+
+    ImageDbWriter db;
+    ImageList images;
+    db.ReadDbFilesById(images, fileIds);
+
+    // Update db
+    foreach (ImageItem *im, images)
+    {
+        if (transform == kResetExif)
+        {
+            ImageMetaData::PopulateMetaValues(im);
+        }
+        else
+        {
+            // Apply transform to this image
+            im->m_orientation = ExifOrientation::Transformed(im->m_orientation,
+                                                             transform);
+        }
+        db.SetOrientation(im);
+    }
+
+    // Clean up thumbnails & update clients
+    // Thumb generator now owns the image objects
+    ImageList noDirs;
+    QStringList mesg = ImageThumb::getInstance()->DeleteThumbs(images, noDirs);
+
+    // Swap ids from 'deleted' to 'changed'
+    mesg.swap(0,1);
+    // Notify clients of changed images, thumbs
+    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
+
+    return QStringList("OK");
+}
+
+/*!
+ \brief Creates a new image dirs
+ \details Creates dirs in Photographs storage group 'most free' path. Only fails if
+ no new dirs are created. Other clients are not notified.
+ \param names Csv list of dir names
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleDirs(QStringList names)
+{
+    // Note: Could/should be implemented by RemoteFile
+
+    // Get SG dir
+    QString sgDir = ImageSg::getInstance()->m_sgImages.FindNextDirMostFree();
+    if (sgDir.isEmpty())
+        return QStringList("ERROR") << "Empty Storage Group";
+
+    bool success = false;
+    QDir dir;
+    for (int i = 0; i < names.size(); ++i)
+    {
+        if (dir.mkpath(QString("%1/%2").arg(sgDir, names[i])))
+            success = true;
+        else
+            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to create dir %1")
+                .arg(names[i]));
+    }
+
+    return success ? QStringList("OK")
+                   : QStringList("ERROR") << "Create failed";
+}
+
+/*!
+ \brief Updates/resets cover thumbnail for an image dir
+ \details Notifies all clients of new cover
+ \param dir Directory id
+ \param Cover Id of 0 resets dir to use its own thumbnail
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleCover(int dir, int cover)
+{
+    ImageDbWriter db;
+    db.SetCover(dir, cover);
+
+    LOG(VB_FILE, LOG_DEBUG, QString("Image: Cover of %1 is now %2")
+        .arg(dir).arg(cover));
+
+    // Id has changed, nothing deleted
+    QStringList mesg = QStringList("") << QString::number(dir);
+    gCoreContext->SendEvent(MythEvent("IMAGE_DB_CHANGED", mesg));
+
+    return QStringList("OK");
+}
+
+/*!
+ \brief Updates exclusion list for images
+ \details Stores new exclusions setting & rescans. Exclusions is a global setting
+ that dictates which files the scanner ignores. However it is set by any client
+ (last writer wins). Glob characters * and ? are valid.
+ \param exclusions Csv list of exclusion patterns
+ \return QStringList Error message or "OK"
+*/
+QStringList ImageHandler::HandleIgnore(QString exclusions)
+{
+    // Save new setting. FE will have already saved it but not cleared the cache
+    gCoreContext->SaveSettingOnHost("GalleryIgnoreFilter", exclusions, NULL);
+
+    // Rescan
+    QStringList scan;
+    scan << "IMAGE_SCAN" << "START";
+    ImageScan *is = ImageScan::getInstance();
+    return is->HandleScanRequest(scan);
+}
+
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/imagehandlers.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/imagehandlers.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/imagehandlers.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/imagehandlers.h	2015-04-30 11:17:45.418893173 +0200
@@ -0,0 +1,25 @@
+//! \file
+//! \brief Encapsulates BE
+
+#ifndef IMAGEHANDLERS_H
+#define IMAGEHANDLERS_H
+
+#include <QStringList>
+
+//! Processes BE requests regarding images
+class ImageHandler
+{
+public:
+
+    static QStringList HandleRename(QString, QString);
+    static QStringList HandleDelete(QString);
+    static QStringList HandleGetMetadata(QString);
+    static QStringList HandleMove(QString, QString);
+    static QStringList HandleHide(bool, QString);
+    static QStringList HandleTransform(int, QString);
+    static QStringList HandleDirs(QStringList);
+    static QStringList HandleCover(int, int);
+    static QStringList HandleIgnore(QString);
+};
+
+#endif // IMAGEHANDLERS_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/mainserver.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/mainserver.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/mainserver.cpp	2015-04-30 11:09:04.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/mainserver.cpp	2015-04-30 11:17:45.418893173 +0200
@@ -74,9 +74,9 @@
 #include "filesysteminfo.h"
 #include "metaio.h"
 #include "musicmetadata.h"
-#include "imagescan.h"
-#include "imagethumbgenthread.h"
-#include "imageutils.h"
+#include "imagescanner.h"
+#include "imagethumbs.h"
+#include "imagehandlers.h"
 
 // mythbackend headers
 #include "backendcontext.h"
@@ -897,93 +897,89 @@
     }
     else if (command == "IMAGE_SCAN")
     {
-        QString err = QString("Bad IMAGE_SCAN");
-
-        if (listline.size() == 2)
-
-            err = HandleScanImages(listline, pbs);
-
-        if (err.isEmpty())
-        {
-            QStringList ok = QStringList("OK");
-            SendResponse(pbs->getSocket(), ok);
-        }
-        else
-            SendErrorResponse(pbs, err);
+        QStringList reply = ImageScan::getInstance()->HandleScanRequest(listline);
+        SendResponse(pbs->getSocket(), reply);
     }
-    else if (command == "IMAGE_GET_SCAN_STATUS")
+    else if (command == "IMAGE_MOVE")
     {
-        if (listline.size() != 1)
-            SendErrorResponse(pbs, "Bad IMAGE_GET_SCAN_STATUS");
-        else
-            HandleQueryImageScanStatus(pbs);
-    }
-    else if (command == "IMAGE_THUMBNAILS")
-    {
-        if (listline.size() < 3)
-            SendErrorResponse(pbs, "Bad IMAGE_THUMBNAILS");
-        else
-            HandleCreateThumbnails(listline, pbs);
+        // Expects destination dir id, comma-delimited dir/file ids
+        QStringList reply = (listline.size() == 3)
+                         ? ImageHandler::HandleMove(listline[1], listline[2])
+                         : QStringList("ERROR") << "Bad IMAGE_MOVE";
+
+        SendResponse(pbs->getSocket(), reply);
     }
     else if (command == "IMAGE_DELETE")
     {
-        QString err = QString("Bad IMAGE_DELETE");
+        // Expects comma-delimited dir/file ids
+        QStringList reply = (listline.size() == 2)
+                ? ImageHandler::HandleDelete(listline[1])
+                : QStringList("ERROR") << "Bad IMAGE_DELETE";
 
-        if (listline.size() == 2)
+        SendResponse(pbs->getSocket(), reply);
+    }
+    else if (command == "IMAGE_HIDE")
+    {
+        // Expects hide flag, comma-delimited file/dir ids
+        QStringList reply = (listline.size() == 3)
+                ? ImageHandler::HandleHide(listline[1].toInt(), listline[2])
+                : QStringList("ERROR") << "Bad IMAGE_HIDE";
 
-            err = HandleDeleteImage(listline, pbs);
+        SendResponse(pbs->getSocket(), reply);
+    }
+    else if (command == "IMAGE_TRANSFORM")
+    {
+        // Expects transformation, write file flag,
+        QStringList reply = (listline.size() == 3)
+                ? ImageHandler::HandleTransform(listline[1].toInt(), listline[2])
+                : QStringList("ERROR") << "Bad IMAGE_TRANSFORM";
 
-        if (err.isEmpty())
-        {
-            QStringList ok = QStringList("OK");
-            SendResponse(pbs->getSocket(), ok);
-        }
-        else
-            SendErrorResponse(pbs, err);
+        SendResponse(pbs->getSocket(), reply);
     }
     else if (command == "IMAGE_RENAME")
     {
-        QString err = QString("Bad IMAGE_RENAME");
-
-        if (listline.size() == 3)
+        // Expects file/dir id, new basename
+        QStringList reply = (listline.size() == 3)
+                ? ImageHandler::HandleRename(listline[1], listline[2])
+                : QStringList("ERROR") << "Bad IMAGE_RENAME";
 
-            err = HandleRenameImage(listline, pbs);
-
-        if (err.isEmpty())
-        {
-            QStringList ok = QStringList("OK");
-            SendResponse(pbs->getSocket(), ok);
-        }
-        else
-            SendErrorResponse(pbs, err);
+        SendResponse(pbs->getSocket(), reply);
     }
-    else if (command == "IMAGE_SET_EXIF")
+    else if (command == "IMAGE_CREATE_DIRS")
     {
-        QString err = QString("Bad IMAGE_SET_EXIF");
-
-        if (listline.size() == 4)
+        // Expects list of dir names
+        QStringList reply = (listline.size() == 2)
+                ? ImageHandler::HandleDirs(listline[1].split(","))
+                : QStringList("ERROR") << "Bad IMAGE_CREATE_DIRS";
 
-            err = HandleSetImageExif(listline, pbs);
-
-        if (err.isEmpty())
-        {
-            QStringList ok = QStringList("OK");
-            SendResponse(pbs->getSocket(), ok);
-        }
-        else
-            SendErrorResponse(pbs, err);
+        SendResponse(pbs->getSocket(), reply);
     }
-    else if (command == "IMAGE_GET_EXIF")
+    else if (command == "IMAGE_COVER")
     {
-        QString err = QString("Bad IMAGE_GET_EXIF");
-
-        if (listline.size() == 2)
+        // Expects dir id, cover id. Cover id of 0 resets dir to use its own
+        QStringList reply = (listline.size() == 3)
+                ? ImageHandler::HandleCover(listline[1].toInt(), listline[2].toInt())
+                : QStringList("ERROR") << "Bad IMAGE_COVER";
 
-            err = HandleGetImageExif(listline, pbs);
+        SendResponse(pbs->getSocket(), reply);
+    }
+    else if (command == "IMAGE_GET_METADATA")
+    {
+        // Expects "IMAGE_GET_METADATA", image id
+        QStringList reply = (listline.size() == 2)
+                ? ImageHandler::HandleGetMetadata(listline[1])
+                : QStringList("ERROR") << "Bad IMAGE_GET_METADATA";
 
-        if (!err.isEmpty())
+        SendResponse(pbs->getSocket(), reply);
+    }
+    else if (command == "IMAGE_IGNORE")
+    {
+        // Expects list of exclusion patterns
+        QStringList reply = (listline.size() == 2)
+                ? ImageHandler::HandleIgnore(listline[1])
+                : QStringList("ERROR") << "Bad IMAGE_IGNORE";
 
-            SendErrorResponse(pbs, err);
+        SendResponse(pbs->getSocket(), reply);
     }
     else if (command == "ALLOW_SHUTDOWN")
     {
@@ -1379,6 +1375,9 @@
         if (me->Message().startsWith("LOCAL_"))
             return;
 
+        if (me->Message() == "CREATE_THUMBNAILS")
+            ImageThumb::getInstance()->HandleCreateThumbnails(me->ExtraDataList());
+
         MythEvent mod_me("");
         if (me->Message().startsWith("MASTER_UPDATE_REC_INFO"))
         {
@@ -6495,6 +6494,7 @@
         SendResponse(pbssock, strlist);
 }
 
+
 void MainServer::HandleMusicTagRemoveImage(const QStringList& slist, PlaybackSock* pbs)
 {
 // format: MUSIC_TAG_REMOVEIMAGE <hostname> <songid> <imageid>
@@ -6625,351 +6625,6 @@
         SendResponse(pbssock, strlist);
 }
 
-// Expects: START or STOP
-// Replies: OK or error
-QString MainServer::HandleScanImages(QStringList &slist,
-                                     PlaybackSock *pbs)
-{
-    ImageScan *is = ImageScan::getInstance();
-
-    if (slist[1] == "START")
-
-        is->StartSync();
-
-    else if (slist[1] == "STOP")
-
-        is->StopSync();
-
-    else
-        return QString("Unknown Command %1").arg(slist[1]);
-
-    return QString();
-}
-
-// Expects: nothing
-// Replies: current scan status as an int (0 or 1)
-//        : number of images already scanned
-//        : total number of images detected
-void MainServer::HandleQueryImageScanStatus(PlaybackSock *pbs)
-{
-    ImageScan *is = ImageScan::getInstance();
-    QStringList strlist;
-
-    strlist << "OK"
-            << QString::number(is->SyncIsRunning()) // return bool as an int
-            << QString::number(is->GetCurrent())
-            << QString::number(is->GetTotal());
-
-    SendResponse(pbs->getSocket(), strlist);
-}
-
-// Expects: recreate-even-if-already-present boolean flag, list of image ids
-// Replies: OK
-void MainServer::HandleCreateThumbnails(QStringList &slist,
-                                        PlaybackSock *pbs)
-{
-    // single flag applies to all thumbnails
-    bool recreate = slist[1].toInt();
-
-    ImageUtils *iu = ImageUtils::getInstance();
-    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
-
-    for (int i = 2; i < slist.size(); ++i)
-    {
-        int id = slist[i].toInt();
-
-        ImageMetadata *im = new ImageMetadata();
-
-        // find requested image in DB
-        iu->LoadFileFromDB(im, id);
-
-        if (im->m_fileName.isEmpty())
-        {
-            LOG(VB_FILE, LOG_DEBUG, QString("Image %1 not found in Db").arg(id));
-            delete im;
-        }
-        else
-            // pass to thumbnail generator
-            thumbGen->AddToThumbnailList(im, recreate);
-    }
-
-    // Restart generator
-    thumbGen->StartThumbGen();
-
-    QStringList ok = QStringList("OK");
-    SendResponse(pbs->getSocket(), ok);
-}
-
-// Expects: image id
-// Replies: error or nothing
-QString MainServer::HandleDeleteImage(QStringList &slist, PlaybackSock *pbs)
-{
-    QString sgName = IMAGE_STORAGE_GROUP;
-    StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
-    ImageUtils *iu = ImageUtils::getInstance();
-
-    int id = slist[1].toInt();
-
-    // Find image in DB
-    ImageMetadata *im = new ImageMetadata();
-    iu->LoadFileFromDB(im, id);
-    QString fileName = im->m_fileName;
-    delete im;
-
-    if (fileName.isEmpty())
-
-        return QString("Image %1 not found in Db").arg(id);
-
-    // Find image file
-    QString imageFileName = sg.FindFile(fileName);
-
-    if (imageFileName.isEmpty())
-
-        return QString("File %1 for image %2 not found")
-                .arg(fileName)
-                .arg(id);
-
-    // Remove file
-    if (!QFile::remove(imageFileName))
-
-        return QString("Could not delete file %1 for image %2")
-                .arg(imageFileName)
-                .arg(id);
-
-    LOG(VB_FILE, LOG_DEBUG,
-        QString("Deleted %1 for image %2")
-        .arg(imageFileName)
-        .arg(id));
-
-    // Remove the database entry once the file has been deleted.
-    if (!iu->RemoveFileFromDB(id))
-
-        return QString("Delete from Db failed for image %1").arg(id);
-
-    // success
-    return QString();
-}
-
-// Expects: image id, new name
-// Replies: error or nothing
-QString MainServer::HandleRenameImage(QStringList &slist, PlaybackSock *pbs)
-{
-    QString sgName = IMAGE_STORAGE_GROUP;
-    StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName(), false);
-    ImageUtils *iu = ImageUtils::getInstance();
-
-    int id = slist[1].toInt();
-    QString newName = slist[2];
-
-    // New name must not contain a path
-    if (newName.contains("/") || newName.contains("\\"))
-
-        return QString("New filename '%1' for image %2 must "
-                       "not contain a path")
-                .arg(newName)
-                .arg(id);
-
-    // Find image in DB
-    ImageMetadata *im = new ImageMetadata();
-    iu->LoadFileFromDB(im, id);
-    QString relFileName = im->m_fileName;
-    QString name = im->m_name;
-    QString path = im->m_path;
-    delete im;
-
-    if (relFileName.isEmpty())
-
-        return QString("Image %1 not found in Db").arg(id);
-
-    // Find image file
-    QString absFileName = sg.FindFile(relFileName);
-
-    if (absFileName.isEmpty())
-
-        return QString("File %1 for image %2 not found")
-                .arg(relFileName)
-                .arg(id);
-
-    // Rename the file
-    QFile file;
-    file.setFileName(absFileName);
-    QFileInfo info = QFileInfo(file);
-    QString absNewName = QString("%1/%2").arg(info.absolutePath()).arg(newName);
-
-    if (!file.rename(absNewName))
-
-        return QString("Renaming %1 to %2 failed for image %3")
-                .arg(name)
-                .arg(newName)
-                .arg(id);
-
-    LOG(VB_FILE, LOG_DEBUG,
-        QString("Renamed %1 to %2 for image %3")
-        .arg(name)
-        .arg(newName)
-        .arg(id));
-
-    // Update the database
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(QString("UPDATE gallery_files SET "
-                          "name           = :NAME "
-                          "WHERE file_id  = :ID;"));
-    query.bindValue(":NAME", newName);
-    query.bindValue(":ID",   id);
-
-    if (!query.exec())
-
-        return QString("Rename in Db failed for image %1").arg(id);
-
-    // success
-    return QString();
-}
-
-// Expects: image id, property, tag value
-// Replies: error or nothing
-QString MainServer::HandleSetImageExif(QStringList &slist, PlaybackSock *pbs)
-{
-    QString sgName = IMAGE_STORAGE_GROUP;
-    StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
-    ImageUtils *iu = ImageUtils::getInstance();
-
-    int id = slist[1].toInt();
-    QString property = slist[2];
-    QString tagValue = slist[3];
-
-    // validate
-    QString tag;
-    int value;
-    if (property == "ORIENTATION")
-    {
-        tag = "Exif.Image.Orientation";
-        value = tagValue.toInt();
-
-        // See http://jpegclub.org/exif_orientation.html for details
-        if ( value < 1 || value > 8)
-
-            return QString("Invalid orientation %1 requested for image %2")
-                    .arg(tagValue)
-                    .arg(id);
-    }
-    else
-        return QString("Setting property %1 not implemented").arg(property);
-
-    // Find image in DB
-    ImageMetadata *im = new ImageMetadata();
-    iu->LoadFileFromDB(im, id);
-    QString fileName = im->m_fileName;
-    delete im;
-
-    if (fileName.isEmpty())
-
-        return QString("Image %1 not found in Db").arg(id);
-
-    // Find image file
-    QString imageFileName = sg.FindFile(fileName);
-
-    if (imageFileName.isEmpty())
-
-        return QString("File %1 for image %2 not found")
-                .arg(fileName)
-                .arg(id);
-
-    // Set Exif
-    bool ok;
-    iu->SetExifValue(imageFileName, tag, tagValue, &ok);
-
-    if (!ok)
-
-        return QString("Setting exif %1 failed for image %2")
-                .arg(property)
-                .arg(id);
-
-    LOG(VB_FILE, LOG_DEBUG,
-        QString("Set exif %1 to %2 for image %3")
-        .arg(property)
-        .arg(tagValue)
-        .arg(id));
-
-    // Update the database
-    if (property == "ORIENTATION")
-    {
-        MSqlQuery query(MSqlQuery::InitCon());
-        query.prepare(QString("UPDATE gallery_files SET "
-                              "orientation    = :ORIENT "
-                              "WHERE file_id  = :ID;"));
-        query.bindValue(":ORIENT", value);
-        query.bindValue(":ID",     id);
-
-        if (!query.exec())
-
-            return QString("Set exif in Db failed for image %1").arg(id);
-    }
-    // success
-    return QString();
-}
-
-// Expects: image id
-// Replies: error or list of
-QString MainServer::HandleGetImageExif(QStringList &slist, PlaybackSock *pbs)
-{
-    QString sgName = IMAGE_STORAGE_GROUP;
-    StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
-    ImageUtils *iu = ImageUtils::getInstance();
-
-    int id = slist[1].toInt();
-
-    // Find image in DB
-    ImageMetadata *im = new ImageMetadata();
-    iu->LoadFileFromDB(im, id);
-    QString fileName = im->m_fileName;
-    delete im;
-
-    if (fileName.isEmpty())
-
-        return QString("Image %1 not found in Db").arg(id);
-
-    // Find image file
-    QString imageFileName = sg.FindFile(fileName);
-
-    if (imageFileName.isEmpty())
-
-        return QString("File %1 for image %2 not found")
-                .arg(fileName)
-                .arg(id);
-
-    // Get Exif
-    QList<QStringList> valueList = iu->GetAllExifValues(imageFileName);
-
-    if (valueList.size() == 0)
-
-        return QString("Could not read %1 exif tags for image %2")
-                .arg(imageFileName)
-                .arg(id);
-
-    // Each property is described by a stringlist of
-    // <familyname>, <groupname>, <tagname>, <taglabel>, <value>
-    // Combine label/value using a (hopefully unique) delimiter
-    // to return 1 string per property.
-    // Clients must use the supplied seperator to split the strings
-    const QString seperator = ":|-|:";
-    QStringList result;
-    result << "OK" << seperator;
-
-    for (int i = 0; i < valueList.size(); ++i)
-    {
-        const QStringList values = valueList.at(i);
-
-        result.append(QString("%1%2%3")
-                      .arg(values.at(4))
-                      .arg(seperator)
-                      .arg(values.at(5)));
-    }
-
-    SendResponse(pbs->getSocket(), result);
-
-    // success
-    return QString();
-}
 
 void MainServer::HandleFileTransferQuery(QStringList &slist,
                                          QStringList &commands,
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/mainserver.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/mainserver.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/mainserver.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/mainserver.h	2015-04-30 11:17:45.418893173 +0200
@@ -228,13 +228,6 @@
     void HandleMusicTagRemoveImage(const QStringList &slist, PlaybackSock *pbs);
     void HandleMusicTagChangeImage(const QStringList &slist, PlaybackSock *pbs);
     void HandleMusicCalcTrackLen(const QStringList &slist, PlaybackSock *pbs);
-    QString HandleScanImages(QStringList &slist, PlaybackSock *pbs);
-    void HandleQueryImageScanStatus(PlaybackSock *pbs);
-    void HandleCreateThumbnails(QStringList &slist, PlaybackSock *pbs);
-    QString HandleDeleteImage(QStringList &slist, PlaybackSock *pbs);
-    QString HandleRenameImage(QStringList &slist, PlaybackSock *pbs);
-    QString HandleSetImageExif(QStringList &slist, PlaybackSock *pbs);
-    QString HandleGetImageExif(QStringList &slist, PlaybackSock *pbs);
     void HandleVersion(MythSocket *socket, const QStringList &slist);
     void HandleBackendRefresh(MythSocket *socket);
     void HandleQueryLoad(PlaybackSock *pbs);
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/mythbackend.pro mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/mythbackend.pro
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/mythbackend.pro	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/mythbackend.pro	2015-04-30 11:17:45.418893173 +0200
@@ -30,7 +30,7 @@
 # Input
 HEADERS += autoexpire.h encoderlink.h filetransfer.h httpstatus.h mainserver.h
 HEADERS += playbacksock.h scheduler.h server.h backendhousekeeper.h
-HEADERS += backendutil.h
+HEADERS += backendutil.h imagehandlers.h
 HEADERS += upnpcdstv.h upnpcdsmusic.h upnpcdsvideo.h mediaserver.h
 HEADERS += internetContent.h main_helpers.h backendcontext.h
 HEADERS += httpconfig.h mythsettings.h commandlineparser.h
@@ -48,7 +48,7 @@
 
 SOURCES += autoexpire.cpp encoderlink.cpp filetransfer.cpp httpstatus.cpp
 SOURCES += main.cpp mainserver.cpp playbacksock.cpp scheduler.cpp server.cpp
-SOURCES += backendhousekeeper.cpp backendutil.cpp
+SOURCES += backendhousekeeper.cpp backendutil.cpp imagehandlers.cpp
 SOURCES += upnpcdstv.cpp upnpcdsmusic.cpp upnpcdsvideo.cpp mediaserver.cpp
 SOURCES += internetContent.cpp main_helpers.cpp backendcontext.cpp
 SOURCES += httpconfig.cpp mythsettings.cpp commandlineparser.cpp
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/hackimage.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/hackimage.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/hackimage.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/hackimage.cpp	2015-04-30 11:17:45.418893173 +0200
@@ -0,0 +1,372 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: image.cpp
+// Created     : Jul. 27, 2012
+//
+// Copyright (c) 2012 Robert Siebert  <trebor_s@web.de>
+//
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA
+//
+// You should have received a copy of the GNU General Public License
+// along with this program.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#include <QFile>
+
+//#include "mythcorecontext.h"
+//#include "storagegroup.h"
+
+//#include <imagemetadata.h>
+//#include "imagescanner.h"
+//#include "imagethumbs.h"
+//#include "imageutils.h"
+#include "image.h"
+#include <imagehandlers.h>
+
+//QString Image::GetImage(int id, ImageItem* im, const QString &function)
+//{
+//    QString imageFileName = QString();
+
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    iu->LoadFileFromDB(*im, id);
+
+//    if (im->m_fileName.isEmpty())
+
+//        LOG(VB_GENERAL, LOG_ERR, QString("%1 - Image %2 not found in DB.")
+//            .arg(function)
+//            .arg(id));
+//    else
+//    {
+//        QString sgName = IMAGE_STORAGE_GROUP;
+//        StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
+//        imageFileName = sg.FindFile(im->m_fileName);
+
+//        if (imageFileName.isEmpty())
+
+//            LOG(VB_GENERAL, LOG_ERR,
+//                QString("%1 - Storage Group file %2 not found for image %3")
+//                .arg(function)
+//                .arg(im->m_fileName)
+//                .arg(id));
+//    }
+//    return imageFileName;
+//}
+
+
+///** \fn     Image::SetImageInfo( int id,
+//                                 const QString &tag,
+//                                 const QString &value )
+// *  \brief  Saves the given value into the exif tag of the filename.
+// *  \param  id The database id of the file
+// *  \param  tag The tag that shall be overwritten
+// *  \param  value The new value
+// *  \return bool True when saving was successful, otherwise false
+// */
+//bool Image::SetImageInfo( int id, const QString &tag, const QString &value )
+//{
+//    ImageItem *im = new ImageItem();
+//    QString fileName = GetImage(id, im, QString("SetImageInfo"));
+//    delete im;
+
+//    if (fileName.isEmpty())
+
+//        return false;
+
+//    // We got the file name from the ID, so use this method
+//    // which does the same but just on a filename basis.
+//    return SetImageInfoByFileName(fileName, tag, value);
+// }
+
+
+
+///** \fn     Image::SetImageInfoByFileName( const QString &fileName,
+//                                           const QString &tag,
+//                                           const QString &value )
+// *  \brief  Saves the given value into the exif tag of the filename.
+// *  \param  fileName The full filename
+// *  \param  tag The tag that shall be overwritten
+// *  \param  value The new value
+// *  \return bool True when saving was successful, otherwise false
+// */
+//bool Image::SetImageInfoByFileName( const QString &fileName,
+//                                    const QString &tag,
+//                                    const QString &value )
+//{
+//    if (!QFile::exists( fileName ))
+//    {
+//        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - File does not exist.");
+//        return false;
+//    }
+
+//    if (tag.isEmpty() || value.isEmpty())
+//    {
+//        LOG(VB_GENERAL, LOG_ERR, "SetImageInfoByFileName - Exif tag name or value is missing.");
+//        return false;
+//    }
+
+//    bool ok;
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    iu->SetExifValue(fileName, tag, value, &ok);
+
+//    return false;
+//}
+
+
+
+/**
+ *  \brief  Returns the value of the specified metadata tag from the image
+            file. If the filename or metadata do not exist, an empty value is returned.
+ *  \param  id The database id of the file
+ *  \param  tag The tag name, as per Exif 2.2 standard tag names,
+ *          see http://www.exiv2.org/tags.html. For videos the Exif orientation and
+ *          datetime tag names are recognised.
+ *  \return QString The tag value if successful, otherwise empty
+ */
+QString Image::GetImageInfo( int id, const QString &tag )
+{
+    ImageList items;
+    ImageDbWriter db;
+    db.ReadDbFilesById(items, QString::number(id));
+
+    if (items.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
+            .arg(id));
+        return QString();
+    }
+
+    ImageMetaData::TagMap tags;
+    tags.insert(tag, qMakePair(QString(), QString()));
+
+    if (!ImageMetaData::GetMetaData(items[0], tags))
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Tag %1 not found for image %2.")
+            .arg(tag).arg(id));
+        qDeleteAll(items);
+        return QString();
+    }
+
+    qDeleteAll(items);
+    return tags[tag].first;
+}
+
+
+
+///** \fn     Image::GetImageInfoByFileName( const QString &fileName,
+//                                           const QString &tag )
+// *  \brief  Returns the value of the specified exif tag from the image
+//            file. If the filename or exif tag do not
+//            exist or the tag has no contents, an empty value is returned.
+// *  \param  fileName The full filename
+// *  \param  tag The exif tag
+// *  \return QString The exif tag value if successful, otherwise empty
+// */
+//QString Image::GetImageInfoByFileName( const QString &fileName, const QString &tag )
+//{
+//    if (!QFile::exists( fileName ))
+//    {
+//        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - File does not exist.");
+//        return QString();
+//    }
+
+//    if (tag.isEmpty())
+//    {
+//        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Exif tag name is missing.");
+//        return QString();
+//    }
+
+//    bool ok;
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    QString value = iu->GetExifValue(fileName, tag, &ok);
+
+//    if (!ok)
+//    {
+//        LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Could not read exif tag");
+//        return QString();
+//    }
+
+//    return value;
+//    return QString();
+//}
+
+
+
+/**
+ *  \brief  Returns all metadata tags
+ *  \param  id The database id of the file
+ *  \return DTC::ImageMetadataInfoList The list of metadata tags
+ */
+DTC::ImageMetadataInfoList* Image::GetImageInfoList( int id )
+{
+    ImageList items;
+    ImageDbWriter db;
+    db.ReadDbFilesById(items, QString::number(id));
+
+    if (items.size() != 1)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
+            .arg(id));
+        return NULL;
+    }
+
+    ImageItem *im = items[0];
+    ImageMetaData::TagMap tags;
+    if (!ImageMetaData::GetMetaData(im, tags))
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("GetImageInfo - Could not read metadata for %1")
+            .arg(im->m_fileName));
+        return NULL;
+    }
+
+    // This holds the xml data structure from
+    // the returned stringlist with the exif data
+    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
+
+    // Set the general information of the image
+    imInfoList->setCount(tags.size());
+    imInfoList->setFile(im->m_fileName);
+    imInfoList->setPath(im->m_path);
+    imInfoList->setSize(im->m_size);
+    imInfoList->setExtension(im->m_extension);
+
+    // Each property is described by a pair of <tagvalue> : <taglabel>
+    int index = 0;
+    foreach (const QString &key, tags.keys())
+    {
+        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
+
+        imInfo->setNumber( index++);
+        imInfo->setTag(    key);
+        imInfo->setLabel(  tags[key].second);
+        imInfo->setValue(  tags[key].first);
+    }
+
+    return imInfoList;
+}
+
+
+bool Image::RemoveImage( int id )
+{
+    QStringList result = ImageHandler::HandleDelete(QString::number(id));
+    return result[0] == "OK";
+}
+
+
+bool Image::RenameImage( int id, const QString &newName)
+{
+    QStringList result = ImageHandler::HandleRename(QString::number(id),
+                                                         newName);
+    return result[0] == "OK";
+}
+
+
+bool Image::MoveImage(int id, int destinationDir)
+{
+    QStringList result = ImageHandler::HandleMove(QString::number(destinationDir),
+                                                  QString::number(id));
+    return result[0] == "OK";
+}
+
+
+/** \fn     Image::StartSync(void)
+ *  \brief  Starts the synchronization of the images with the database
+ *  \return bool True if the sync has started, otherwise false
+ */
+bool Image::StartSync( void )
+{
+    // TODO
+    // Check that the required image tables exist to avoid
+    // syncing against non existent tables in the database.
+//    if (gCoreContext->GetNumSetting("DBSchemaVer") < 1318)
+//    {
+//        LOG(VB_GENERAL, LOG_INFO,
+//            "Sync cannot start, the required database tables are missing."
+//            "Please upgrade your database schema to at least 1318.");
+//        return false;
+//    }
+
+//    ImageScan *is = ImageScan::getInstance();
+//    if (!is->SyncIsRunning())
+//        is->StartSync();
+
+//    return is->SyncIsRunning();
+    return false;
+}
+
+
+
+/** \fn     Image::StopSync(void)
+ *  \brief  Stops the image synchronization if its running
+ *  \return bool True if the sync has stopped, otherwise false
+ */
+bool Image::StopSync( void )
+{
+    // TODO
+//    ImageScan *is = ImageScan::getInstance();
+//    if (is->SyncIsRunning())
+//        is->StopSync();
+
+//    return is->SyncIsRunning();
+    return false;
+}
+
+
+
+/** \fn     Image::GetSyncStatus(void)
+ *  \brief  Returns a list with information if the synchronization is
+            currently running, the already synchronized images and
+            the total amount of images that shall be synchronized.
+ *  \return DTC::ImageSyncInfo The status information
+ */
+DTC::ImageSyncInfo* Image::GetSyncStatus( void )
+{
+    DTC::ImageSyncInfo *syncInfo = new DTC::ImageSyncInfo();
+
+    // TODO
+//    ImageScan *is = ImageScan::getInstance();
+
+//    LOG(VB_GENERAL, LOG_DEBUG,
+//        QString("Image: Sync status is running: %1, current: %2, total: %3")
+//        .arg(is->SyncIsRunning())
+//        .arg(is->GetCurrent())
+//        .arg(is->GetTotal()));
+
+//    syncInfo->setRunning(is->SyncIsRunning());
+//    syncInfo->setCurrent(is->GetCurrent());
+//    syncInfo->setTotal(is->GetTotal());
+
+    return syncInfo;
+}
+
+bool Image::CreateThumbnail(int id, bool recreate)
+{
+    // TODO
+//    ImageItem *im = new ImageItem();
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    iu->LoadFileFromDB(*im, id);
+
+//    if (im->m_fileName.isEmpty())
+//    {
+//        LOG(VB_GENERAL, LOG_ERR,
+//            QString("CreateThumbnail - Image %1 not found in DB").arg(id));
+//        delete im;
+//        return false;
+//    }
+
+//    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
+//    return thumbGen->AddToThumbnailList(im, recreate);
+    return false;
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/hackimage.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/hackimage.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/hackimage.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/hackimage.h	2015-04-30 11:17:45.418893173 +0200
@@ -0,0 +1,208 @@
+//////////////////////////////////////////////////////////////////////////////
+// Program Name: image.h
+// Created     : Jul. 27, 2012
+//
+// Copyright (c) 2012 Robert Siebert <trebor_s@web.de>
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or at your option any later version of the LGPL.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library.  If not, see <http://www.gnu.org/licenses/>.
+//
+//////////////////////////////////////////////////////////////////////////////
+
+#ifndef IMAGE_H
+#define IMAGE_H
+
+#include <QScriptEngine>
+#include "services/imageServices.h"
+#include "imagemetadata.h"
+
+
+class Image : public ImageServices
+{
+    Q_OBJECT
+
+public:
+    Q_INVOKABLE Image( QObject *parent = 0 ) {}
+
+public:
+    QString                     GetImageInfo       ( int   id,
+                                                     const QString &Tag );
+
+    DTC::ImageMetadataInfoList* GetImageInfoList   ( int   id );
+
+    bool                        RemoveImage        ( int   id );
+
+    bool                        RenameImage        ( int   id,
+                                                     const QString &newName );
+
+    bool                        MoveImage          ( int   id,
+                                                     int   destinationDir);
+
+    bool                        HideImage          ( int   id,
+                                                     bool  show);
+
+    bool                        TransformImage     ( int   id,
+                                                     int   transform);
+
+    bool                        SetCover           ( int   dirId,
+                                                     int   thumbId );
+
+    bool                        CreateDir          ( int   id,
+                                                     const QString &name );
+
+    bool                        SetExclusionList   ( const QString &exclusions );
+
+    bool                        StartSync          ( void );
+    bool                        StopSync           ( void );
+    DTC::ImageSyncInfo*         GetSyncStatus      ( void );
+
+    bool                        CreateThumbnail    ( int   id );
+};
+
+// --------------------------------------------------------------------------
+// The following class wrapper is due to a limitation in Qt Script Engine.  It
+// requires all methods that return pointers to user classes that are derived from
+// QObject actually return QObject* (not the user class *).  If the user class pointer
+// is returned, the script engine treats it as a QVariant and doesn't create a
+// javascript prototype wrapper for it.
+//
+// This class allows us to keep the rich return types in the main API class while
+// offering the script engine a class it can work with.
+//
+// Only API Classes that return custom classes needs to implement these wrappers.
+//
+// We should continue to look for a cleaning solution to this problem.
+// --------------------------------------------------------------------------
+
+class ScriptableImage : public QObject
+{
+    Q_OBJECT
+
+    private:
+
+        Image          m_obj;
+        QScriptEngine *m_pEngine;
+
+    public:
+
+        Q_INVOKABLE ScriptableImage( QScriptEngine *pEngine, QObject *parent = 0 ) : QObject( parent )
+        {
+            m_pEngine = pEngine;
+        }
+
+    public slots:
+
+//        bool SetImageInfo ( int   Id,
+//                            const QString &Tag,
+//                            const QString &Value )
+//        {
+//            SCRIPT_CATCH_EXCEPTION( false,
+//                return m_obj.SetImageInfo( Id, Tag, Value );
+//            )
+//        }
+
+//        bool SetImageInfoByFileName ( const QString &FileName,
+//                                      const QString &Tag,
+//                                      const QString &Value )
+//        {
+//            SCRIPT_CATCH_EXCEPTION( false,
+//                return m_obj.SetImageInfoByFileName( FileName,
+//                                                     Tag,
+//                                                     Value );
+//            )
+//        }
+
+        QString GetImageInfo( int   Id,
+                              const QString &Tag )
+        {
+            SCRIPT_CATCH_EXCEPTION( QString(),
+                return m_obj.GetImageInfo( Id, Tag );
+            )
+        }
+
+//        QString GetImageInfoByFileName( const QString &FileName,
+//                                        const QString &Tag )
+//        {
+//            SCRIPT_CATCH_EXCEPTION( QString(),
+//                return m_obj.GetImageInfoByFileName( FileName, Tag );
+//            )
+//        }
+
+        QObject* GetImageInfoList( int   Id )
+        {
+            SCRIPT_CATCH_EXCEPTION( NULL,
+                return m_obj.GetImageInfoList( Id );
+            )
+        }
+
+//        QObject* GetImageInfoListByFileName ( const QString &FileName )
+//        {
+//            SCRIPT_CATCH_EXCEPTION( NULL,
+//                return m_obj.GetImageInfoListByFileName( FileName );
+//            )
+//        }
+
+//        bool RemoveImageFromDB( int Id )
+//        {
+//            SCRIPT_CATCH_EXCEPTION( false,
+//                return m_obj.RemoveImageFromDB( Id );
+//            )
+//        }
+
+        bool RemoveImage( int Id )
+        {
+            SCRIPT_CATCH_EXCEPTION( false,
+                return m_obj.RemoveImage( Id );
+            )
+        }
+
+        bool RenameImage( int   Id,
+                          const QString &NewName )
+        {
+            SCRIPT_CATCH_EXCEPTION( false,
+                return m_obj.RenameImage( Id, NewName );
+            )
+        }
+
+        bool StartSync( void )
+        {
+            SCRIPT_CATCH_EXCEPTION( false,
+                return m_obj.StartSync();
+            )
+        }
+
+        bool StopSync( void )
+        {
+            SCRIPT_CATCH_EXCEPTION( false,
+                return m_obj.StopSync();
+            )
+        }
+
+        QObject* GetSyncStatus( void )
+        {
+            SCRIPT_CATCH_EXCEPTION( NULL,
+                return m_obj.GetSyncStatus();
+            )
+        }
+
+        bool CreateThumbnail    ( int   Id, bool Recreate )
+        {
+            SCRIPT_CATCH_EXCEPTION( false,
+                return m_obj.CreateThumbnail( Id, Recreate );
+            )
+        }
+};
+
+Q_SCRIPT_DECLARE_QMETAOBJECT_MYTHTV( ScriptableImage, QObject*)
+
+#endif
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/image.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/image.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/image.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/image.cpp	2015-04-30 11:17:45.418893173 +0200
@@ -28,25 +28,28 @@
 #include "mythcorecontext.h"
 #include "storagegroup.h"
 
-#include "imagescan.h"
-#include "imagethumbgenthread.h"
+#include "imagescanner.h"
+#include "imagethumbs.h"
+#include "imagehandlers.h"
 #include "imageutils.h"
 #include "image.h"
 
-QString Image::GetImage(int id, ImageMetadata* im, const QString &function)
+QString Image::GetImage(int id, ImageItem* im, const QString &function)
 {
     QString imageFileName = QString();
 
-    ImageUtils *iu = ImageUtils::getInstance();
-    iu->LoadFileFromDB(im, id);
+    ImageList items;
+    ImageDbWriter db;
+    db.ReadDbFilesById(items, QString::number(id));
 
-    if (im->m_fileName.isEmpty())
+    if (items.isEmpty())
 
         LOG(VB_GENERAL, LOG_ERR, QString("%1 - Image %2 not found in DB.")
             .arg(function)
             .arg(id));
     else
     {
+        im = items[0];
         QString sgName = IMAGE_STORAGE_GROUP;
         StorageGroup sg = StorageGroup(sgName, gCoreContext->GetHostName());
         imageFileName = sg.FindFile(im->m_fileName);
@@ -62,9 +65,7 @@
     return imageFileName;
 }
 
-/** \fn     Image::SetImageInfo( int id,
-                                 const QString &tag,
-                                 const QString &value )
+/**
  *  \brief  Saves the given value into the exif tag of the filename.
  *  \param  id The database id of the file
  *  \param  tag The tag that shall be overwritten
@@ -73,7 +74,7 @@
  */
 bool Image::SetImageInfo( int id, const QString &tag, const QString &value )
 {
-    ImageMetadata *im = new ImageMetadata();
+    ImageItem *im = new ImageItem();
     QString fileName = GetImage(id, im, QString("SetImageInfo"));
     delete im;
 
@@ -88,9 +89,7 @@
 
 
 
-/** \fn     Image::SetImageInfoByFileName( const QString &fileName,
-                                           const QString &tag,
-                                           const QString &value )
+/**
  *  \brief  Saves the given value into the exif tag of the filename.
  *  \param  fileName The full filename
  *  \param  tag The tag that shall be overwritten
@@ -113,16 +112,17 @@
         return false;
     }
 
-    bool ok;
-    ImageUtils *iu = ImageUtils::getInstance();
-    iu->SetExifValue(fileName, tag, value, &ok);
+    // FIXME
+//    bool ok;
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    iu->SetExifValue(fileName, tag, value, &ok);
 
-    return ok;
+    return false;
 }
 
 
 
-/** \fn     Image::GetImageInfo( int id, const QString &tag )
+/**
  *  \brief  Returns the value of the specified exif tag from the image
             file. If the filename or exif tag do not
             exist or the tag has no contents, an empty value is returned.
@@ -132,23 +132,35 @@
  */
 QString Image::GetImageInfo( int id, const QString &tag )
 {
-    ImageMetadata *im = new ImageMetadata();
-    QString fileName = GetImage(id, im, QString("GetImageInfo"));
-    delete im;
+    ImageList items;
+    ImageDbWriter db;
+    db.ReadDbFilesById(items, QString::number(id));
 
-    if (fileName.isEmpty())
+    if (items.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
+            .arg(id));
+        return QString();
+    }
+
+    ImageMetaData::TagMap tags;
+    tags.insert(tag, qMakePair(QString(), QString()));
 
+    if (!ImageMetaData::GetMetaData(items[0], tags))
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Tag %1 not found for image %2.")
+            .arg(tag).arg(id));
+        qDeleteAll(items);
         return QString();
+    }
 
-    // We got the file name from the ID, so use this method
-    // which does the same but just on a filename basis.
-    return GetImageInfoByFileName( fileName, tag );
+    qDeleteAll(items);
+    return tags[tag].first;
 }
 
 
 
-/** \fn     Image::GetImageInfoByFileName( const QString &fileName,
-                                           const QString &tag )
+/**
  *  \brief  Returns the value of the specified exif tag from the image
             file. If the filename or exif tag do not
             exist or the tag has no contents, an empty value is returned.
@@ -170,44 +182,79 @@
         return QString();
     }
 
-    bool ok;
-    ImageUtils *iu = ImageUtils::getInstance();
-    QString value = iu->GetExifValue(fileName, tag, &ok);
+    // FIXME
+//    bool ok;
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    QString value = iu->GetExifValue(fileName, tag, &ok);
 
-    if (!ok)
+//    if (!ok)
     {
         LOG(VB_GENERAL, LOG_ERR, "GetImageInfoByFileName - Could not read exif tag");
         return QString();
     }
 
-    return value;
+//    return value;
 }
 
 
 
-/** \fn     Image::GetImageInfoList(int id)
+/**
  *  \brief  Returns all values from all available exif tags
  *  \param  id The database id of the file
  *  \return DTC::ImageMetadataInfoList The list with all exif values
  */
 DTC::ImageMetadataInfoList* Image::GetImageInfoList( int id )
 {
-    ImageMetadata *im = new ImageMetadata();
-    QString fileName = GetImage(id, im, QString("GetImageInfoList"));
-    delete im;
+    ImageList items;
+    ImageDbWriter db;
+    db.ReadDbFilesById(items, QString::number(id));
 
-    if (fileName.isEmpty())
+    if (items.size() != 1)
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("GetImageInfo: Image %1 not found.")
+            .arg(id));
+        return NULL;
+    }
 
+    ImageItem *im = items[0];
+    ImageMetaData::TagMap tags;
+    if (!ImageMetaData::GetMetaData(im, tags))
+    {
+        LOG(VB_GENERAL, LOG_ERR,
+            QString("GetImageInfo - Could not read metadata for %1")
+            .arg(im->m_fileName));
         return NULL;
+    }
 
-    // We got the file name from the ID, so use this method
-    // which does the same but just on a filename basis.
-    return GetImageInfoListByFileName(fileName);
+    // This holds the xml data structure from
+    // the returned stringlist with the exif data
+    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
+
+    // Set the general information of the image
+    imInfoList->setCount(tags.size());
+    imInfoList->setFile(im->m_fileName);
+    imInfoList->setPath(im->m_path);
+    imInfoList->setSize(im->m_size);
+    imInfoList->setExtension(im->m_extension);
+
+    // Each property is described by a pair of <tagvalue> : <taglabel>
+    int index = 0;
+    foreach (const QString &key, tags.keys())
+    {
+        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
+
+        imInfo->setNumber( index++);
+        imInfo->setTag(    key);
+        imInfo->setLabel(  tags[key].second);
+        imInfo->setValue(  tags[key].first);
+    }
+
+    return imInfoList;
 }
 
 
 
-/** \fn     Image::GetImageInfoListByFileName(QString &fileName)
+/**
  *  \brief  Returns all values from all available exif tags
  *  \param  fileName The name of the file
  *  \return DTC::ImageMetadataInfoList The list with all exif values
@@ -220,218 +267,112 @@
         return NULL;
     }
 
+    // FIXME
     // Read all available exif tag
     // values from the given image file
-    ImageUtils *iu = ImageUtils::getInstance();
-    QList<QStringList> valueList = iu->GetAllExifValues(fileName);
+//    ImageUtils *iu = ImageUtils::getInstance();
+//    QList<QStringList> valueList = iu->GetAllExifValues(fileName);
 
-    if (valueList.size() == 0)
+//    if (valueList.size() == 0)
     {
         LOG(VB_GENERAL, LOG_ERR, "GetImageInfoListByFileName - Could not read exif tags");
         return NULL;
     }
 
-    // This holds the xml data structure from
-    // the returned stringlist with the exif data
-    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
-
-    // Set the general information of the image
-    QFileInfo fi(fileName);
-    imInfoList->setCount(valueList.size());
-    imInfoList->setFile(fi.fileName());
-    imInfoList->setPath(fi.path());
-    imInfoList->setSize(fi.size());
-    imInfoList->setExtension(fi.suffix());
-
-    // The returned stringlist contents are
-    // <familyname>, <groupname>, <tagname>, <taglabel>, <value>
-    // Go through all list items and build the response. Create
-    // a new tag and add the tagnames below it. Each tagname
-    // has these children: family, group, name, label, value.
-    for (int i = 0; i < valueList.size(); ++i)
-    {
-        QStringList values = valueList.at(i);
-
-        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
-
-        imInfo->setNumber(  i);
-        imInfo->setFamily(  values.at(0));
-        imInfo->setGroup(   values.at(1));
-        imInfo->setTag(     values.at(2));
-        imInfo->setKey(     values.at(3));
-        imInfo->setLabel(   values.at(4));
-        imInfo->setValue(   values.at(5));
-    }
-
-    return imInfoList;
-}
-
-
-
-/** \fn     Image::RemoveImageFromDB(int id)
- *  \brief  Returns all values from all available exif tags
- *  \param  id The database id of the file
- *  \return bool True if successful, otherwise false
- */
-bool Image::RemoveImageFromDB( int id )
-{
-    ImageUtils *iu = ImageUtils::getInstance();
-    return iu->RemoveFileFromDB(id);
+//    // This holds the xml data structure from
+//    // the returned stringlist with the exif data
+//    DTC::ImageMetadataInfoList *imInfoList = new DTC::ImageMetadataInfoList();
+
+//    // Set the general information of the image
+//    QFileInfo fi(fileName);
+//    imInfoList->setCount(valueList.size());
+//    imInfoList->setFile(fi.fileName());
+//    imInfoList->setPath(fi.path());
+//    imInfoList->setSize(fi.size());
+//    imInfoList->setExtension(fi.suffix());
+
+//    // The returned stringlist contents are
+//    // <familyname>, <groupname>, <tagname>, <taglabel>, <value>
+//    // Go through all list items and build the response. Create
+//    // a new tag and add the tagnames below it. Each tagname
+//    // has these children: family, group, name, label, value.
+//    for (int i = 0; i < valueList.size(); ++i)
+//    {
+//        QStringList values = valueList.at(i);
+
+//        DTC::ImageMetadataInfo *imInfo = imInfoList->AddNewImageMetadataInfo();
+
+//        imInfo->setNumber(  i);
+//        imInfo->setFamily(  values.at(0));
+//        imInfo->setGroup(   values.at(1));
+//        imInfo->setTag(     values.at(2));
+//        imInfo->setKey(     values.at(3));
+//        imInfo->setLabel(   values.at(4));
+//        imInfo->setValue(   values.at(5));
+//    }
+
+//    return imInfoList;
 }
 
 
 
-/** \fn     Image::RemoveImage(int id)
- *  \brief  Returns all values from all available exif tags
- *  \param  id The database id of the file
- *  \return bool True if successful, otherwise false
- */
+/*!
+ \brief Deletes an image file or dir subtree from filesystem and database
+ \param id Image
+ \return bool True if deleted, false otherwise
+*/
 bool Image::RemoveImage( int id )
 {
-    ImageMetadata *im = new ImageMetadata();
-    QString fileName = GetImage(id, im, QString("RemoveImage"));
-    delete im;
-
-    if (fileName.isEmpty())
-
-        return false;
-
-    if (!QFile::exists( fileName ))
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("RemoveImage - File %1 not found for image %2")
-            .arg(fileName)
-            .arg(id));
-    }
-    else if (!QFile::remove( fileName ))
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("RemoveImage - Could not delete file %1 for image %2")
-            .arg(fileName)
-            .arg(id));
-    }
-    else
-    {
-        LOG(VB_FILE, LOG_DEBUG,
-            QString("RemoveImage - Deleted %1 for image %3")
-                    .arg(fileName)
-                    .arg(id));
-
-        // Remove the database entry if the file has been deleted.
-        return RemoveImageFromDB(id);
-    }
-    return false;
+    QStringList result = ImageHandler::HandleDelete(QString::number(id));
+    return result[0] == "OK";
 }
 
 
-/** \fn     Image::RenameImage(int Id,
- *                             const QString &sNewFile)
+/**
  *  \brief  Renames the file to the new name.
  *  \param  id The database id of the file
  *  \param  sNewName  The new name of the file (only the name, no path)
  *  \return bool True if renaming was successful, otherwise false
  */
-bool Image::RenameImage( int id,
-                         const QString &newName)
+bool Image::RenameImage( int id, const QString &newName)
 {
-    ImageMetadata *im = new ImageMetadata();
-    QString fileName = GetImage(id, im, QString("RenameImage"));
-    delete im;
-
-    if (fileName.isEmpty())
-
-        return false;
-
-    // Check if the file exists
-    if (!QFile::exists(fileName))
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("RenameImage - File %1 not found for image %2")
-            .arg(fileName)
-            .arg(id));
-        return false;
-    }
-
-    // New name must not contain a path
-    if (newName.contains("/") || newName.contains("\\"))
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("RenameImage - New filename '%1' for image %2 must "
-                    "not contain a path")
-            .arg(newName)
-            .arg(id));
-        return false;
-    }
-
-    // Rename the file
-    QFile file;
-    file.setFileName(fileName);
-    QFileInfo info = QFileInfo(file);
-    QDir::setCurrent(info.absolutePath());
-    bool done = file.rename(newName);
-
-    if (done)
-    {
-        LOG(VB_FILE, LOG_DEBUG,
-            QString("RenameImage - Renamed %1 to %2 for image %3")
-                    .arg(fileName)
-                    .arg(newName)
-                    .arg(id));
-    }
-    else
-    {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("RenameImage - Renaming %1 to %2 failed for image %3")
-                    .arg(fileName)
-                    .arg(newName)
-                    .arg(id));
-    }
-
-    return done;
+    QStringList result = ImageHandler::HandleRename(QString::number(id),
+                                                         newName);
+    return result[0] == "OK";
 }
 
 
-/** \fn     Image::StartSync(void)
+/**
  *  \brief  Starts the synchronization of the images with the database
  *  \return bool True if the sync has started, otherwise false
  */
 bool Image::StartSync( void )
 {
-    // Check that the required image tables exist to avoid
-    // syncing against non existent tables in the database.
-    if (gCoreContext->GetNumSetting("DBSchemaVer") < 1318)
-    {
-        LOG(VB_GENERAL, LOG_INFO,
-            "Sync cannot start, the required database tables are missing."
-            "Please upgrade your database schema to at least 1318.");
-        return false;
-    }
-
-    ImageScan *is = ImageScan::getInstance();
-    if (!is->SyncIsRunning())
-        is->StartSync();
+    QStringList request;
+    request << "IMAGE_SCAN" << "START";
 
-    return is->SyncIsRunning();
+    QStringList result = ImageScan::getInstance()->HandleScanRequest(request);
+    return result.size() >= 2 && !result[1].isEmpty();
 }
 
 
 
-/** \fn     Image::StopSync(void)
+/**
  *  \brief  Stops the image synchronization if its running
  *  \return bool True if the sync has stopped, otherwise false
  */
 bool Image::StopSync( void )
 {
-    ImageScan *is = ImageScan::getInstance();
-    if (is->SyncIsRunning())
-        is->StopSync();
+    QStringList request;
+    request << "IMAGE_SCAN" << "STOP";
 
-    return is->SyncIsRunning();
+    QStringList result = ImageScan::getInstance()->HandleScanRequest(request);
+    return result.size() >= 2 && !result[1].isEmpty();
 }
 
 
 
-/** \fn     Image::GetSyncStatus(void)
+/**
  *  \brief  Returns a list with information if the synchronization is
             currently running, the already synchronized images and
             the total amount of images that shall be synchronized.
@@ -441,35 +382,47 @@
 {
     DTC::ImageSyncInfo *syncInfo = new DTC::ImageSyncInfo();
 
-    ImageScan *is = ImageScan::getInstance();
+    QStringList request;
+    request << "IMAGE_SCAN" << "QUERY";
+
+    QStringList result = ImageScan::getInstance()->HandleScanRequest(request);
+
+    if (result.size() < 4 || result[0] != "OK")
+    {
+        // Default to no scan
+        result.clear();
+        result << "ERROR" << "" << "0" << "0";
+    }
 
     LOG(VB_GENERAL, LOG_DEBUG,
         QString("Image: Sync status is running: %1, current: %2, total: %3")
-        .arg(is->SyncIsRunning())
-        .arg(is->GetCurrent())
-        .arg(is->GetTotal()));
-
-    syncInfo->setRunning(is->SyncIsRunning());
-    syncInfo->setCurrent(is->GetCurrent());
-    syncInfo->setTotal(is->GetTotal());
+        .arg(result[1], result[2], result[3]));
+
+    syncInfo->setRunning(!result[1].isEmpty());
+    syncInfo->setCurrent(result[2].toInt());
+    syncInfo->setTotal(result[3].toInt());
 
     return syncInfo;
 }
 
-bool Image::CreateThumbnail(int id, bool recreate)
-{
-    ImageMetadata *im = new ImageMetadata();
-    ImageUtils *iu = ImageUtils::getInstance();
-    iu->LoadFileFromDB(im, id);
+/*!
+ \brief Request creation of a thumbnail
+ \param id Image
+ \return bool True if image is valid
+*/
+bool Image::CreateThumbnail(int id)
+{
+    ImageList items;
+    ImageDbWriter db;
+    db.ReadDbFilesById(items, QString::number(id));
 
-    if (im->m_fileName.isEmpty())
+    if (items.size() != 1)
     {
-        LOG(VB_GENERAL, LOG_ERR,
-            QString("CreateThumbnail - Image %1 not found in DB").arg(id));
-        delete im;
+        LOG(VB_GENERAL, LOG_ERR, QString("CreateThumbnail: Image %1 not found.")
+            .arg(id));
         return false;
     }
 
-    ImageThumbGen *thumbGen = ImageThumbGen::getInstance();
-    return thumbGen->AddToThumbnailList(im, recreate);
+    ImageThumb::getInstance()->CreateThumbnail(items[0], kPicRequestPriority);
+    return true;
 }
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/image.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/image.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythbackend/services/image.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythbackend/services/image.h	2015-04-30 11:17:45.418893173 +0200
@@ -24,6 +24,7 @@
 
 #include <QScriptEngine>
 #include "services/imageServices.h"
+#include "imageutils.h"
 #include "imagemetadata.h"
 
 
@@ -53,7 +54,6 @@
 
     DTC::ImageMetadataInfoList* GetImageInfoListByFileName  ( const QString &FileName );
 
-    bool                        RemoveImageFromDB  ( int   Id );
     bool                        RemoveImage        ( int   Id );
     bool                        RenameImage        ( int   Id,
                                                      const QString &NewName );
@@ -62,10 +62,9 @@
     bool                        StopSync           ( void );
     DTC::ImageSyncInfo*         GetSyncStatus      ( void );
 
-    bool                        CreateThumbnail    ( int   Id,
-                                                     bool  Recreate);
+    bool                        CreateThumbnail    (int   Id);
 private:
-    QString GetImage(int, ImageMetadata *, const QString & );
+    QString GetImage(int, ImageItem *, const QString & );
 
 };
 
@@ -152,13 +151,6 @@
             )
         }
 
-        bool RemoveImageFromDB( int Id )
-        {
-            SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.RemoveImageFromDB( Id );
-            )
-        }
-
         bool RemoveImage( int Id )
         {
             SCRIPT_CATCH_EXCEPTION( false,
@@ -195,10 +187,10 @@
             )
         }
 
-        bool CreateThumbnail    ( int   Id, bool Recreate )
+        bool CreateThumbnail    ( int   Id )
         {
             SCRIPT_CATCH_EXCEPTION( false,
-                return m_obj.CreateThumbnail( Id, Recreate );
+                return m_obj.CreateThumbnail( Id );
             )
         }
 };
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerycommhelper.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerycommhelper.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerycommhelper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerycommhelper.cpp	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,358 @@
+#include "gallerycommhelper.h"
+
+#include <unistd.h> // for usleep
+
+#include <QApplication>
+
+#include <mythsystemlegacy.h>
+#include <remotefile.h>
+
+
+/*!
+ * \brief Request BE to start/stop synchronising the image db to the storage group
+ * \param start Start scan, if true. Otherwise stop scan
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::ScanImagesAction(bool start)
+{
+    QStringList strList;
+    strList << "IMAGE_SCAN" << (start ? "START" : "STOP");
+
+    bool ok = gCoreContext->SendReceiveStringList(strList, true);
+    return ok ? "" : strList[1];
+}
+
+
+/*!
+ * \brief Returns BE scan status
+ * \return QStringList State ("ERROR" | "OK"), Mode ("SCANNING" | ""),
+ * Progress count, Total
+ */
+QStringList GalleryBERequest::ScanQuery()
+{
+    QStringList strList;
+    strList << "IMAGE_SCAN" << "QUERY";
+
+    if (!gCoreContext->SendReceiveStringList(strList))
+    {
+        LOG(VB_GENERAL, LOG_ERR, QString("Image: Scan query failed : %1")
+            .arg(strList.join(",")));
+
+        // Default to no scan
+        strList.clear();
+        strList << "ERROR" << "" << "0" << "0";
+    }
+    return strList;
+}
+
+
+/*!
+ * \brief Request BE to clear image db
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::ClearDatabase()
+{
+    QStringList strList;
+    strList << "IMAGE_SCAN" << "CLEAR";
+
+    bool ok = gCoreContext->SendReceiveStringList(strList, true);
+    return ok ? "" : strList[1];
+}
+
+
+/*!
+ * \brief Request BE to create thumbnails for images
+ * \param ids List of image ids
+ * \param isForFolder Set if images are for a directory cover, which are generated
+ * after images
+ */
+void GalleryBERequest::CreateThumbnails(QStringList ids, bool isForFolder)
+{
+    LOG(VB_FILE, LOG_DEBUG, QString("Image: Sending CREATE_THUMBNAILS %1 (forFolder %2)")
+        .arg(ids.join(",")).arg(isForFolder));
+
+    QStringList message;
+    message << ids.join(",") << QString::number(isForFolder);
+    gCoreContext->SendEvent(MythEvent("CREATE_THUMBNAILS", message));
+}
+
+
+/*!
+ * \brief Request BE to hide/unhide images
+ * \param hidden Hide | unhide
+ * \param ids List of image ids
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::HideFiles(bool hidden, ImageIdList ids)
+{
+    if (ids.isEmpty())
+        return "Bad Hide Request";
+
+    QStringList idents;
+    foreach (int id, ids)
+    {
+        idents.append(QString::number(id));
+    }
+
+    QStringList message;
+    message << "IMAGE_HIDE" << QString::number(hidden) << idents.join(",");
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Request BE to rename an image
+ * \param  id An image id
+ * \param  name New name of the file (only the filename, no path)
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::RenameFile(int id, QString name)
+{
+    QStringList message;
+    message << "IMAGE_RENAME" << QString::number(id) << name;
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Request BE to delete images
+ * \param  ids List of image ids
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::RemoveFiles(ImageIdList ids)
+{
+    QStringList idents;
+    foreach (int id, ids)
+    {
+        idents.append(QString::number(id));
+    }
+
+    QStringList message;
+    message << "IMAGE_DELETE" << idents.join(",");
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Request BE to apply an orientation transform to images
+ * \param  transform Transformation to apply
+ * \param  ids List of image ids
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::ChangeOrientation(ImageFileTransform transform,
+                                            ImageIdList ids)
+{
+    QStringList idents;
+    foreach (int id, ids)
+    {
+        idents.append(QString::number(id));
+    }
+
+    QStringList message;
+    message << "IMAGE_TRANSFORM"
+         << QString::number(transform)
+         << idents.join(",");
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Request BE to set image to use as a cover thumbnail(s)
+ * \param  parent Directory id
+ * \param  to Image to use as cover
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::SetCover(int parent, int to)
+{
+    QStringList message;
+    message << "IMAGE_COVER"
+         << QString::number(parent)
+         << QString::number(to);
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Returns all exif tags and values from an image
+ * \param  im An image
+ * \return QString Error message, if not empty
+ */
+NameMap GalleryBERequest::GetMetaData(const ImageItem *im)
+{
+    QMap<QString, QString> tags;
+    QStringList            strlist;
+    strlist << "IMAGE_GET_METADATA"
+            << QString::number(im->m_id);
+
+    if (gCoreContext->SendReceiveStringList(strlist))
+    {
+        // Each string contains a Label<seperator>Value
+        QString seperator = strlist[1];
+        for (int i = 2; i < strlist.size(); ++i)
+        {
+            QStringList parts = strlist[i].split(seperator);
+
+            LOG(VB_FILE, LOG_DEBUG,
+                QString("Image: Metadata %1 : %2").arg(parts[0], parts[1]));
+
+            tags.insert(parts[0], parts[1]);
+        }
+    }
+    return tags;
+}
+
+
+/*!
+ * \brief Moves images to an image directory
+ * \param destination Id of an image directory
+ * \param ids Ids of images/dirs to move
+ * \return QString Error message
+ */
+QString GalleryBERequest::MoveFiles(int destination, ImageIdList ids)
+{
+    QStringList idents;
+    foreach (int id, ids)
+    {
+        idents.append(QString::number(id));
+    }
+
+    QStringList message("IMAGE_MOVE");
+    message << QString::number(destination) << idents.join(",");
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+/*!
+ * \brief Create directories
+ * \param names List of directory paths
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::MakeDirs(QStringList names)
+{
+    names.insert(0, "IMAGE_CREATE_DIRS");
+
+    bool ok = gCoreContext->SendReceiveStringList(names, true);
+    return ok ? "" : names[1];
+}
+
+
+/*!
+ * \brief Set directories to ignore during scan & rescan
+ * \param excludes Comma separated list of dir names/patterns to exclude. Glob
+ * characters * and ? permitted.
+ * \return QString Error message, if not empty
+ */
+QString GalleryBERequest::IgnoreDirs(QString excludes)
+{
+    QStringList message("IMAGE_IGNORE");
+    message << excludes;
+
+    bool ok = gCoreContext->SendReceiveStringList(message, true);
+    return ok ? "" : message[1];
+}
+
+
+int RunWorker(WorkerThread *worker)
+{
+    worker->start();
+
+    // Wait for worker to complete
+    while (!worker->isFinished())
+    {
+        usleep(1000);
+        qApp->processEvents();
+    }
+
+    int result = worker->GetResult();
+    delete worker;
+
+    return result;
+}
+
+
+void ShellWorker::run()
+{
+    RunProlog();
+    LOG(VB_GENERAL, LOG_INFO, QString("Image: Executing \"%1\"").arg(m_command));
+    m_result = myth_system(m_command);
+    RunEpilog();
+}
+
+
+/*!
+ * \brief Thread worker to copy/move files
+ * \param deleteAfter Remove original file after copy, if set
+ * \param files Map of source/destination filepaths
+ * \param dialog Dialog that reflects progress
+ */
+FileTransferWorker::FileTransferWorker(bool deleteAfter, NameMap files,
+                                       MythUIProgressDialog *dialog)
+    : WorkerThread("FileTransfer"),
+    m_delete(deleteAfter),
+    m_files(files),
+    m_dialog(dialog)
+{
+}
+
+
+void FileTransferWorker::run()
+{
+    RunProlog();
+
+    uint total    = m_files.size();
+    uint progress = 0;
+    m_result = 0;
+    QString action = m_delete ? tr("Moving %1") : tr("Copying %1");
+
+    foreach (const QString &src, m_files.keys())
+    {
+        // Update progress dialog
+        if (m_dialog)
+        {
+            QFileInfo            fi(src);
+            int size = fi.size() / 1024;
+            QString message = action.arg(fi.fileName())
+                    + (size > 0 ? QString(" (%2 Kb)").arg(size) : "");
+            ProgressUpdateEvent *pue     =
+                new ProgressUpdateEvent(++progress, total, message);
+
+            QApplication::postEvent(m_dialog, pue);
+        }
+
+        LOG(VB_FILE, LOG_INFO, action.arg(src) + QString(" -> %1").arg(m_files[src]));
+
+        // Copy file
+        if (RemoteFile::CopyFile(src, m_files[src]))
+        {
+            ++m_result;
+            if (m_delete)
+            {
+                // Delete source file
+                QFile file(src);
+                if (!file.remove())
+                    LOG(VB_FILE, LOG_ERR, QString("Image: Failed to delete %1")
+                        .arg(src));
+            }
+        }
+        else
+            LOG(VB_FILE, LOG_ERR, QString("Image: Failed to copy %1 to %2")
+                .arg(src, m_files[src]));
+    }
+
+    if (m_dialog)
+        m_dialog->Close();
+
+    RunEpilog();
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerycommhelper.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerycommhelper.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerycommhelper.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerycommhelper.h	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,85 @@
+//! \file
+//! \brief Encapsulates BE requests that originate from FE or services client
+
+#ifndef GALLERYCOMMHELPER_H
+#define GALLERYCOMMHELPER_H
+
+#include <QMap>
+#include <QStringList>
+#include <QString>
+
+#include <mthread.h>
+#include <imagemetadata.h>
+#include <imageutils.h>
+#include <mythprogressdialog.h>
+
+
+typedef QMap<QString, QString> NameMap;
+
+//! BE Requests
+class GalleryBERequest
+{
+public:
+    static QString     ScanImagesAction(bool);
+    static QStringList ScanQuery();
+    static void        CreateThumbnails(QStringList, bool);
+    static QString     HideFiles(bool, ImageIdList);
+    static QString     RemoveFiles(ImageIdList);
+    static QString     RenameFile(int, QString);
+    static QString     ChangeOrientation(ImageFileTransform transform,
+                                         ImageIdList);
+    static QString     ClearDatabase();
+    static QString     SetCover(int, int);
+    static NameMap     GetMetaData(const ImageItem *);
+    static QString     MoveFiles(int, ImageIdList);
+    static QString     MakeDirs(QStringList);
+    static QString     IgnoreDirs(QString);
+};
+
+
+//! Base thread returning a result
+class WorkerThread: public MThread
+{
+public:
+    WorkerThread(QString name) : MThread(name) {}
+    int GetResult(void) { return m_result; }
+protected:
+    int m_result;
+};
+
+
+//! Worker thread for running commands
+class ShellWorker: public WorkerThread
+{
+public:
+    ShellWorker(QString cmd) : WorkerThread("import"), m_command(cmd) {}
+    virtual void run();
+private:
+    QString m_command;
+};
+
+
+//! Worker thread for copying/moving files
+class FileTransferWorker : public WorkerThread
+{
+    Q_DECLARE_TR_FUNCTIONS(FileTransferWorker)
+public:
+    FileTransferWorker(bool, NameMap, MythUIProgressDialog *);
+    virtual void run();
+
+private:
+    //! Whether to delete files after they have been copied
+    bool m_delete;
+
+    //! Maps source filepath to destination filepath
+    NameMap m_files;
+
+    //! Progress dialog for transfer
+    MythUIProgressDialog *m_dialog;
+};
+
+
+int RunWorker(WorkerThread *);
+
+
+#endif // GALLERYCOMMHELPER_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryconfig.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryconfig.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryconfig.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryconfig.cpp	2015-04-30 11:17:45.422226492 +0200
@@ -1,274 +1,196 @@
-
 #include "galleryconfig.h"
 
-// Qt headers
-
-// MythTV headers
-#include "mythcontext.h"
-#include "mythmainwindow.h"
-#include "mythuitextedit.h"
-#include "mythuicheckbox.h"
-#include "mythuibutton.h"
-#include "mythuibuttonlist.h"
-#include "mythuispinbox.h"
-#include "mythdialogbox.h"
-#include "mythscreentype.h"
-
-#include "gallerydatabasehelper.h"
-#include "gallerytypedefs.h"
-
-
-
-/** \fn     GalleryConfig::GalleryConfig(MythScreenStack *, const char *)
- *  \brief  Constructor
- *  \param  parent The screen parent
- *  \param  name The name of the screen
- *  \return void
- */
-GalleryConfig::GalleryConfig(MythScreenStack *parent, const char *name)
-    : MythScreenType(parent, name),
-      m_sortOrder(NULL),
-      m_slideShowTime(NULL),
-      m_transitionType(NULL),
-      m_transitionTime(NULL),
-      m_showHiddenFiles(NULL),
-      m_saveButton(NULL),
-      m_cancelButton(NULL),
-      m_clearDbButton(NULL)
-{
-    // preset or load all variables
-    m_sortOrder = 0;
-}
-
-
-
-/** \fn     GalleryConfig::~GalleryConfig()
- *  \brief  Destructor
- *  \return void
- */
-GalleryConfig::~GalleryConfig()
-{
-
-}
-
+#include "gallerytransitions.h"
 
 
-/** \fn     GalleryConfig::Create()
- *  \brief  Initialises and shows the graphical elements
- *  \return void
- */
-bool GalleryConfig::Create()
+/*!
+ \brief Settings for Thumbnail view
+*/
+class ThumbSettings : public VerticalConfigurationGroup
 {
-    // Load the theme for this screen
-    if (!LoadWindowFromXML("image-ui.xml", "galleryconfig", this))
-        return false;
-
-    bool err = false;
-    UIUtilE::Assign(this, m_sortOrder, "sortorder", &err);
-    UIUtilE::Assign(this, m_slideShowTime, "slideshowtime", &err);
-    UIUtilE::Assign(this, m_transitionType, "transitiontype", &err);
-    UIUtilE::Assign(this, m_transitionTime, "transitiontime", &err);
-    UIUtilE::Assign(this, m_showHiddenFiles, "showhiddenfiles", &err);
-
-    UIUtilE::Assign(this, m_saveButton, "save", &err);
-    UIUtilE::Assign(this, m_cancelButton, "cancel", &err);
-    UIUtilW::Assign(this, m_clearDbButton, "cleardatabase", &err);
-
-    // check if all widgets are present
-    if (err)
+public:
+    ThumbSettings() : VerticalConfigurationGroup()
     {
-        LOG(VB_GENERAL, LOG_ERR, "Theme is missing critical theme elements.");
-        return false;
-    }
-
-    // Load the values from the database
-    Load();
-
-    // connect the widgets to their methods
-    connect(m_saveButton, SIGNAL(Clicked()), this, SLOT(Save()));
-    connect(m_cancelButton, SIGNAL(Clicked()), this, SLOT(Exit()));
-
-    if (m_clearDbButton)
-        connect(m_clearDbButton, SIGNAL(Clicked()), this, SLOT(ConfirmClearDatabase()));
-
-    BuildFocusList();
-
-    SetFocusWidget(m_sortOrder);
-
-    return true;
-}
-
-
-
-/** \fn     GalleryConfig::keyPressEvent(QKeyEvent *)
- *  \brief  Translates the keypresses and keys bound to the
- *          plugin to specific actions within the plugin
- *  \param  event The pressed key
- *  \return bool True if the key was used, otherwise false
- */
-bool GalleryConfig::keyPressEvent(QKeyEvent *event)
-{
-    if (GetFocusWidget()->keyPressEvent(event))
-        return true;
-
-    bool handled = false;
-
-    if (!handled && MythScreenType::keyPressEvent(event))
-        handled = true;
-
-    return handled;
-}
+        setLabel(tr("Thumbnails"));
 
+        HostComboBox *order = new HostComboBox("GallerySortOrder");
+        order->setLabel(tr("Image Order"));
+        order->setHelpText(tr("The order that images are shown in thumbnail view "
+                              "and (ordered) slideshows."));
+        order->addSelection(tr("Filename (A-Z)"), QString::number(kSortByNameAsc));
+        order->addSelection(tr("Reverse Filename (Z-A)"), QString::number(kSortByNameDesc));
+        order->addSelection(tr("Exif Date (oldest first)"), QString::number(kSortByDateAsc));
+        order->addSelection(tr("Reverse Exif Date (newest first)"), QString::number(kSortByDateDesc));
+        order->addSelection(tr("File Modified Time (oldest first)"), QString::number(kSortByModTimeAsc));
+        order->addSelection(tr("Reverse File Modified Time (newest first)"), QString::number(kSortByModTimeDesc));
+        order->addSelection(tr("File Extension (A-Z)"), QString::number(kSortByExtAsc));
+        order->addSelection(tr("Reverse File Extension (Z-A)"), QString::number(kSortByExtDesc));
+        order->addSelection(tr("File Size (smallest first)"), QString::number(kSortBySizeAsc));
+        order->addSelection(tr("Reverse File Size (largest first)"), QString::number(kSortBySizeDesc));
+        addChild(order);
+    }
+};
 
 
-/** \fn     GalleryView::customEvent(QEvent *)
- *  \brief  Translates the keypresses to specific actions within the plugin
- *  \param  event The custom event
- *  \return void
- */
-void GalleryConfig::customEvent(QEvent *event)
+/*!
+ \brief Settings for Slideshow view
+*/
+class SlideSettings : public VerticalConfigurationGroup
 {
-    if (event->type() == DialogCompletionEvent::kEventType)
+public:
+    SlideSettings() : VerticalConfigurationGroup()
     {
-        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
-
-        QString resultid  = dce->GetId();
-        int     buttonnum = dce->GetResult();
+        setLabel(tr("Slideshow"));
 
-        // Confirm current file deletion
-        if (resultid == "confirmdelete")
+        HostComboBox *tranBox = new HostComboBox("GalleryTransitionType");
+        tranBox->setLabel(tr("Transition"));
+        tranBox->setHelpText(tr("Effect to use between slides"));
+
+        // Initialise selected transition
+        TransitionRegistry availableTransitions(GetMythPainter()->SupportsAnimation());
+        TransitionMap transitions = availableTransitions.GetAll();
+        QMapIterator<int, Transition*> i(transitions);
+        while (i.hasNext())
         {
-            switch (buttonnum)
-            {
-            case 0 :
-                break;
-            case 1 :
-                ClearDatabase();
-                break;
-            }
+            i.next();
+            tranBox->addSelection(i.value()->GetName(), QString::number(i.key()));
         }
-    }
-}
-
-
-
-/** \fn     GalleryConfig::Load()
- *  \brief  Load the values from the database and adds them to the widgets
- *  \return void
- */
-void GalleryConfig::Load()
-{
-    new MythUIButtonListItem(m_sortOrder, tr("Name (A-Z alpha)"),
-                             qVariantFromValue(QString::number(kSortByNameAsc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Reverse Name (Z-A alpha)"),
-                             qVariantFromValue(QString::number(kSortByNameDesc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Mod Time (oldest first)"),
-                             qVariantFromValue(QString::number(kSortByModTimeAsc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Reverse Mod Time (newest first)"),
-                             qVariantFromValue(QString::number(kSortByModTimeDesc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Extension (A-Z alpha)"),
-                             qVariantFromValue(QString::number(kSortByExtAsc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Reverse Extension (Z-A alpha)"),
-                             qVariantFromValue(QString::number(kSortByExtDesc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Filesize (smallest first)"),
-                             qVariantFromValue(QString::number(kSortBySizeAsc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Reverse Filesize (largest first)"),
-                             qVariantFromValue(QString::number(kSortBySizeDesc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Date (oldest first)"),
-                             qVariantFromValue(QString::number(kSortByDateAsc)));
-    new MythUIButtonListItem(m_sortOrder, tr("Reverse Date (neweset first)"),
-                             qVariantFromValue(QString::number(kSortByDateDesc)));
-    m_sortOrder->SetValueByData(gCoreContext->GetNumSetting("GallerySortOrder", kSortByDateAsc));
-
-    m_slideShowTime->SetRange(0, 30000, 500);
-    m_slideShowTime->SetValue(gCoreContext->GetSetting("GallerySlideShowTime", "3000"));
-
-    new MythUIButtonListItem(m_transitionType, tr("None"), qVariantFromValue(0));
-    new MythUIButtonListItem(m_transitionType, tr("Fade"), qVariantFromValue(1));
-    m_transitionType->SetValueByData(gCoreContext->GetNumSetting("GalleryTransitionType", kFade));
-
-    m_transitionTime->SetRange(0, 5000, 100);
-    m_transitionTime->SetValue(gCoreContext->GetSetting("GalleryTransitionTime", "1000"));
-
-    int setting = gCoreContext->GetNumSetting("GalleryShowHiddenFiles", 0);
-    if (setting == 1)
-        m_showHiddenFiles->SetCheckState(MythUIStateType::Full);
-}
+        addChild(tranBox);
 
+        HostSpinBox *slide = new HostSpinBox("GallerySlideShowTime", 100, 60000, 100);
+        slide->setLabel(tr("Slide Duration (ms)"));
+        slide->setHelpText(tr("The time that a slide is displayed (between transitions), "
+                              "in milliseconds."));
+        addChild(slide);
+
+        HostSpinBox *transition = new HostSpinBox("GalleryTransitionTime", 100, 60000, 100);
+        transition->setLabel(tr("Transition Duration (ms)"));
+        transition->setHelpText(tr("The time that each transition lasts, in milliseconds."));
+        addChild(transition);
+    }
+};
 
 
-/** \fn     GalleryConfig::Save()
- *  \brief  Saves the values from the widgets into the database
- *  \return void
- */
-void GalleryConfig::Save()
+/*!
+ \brief Settings Page 1
+*/
+GallerySettings::GallerySettings() : VerticalConfigurationGroup(false)
 {
-    gCoreContext->SaveSetting("GallerySortOrder",
-                              m_sortOrder->GetDataValue().toString());
-    gCoreContext->SaveSetting("GallerySlideShowTime",
-                              m_slideShowTime->GetValue());
-    gCoreContext->SaveSetting("GalleryTransitionType",
-                              m_transitionType->GetDataValue().toString());
-    gCoreContext->SaveSetting("GalleryTransitionTime",
-                              m_transitionTime->GetValue());
-
-    int checkstate = (m_showHiddenFiles->GetCheckState() == MythUIStateType::Full) ? 1 : 0;
-    gCoreContext->SaveSetting("GalleryShowHiddenFiles", checkstate);
-
-    // tell the main view to reload the images
-    // because the storage group dir might have changed
-    emit configSaved();
-
-    Close();
-}
-
-
+    setLabel(tr("Gallery Settings"));
 
-/** \fn     GalleryConfig::Exit()
- *  \brief  Exits the configuration screen
- *  \return void
- */
-void GalleryConfig::Exit()
-{
-    Close();
+    addChild(new ThumbSettings());
+    addChild(new SlideSettings());
 }
 
 
-
-/** \fn     GalleryConfig::ConfirmClearDatabase()
- *  \brief  Asks the user to confirm the removal of
- *          all image related contents from the database
- *  \return void
- */
-void GalleryConfig::ConfirmClearDatabase()
+class ImportSettings : public VerticalConfigurationGroup
 {
-    QString msg = QString("Do you want to clear all database contents?");
-    MythScreenStack         *m_popupStack = GetMythMainWindow()->GetStack("popup stack");
-    MythConfirmationDialog  *m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
-
-    if (m_confirmPopup->Create())
+public:
+    /*!
+     \brief Settings for Importing
+     \param enable True if password has been entered
+    */
+    ImportSettings(bool enable) : VerticalConfigurationGroup()
     {
-        m_confirmPopup->SetReturnEvent(this, "confirmdelete");
-        m_popupStack->AddScreen(m_confirmPopup);
+        setLabel(tr("Import"));
+        setEnabled(enable);
+
+        HostLineEdit *import = new HostLineEdit("GalleryImportLocation", true);
+        import->setLabel(tr("Import Path"));
+        import->setHelpText(tr("The path where the Import dialog usually starts."));
+        import->setEnabled(enable);
+        addChild(import);
+
+        TriggeredConfigurationGroup *group = new TriggeredConfigurationGroup(false, false);
+        group->SetVertical(false);
+        addChild(group);
+
+        HostCheckBox *useScript = new HostCheckBox("GalleryUseImportCmd");
+        useScript->setLabel(tr("Use Import Command"));
+        useScript->setHelpText(tr("Defines a command/script to aid importing. "
+                                  "Useful if a camera doesn't provide a mountable filesystem "
+                                  "and you need an alternative way of transferring images."));
+        useScript->setEnabled(enable);
+        group->addChild(useScript);
+
+        HostLineEdit *script = new HostLineEdit("GalleryImportCmd", true);
+        script->setLabel(tr(""));
+        script->setHelpText(tr("Command/script that can be run from the menu. "
+                               "%DIR% will be replaced by the Import Path."
+                               "\n%TMPDIR% will be replaced by a new temporary directory, "
+                               "which the import dialog will show automatically. The "
+                               "directory will be removed when Gallery exits."));
+
+        script->setEnabled(enable);
+        group->setTrigger(useScript);
+        group->addTarget("0", new HorizontalConfigurationGroup(false, false));
+        group->addTarget("1", script);
     }
-    else
-        delete m_confirmPopup;
-}
+};
 
 
 
-/** \fn     GalleryConfig::ClearDatabase()
- *  \brief  Clears all image related contents from the database
- *  \return void
- */
-void GalleryConfig::ClearDatabase()
-{
-    GalleryDatabaseHelper *m_dbHelper = new GalleryDatabaseHelper();
-    m_dbHelper->ClearDatabase();
-    delete m_dbHelper;
-
-    // tell the main view to reload the images
-    // because the storage group dir might have changed
-    emit configSaved();
-    Close();
+/*!
+ \brief Settings Page 2
+ \param enable True if password has been entered
+*/
+DatabaseSettings::DatabaseSettings(bool enable)
+    : VerticalConfigurationGroup(false)
+{
+    setLabel(tr("Database Settings") + (enable ? "" : tr(" (Requires edit privileges)")));
+
+    addChild(new ImportSettings(enable));
+
+    // Exclusions - Use stacked to preserve spacing
+    StackedConfigurationGroup *group1 = new StackedConfigurationGroup(false, false);
+    addChild(group1);
+
+    GlobalLineEdit *exclusions = new GlobalLineEdit("GalleryIgnoreFilter");
+    exclusions->setLabel(tr("Scanner Exclusions"));
+    exclusions->setHelpText(tr("Comma-separated list of filenames/directory names "
+                               "to be ignored when scanning. "
+                               "Glob wildcards * and ? are valid."));
+    exclusions->setEnabled(enable);
+    group1->addChild(exclusions);
+
+    // Password - Use stacked to preserve spacing
+    StackedConfigurationGroup *group2 = new StackedConfigurationGroup(false, false);
+    addChild(group2);
+
+    HostLineEdit *password = new HostLineEdit("GalleryPassword");
+    password->setLabel(tr("Password"));
+    password->SetPasswordEcho(true);
+    password->setHelpText(tr("If set then all actions that modify the filesystem or "
+                             "database are password-protected (copy, move, import, "
+                             "transform, hiding, set covers). Protection is disabled "
+                             "by an empty password.\nPrivileges persist until "
+                             "Gallery exits to main menu."));
+    password->setEnabled(enable);
+    group2->addChild(password);
+
+    // Clear Db
+    TriggeredConfigurationGroup *group3 = new TriggeredConfigurationGroup(false, false);
+    group3->SetVertical(false);
+    addChild(group3);
+
+    TransCheckBoxSetting *clear = new TransCheckBoxSetting();
+    clear->setLabel(tr("Reset Image Database"));
+    clear->setHelpText(tr("Clears the Image Database and all thumbnails. A rescan "
+                          "will be required."));
+    clear->setEnabled(enable);
+    group3->addChild(clear);
+
+    HorizontalConfigurationGroup *clrSub =new HorizontalConfigurationGroup(false, false);
+
+    TransButtonSetting *confirm = new TransButtonSetting("clearDb");
+    confirm->setLabel(tr("Clear Now!"));
+    confirm->setHelpText(tr("Warning! This will erase settings for: hidden images, "
+                            "directory covers and modified orientations. "
+                            "You will have to set them again after re-scanning."));
+    connect(confirm, SIGNAL(pressed()), this, SLOT(ClearDb()));
+    clrSub->addChild(confirm);
+
+    group3->setTrigger(clear);
+    group3->addTarget("0", new HorizontalConfigurationGroup(false, false));
+    group3->addTarget("1", clrSub);
 }
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryconfig.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryconfig.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryconfig.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryconfig.h	2015-04-30 11:17:45.422226492 +0200
@@ -1,44 +1,45 @@
+//! \file
+//! \brief Provides Gallery configuration screens
+//!
+
 #ifndef GALLERYCONFIG_H
 #define GALLERYCONFIG_H
 
-// Qt headers
+#include <mythconfigdialogs.h>
+#include <mythconfiggroups.h>
+#include "gallerycommhelper.h"
 
-// MythTV headers
-#include "mythscreentype.h"
 
+//! Settings page 1
+class GallerySettings : public VerticalConfigurationGroup
+{
+public:
+    GallerySettings();
+};
 
 
-class GalleryConfig : public MythScreenType
+//! Settings page 2
+class DatabaseSettings : public VerticalConfigurationGroup
 {
     Q_OBJECT
 public:
-    GalleryConfig(MythScreenStack *parent, const char *name);
-    ~GalleryConfig();
-
-    bool Create();
-    bool keyPressEvent(QKeyEvent *);
-    void customEvent(QEvent*);
-
-signals:
-    void configSaved();
-
-private:
-    MythUIButtonList   *m_sortOrder;
-    MythUISpinBox      *m_slideShowTime;
-    MythUIButtonList   *m_transitionType;
-    MythUISpinBox      *m_transitionTime;
-    MythUICheckBox     *m_showHiddenFiles;
-
-    MythUIButton       *m_saveButton;
-    MythUIButton       *m_cancelButton;
-    MythUIButton       *m_clearDbButton;
+    DatabaseSettings(bool enable);
 
 private slots:
-    void Save();
-    void Exit();
-    void Load();
-    void ConfirmClearDatabase();
-    void ClearDatabase();
+    void ClearDb()    { GalleryBERequest::ClearDatabase(); }
 };
 
+
+//! Gallery Settings pages
+class GalleryConfig : public ConfigurationWizard
+{
+public:
+    GalleryConfig(bool editMode)
+    {
+        addChild(new GallerySettings());
+        addChild(new DatabaseSettings(editMode));
+    }
+};
+
+
 #endif // GALLERYCONFIG_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,483 +0,0 @@
-// Qt headers
-#include <QDir>
-
-// MythTV headers
-#include "mythcontext.h"
-#include "gallerydatabasehelper.h"
-
-
-GalleryDatabaseHelper::GalleryDatabaseHelper()
-{
-}
-
-
-GalleryDatabaseHelper::~GalleryDatabaseHelper()
-{
-}
-
-
-/** \fn     GalleryDatabaseHelper::LoadParentDirectory(QList<ImageMetadata *>* , int)
- *  \brief  Loads the information from the database for a given directory
- *  \param  dbList The list where the results are stored
- *  \param  parentId The id of the given directory
- *  \return void
- */
-void GalleryDatabaseHelper::LoadParentDirectory(QList<ImageMetadata *>* dbList, int parentId)
-{
-    dbList->clear();
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("SELECT "
-                  "dir_id, filename, name, path, parent_id, "
-                  "dir_count, file_count, "
-                  "hidden "
-                  "FROM gallery_directories "
-                  "WHERE dir_id = :PARENTID;");
-    query.bindValue(":PARENTID", parentId);
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    while (query.next())
-    {
-        ImageMetadata *im = new ImageMetadata();
-        LoadDirectoryValues(query, im);
-
-        // Overwrite the folder type
-        im->m_type = kUpDirectory;
-        dbList->append(im);
-    }
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::LoadDirectories(QList<ImageMetadata *>* , int)
- *  \brief  Loads all subdirectory information from the database for a given directory
- *  \param  dbList The list where the results are stored
- *  \param  parentId The id of the given directory
- *  \return void
- */
-void GalleryDatabaseHelper::LoadDirectories(QList<ImageMetadata *>* dbList, int parentId)
-{
-    dbList->clear();
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("SELECT "
-                        "dir_id, filename, name, path, parent_id, "
-                        "dir_count, file_count, "
-                        "hidden "
-                        "FROM gallery_directories "
-                        "WHERE (parent_id = :PARENTID) "
-                        "AND (hidden = '0' OR hidden = :HIDDEN) "
-                        "ORDER BY name ASC;");
-    query.bindValue(":PARENTID", parentId);
-    query.bindValue(":HIDDEN", gCoreContext->GetNumSetting("GalleryShowHiddenFiles"));
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    while (query.next())
-    {
-        ImageMetadata *im = new ImageMetadata();
-        LoadDirectoryValues(query, im);
-        dbList->append(im);
-    }
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::LoadFiles(QList<ImageMetadata *>* , int)
- *  \brief  Loads all file information from the database for a given directory
- *  \param  dbList The list where the results are stored
- *  \param  parentId The id of the given directory
- *  \return void
- */
-void GalleryDatabaseHelper::LoadFiles(QList<ImageMetadata *>* dbList, int parentId)
-{
-    dbList->clear();
-
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("SELECT "
-                    "file_id, CONCAT_WS('/', path, filename), name, path, dir_id, "
-                    "type, modtime, size, extension, "
-                    "angle, date, zoom, hidden, orientation "
-                    "FROM gallery_files "
-                    "WHERE (dir_id = :PARENTID) "
-                    "AND (hidden = '0' OR hidden = :HIDDEN) "
-                    "ORDER BY :ORDERBY");
-    query.bindValue(":PARENTID", parentId);
-    query.bindValue(":HIDDEN", gCoreContext->GetNumSetting("GalleryShowHiddenFiles"));
-    query.bindValue(":ORDERBY", GetSortOrder());
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    while (query.next())
-    {
-        ImageMetadata *im = new ImageMetadata();
-        LoadFileValues(query, im);
-        dbList->append(im);
-    }
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::InsertDirectory(ImageMetadata *)
- *  \brief  Saves information about a given directory in the database
- *  \param  im Information of the directory
- *  \return void
- */
-int GalleryDatabaseHelper::InsertDirectory(ImageMetadata *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("INSERT INTO gallery_directories ("
-                        "filename, name, path, parent_id, "
-                        "dir_count, file_count, "
-                        "hidden "
-                        ") VALUES ("
-                        ":FILENAME, :NAME, :PATH, :PARENT_ID, "
-                        ":DIRCOUNT, :FILECOUNT, "
-                        ":HIDDEN)");
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":PARENT_ID",   im->m_parentId);
-    query.bindValue(":DIRCOUNT" ,   im->m_dirCount);
-    query.bindValue(":FILECOUNT",   im->m_fileCount);
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-
-    if (!query.exec())
-        MythDB::DBError("Error inserting, query: ", query);
-
-    return query.lastInsertId().toInt();
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::InsertFile(ImageMetadata *)
- *  \brief  Saves information about a given file in the database
- *  \param  im Information of the file
- *  \return void
- */
-int GalleryDatabaseHelper::InsertFile(ImageMetadata *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("INSERT INTO gallery_files ("
-                    "filename, name, path, dir_id, "
-                    "type, modtime, size, extension, "
-                    "angle, date, zoom, "
-                    "hidden, orientation "
-                    ") VALUES ("
-                    ":FILENAME, :NAME, :PATH, :DIR_ID, "
-                    ":TYPE, :MODTIME, :SIZE, :EXTENSION, "
-                    ":ANGLE, :DATE, :ZOOM, "
-                    ":HIDDEN, :ORIENT)");
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":DIR_ID",      im->m_parentId);
-    query.bindValue(":TYPE",        im->m_type);
-    query.bindValue(":MODTIME",     im->m_modTime);
-    query.bindValue(":SIZE",        im->m_size);
-    query.bindValue(":EXTENSION",   im->m_extension);
-    query.bindValue(":ANGLE",       im->GetAngle());
-    query.bindValue(":DATE",        im->m_date);
-    query.bindValue(":ZOOM",        im->GetZoom());
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-    query.bindValue(":ORIENT",      im->GetOrientation());
-
-    if (!query.exec())
-        MythDB::DBError("Error inserting, query: ", query);
-
-    return query.lastInsertId().toInt();
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::UpdateDirectory(ImageMetadata *)
- *  \brief  Updates the information about a given directory in the database
- *  \param  im Information of the directory
- *  \return void
- */
-void GalleryDatabaseHelper::UpdateDirectory(ImageMetadata *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("UPDATE gallery_directories SET "
-                    "filename =     :FILENAME, "
-                    "name =         :NAME, "
-                    "path =         :PATH, "
-                    "parent_id =    :PARENT_ID, "
-                    "dir_count =    :DIR_COUNT, "
-                    "file_count =   :FILE_COUNT, "
-                    "hidden =       :HIDDEN "
-                    "WHERE dir_id = :ID;");
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":PARENT_ID",   im->m_parentId);
-    query.bindValue(":DIR_COUNT",   im->m_dirCount);
-    query.bindValue(":FILE_COUNT",  im->m_fileCount);
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-    query.bindValue(":ID",          im->m_id);
-
-    if (!query.exec())
-        MythDB::DBError("Error updating, query: ", query);
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::UpdateFile(ImageMetadata *)
- *  \brief  Updates the information about a given file in the database
- *  \param  im Information of the file
- *  \return void
- */
-void GalleryDatabaseHelper::UpdateFile(ImageMetadata *im)
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("UPDATE gallery_files SET "
-                    "filename       = :FILENAME, "
-                    "name           = :NAME, "
-                    "path           = :PATH, "
-                    "dir_id         = :DIR_ID, "
-                    "type           = :TYPE, "
-                    "modtime        = :MODTIME, "
-                    "size           = :SIZE, "
-                    "extension      = :EXTENSION, "
-                    "angle          = :ANGLE, "
-                    "date           = :DATE, "
-                    "zoom           = :ZOOM, "
-                    "hidden         = :HIDDEN, "
-                    "orientation    = :ORIENT "
-                    "WHERE file_id  = :ID;");
-    query.bindValue(":FILENAME",    im->m_fileName);
-    query.bindValue(":NAME",        im->m_name);
-    query.bindValue(":PATH",        im->m_path);
-    query.bindValue(":DIR_ID",      im->m_parentId);
-    query.bindValue(":TYPE",        im->m_type);
-    query.bindValue(":MODTIME",     im->m_modTime);
-    query.bindValue(":SIZE",        im->m_size);
-    query.bindValue(":EXTENSION",   im->m_extension);
-    query.bindValue(":ANGLE",       im->GetAngle());
-    query.bindValue(":DATE",        im->m_date);
-    query.bindValue(":ZOOM",        im->GetZoom());
-    query.bindValue(":HIDDEN",      im->m_isHidden);
-    query.bindValue(":ORIENT",      im->GetOrientation());
-    query.bindValue(":ID",          im->m_id);
-
-    if (!query.exec())
-        MythDB::DBError("Error updating, query: ", query);
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::UpdateData(ImageMetadata *)
- *  \brief  Updates either a directory or a file in the database
- *  \param  im Information of the given item
- *  \return void
- */
-void GalleryDatabaseHelper::UpdateData(ImageMetadata *im)
-{
-    if (!im)
-        return;
-
-    if (im->m_type == kSubDirectory || im->m_type == kUpDirectory)
-        UpdateDirectory(im);
-
-    if (im->m_type == kImageFile || im->m_type == kVideoFile)
-        UpdateFile(im);
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::LoadDirectoryValues(MSqlQuery &, ImageMetadata *)
- *  \brief  Loads the directory information from the database
- *  \param  query Information from the database
- *  \param  im Holds the loaded information
- *  \return void
- */
-void GalleryDatabaseHelper::LoadDirectoryValues(MSqlQuery &query, ImageMetadata *im)
-{
-    im->m_id            = query.value(0).toInt();
-    im->m_name          = query.value(2).toString();
-    im->m_path          = query.value(3).toString();
-    im->m_fileName      = QDir::cleanPath(QDir(im->m_path).filePath(im->m_name));
-    im->m_parentId      = query.value(4).toInt();
-    im->m_dirCount      = query.value(5).toInt();
-    im->m_fileCount     = query.value(6).toInt();
-    im->m_isHidden      = query.value(7).toInt();
-
-    // preset all directories as subfolders
-    im->m_type          = kSubDirectory;
-
-    LoadDirectoryThumbnailValues(im);
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::LoadFileValues(MSqlQuery &, ImageMetadata *)
- *  \brief  Loads the file information from the database
- *  \param  query Information from the database
- *  \param  im Holds the loaded information
- *  \return void
- */
-void GalleryDatabaseHelper::LoadFileValues(MSqlQuery &query, ImageMetadata *im)
-{
-    im->m_id            = query.value(0).toInt();
-    im->m_name          = query.value(2).toString();
-    im->m_path          = query.value(3).toString();
-    im->m_fileName      = QDir::cleanPath(QDir(im->m_path).filePath(im->m_name));
-    im->m_parentId      = query.value(4).toInt();
-    im->m_type          = query.value(5).toInt();
-    im->m_modTime       = query.value(6).toInt();
-    im->m_size          = query.value(7).toInt();
-    im->m_extension     = query.value(8).toString();
-    im->SetAngle(         query.value(9).toInt());
-    im->m_date          = query.value(10).toInt();
-    im->SetZoom(          query.value(11).toInt(), true);
-    im->m_isHidden      = query.value(12).toInt();
-    im->SetOrientation(   query.value(13).toInt(), true);
-
-    LoadFileThumbnailValues(im);
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::LoadDirectoryThumbnailValues(ImageMetadata *)
- *  \brief  Gets four images from the directory from the
- *          database which will be used as a folder thumbnail
- *  \param  im Holds the loaded information
- *  \return void
- */
-void GalleryDatabaseHelper::LoadDirectoryThumbnailValues(ImageMetadata *im)
-{
-    // Try to get four new thumbnail filenames
-    // from the available images in this folder
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare("SELECT file_id, CONCAT_WS('/', path, name) "
-                          "FROM gallery_files "
-                          "WHERE path = :PATH "
-                          "AND type = :TYPE "
-                          "AND hidden = '0' LIMIT :LIMIT");
-    query.bindValue(":PATH", im->m_fileName);
-    query.bindValue(":TYPE", kImageFile);
-    query.bindValue(":LIMIT", kMaxFolderThumbnails);
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    int i = 0;
-    im->m_thumbFileIdList.clear();
-    while (query.next() && i < im->m_thumbFileNameList->size())
-    {
-        QString thumbFileName = QString("%1%2")
-                .arg("/MythImage/")
-                .arg(query.value(1).toString());
-
-        thumbFileName = gCoreContext->GenMythURL(gCoreContext->GetMasterHostName(),
-                                                 gCoreContext->GetMasterServerPort(),
-                                                 thumbFileName, "Temp");
-
-        im->m_thumbFileNameList->replace(i, thumbFileName);
-        im->m_thumbFileIdList.append(query.value(0).toInt());
-        ++i;
-    }
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::LoadFileThumbnailValues(ImageMetadata *)
- *  \brief  Sets the thumbnail information for a file
- *  \param  im Holds the loaded information
- *  \return void
- */
-void GalleryDatabaseHelper::LoadFileThumbnailValues(ImageMetadata *im)
-{
-
-    // Create the relative path and filename to the thumbnail image
-    QString thumbFileName = QString("%1%2")
-            .arg("/MythImage/")
-            .arg(im->m_fileName);
-
-    // If the file is a video then append a png, otherwise the preview
-    // image would not be readable due to the video file extension
-    if (im->m_type == kVideoFile)
-        thumbFileName.append(".png");
-
-    thumbFileName = gCoreContext->GenMythURL(gCoreContext->GetMasterHostName(),
-                                             gCoreContext->GetNumSetting("MasterServerPort"),
-                                             thumbFileName, "Temp");
-
-    im->m_thumbFileNameList->replace(0, thumbFileName);
-    im->m_thumbFileIdList.insert(0, im->m_id);
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::GetSortOrder()
- *  \brief  Prepares the SQL query according to the sorting
- *          rules specified by the user in the settings.
- *  \return void
- */
-QString GalleryDatabaseHelper::GetSortOrder()
-{
-    // prepare the sorting statement
-    QString sort;
-    switch (gCoreContext->GetNumSetting("GallerySortOrder"))
-    {
-    case kSortByNameAsc:
-        sort.append("name ASC ");
-        break;
-    case kSortByNameDesc:
-        sort.append("name DESC ");
-        break;
-    case kSortByModTimeAsc:
-        sort.append("modtime ASC, name ASC ");
-        break;
-    case kSortByModTimeDesc:
-        sort.append("modtime DESC, name ASC ");
-        break;
-    case kSortByExtAsc:
-        sort.append("extension ASC, name ASC ");
-        break;
-    case kSortByExtDesc:
-        sort.append("extension DESC, name ASC ");
-        break;
-    case kSortBySizeAsc:
-        sort.append("size ASC, name ASC ");
-        break;
-    case kSortBySizeDesc:
-        sort.append("size DESC, name ASC ");
-        break;
-    case kSortByDateAsc:
-        sort.append("date ASC, name ASC ");
-        break;
-    case kSortByDateDesc:
-        sort.append("date DESC, name ASC ");
-        break;
-    default:
-        sort.append("name ASC ");
-        break;
-    }
-
-    return sort;
-}
-
-
-
-/** \fn     GalleryDatabaseHelper::ClearDatabase()
- *  \brief  Removes all contents from the gallery_directories and gallery_files tables.
- *  \return void
- */
-void GalleryDatabaseHelper::ClearDatabase()
-{
-    MSqlQuery query(MSqlQuery::InitCon());
-    query.prepare(QString("TRUNCATE gallery_directories;"));
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-
-    query.prepare(QString("TRUNCATE gallery_files;"));
-
-    if (!query.exec())
-        LOG(VB_GENERAL, LOG_ERR, MythDB::DBErrorMessage(query.lastError()));
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerydatabasehelper.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerydatabasehelper.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,43 +0,0 @@
-#ifndef GALLERYDATABASEHELPER_H
-#define GALLERYDATABASEHELPER_H
-
-// Qt headers
-
-// MythTV headers
-#include "mythdbcon.h"
-#include "imagemetadata.h"
-
-#include "gallerytypedefs.h"
-
-
-// TODO: Merge this into libmythmetadata/imageutils.h and remove
-class GalleryDatabaseHelper
-{
-public:
-    GalleryDatabaseHelper();
-    ~GalleryDatabaseHelper();
-
-    void LoadParentDirectory(QList<ImageMetadata *>*, int);
-    void LoadDirectories(QList<ImageMetadata *>*, int);
-    void LoadFiles(QList<ImageMetadata *>*, int);
-
-    void UpdateData(ImageMetadata *);
-
-    void ClearDatabase();
-
-private:
-    int InsertDirectory(ImageMetadata *);
-    int InsertFile(ImageMetadata *);
-    void UpdateDirectory(ImageMetadata *);
-    void UpdateFile(ImageMetadata *);
-
-    void LoadDirectoryValues(MSqlQuery &, ImageMetadata *);
-    void LoadFileValues(MSqlQuery &, ImageMetadata *);
-
-    void LoadDirectoryThumbnailValues(ImageMetadata *);
-    void LoadFileThumbnailValues(ImageMetadata *);
-
-    QString GetSortOrder();
-};
-
-#endif // GALLERYDATABASEHELPER_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryfilehelper.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryfilehelper.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryfilehelper.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryfilehelper.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,179 +0,0 @@
-
-#include "galleryfilehelper.h"
-
-// Qt headers
-#include <QString>
-
-// MythTV headers
-#include "mythcontext.h"
-
-
-/** \fn     GalleryFileHelper::GalleryFileHelper()
- *  \brief  Constructor
- *  \return void
- */
-GalleryFileHelper::GalleryFileHelper()
-{
-}
-
-
-/** \fn     GalleryFileHelper::~GalleryFileHelper()
- *  \brief  Destructor
- *  \return void
- */
-GalleryFileHelper::~GalleryFileHelper()
-{
-}
-
-
-/** \fn     GalleryFileHelper::StartSyncImages()
- *  \brief  Starts the image syncronization from the backend
- *  \return void
- */
-void GalleryFileHelper::StartSyncImages()
-{
-    QStringList strList;
-    strList << "IMAGE_SCAN" << "START";
-
-    if (!gCoreContext->SendReceiveStringList(strList))
-
-        LOG(VB_GENERAL, LOG_ERR, "Sync start request failed");
-}
-
-
-/** \fn     GalleryFileHelper::StopSyncImages()
- *  \brief  Stops the image syncronization from the backend
- *  \return void
- */
-void GalleryFileHelper::StopSyncImages()
-{
-    QStringList strList;
-    strList << "IMAGE_SCAN" << "STOP";
-
-    if (!gCoreContext->SendReceiveStringList(strList))
-
-        LOG(VB_GENERAL, LOG_ERR, "Sync stop request failed");
-}
-
-
-/** \fn     GalleryFileHelper::GetSyncStatus()
- *  \brief  Reads the current image syncronization status
- *  \return Struct with bool running, int current image, int total images
- */
-GallerySyncStatus GalleryFileHelper::GetSyncStatus()
-{
-    GallerySyncStatus status;
-    status.running = false;
-    status.current = 0;
-    status.total = 0;
-
-    QStringList strList;
-
-    strList << "IMAGE_GET_SCAN_STATUS";
-    bool ok = gCoreContext->SendReceiveStringList(strList);
-
-    // expect request status, sync-running status, number done, total number
-    if (ok && strList.size() == 4)
-    {
-        status.running = strList[1].toInt(); // convert int to bool
-        status.current = strList[2].toInt();
-        status.total   = strList[3].toInt();
-    }
-
-    return status;
-}
-
-
-void GalleryFileHelper::AddToThumbnailList(ImageMetadata* im, bool recreate)
-{
-    if (!im || im->m_thumbFileIdList.size() == 0)
-        return;
-
-    QStringList message;
-    message << "IMAGE_THUMBNAILS"
-            << QString::number(recreate);
-
-    // folders use multiple thumbnails
-    for (int i = 0; i < im->m_thumbFileIdList.size(); i++)
-
-        message << QString::number(im->m_thumbFileIdList.at(i));
-
-    gCoreContext->SendReceiveStringList(message, true);
-}
-
-
-/** \fn     GalleryFileHelper::RenameFile(const int &, const QString &)
- *  \brief  Renames the file via the service api
- *  \param  im The image metadata object that contains all required information
- *  \param  name The new name of the file (only the filename, no path)
- *  \return True if removal was successful, otherwise false
- */
-bool GalleryFileHelper::RenameFile(ImageMetadata *im, const QString &name)
-{
-    QStringList strlist;
-    strlist << "IMAGE_RENAME"
-            << QString::number(im->m_id)
-            << name;
-
-    return gCoreContext->SendReceiveStringList(strlist, true);
-}
-
-
-/** \fn     GalleryFileHelper::RemoveFile(ImageMetadata *)
- *  \brief  Deletes the file via the service api
- *  \param  im The image metadata object that contains all required information
- *  \return True if removal was successful, otherwise false
- */
-bool GalleryFileHelper::RemoveFile(ImageMetadata *im)
-{
-    QStringList strlist;
-    strlist << "IMAGE_DELETE"
-            << QString::number(im->m_id);
-
-    return gCoreContext->SendReceiveStringList(strlist, true);
-}
-
-
-/** \fn     GalleryFileHelper::SetImageOrientation(ImageMetadata *)
- *  \brief  Saves the given value in the orientation exif tag
- *  \param  im The image metadata object that contains all required information
- *  \return True if saving the orientation was successful, otherwise false
- */
-bool GalleryFileHelper::SetImageOrientation(ImageMetadata *im)
-{
-    QStringList strlist;
-    strlist << "IMAGE_SET_EXIF"
-            << QString::number(im->m_id)
-            << "ORIENTATION"
-            << QString::number(im->GetOrientation());
-
-    return gCoreContext->SendReceiveStringList(strlist, true);
-}
-
-
-/** \fn     GalleryFileHelper::GetExifValues(ImageMetadata *)
- *  \brief  Returns the XML data that contains all available exif header
-            tags and values from the image specified by the id.
- *  \param  im The image metadata object that contains all required information
- *  \return The returned XML data
- */
-QMap<QString, QString> GalleryFileHelper::GetExifValues(ImageMetadata *im)
-{
-    QStringList strlist;
-    strlist << "IMAGE_GET_EXIF"
-            << QString::number(im->m_id);
-
-    QMap<QString, QString> properties;
-
-    if (gCoreContext->SendReceiveStringList(strlist, true))
-    {
-        // Each string contains a Label<seperator>Value
-        QString seperator = strlist[1];
-        for (int i = 2; i < strlist.size(); ++i)
-        {
-            QStringList parts = strlist[i].split(seperator);
-            properties.insert(parts[0], parts[1]);
-        }
-    }
-    return properties;
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryfilehelper.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryfilehelper.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryfilehelper.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryfilehelper.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
-#ifndef GALLERYFILEHELPER_H
-#define GALLERYFILEHELPER_H
-
-// Qt headers
-#include <QNetworkProxy>
-#include <QMap>
-#include <QList>
-
-// MythImage headers
-#include "imagemetadata.h"
-
-struct GallerySyncStatus {
-    bool running;
-    int  current;
-    int  total;
-};
-
-class GalleryFileHelper
-{
-public:
-    GalleryFileHelper();
-    ~GalleryFileHelper();
-
-    void        StartSyncImages();
-    void        StopSyncImages();
-    void        AddToThumbnailList(ImageMetadata *, bool);
-    bool        RemoveFile(ImageMetadata *);
-    bool        RenameFile(ImageMetadata *, const QString &);
-    bool        SetImageOrientation(ImageMetadata *);
-
-    GallerySyncStatus      GetSyncStatus();
-    QMap<QString, QString> GetExifValues(ImageMetadata *);
-};
-
-#endif // GALLERYFILEHELPER_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslide.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslide.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslide.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslide.cpp	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,734 @@
+#include "galleryslide.h"
+
+#include <math.h>
+
+#include <mythmainwindow.h>
+
+
+/*!
+ \brief Initialise & start base animation
+ \param forwards Direction
+ \param speed Factor, 1 = real-time, 2 = double-time
+ \return bool Always True
+*/
+bool AbstractAnimation::Start(bool forwards, float speed)
+{
+    m_forwards = forwards;
+    m_speed    = speed;
+    m_running  = true;
+    return true;
+}
+
+
+/*!
+ \brief Create simple animation
+ \param image Image to be animated
+ \param type Effect to be animated
+*/
+Animation::Animation(Slide *image, Type type)
+    : AbstractAnimation(),
+      QVariantAnimation(),
+      m_parent(image), m_type(type), m_centre(UIEffects::Middle),
+      m_elapsed(0)
+{
+}
+
+
+/*!
+ \brief Initialises an animation
+ \param from Start value
+ \param to End value
+ \param duration Animation duration
+ \param curve Easing curve governing animation
+ \param centre Zoom centre
+*/
+void Animation::Set(QVariant from, QVariant to, int duration,
+                    QEasingCurve curve, UIEffects::Centre centre)
+{
+    setStartValue(from);
+    setEndValue(to);
+    m_centre = centre;
+    setDuration(duration);
+    setEasingCurve(curve);
+}
+
+
+/*!
+ \brief Start a single animation
+ \param forwards Direction
+ \param speed Speed factor, 1x, 2x etc
+ \return bool True if started
+*/
+bool Animation::Start(bool forwards, float speed)
+{
+    if (duration() == 0)
+        return false;
+
+    m_elapsed = forwards ? 0 : duration();
+    setCurrentTime(m_elapsed);
+
+    return AbstractAnimation::Start(forwards, speed);
+}
+
+
+/*!
+ \brief Progress single animation
+ \param interval Millisecs since last update
+*/
+void Animation::Pulse(int interval)
+{
+    if (!m_running)
+        return;
+
+    m_elapsed += (m_forwards ? interval : -interval) * m_speed;
+
+    setCurrentTime(m_elapsed);
+
+    // Detect completion
+    if ((m_forwards && m_elapsed >= duration())
+        || (!m_forwards && m_elapsed <= 0))
+        Finished();
+}
+
+
+/*!
+ \brief Update animated value
+ \param value Latest value, derived from animation time & easing curve
+*/
+void Animation::updateCurrentValue(const QVariant &value)
+{
+    if (m_parent && m_running)
+    {
+        m_parent->SetCentre(m_centre);
+
+        switch (m_type)
+        {
+            case Position: m_parent->SetPosition(value.toPoint()); break;
+            case Alpha: m_parent->SetAlpha(value.toInt()); break;
+            case Zoom: m_parent->SetZoom(value.toFloat()); break;
+            case HorizontalZoom: m_parent->SetHorizontalZoom(value.toFloat());
+                break;
+            case VerticalZoom: m_parent->SetVerticalZoom(value.toFloat());
+                break;
+            case Angle: m_parent->SetAngle(value.toFloat()); break;
+            case None:;
+        }
+    }
+}
+
+
+/*!
+ \brief Add child animation to group
+ \param child
+*/
+void GroupAnimation::Add(AbstractAnimation *child)
+{
+    // Signal group when child completes
+    m_group.append(child);
+    connect(child, SIGNAL(finished()), this, SLOT(Finished()));
+}
+
+
+/*!
+ \brief Delete all child animations
+*/
+void GroupAnimation::Clear()
+{
+    qDeleteAll(m_group);
+    m_group.clear();
+}
+
+
+/*!
+ \brief Progress sequential animation
+ \param interval Millisecs since last update
+*/
+void SequentialAnimation::Pulse(int interval)
+{
+    if (!m_running || m_current < 0 || m_current >= m_group.size())
+        return;
+
+    // Pulse current running child
+    m_group.at(m_current)->Pulse(interval);
+}
+
+
+/*!
+ \brief Start sequential animation
+ \param forwards Direction. If false, the last child will be played (backwards) first
+ \param speed Factor, 1x, 2x etc
+ \return bool Always true
+*/
+bool SequentialAnimation::Start(bool forwards, float speed)
+{
+    if (m_group.size() == 0)
+        return false;
+
+    m_current = forwards ? 0 : m_group.size() - 1;
+
+    // Start group, then first child
+    AbstractAnimation::Start(forwards, speed);
+    m_group.at(m_current)->Start(m_forwards, m_speed);
+    return true;
+}
+
+
+/*!
+ \brief Change speed of current child animation and all subsequent ones
+ \param speed New speed factor
+*/
+void SequentialAnimation::SetSpeed(float speed)
+{
+    // Set group speed for subsequent children
+    AbstractAnimation::SetSpeed(speed);
+
+    // Set active child
+    if (!m_running || m_current < 0 || m_current >= m_group.size())
+        return;
+
+    m_group.at(m_current)->SetSpeed(speed);
+}
+
+
+/*!
+ \brief A child animation has completed
+*/
+void SequentialAnimation::Finished()
+{
+    // Finish group when last child finishes
+    if ((m_forwards && ++m_current == m_group.size())
+        || (!m_forwards && --m_current < 0))
+        AbstractAnimation::Finished();
+    else
+        // Start next child
+        m_group.at(m_current)->Start(m_forwards, m_speed);
+}
+
+
+/*!
+ \brief Progress parallel animations
+ \param interval Millisecs since last update
+*/
+void ParallelAnimation::Pulse(int interval)
+{
+    if (m_running)
+        // Pulse all children
+        foreach(AbstractAnimation *animation, m_group)
+            animation->Pulse(interval);
+}
+
+
+/*!
+ \brief Start parallel group. All children play simultaneously
+ \param forwards Direction
+ \param speed Factor, 1x, 2x etc
+ \return bool Always true
+*/
+bool ParallelAnimation::Start(bool forwards, float speed)
+{
+    if (m_group.size() == 0)
+        return false;
+
+    m_finished = m_group.size();
+
+    // Start group, then all children
+    AbstractAnimation::Start(forwards, speed);
+    foreach(AbstractAnimation *animation, m_group)
+        animation->Start(m_forwards, m_speed);
+
+    return true;
+}
+
+
+/*!
+ \brief Change speed of group and all child animations
+ \param speed New speed factor
+*/
+void ParallelAnimation::SetSpeed(float speed)
+{
+    // Set group speed, then all children
+    AbstractAnimation::SetSpeed(speed);
+    foreach(AbstractAnimation *animation, m_group)
+        animation->SetSpeed(m_speed);
+}
+
+
+/*!
+ \brief A child animation has completed
+*/
+void ParallelAnimation::Finished()
+{
+    // Finish group when last child finishes
+    if (--m_finished == 0)
+        AbstractAnimation::Finished();
+}
+
+
+/*!
+ \brief Update pan value
+ \param value Pan position
+*/
+void PanAnimation::updateCurrentValue(const QVariant &value)
+{
+    if (m_parent && m_running)
+    {
+        Slide *image = dynamic_cast<Slide *>(m_parent);
+        image->SetPan(value.toPoint());
+    }
+}
+
+
+/*!
+ \brief Clone slide from a theme MythUIImage
+ \param parent Parent widget
+ \param name Slide name
+ \param image Theme MythUIImage to clone
+*/
+Slide::Slide(MythUIType *parent, QString name, MythUIImage *image)
+    : MythUIImage(parent, name),
+    m_ilt(new ImageLoadingThread(this)),
+    m_data(NULL),
+    m_waitingFor(NULL),
+    m_zoom(1.0),
+    m_isReady(false),
+    m_loadFailed(false),
+    m_direction(0),
+    m_zoomAnimation(NULL),
+    m_panAnimation(NULL),
+    m_pan(QPoint(0,0))
+{
+    // Clone from image
+    CopyFrom(image);
+
+    // Null parent indicates we should become a child of the image (after
+    // copy to avoid recursion)
+    if (!parent)
+    {
+        // Slides sit on top of parent image area
+        SetArea(MythRect(image->GetArea().toQRect()));
+        m_Area.moveTo(0, 0);
+        m_Parent = image;
+        image->AddChild(this);
+    }
+
+    // Listen for "image completed load" signals
+    connect(m_ilt, SIGNAL(finished()), this, SLOT(LoadComplete()));
+
+    // Provide animations for pan & zoom
+    if (GetPainter()->SupportsAnimation())
+    {
+        m_zoomAnimation = new Animation(this, Animation::Zoom);
+        m_panAnimation  = new PanAnimation(this);
+    }
+}
+
+
+/*!
+ \brief Destroy slide
+*/
+Slide::~Slide()
+{
+    if (m_ilt)
+        m_ilt->wait();
+    delete m_ilt;
+    delete m_zoomAnimation;
+    delete m_panAnimation;
+}
+
+
+/*!
+ \brief Reset slide to unused state
+*/
+void Slide::Clear()
+{
+    m_isReady   = false;
+    m_loadFailed = false;
+    m_data       = NULL;
+}
+
+
+/*!
+ \brief Load slide with an image
+ \details If the requested image is already loaded (due to pre-load) then returns immediately.
+ Otherwise it initiates an image load in a child thread, provided an image is not already loading
+ (multiple requests due to skipping). If loader is busy then the most recent request is queued.
+ Intervening requests are discarded.
+ \param im The image to load
+ \param direction Navigation that caused this load. Determines transition direction
+ \param notifyCompletion if True, emits a signal when the last requested image has loaded
+ \return bool True if the requested image is already loaded
+*/
+bool Slide::Load(ImageItem *im, int direction, bool notifyCompletion)
+{
+    m_waitingFor = notifyCompletion ? im : NULL;
+    m_direction = direction;
+
+    if (im == m_data)
+    {
+        LOG(VB_FILE, LOG_DEBUG, QString("Slide: Already loading/loaded %1 in %2")
+            .arg(im->m_fileName, objectName()));
+
+        if (m_isReady && notifyCompletion)
+            // Image has been pre-loaded
+            emit ImageLoaded(this);
+
+        return m_isReady;
+    }
+
+    // Is a different image loading ?
+    if (m_ilt && m_ilt->isRunning())
+    {
+        // Can't abort image loads, so must wait for it to finish
+        // before starting new load
+        m_waitingFor = im;
+
+        LOG(VB_FILE, LOG_DEBUG, QString("Slide: Postponing load of %1 in %2")
+            .arg(im->m_fileName, objectName()));
+
+        return false;
+    }
+
+    // Start load
+    m_data      = im;
+    m_isReady   = m_loadFailed = false;
+    ImageSg *sg = ImageSg::getInstance();
+
+    if (im->m_type == kVideoFile)
+    {
+        // Use thumbnail, which has already been orientated
+        SetFilename(sg->GenerateThumbUrl(im->m_thumbNails.at(0)));
+        SetOrientation(1);
+    }
+    else
+    {
+        SetFilename(sg->GenerateUrl(im->m_fileName));
+        SetOrientation(m_data->m_orientation);
+    }
+
+    SetCropRect(0, 0, 0, 0);
+    m_ilt->start();
+    return false;
+}
+
+
+/*!
+ \brief An image has completed loading
+ \details If the loaded image matches the most recently requested and client is waiting then
+ signals that the slide is ready. Otherwise starts loading the latest requested image, if
+ different. Superseded loads are discarded.
+*/
+void Slide::LoadComplete()
+{
+    m_isReady = true;
+    m_loadFailed = (m_Images[0] == NULL);
+
+    // Ignore superseded requests and preloads
+    if (m_data == m_waitingFor)
+    {
+        // Loaded image is the latest requested
+        emit ImageLoaded(this);
+    }
+    else if (m_waitingFor)
+    {
+        LOG(VB_FILE, LOG_DEBUG, QString("Slide: Starting delayed load %1")
+            .arg(m_waitingFor->m_fileName));
+
+        // Start latest postponed load
+        Load(m_waitingFor, m_direction, true);
+    }
+}
+
+
+/*!
+ \brief Initiate slide zoom
+ \param percentage Factor of current zoom, ie. 100% = double-size. Sentinel
+ 0% = Reset to default/fullscreen
+*/
+void Slide::Zoom(int percentage)
+{
+    // Sentinel indicates reset to default zoom
+    float newZoom = (percentage == 0)
+                    ? 1.0
+                    : qMax(MIN_ZOOM,
+                           qMin(MAX_ZOOM, m_zoom * (1.0 + percentage / 100.0)));
+    if (newZoom != m_zoom)
+    {
+        if (m_zoomAnimation)
+        {
+            m_zoomAnimation->Set(m_zoom, newZoom, 250, QEasingCurve::OutQuad);
+            m_zoomAnimation->Start();
+        }
+        else
+            SetZoom(newZoom);
+    }
+}
+
+
+/*!
+ \brief Initiate pan
+ \param offset Offset to apply to current position. Sentinel (0,0) resets pan.
+*/
+void Slide::Pan(QPoint offset)
+{
+    // Panning only possible when zoomed in
+    if (m_zoom > 1.0)
+    {
+        QPoint start = m_pan;
+
+        // Sentinel indicates reset to centre
+        // Panning is applied to original (unzoomed) image co-ords.
+        // Adjust offset for zoom so that pan moves a constant screen distance rather
+        // than constant image distance
+        QPoint dest = offset.isNull() ? QPoint(0, 0) : start + offset / m_zoom;
+
+        if (m_panAnimation)
+        {
+            m_panAnimation->Set(start, dest, 250, QEasingCurve::Linear);
+            m_panAnimation->Start();
+        }
+        else
+            SetPan(dest);
+    }
+}
+
+
+/*!
+ \brief Sets slide zoom
+ \details Applies zoom immediately
+ \sa Slide::Zoom
+ \param zoom New zoom level, 1.0 = full-size
+*/
+void Slide::SetZoom(float zoom)
+{
+    m_zoom          = zoom;
+    m_Effects.hzoom = m_Effects.vzoom = zoom;
+
+    // TODO
+    // MythUIImage displaces widget or doesn't centre for some combinations of
+    // zoom centre/cropping so frig centre for now.
+    m_Effects.centre = zoom < 1.0 ? UIEffects::Middle : UIEffects::TopLeft;
+
+    SetPan(m_pan);
+}
+
+
+/*!
+ \brief Sets slide pan
+ \details Applies pan immediately
+ \sa Slide::Pan
+ \param pos New pan offset
+*/
+void Slide::SetPan(QPoint pos)
+{
+    if (m_loadFailed)
+    {
+        m_pan = pos;
+        return;
+    }
+
+    // Determine zoom of largest dimension
+    QRect imageArea = m_Images[m_CurPos]->rect();
+    float hRatio    = float(imageArea.height()) / m_Area.height();
+    float wRatio    = float(imageArea.width()) / m_Area.width();
+    float ratio     = qMax(hRatio, wRatio) / m_zoom;
+
+    // Determine crop area
+    int h = qMin(int(roundf(m_Area.height() * ratio)), imageArea.height());
+    int w = qMin(int(roundf(m_Area.width() * ratio)), imageArea.width());
+    int x = imageArea.center().x() - w / 2;
+    int y = imageArea.center().y() - h / 2;
+
+    // Constrain pan to boundaries
+    int limitX = (imageArea.width() - w) / 2;
+    int limitY = (imageArea.height() - h) / 2;
+    m_pan.setX(qMax(qMin(pos.x(), limitX), -limitX));
+    m_pan.setY(qMax(qMin(pos.y(), limitY), -limitY));
+
+    SetCropRect(x + m_pan.x(), y + m_pan.y(), w, h);
+    SetRedraw();
+}
+
+
+/*!
+ \brief Update pan & zoom animations
+*/
+void Slide::Pulse()
+{
+    // Update zoom/pan animations
+    if (m_zoomAnimation)
+        m_zoomAnimation->Pulse(GetMythMainWindow()->GetDrawInterval());
+
+    if (m_panAnimation)
+        m_panAnimation->Pulse(GetMythMainWindow()->GetDrawInterval());
+}
+
+
+/*!
+ \brief Construct buffer
+ \details Slides are cloned from an image and become children of it. Only the
+ first is visible. Requires a minimum of 3 slides: 2 for a transition, 1 to handle
+ requests
+ \param image Parent image used as a template for slides
+ \param size Number of slides in buffer
+*/
+SlideBuffer::SlideBuffer(MythUIImage *image, int size)
+    : m_nextLoad(1)
+{
+    if (size < 3)
+        // Require at least 3 slides: 2 for transitions & 1 to handle further requests
+        return;
+
+    // Fill buffer with slides cloned from the XML image widget
+
+    // Create first as a child of the image.
+    Slide *slide = new Slide(NULL, "slide0", image);
+
+    // Buffer is notified when it has loaded image
+    connect(slide, SIGNAL(ImageLoaded(Slide *)),
+            this, SLOT(FlushAvailable(Slide *)));
+
+    m_queue.enqueue(slide);
+
+    // Rest are simple clones of first
+    for (int i = 1; i < size; ++i)
+    {
+        slide = new Slide(image, QString("slide%1").arg(i), slide);
+
+        // All slides (except first) start off hidden
+        slide->SetVisible(false);
+
+        // Buffer is notified when it has loaded image
+        connect(slide, SIGNAL(ImageLoaded(Slide *)),
+                this, SLOT(FlushAvailable(Slide *)));
+
+        m_queue.enqueue(slide);
+    }
+}
+
+
+/*!
+ \brief Destructor
+*/
+SlideBuffer::~SlideBuffer()
+{
+    // TODO: Detach from parent
+    qDeleteAll(m_queue);
+}
+
+
+/*!
+ \brief Assign an image to next available slide, start loading and signal
+ when done.
+ \param im Image to load
+ \param direction Navigation causing the load
+ \return bool True if image is already loaded
+*/
+bool SlideBuffer::Load(ImageItem *im, int direction)
+{
+    // Start loading image in next available slide
+    Slide *slide = m_queue.at(m_nextLoad);
+
+    // Further load requests will go to same slide if no free ones are available
+    QString extra = "";
+    if (m_nextLoad < m_queue.size() - 1)
+        ++m_nextLoad;
+    else
+        extra = "(No spare slides)";
+
+    LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Loading %1 in %2, next load in slot %3 %4")
+        .arg(im->m_fileName, slide->objectName()).arg(m_nextLoad).arg(extra));
+
+    return slide->Load(im, direction, true);
+}
+
+
+/*!
+ \brief Load an image in next available slide
+ \param im Image to load
+*/
+void SlideBuffer::Preload(ImageItem *im)
+{
+    if (im)
+    {
+        // Start loading image in next available slide
+        Slide *slide = m_queue.at(m_nextLoad);
+
+        LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Preloading %1 in %2 in slot %3")
+            .arg(im->m_fileName, slide->objectName()).arg(m_nextLoad));
+
+        // Load silently
+        m_queue.at(m_nextLoad)->Load(im);
+    }
+}
+
+
+/*!
+ \brief Remove & return slide from head of queue
+ \return Slide Next slide for display
+*/
+Slide* SlideBuffer::TakeNext()
+{
+    if (m_queue.isEmpty())
+        // Shouldn't happen unless init failed
+        return NULL;
+
+    // Dispense next slide & adjust load ptr to account for queue shuffling
+    Slide *next = m_queue.dequeue();
+    --m_nextLoad;
+
+    ImageItem *im = next->GetImageData();
+    LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Taking %1 in %2, next load in slot %3")
+        .arg(im ? im->m_fileName : "Empty", next->objectName()).arg(m_nextLoad));
+
+    return next;
+}
+
+
+/*!
+ \brief Return slide to queue and flush next image, if it is waiting for display
+ \param slide Unused slide for re-use
+ \return int Number of slides waiting for display at head
+*/
+int SlideBuffer::Release(Slide *slide)
+{
+    LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: Releasing %1").arg(slide->objectName()));
+
+    // Reset slide & return to buffer for re-use
+    slide->Clear();
+    m_queue.enqueue(slide);
+
+    // Free constrained load ptr now a spare slide is available
+    if (m_queue.at(m_nextLoad)->IsAvailable())
+        ++m_nextLoad;
+
+    // Flush any pending slides that originate from multiple requests (skipping)
+    return FlushAvailable(m_queue.head(), "Pending");
+}
+
+
+/*!
+ \brief Signal if any slides are waiting to be displayed
+ \param slide The slide that has loaded or being tested
+ \param reason Debug text describing reason for test
+ \return int Number of slides available for display
+*/
+int SlideBuffer::FlushAvailable(Slide *slide, QString reason)
+{
+    // Determine number of consecutive slides that are now available at head
+    // Ignore last slide: it can't be displayed because it may start handling a new request
+    int available = 0;
+    while (available < m_queue.size() - 1 && m_queue.at(available)->IsAvailable())
+        ++available;
+
+    // Notify if slides are available
+    if (available > 0)
+    {
+        LOG(VB_FILE, LOG_DEBUG, QString("SlideBuffer: %1 %2 in %3 (%4 available)")
+            .arg(reason, slide->GetImageData()->m_fileName, slide->objectName())
+            .arg(available));
+
+        emit SlideReady(available);
+    }
+
+    return available;
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslide.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslide.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslide.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslide.h	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,261 @@
+//! \file
+//! \brief Defines specialised images used by the Gallery slideshow and
+//! the animation framework used by transformations
+//! \details Qt Animation Framework doesn't support acceleration and is driven
+//! by a timer that isn't synchronised to Myth's Pulse.
+//! So we provide our own lightweight version.
+//! An animation may be a hierarchy of sequential or parallel groups to achieve
+//! any combination of consecutive and/or simultaneous effects
+
+#ifndef GALLERYSLIDE_H
+#define GALLERYSLIDE_H
+
+#include <QThread>
+#include <QQueue>
+#include <QVariantAnimation>
+
+#include <mythuiimage.h>
+#include <imageutils.h>
+
+// Min/max zoom extents available in slideshow
+#define MIN_ZOOM 0.1
+#define MAX_ZOOM 20.0
+
+
+//! An wrapped image loader so that we can detect when it completes
+class ImageLoadingThread : public QThread
+{
+public:
+    ImageLoadingThread(MythUIImage *image) : QThread(), m_image(image) {}
+
+protected:
+    void run()   { if (m_image) m_image->Load(false); }
+
+    MythUIImage *m_image;
+};
+
+
+class Slide;
+
+//! \brief Base animation class that is driven by a Myth pulse and implements
+//! variable speed
+//! \note Although concrete, for convenience, this shouldn't be used directly
+class AbstractAnimation : public QObject
+{
+    Q_OBJECT
+public:
+    AbstractAnimation() : m_forwards(true), m_running(false), m_speed(0.0) {}
+    virtual bool Start(bool forwards, float speed = 1.0);
+    virtual void Stop()                { m_running = false; }
+    virtual void SetSpeed(float speed) { m_speed = speed; }
+    virtual void Pulse(int interval) = 0;
+    virtual void Clear()               {}
+    bool         IsRunning() const     { return m_running; }
+
+protected slots:
+    //! To be called when animation completes
+    virtual void Finished()  { m_running = false; emit finished(); }
+
+signals:
+    //! Signals animation has finished
+    void         finished();
+
+protected:
+    // Play direction
+    bool  m_forwards;
+    bool  m_running;
+    // Real-time = 1.0, Double-speed = 2.0
+    float m_speed;
+};
+
+
+//! \brief A single animation controlling alpha, zoom, rotation and position
+//! \note This is almost compatible with MythUIAnimation (they could be merged)
+class Animation : public AbstractAnimation, public QVariantAnimation
+{
+public:
+    //! Supported effects
+    enum Type {None, Alpha, Position, Zoom, HorizontalZoom, VerticalZoom, Angle};
+
+    Animation(Slide *image, Type type = Alpha);
+    virtual bool Start(bool forwards = true, float speed = 1.0);
+    virtual void Pulse(int interval);
+    void         Set(QVariant from, QVariant to,
+                     int duration = 500,
+                     QEasingCurve curve = QEasingCurve::InOutCubic,
+                     UIEffects::Centre = UIEffects::Middle);
+    virtual void updateCurrentValue(const QVariant &value);
+
+protected:
+    //! Image to be animated
+    // Should be MythUItype but that impacts elsewhere: SetZoom must become
+    // virtual, which causes compiler warnings in subtitles (fn hiding)
+    Slide            *m_parent;
+    Type              m_type;
+    UIEffects::Centre m_centre;
+    //! Current millisec position within animation, 0..duration.
+    //! Decreases duration..0 when playing backwards
+    int               m_elapsed;
+};
+
+
+//! \brief Abstract class for groups of animations
+class GroupAnimation : public AbstractAnimation
+{
+public:
+    GroupAnimation() : AbstractAnimation()                 {}
+    virtual ~GroupAnimation()                              { Clear(); }
+    virtual void Pulse(int interval)                     = 0;
+    virtual bool Start(bool forwards, float speed = 1.0) = 0;
+    virtual void SetSpeed(float speed)                   = 0;
+    virtual void Add(AbstractAnimation *child);
+    virtual void Clear();
+
+protected:
+    QList<AbstractAnimation *> m_group;
+};
+
+
+//! \brief A group of animations to be played sequentially
+//! \details When played backwards the last animation will play first (backwards)
+class SequentialAnimation : public GroupAnimation
+{
+    Q_OBJECT
+public:
+    SequentialAnimation() : GroupAnimation(), m_current(-1)  {}
+    virtual void Pulse(int interval);
+    virtual bool Start(bool forwards, float speed = 1.0);
+    virtual void SetSpeed(float speed);
+
+protected slots:
+    virtual void Finished();
+
+protected:
+    //! Index of child currently playing
+    int m_current;
+};
+
+
+//! \brief A group of animations to be played simultaneously
+class ParallelAnimation : public GroupAnimation
+{
+    Q_OBJECT
+public:
+    ParallelAnimation() : GroupAnimation(), m_finished(0)  {}
+    virtual void Pulse(int interval);
+    virtual bool Start(bool forwards, float speed = 1.0);
+    virtual void SetSpeed(float speed);
+
+protected slots:
+    virtual void Finished();
+
+protected:
+    //! Count of child animations that have finished
+    int m_finished;
+};
+
+
+//! \brief Specialised animation for panning slideshow images (MythUI doesn't
+//! support panning)
+class PanAnimation : public Animation
+{
+public:
+    PanAnimation(Slide *image) : Animation(image) {}
+    virtual void updateCurrentValue(const QVariant &value);
+};
+
+
+//! \brief A specialised image for slideshows
+class Slide : public MythUIImage
+{
+    Q_OBJECT
+public:
+    Slide(MythUIType *parent, QString name, MythUIImage *image);
+    ~Slide();
+
+    bool       Load(ImageItem *im, int direction = 0, bool waiting = false);
+    bool       Display(ImageItem *im);
+    ImageItem *GetImageData() const  { return m_data; }
+    void       Zoom(int percentage);
+    void       SetZoom(float);
+    void       SetPan(QPoint value);
+    void       Pan(QPoint distance);
+    bool       CanZoomIn() const     { return m_zoom < MAX_ZOOM; }
+    bool       CanZoomOut() const    { return m_zoom > MIN_ZOOM; }
+    void       Clear();
+    bool       IsAvailable() const   { return m_isReady; }
+    bool       FailedLoad() const    { return m_loadFailed; }
+    int        GetDirection() const  { return m_direction; }
+    void       Lock(bool set = true) { m_locked = set; }
+    bool       IsLocked() const      { return m_locked; }
+    void       Pulse();
+
+public slots:
+    void       LoadComplete();
+
+signals:
+    //! Generated when the last requested image has loaded
+    void       ImageLoaded(Slide*);
+
+private:
+    //! Separate thread loads images from BE
+    ImageLoadingThread *m_ilt;
+    //! The image currently loading/loaded
+    ImageItem      *m_data;
+    //! The most recently requested image. Differs from m_data when skipping
+    ImageItem      *m_waitingFor;
+    //! Current zoom, 1.0 = fullsize
+    float           m_zoom;
+    //! True when image is available for display
+    bool            m_isReady;
+    //! True when image load failed (it's disappeared or BE is down)
+    bool            m_loadFailed;
+    bool            m_locked;
+    //! Navigation that created this image, -1 = Prev, 0 = Update, 1 = Next
+    int             m_direction;
+    //! Dedicated animation for zoom
+    Animation      *m_zoomAnimation;
+    //! Dedicated animation for panning
+    PanAnimation   *m_panAnimation;
+    //! Pan position (0,0) = no pan
+    QPoint          m_pan;
+};
+
+
+/*!
+ \brief Provides a queue/pool of slides
+ \details Slides are cloned from a theme-provided image definition, so are
+ created at start-up and re-used (a pool).
+ Image requests are assigned to successive slides. When loaded a slide becomes
+ available for display in requested order (a queue). When displayed the head
+ slide is removed from the queue and returned to the tail for re-use only when
+ it is no longer displayed. If a rapid batch of requests fill the buffer then
+ subsequent requests overwrite the last slide, discarding the previous image
+ (jumping behaviour)
+*/
+class SlideBuffer : public QObject
+{
+    Q_OBJECT
+public:
+    SlideBuffer(MythUIImage *image, int size);
+    ~SlideBuffer();
+    bool Load(ImageItem *im, int direction);
+    void Preload(ImageItem *im);
+    Slide* TakeNext();
+    int Release(Slide*);
+
+signals:
+    //! Signals that buffer has (count) loaded slides awaiting display
+    void SlideReady(int count);
+
+private slots:
+    int FlushAvailable(Slide*, QString reason = "Loaded");
+
+protected:
+    //! Queue of slides awaiting display, loading or spare
+    QQueue<Slide*> m_queue;
+    //! Queue index of first spare slide, or last slide if none spare
+    int m_nextLoad;
+};
+
+#endif // GALLERYSLIDE_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslideview.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslideview.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslideview.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslideview.cpp	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,793 @@
+#include "galleryslideview.h"
+
+#include <mythmainwindow.h>
+#include <mythuitext.h>
+
+#include "gallerycommhelper.h"
+
+
+// Numbers of slides to use for buffering image requests.
+// Each will remotely load its image from BE so too many will hamper performance
+// Fewer will result in jumping between slides rather than flicking quickly through them
+// Minimum is 3: 2 for displaying a transition, 1 to handle load requests
+// Reasonable range is 4 - 16 ?
+#define SLIDE_BUFFER_SIZE 8
+
+/**
+ *  \brief  Constructor
+ *  \param  parent The screen parent
+ *  \param  name The name of the screen
+ */
+GallerySlideView::GallerySlideView(MythScreenStack *parent,
+                                   const char *name)
+    : MythScreenType(parent, name),
+    m_uiImage(NULL),
+    m_uiStatus(NULL),
+    m_slideShowType(kBrowseSlides),
+    m_slideShowTime(gCoreContext->GetNumSetting("GallerySlideShowTime", 3000)),
+    m_paused(false),
+    m_suspended(false),
+    m_showCaptions(gCoreContext->GetNumSetting("GalleryShowSlideCaptions",
+                                               true)),
+    m_infoList(NULL),
+    m_view(NULL),
+    m_slides(NULL),
+    m_slideCurrent(NULL),
+    m_slideNext(NULL),
+    m_pending(0),
+    m_availableTransitions(GetMythPainter()->SupportsAnimation()),
+    m_updateTransition()
+{
+    // Get notified when update Transition completes
+    connect(&m_updateTransition, SIGNAL(finished()),
+            this, SLOT(TransitionComplete()));
+
+    // Initialise transition
+    int setting = gCoreContext->GetNumSetting("GalleryTransitionType",
+                                              kBlendTransition);
+    m_transition = m_availableTransitions.Select(setting);
+
+    // Transitions signal when complete
+    connect(m_transition, SIGNAL(finished()), this, SLOT(TransitionComplete()));
+
+    // Used by random transition
+    qsrand(QTime::currentTime().msec());
+
+    // Slideshow timer
+    m_timer = new QTimer();
+    m_timer->setSingleShot(true);
+    m_timer->setInterval(m_slideShowTime);
+    connect(m_timer, SIGNAL(timeout()), this, SLOT(ShowNextSlide()));
+
+    // Filter db reads using current settings.
+    // These can't change whilst slideshow is displayed.
+    m_db = new ImageDbReader(gCoreContext->GetNumSetting("GallerySortOrder"),
+                             gCoreContext->GetNumSetting("GalleryShowHidden"),
+                             gCoreContext->GetNumSetting("GalleryShowType"));
+}
+
+
+/**
+ *  \brief  Destructor
+ */
+GallerySlideView::~GallerySlideView()
+{
+    delete m_timer;
+    delete m_infoList;
+    delete m_view;
+    delete m_slides;
+    delete m_slideCurrent;
+    delete m_slideNext;
+    delete m_db;
+}
+
+
+/**
+ *  \brief  Initialises the graphical elements
+ *  \return True if successful otherwise false
+ */
+bool GallerySlideView::Create()
+{
+    if (!LoadWindowFromXML("image-ui.xml", "slideshow", this))
+        return false;
+
+    // Get widgets from XML
+    bool err = false;
+    UIUtilE::Assign(this, m_uiImage, "image", &err);
+    UIUtilW::Assign(this, m_uiStatus, "status");
+    UIUtilW::Assign(this, m_uiSlideCount, "slidecount");
+    UIUtilW::Assign(this, m_uiCaptionText, "caption");
+    UIUtilW::Assign(this, m_uiHideCaptions, "hidecaptions");
+
+    // File details list is managed elsewhere
+    m_infoList = InfoList::Create(this, true, tr("Not defined"));
+
+    if (err || !m_infoList)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Slideview: Cannot load screen 'Slideshow'");
+        return false;
+    }
+
+    // Create display buffer
+    m_slides = new SlideBuffer(m_uiImage, SLIDE_BUFFER_SIZE);
+
+    // Use empty slide to transition from
+    m_slideCurrent = m_slides->TakeNext();
+    if (!m_slideCurrent)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Slideview: Failed to initialise Slideshow");
+        return false;
+    }
+
+    if (m_uiHideCaptions)
+        m_uiHideCaptions->SetText(m_showCaptions ? "" : tr("Hide"));
+
+    BuildFocusList();
+    SetFocusWidget(m_uiImage);
+
+    // Get notified when a slide is ready for display. Must be queued to
+    // avoid event recursion, ie. event handlers must complete before new
+    // slide notifications are processed.
+    connect(m_slides, SIGNAL(SlideReady(int)),
+            this, SLOT(SlideAvailable(int)), Qt::QueuedConnection);
+
+    return true;
+}
+
+
+/*!
+ \brief Update transition
+*/
+void GallerySlideView::Pulse()
+{
+    // Update transition animations
+    if (m_transition)
+        m_transition->Pulse(GetMythMainWindow()->GetDrawInterval());
+
+    MythScreenType::Pulse();
+}
+
+
+/*!
+ \brief Update changed images
+ \param id Image that has changed
+*/
+void GallerySlideView::ThumbnailChange(int id)
+{
+    if (m_view->Update(id))
+        // Current image has changed, so redisplay
+        ShowSlide();
+}
+
+
+/**
+ *  \brief  Handle keypresses
+ *  \param  event The pressed key
+ *  \return True if key was used, otherwise false
+ */
+bool GallerySlideView::keyPressEvent(QKeyEvent *event)
+{
+    if (GetFocusWidget()->keyPressEvent(event))
+        return true;
+
+    bool        handled = false;
+    QStringList actions;
+    handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
+
+    for (int i = 0; i < actions.size() && !handled; i++)
+    {
+        QString action = actions[i];
+        handled = true;
+
+        if (action == "LEFT")
+            ShowPrevSlide();
+        else if (action == "RIGHT")
+            ShowNextSlide();
+        else if (action == "INFO")
+            ShowInfo();
+        else if (action == "MENU")
+            MenuMain();
+        else if (action == "SLIDESHOW")
+        {
+            // If a slideshow is active then pause/un-pause it
+            // Otherwise start a normal one
+            if (m_slideShowType == kBrowseSlides)
+                StartNormal();
+            else if (m_paused)
+                Resume();
+            else
+                Pause();
+        }
+        else if (action == "PAUSE")
+            Pause();
+        else if (action == "SELECT")
+            PlayVideo();
+        else if (action == "STOP")
+            Stop();
+        else if (action == "ROTRIGHT")
+            Transform(kRotateCW);
+        else if (action == "ROTLEFT")
+            Transform(kRotateCCW);
+        else if (action == "FLIPHORIZONTAL")
+            Transform(kFlipHorizontal);
+        else if (action == "FLIPVERTICAL")
+            Transform(kFlipVertical);
+        else if (action == "ZOOMIN")
+            Zoom(10);
+        else if (action == "ZOOMOUT")
+            Zoom(-10);
+        else if (action == "FULLSIZE")
+            Zoom();
+        else if (action == "SCROLLUP")
+            Pan(QPoint(0, 100));
+        else if (action == "SCROLLDOWN")
+            Pan(QPoint(0, -100));
+        else if (action == "SCROLLLEFT")
+            Pan(QPoint(-120, 0));
+        else if (action == "SCROLLRIGHT")
+            Pan(QPoint(120, 0));
+        else if (action == "RECENTER")
+            Pan();
+        else if (action == "ESCAPE" && !GetMythMainWindow()->IsExitingToMain())
+        {
+            // Exit info details, if shown
+            handled = m_infoList->Hide();
+            if (!handled)
+            {
+                // We're exiting - update gallerythumbview selection
+                ImageItem *im = m_view->GetSelected();
+                if (im)
+                    emit ImageSelected(im->m_id);
+            }
+        }
+        else
+            handled = false;
+    }
+
+    if (!handled)
+
+        handled = MythScreenType::keyPressEvent(event);
+
+    return handled;
+}
+
+
+/**
+ *  \brief  Handle custom events
+ *  \param  event The custom event
+ */
+void GallerySlideView::customEvent(QEvent *event)
+{
+    if (event->type() == DialogCompletionEvent::kEventType)
+    {
+        DialogCompletionEvent *dce = (DialogCompletionEvent *)(event);
+
+        QString resultid  = dce->GetId();
+        int     buttonnum = dce->GetResult();
+
+        if (resultid == "metadatamenu")
+        {
+            switch (buttonnum)
+            {
+                case 0: Transform(kRotateCW); break;
+                case 1: Transform(kRotateCCW); break;
+                case 2: Transform(kFlipHorizontal); break;
+                case 3: Transform(kFlipVertical); break;
+                case 4: Transform(kResetExif); break;
+                case 5: Zoom(10); break;
+                case 6: Zoom(-10); break;
+            }
+        }
+    }
+}
+
+
+/**
+ *  \brief  Shows the popup menu
+ */
+void GallerySlideView::MenuMain()
+{
+    // Create the main menu that will contain the submenus above
+    MythMenu *menu =
+        new MythMenu(tr("Slideshow Options"), this, "mainmenu");
+
+    ImageItem *im = m_slideCurrent->GetImageData();
+    if (im && im->m_type == kVideoFile)
+        menu->AddItem(tr("Play Video"), SLOT(PlayVideo()));
+
+    if (m_slideShowType == kBrowseSlides)
+    {
+        menu->AddItem(tr("Start SlideShow"),
+                      SLOT(StartNormal()));
+        menu->AddItem(tr("Start Recursive SlideShow"),
+                      SLOT(StartRecursive()));
+    }
+    else
+    {
+        if (m_paused)
+            menu->AddItem(tr("Resume"), SLOT(Resume()));
+        else
+            menu->AddItem(tr("Pause"), SLOT(Pause()));
+
+        menu->AddItem(tr("Stop"), SLOT(Stop()));
+    }
+
+    MenuTransforms(menu);
+
+    if (m_uiHideCaptions)
+    {
+        if (m_showCaptions)
+            menu->AddItem(tr("Hide Captions"), SLOT(HideCaptions()));
+        else
+            menu->AddItem(tr("Show Captions"), SLOT(ShowCaptions()));
+    }
+
+    QString details;
+    switch (m_infoList->GetState())
+    {
+        case kBasicInfo: details = tr("More Details"); break;
+        case kFullInfo: details  = tr("Less Details"); break;
+        default:
+        case kNoInfo: details = tr("Show Details"); break;
+    }
+    menu->AddItem(details, SLOT(ShowInfo()));
+
+    if (m_infoList->GetState() != kNoInfo)
+        menu->AddItem(tr("Hide Details"), SLOT(HideInfo()));
+
+    MythScreenStack *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythDialogBox *menuPopup = new MythDialogBox(menu, popupStack, "menuPopup");
+    if (menuPopup->Create())
+        popupStack->AddScreen(menuPopup);
+    else
+        delete menuPopup;
+}
+
+
+/**
+ *  \brief  Add Transforms submenu
+ *  \param  mainMenu Parent menu
+ */
+void GallerySlideView::MenuTransforms(MythMenu *mainMenu)
+{
+    ImageItem *im = m_slideCurrent->GetImageData();
+    if (im && SlideShowNotActive())
+    {
+        MythMenu *menu = new MythMenu(tr("Transform Options"),
+                                      this, "metadatamenu");
+
+        if (im->m_type == kImageFile)
+        {
+            menu->AddItem(tr("Rotate CW"));
+            menu->AddItem(tr("Rotate CCW"));
+            menu->AddItem(tr("Flip Horizontal"));
+            menu->AddItem(tr("Flip Vertical"));
+            menu->AddItem(tr("Reset to Exif"));
+        }
+        if (m_slideCurrent->CanZoomIn())
+            menu->AddItem(tr("Zoom In"));
+
+        if (m_slideCurrent->CanZoomOut())
+            menu->AddItem(tr("Zoom Out"));
+
+        mainMenu->AddItem(tr("Transforms"), NULL, menu);
+    }
+}
+
+
+/*!
+ \brief  Start slideshow
+ \param type Browsing, Normal or Recursive
+ \param view View to initialise slideshow from.
+ \param newScreen True if starting from Thumbview, False otherwise
+*/
+void GallerySlideView::Start(ImageSlideShowType type, int parentId,
+                             int selectedId, bool newScreen)
+{
+    // Cleanup any current slideshow
+    Stop();
+    delete m_view;
+
+    m_slideShowType = type;
+
+    if (type == kBrowseSlides)
+    {
+        // Browsing views a single ordered directory
+        m_view = new FlatView(kOrdered, m_db);
+
+        // Load db images
+        m_view->LoadFromDb(parentId);
+
+        // Display current selection, falling back to first
+        m_view->Select(selectedId);
+
+        // Display slide immediately
+        ShowSlide();
+    }
+    else
+    {
+        int orderInt = gCoreContext->GetNumSetting("GallerySlideOrder",
+                                                   kOrdered);
+
+        SlideOrderType order = orderInt < kOrdered || orderInt > kSeasonal
+                ? kOrdered
+                : static_cast<SlideOrderType>(orderInt);
+
+        // Recursive uses a view of a directory subtree; Normal views a single directory
+        m_view = (type == kRecursiveSlideShow)
+                ? new TreeView(order, m_db) : new FlatView(order, m_db);
+
+        // Load db images
+        m_view->LoadFromDb(parentId);
+
+        // Ordered views start from selected image
+        if (order == kOrdered)
+            // Adjust list so that slideshows show count rather than position
+            // Start at selection for new screens; old screens start at the subsequent
+            // image (they're already showing the selected)
+            m_view->Rotate(selectedId, newScreen ? 0 : 1);
+
+        // Show first image, immediately for new screens
+        ShowNextSlide(!newScreen);
+
+        // Start slideshow
+        Resume();
+    }
+}
+
+
+/**
+ *  \brief  Stops an active slideshow
+ */
+void GallerySlideView::Stop()
+{
+    m_timer->stop();
+    m_slideShowType = kBrowseSlides;
+    if (m_uiStatus)
+        // Clear paused text
+        m_uiStatus->SetVisible(false);
+}
+
+
+/**
+ *  \brief  Pauses an active slideshow
+ */
+void GallerySlideView::Pause()
+{
+    m_timer->stop();
+    m_paused = true;
+    SetStatus(tr("Paused"));
+}
+
+
+/**
+ *  \brief  Resumes a paused slideshow
+ */
+void GallerySlideView::Resume()
+{
+    m_paused = false;
+    if (m_uiStatus)
+        m_uiStatus->SetVisible(false);
+    if (!m_suspended)
+        m_timer->start();
+}
+
+
+/*!
+ \brief Pause transition timer temporarily
+*/
+void GallerySlideView::Suspend()
+{
+    m_timer->stop();
+    m_suspended = true;
+}
+
+
+/*!
+ \brief Unpause transition timer
+*/
+void GallerySlideView::Release()
+{
+    m_suspended = false;
+    if (!m_paused && m_slideShowType != kBrowseSlides)
+        m_timer->start();
+}
+
+
+/*!
+ \brief Action transform request
+ \param state Transform to apply
+*/
+void GallerySlideView::Transform(ImageFileTransform state)
+{
+    ImageItem *im = m_view->GetSelected();
+    if (im && SlideShowNotActive())
+    {
+        ImageIdList list;
+        list.append(im->m_id);
+        QString err = GalleryBERequest::ChangeOrientation(state, list);
+        if (!err.isEmpty())
+            ShowOkPopup(err);
+    }
+}
+
+
+/*!
+ \brief Zoom current slide
+ \param increment Percentage factor
+*/
+void GallerySlideView::Zoom(int increment)
+{
+    if (SlideShowNotActive())
+        m_slideCurrent->Zoom(increment);
+}
+
+
+/*!
+ \brief Pan current slide
+ \param offset Offset from current position
+*/
+void GallerySlideView::Pan(QPoint offset)
+{
+    if (SlideShowNotActive())
+        m_slideCurrent->Pan(offset);
+}
+
+
+/*!
+ \brief Show exif info list
+*/
+void GallerySlideView::ShowInfo()
+{
+    ImageItem *im = m_slideCurrent->GetImageData();
+    if (im)
+        m_infoList->Toggle(im);
+}
+
+
+/*!
+ \brief Hide exif info list
+*/
+void GallerySlideView::HideInfo()
+{
+    m_infoList->Hide();
+}
+
+
+/*!
+ \brief Show text widgets
+*/
+void GallerySlideView::ShowCaptions()
+{
+    m_showCaptions = true;
+    m_uiHideCaptions->SetText("");
+}
+
+
+/*!
+ \brief Hide text widgets
+*/
+void GallerySlideView::HideCaptions()
+{
+    m_showCaptions = false;
+    m_uiHideCaptions->SetText(tr("Hide"));
+}
+
+
+/*!
+ \brief Display slide
+ \param direction Navigation direction +1 = forwards, 0 = update, -1 = backwards
+*/
+void GallerySlideView::ShowSlide(int direction)
+{
+    ImageItem *im = m_view->GetSelected();
+    if (!im)
+        // Reached view limits
+        return;
+
+    LOG(VB_FILE, LOG_DEBUG, QString("Slideview: Gallery showing %1")
+        .arg(im->m_fileName));
+
+    // Suspend the timer until the transition has finished
+    Suspend();
+
+    // Load image from file
+    if (!m_slides->Load(im, direction))
+        // Image not yet available: show loading status
+        SetStatus(tr("Loading"));
+}
+
+
+/*!
+ \brief Calculates transition speed factor
+ \details x0.5 for every slide waiting. Min = x1, Max = Half buffer size, so
+ that buffer retains enough free slots
+ \param available Number of slides ready for display
+ \return float Factor to speed up transition by
+*/
+static float Speed(int available)
+{
+    return qMin(1.0 + available / 2.0, SLIDE_BUFFER_SIZE / 2.0);
+}
+
+
+/*!
+ \brief Start transition
+ \details Displays image that has just loaded
+ \param pic Gallery cyclic slide that has loaded the image
+ \param direction Navigation direction
+ \param skipping True if multiple requests have been received. Transitions will
+ be accelerated
+*/
+void GallerySlideView::SlideAvailable(int count)
+{
+    // Are we transitioning ?
+    if (m_slideNext)
+    {
+        // More slides waiting for display: accelerate current transition
+        m_transition->SetSpeed(Speed(count));
+        return;
+    }
+
+    // We've been waiting for this slide: transition immediately
+    // Reset any zoom/pan first
+    Pan();
+    Zoom();
+
+    // Take next slide
+    m_slideNext = m_slides->TakeNext();
+
+    // Update loading status
+    if (m_uiStatus)
+    {
+        if (!m_slideNext->FailedLoad())
+
+            m_uiStatus->SetVisible(false);
+
+        else if (ImageItem *im = m_slideNext->GetImageData())
+
+            SetStatus(tr("Failed to load %1").arg(im->m_name));
+    }
+
+    int direction = m_slideNext->GetDirection();
+
+    // Use special transition for updates/start-up
+    Transition *transition = (direction == 0) ? &m_updateTransition : m_transition;
+
+    // Start transition, transitioning quickly if more slides waiting
+    transition->Start(m_slideCurrent, m_slideNext, direction >= 0, Speed(m_pending));
+}
+
+
+/*!
+ \brief Transition to new slide has finished
+ \details Resets buffers & old slide. Starts next transition if slide loads
+ are pending (skipping). Otherwise updates text widgets for new slide, pre-loads
+ next slide & starts any video.
+*/
+void GallerySlideView::TransitionComplete()
+{
+    // Release old slide. May cause further transitions but they won't be handled
+    // until we've finished here
+    m_pending = m_slides->Release(m_slideCurrent);
+
+    m_slideCurrent = m_slideNext;
+    m_slideNext    = NULL;
+
+    // Update slide counts
+    if (m_uiSlideCount)
+        m_uiSlideCount->SetText(m_view->GetPosition());
+
+    ImageItem *im = m_slideCurrent->GetImageData();
+
+    LOG(VB_FILE, LOG_DEBUG, QString("Slideview: Finished transition to %1")
+        .arg(im->m_fileName));
+
+    // No further actions when skipping
+    if (m_pending > 0)
+        return;
+
+    // Preload next slide, if any
+    m_slides->Preload(m_view->HasNext());
+
+    // Update any file details information
+    m_infoList->Update(im);
+
+    if (m_uiCaptionText)
+    {
+        // show the date & comment
+        QStringList text;
+        text << ImageUtils::ImageDateOf(im);
+
+        if (!im->m_comment.isEmpty())
+            text << im->m_comment;
+
+        m_uiCaptionText->SetText(text.join(" - "));
+    }
+
+    // Start any video unless we're paused or browsing
+    if (im && im->m_type == kVideoFile)
+    {
+        if (m_paused || m_slideShowType == kBrowseSlides)
+
+            SetStatus(tr("Video"));
+        else
+            PlayVideo();
+    }
+
+    // Resume slideshow timer
+    Release();
+}
+
+
+/*!
+ \brief Display the previous slide in the sequence
+*/
+void GallerySlideView::ShowPrevSlide()
+{
+    if (m_view->Prev())
+        ShowSlide(-1);
+}
+
+
+/*!
+ \brief Display the next slide in the sequence
+ \param useTransition if false, slide will be updated instantly
+*/
+void GallerySlideView::ShowNextSlide(bool useTransition)
+{
+    // Browsing always wraps; slideshows depend on repeat setting
+    if (!m_view->HasNext()
+            && m_slideShowType != kBrowseSlides
+            && !gCoreContext->GetNumSetting("GalleryRepeat", false))
+    {
+        Stop();
+        SetStatus(tr("End"));
+    }
+    else if (m_view->Next())
+        ShowSlide(useTransition ? 1 : 0);
+    else
+    {
+        // No images
+        Stop();
+        SetStatus(tr("Empty"));
+        m_infoList->Hide();
+        m_slideCurrent->Clear();
+        if (m_uiSlideCount)
+            m_uiSlideCount->SetText(tr("None"));
+        if (m_uiCaptionText)
+            m_uiCaptionText->SetText("");
+    }
+}
+
+
+/*!
+ \brief Starts internal player for video
+*/
+void GallerySlideView::PlayVideo()
+{
+    if (!m_slideCurrent || m_slideCurrent->FailedLoad())
+        return;
+
+    ImageItem *im = m_slideCurrent->GetImageData();
+
+    if (im && im->m_type == kVideoFile)
+    {
+        QString url = ImageSg::getInstance()->GenerateUrl(im->m_fileName);
+        GetMythMainWindow()->HandleMedia("Internal", url);
+    }
+}
+
+
+/*!
+ \brief Displays status text (Loading, Paused etc.)
+ \param msg Text to show
+*/
+void GallerySlideView::SetStatus(QString msg)
+{
+    if (m_uiStatus)
+    {
+        m_uiStatus->SetText(msg);
+        m_uiStatus->SetVisible(true);
+    }
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslideview.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslideview.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryslideview.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryslideview.h	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,123 @@
+//! \file
+//! \brief Slideshow screen
+
+#ifndef GALLERYWIDGET_H
+#define GALLERYWIDGET_H
+
+#include <QTimer>
+#include <QEvent>
+#include <QPoint>
+
+#include <mythscreentype.h>
+#include <mythdialogbox.h>
+#include <imagemetadata.h>
+
+#include "gallerytransitions.h"
+#include "galleryviews.h"
+#include "galleryslide.h"
+
+
+//! Type of slide show
+enum ImageSlideShowType {
+    kBrowseSlides       = 0,
+    kNormalSlideShow    = 1,
+    kRecursiveSlideShow = 2
+};
+
+
+//! \brief Slideshow screen
+class GallerySlideView : public MythScreenType
+{
+    Q_OBJECT
+public:
+    GallerySlideView(MythScreenStack *parent,
+                     const char *name);
+    ~GallerySlideView();
+    bool Create();
+
+public slots:
+    void Start(ImageSlideShowType type, int parentId, int selectedId = 0,
+               bool newScreen = true);
+    void Pulse();
+    void ThumbnailChange(int id);
+
+signals:
+    void ImageSelected(int);
+
+private:
+    bool keyPressEvent(QKeyEvent *);
+    void customEvent(QEvent *);
+    void MenuMain();
+    void MenuTransforms(MythMenu *);
+    void Suspend();
+    void Release();
+    void Transform(ImageFileTransform);
+    void Zoom(int = 0);
+    void Pan(QPoint = QPoint(0, 0));
+    bool SlideShowNotActive()
+    { return m_slideShowType == kBrowseSlides || m_paused; }
+    void SetStatus(QString msg);
+
+private slots:
+    void ShowPrevSlide();
+    void ShowNextSlide(bool useTransition = true);
+    void SlideAvailable(int count);
+    void TransitionComplete();
+    void ShowSlide(int direction = 0);
+    void StartNormal()     { Start(kNormalSlideShow, m_view->GetParentId(),
+                                   m_view->GetSelected()->m_id, false); }
+    void StartRecursive()  { Start(kRecursiveSlideShow, m_view->GetParentId(),
+                                   m_view->GetSelected()->m_id, false); }
+    void Stop();
+    void Pause();
+    void Resume();
+    void ShowInfo();
+    void HideInfo();
+    void ShowCaptions();
+    void HideCaptions();
+    void PlayVideo();
+
+private:
+    // Theme widgets
+    MythUIImage *m_uiImage;
+    MythUIText  *m_uiStatus, *m_uiSlideCount, *m_uiCaptionText, *m_uiHideCaptions;
+
+    ImageSlideShowType m_slideShowType;
+    int          m_slideShowTime;
+    QTimer      *m_timer;
+    bool         m_paused, m_suspended, m_showCaptions;
+
+    //! Image details overlay
+    InfoList *m_infoList;
+
+    //! List of images in the slideshow
+    FlatView *m_view;
+
+    //! \brief A queue of slides used to display images.
+    //! \details Image requests go to successive slides. When loaded the slide is available
+    //! for display. The head is removed once it is displayed. When no longer on display
+    //! it is returned to the back of the queue for re-use.
+    SlideBuffer *m_slides;
+
+    //! Slide currently displayed or being transitioned from
+    Slide *m_slideCurrent;
+    //! Slide being transitioned to, NULL if no transition in progress.
+    Slide *m_slideNext;
+
+    //! Number of slides waiting to be displayed
+    int m_pending;
+
+    //! Transitions available
+    TransitionRegistry m_availableTransitions;
+    //! Selected transition
+    Transition *m_transition;
+    //! Instant transition that is always used for start-up & image updates
+    TransitionNone m_updateTransition;
+
+    //! \brief Filtered view of the image database
+    //! \details A helper that provides read-only access to the database. Results
+    //! are filtered by 'Show Hidden' setting and sorted iaw Thumbview ordering.
+    ImageDbReader *m_db;
+};
+
+#endif // GALLERYWIDGET_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerythumbview.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerythumbview.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerythumbview.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerythumbview.cpp	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,1843 @@
+#include "gallerythumbview.h"
+
+#include <QFileInfo>
+
+#include <mythcontext.h>
+#include <mythscreentype.h>
+#include <mythuimultifilebrowser.h>
+#include <mythuiprogressbar.h>
+#include <imageutils.h>
+
+#include "galleryconfig.h"
+
+/*!
+ *  \brief  Constructor
+ *  \param  parent The screen parent
+ *  \param  name The name of the screen
+ */
+GalleryThumbView::GalleryThumbView(MythScreenStack *parent, const char *name)
+    : MythScreenType(parent, name),
+    m_imageList(NULL),
+    m_captionText(NULL),
+    m_crumbsText(NULL),
+    m_hideFilterText(NULL),
+    m_typeFilterText(NULL),
+    m_positionText(NULL),
+    m_emptyText(NULL),
+    m_scanProgressText(NULL),
+    m_scanProgressBar(NULL),
+    m_scanInProgress(false),
+    m_zoomLevel(0),
+    m_infoList(NULL),
+    m_editsAllowed(false),
+    m_deleteAfterImport(false),
+    m_importTmp(NULL)
+{
+    // Handles BE messages for all views
+    gCoreContext->addListener(this);
+
+    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
+    m_mainStack  = GetMythMainWindow()->GetMainStack();
+
+    // Filter db reads using current settings
+    m_db = new ImageDbReader(gCoreContext->GetNumSetting("GallerySortOrder"),
+                             gCoreContext->GetNumSetting("GalleryShowHidden"),
+                             gCoreContext->GetNumSetting("GalleryShowType"));
+
+    // This screen uses a single fixed view (Parent dir, ordered dirs, ordered images)
+    m_view = new DirectoryView(kOrdered, m_db);
+
+    m_menuState.Clear();
+}
+
+
+/*!
+ *  \brief  Destructor
+ */
+GalleryThumbView::~GalleryThumbView()
+{
+    gCoreContext->removeListener(this);
+
+    delete m_view;
+    delete m_db;
+    delete m_infoList;
+    delete m_importTmp;
+}
+
+
+/*!
+ *  \brief  Initialises and shows the graphical elements
+ */
+bool GalleryThumbView::Create()
+{
+    if (!LoadWindowFromXML("image-ui.xml", "gallery", this))
+        return false;
+
+    // Determine zoom levels supported by theme
+    // images0 must exist; images1, images2 etc. are optional and enable zoom
+    int               zoom = 0;
+    MythUIButtonList *widget;
+    do
+    {
+        QString name = QString("images%1").arg(zoom++);
+        widget = dynamic_cast<MythUIButtonList *>(this->GetChild(name));
+        if (widget)
+        {
+            m_zoomWidgets.append(widget);
+            widget->SetVisible(false);
+        }
+    }
+    while (widget);
+
+    if (m_zoomWidgets.isEmpty())
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Thumbview: Screen 'Gallery' is missing 'images0'");
+        return false;
+    }
+    LOG(VB_GUI, LOG_DEBUG, QString("Thumbview: Screen 'Gallery' found %1 zoom levels")
+        .arg(m_zoomWidgets.size()));
+
+    // File details list is managed elsewhere
+    m_infoList = InfoList::Create(this, false, tr("Not defined"));
+    if (!m_infoList)
+    {
+        LOG(VB_GENERAL, LOG_ERR, "Slideview: Cannot load screen 'Gallery'");
+        return false;
+    }
+
+    UIUtilW::Assign(this, m_captionText,      "caption");
+    UIUtilW::Assign(this, m_emptyText,        "noimages");
+    UIUtilW::Assign(this, m_positionText,     "position");
+    UIUtilW::Assign(this, m_crumbsText,       "breadcrumbs");
+    UIUtilW::Assign(this, m_hideFilterText,   "hidefilter");
+    UIUtilW::Assign(this, m_typeFilterText,   "typefilter");
+    UIUtilW::Assign(this, m_scanProgressText, "scanprogresstext");
+    UIUtilW::Assign(this, m_scanProgressBar,  "scanprogressbar");
+
+    if (m_scanProgressText)
+        m_scanProgressText->SetVisible(false);
+    if (m_scanProgressBar)
+        m_scanProgressBar->SetVisible(false);
+
+    BuildFocusList();
+
+    // Initialise list widget with appropriate zoom level for this theme.
+    m_zoomLevel = gCoreContext->GetNumSetting("GalleryZoomLevel", 0);
+    SelectZoomWidget(0);
+
+    // Start in edit mode unless a password exists
+    m_editsAllowed = gCoreContext->GetSetting("GalleryPassword").isEmpty();
+
+    return true;
+}
+
+
+/*!
+ *  \brief  Handle keypresses
+ *  \param  event The pressed key
+ */
+bool GalleryThumbView::keyPressEvent(QKeyEvent *event)
+{
+    if (GetFocusWidget()->keyPressEvent(event))
+        return true;
+
+    QStringList actions;
+    bool handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
+
+    for (int i = 0; i < actions.size() && !handled; i++)
+    {
+        QString action = actions[i];
+        handled = true;
+
+        if (action == "MENU")
+            MenuMain();
+        else if (action == "INFO")
+            ShowDetails();
+        else if (action == "ZOOMIN")
+            ZoomIn();
+        else if (action == "ZOOMOUT")
+            ZoomOut();
+        else if (action == "ROTRIGHT")
+            RotateCW();
+        else if (action == "ROTLEFT")
+            RotateCCW();
+        else if (action == "FLIPHORIZONTAL")
+            FlipHorizontal();
+        else if (action == "FLIPVERTICAL")
+            FlipVertical();
+        else if (action == "SLIDESHOW")
+            Slideshow();
+        else if (action == "RECURSIVESHOW")
+            RecursiveSlideshow();
+        else if (action == "MARK")
+        {
+            ImageItem *im = m_view->GetSelected();
+            if (im && m_editsAllowed)
+                MarkItem(!m_view->IsMarked(im->m_id));
+        }
+        else if (action == "ESCAPE" && !GetMythMainWindow()->IsExitingToMain())
+        {
+            // Exit info list, if shown
+            handled = m_infoList->Hide();
+
+            // Ascend the tree if first node is an kUpDirectory
+            if (!handled)
+            {
+                ImageItem *data = m_view->GetParent();
+                if (data && data->m_type == kUpDirectory)
+                    handled = DirSelectUp();
+            }
+        }
+        else
+            handled = false;
+    }
+
+    if (!handled)
+        handled = MythScreenType::keyPressEvent(event);
+
+    return handled;
+}
+
+
+/*!
+ *  \brief  Handle custom events
+ *  \param  event The custom event
+ */
+void GalleryThumbView::customEvent(QEvent *event)
+{
+    if ((MythEvent::Type)(event->type()) == MythEvent::MythEventMessage)
+    {
+        MythEvent *me      = (MythEvent *)event;
+        QString    message = me->Message();
+
+        QStringList extra = me->ExtraDataList();
+
+        if (message == "THUMB_AVAILABLE")
+        {
+            int id = extra[0].toInt();
+
+            // Get all buttons waiting for this thumbnail
+            QList<ThumbLocation> affected = m_pendingMap.values(id);
+
+            // Thumbview is only concerned with thumbnails we've requested
+            if (!affected.isEmpty())
+            {
+                LOG(VB_GENERAL, LOG_DEBUG,
+                    QString("Thumbview: Rx %1 : %2").arg(message, extra.join(",")));
+
+                QString url = "";
+
+                // Set thumbnail for each button now it exists
+                foreach(const ThumbLocation &location, affected)
+                {
+                    MythUIButtonListItem *button = location.first;
+                    int                   index  = location.second;
+                    ImageItem        *im     =
+                            button->GetData().value<ImageItem*>();
+
+                    // All buttons use the same url so only generate it once
+                    if (url.isEmpty())
+                        url = ImageSg::getInstance()->GenerateThumbUrl(im->m_thumbNails.at(index));
+
+                    UpdateThumbnail(button, im, url, index);
+                }
+
+                // Cancel pending request & store url
+                m_pendingMap.remove(id);
+                m_url.insert(id, url);
+            }
+
+            // Pass on to Slideshow
+            emit ThumbnailChanged(id);
+        }
+        else if (message == "IMAGE_DB_CHANGED")
+        {
+            // Expects either:
+            // "ALL" when db cleared, or
+            // csv list of deleted ids, csv list of changed ids,
+            // csv list of urls to remove from cache
+            LOG(VB_GENERAL, LOG_DEBUG,
+                QString("Thumbview: Rx %1 : %2").arg(message, extra.join(",")));
+
+            QStringList idDeleted, idChanged;
+
+            if (!extra.isEmpty())
+                idDeleted = extra.takeFirst().split(",",  QString::SkipEmptyParts);
+            if (!extra.isEmpty())
+                idChanged = extra.takeFirst().split(",",  QString::SkipEmptyParts);
+
+            if (!idDeleted.isEmpty() && idDeleted[0] == "ALL")
+            {
+                m_view->Clear();
+                m_url.clear();
+
+                LOG(VB_FILE, LOG_DEBUG, "Thumbview: Clearing image cache");
+
+                // Remove all cached thumbnails
+                GetMythUI()->RemoveFromCacheByFile(QString("/%1/").arg(THUMBNAIL_DIR));
+                // Remove all cached images
+                GetMythUI()->RemoveFromCacheByFile(QString("//%1@").arg(IMAGE_STORAGE_GROUP));
+            }
+            else
+            {
+                LOG(VB_FILE, LOG_DEBUG, QString("Thumbview: Removing %1- Updating %2")
+                    .arg(idDeleted.join(","), idChanged.join(",")));
+
+                // Reset image urls so that new thumbnails are requested
+                foreach (const QString &ident, idChanged)
+                    m_url.remove(ident.toInt());
+
+                // Cleanup image urls & marked files
+                foreach (const QString &ident, idDeleted)
+                {
+                    m_url.remove(ident.toInt());
+                    m_view->Mark(ident.toInt(), false);
+                }
+
+                // Remove cached thumbs & images
+                foreach(const QString &url, extra)
+                    GetMythUI()->RemoveFromCacheByFile(url);
+            }
+
+            // Refresh display
+            LoadData();
+        }
+        else if (message == "IMAGE_SCAN_STATUS")
+        {
+            // Expects mode, scanned#, total#
+            if (extra.size() == 3)
+            {
+                UpdateScanProgress(extra[0], extra[1], extra[2]);
+            }
+        }
+    }
+    else if (event->type() == DialogCompletionEvent::kEventType)
+    {
+        DialogCompletionEvent *dce = (DialogCompletionEvent *)(event);
+
+        QString resultid  = dce->GetId();
+        int     buttonnum = dce->GetResult();
+
+        if (resultid == "FileRename")
+        {
+            QString newName = dce->GetResultText();
+            if (m_menuState.m_selected)
+            {
+                QString err = GalleryBERequest::RenameFile(
+                    m_menuState.m_selected->m_id, newName);
+
+                if (!err.isEmpty())
+                    ShowOkPopup(err);
+            }
+        }
+        else if (resultid == "ImportFilesSelected")
+        {
+            QStringList files = dce->GetData().value<QStringList>();
+            LOG(VB_FILE, LOG_DEBUG, "Thumbview: Import files " + files.join(","));
+            ImportFiles(files);
+        }
+        else if (resultid == "MakeDir")
+        {
+            if (!m_menuState.m_selected)
+                return;
+
+            QStringList newPath;
+            newPath << QString("%1/%2")
+                .arg(m_menuState.m_selected->m_fileName,
+                     dce->GetResultText());
+
+            QString err = GalleryBERequest::MakeDirs(newPath);
+            if (err.isEmpty())
+                // Rescan to display new dir
+                StartScan();
+            else
+                ShowOkPopup(err);
+        }
+        else if (resultid == "SlideOrderMenu")
+        {
+            SlideOrderType slideOrder = kOrdered;
+
+            switch (buttonnum)
+            {
+                case 0: slideOrder = kOrdered; break;
+                case 1: slideOrder = kShuffle; break;
+                case 2: slideOrder = kRandom; break;
+                case 3: slideOrder = kSeasonal; break;
+            }
+            gCoreContext->SaveSetting("GallerySlideOrder", slideOrder);
+            LOG(VB_FILE, LOG_DEBUG, QString("Order %1").arg(slideOrder));
+        }
+        else if (resultid == "Password")
+        {
+            QString password = dce->GetResultText();
+            m_editsAllowed = (password == gCoreContext->GetSetting("GalleryPassword"));
+        }
+        else if (buttonnum == 1)
+        {
+            // Confirm current file deletion
+            if (resultid == "ConfirmDelete" && m_menuState.m_selected)
+            {
+                ImageIdList ids = ImageIdList() << m_menuState.m_selected->m_id;
+                QString     err = GalleryBERequest::RemoveFiles(ids);
+                if (!err.isEmpty())
+                    ShowOkPopup(err);
+            }
+            // Confirm all selected file deletion
+            else if (resultid == "ConfirmDeleteMarked")
+            {
+                QString err = GalleryBERequest::RemoveFiles(m_menuState.m_markedId);
+                if (!err.isEmpty())
+                    ShowOkPopup(err);
+            }
+        }
+    }
+}
+
+
+/**
+ * @brief Start Thumbnail screen
+ */
+void GalleryThumbView::Start()
+{
+    // Detect any current scans
+    QStringList message = GalleryBERequest::ScanQuery();
+    UpdateScanProgress(message[1], message[2], message[3]);
+
+    // Always start showing top level images
+    LoadData(ROOT_DB_ID);
+}
+
+
+/*!
+ \brief Loads & displays images from database
+ \param parent Id of parent dir
+*/
+void GalleryThumbView::LoadData(int parent)
+{
+    ResetUiSelection();
+
+    // Load view for parent directory
+    if (m_view->LoadFromDb(parent))
+    {
+        m_imageList->SetVisible(true);
+        if (m_emptyText)
+            m_emptyText->SetVisible(false);
+
+        // Build the buttonlist
+        BuildImageList();
+    }
+    else
+    {
+        m_infoList->Hide();
+        m_imageList->SetVisible(false);
+        if (m_emptyText)
+        {
+            m_emptyText->SetVisible(true);
+            m_emptyText->SetText(tr("No images found in the database.\n"
+                                    "Set Photographs storage group,\n"
+                                    "then scan from menu."));
+        }
+    }
+}
+
+
+/*!
+ *  \brief  Displays all images in current view
+ */
+void GalleryThumbView::BuildImageList()
+{
+    m_imageList->Reset();
+    m_pendingMap.clear();
+
+    // get all children from the the active node
+    ImageList      children = m_view->GetAllNodes();
+    ImageItem *selected = m_view->GetSelected();
+
+    // go through the entire list and update
+    foreach(ImageItem *im, children)
+    if (im)
+    {
+        // Data must be set by constructor: First item is automatically
+        // selected and must have data available for selection event, as
+        // subsequent reselection of same item will always fail.
+        MythUIButtonListItem *item = new MythUIButtonListItem(
+            m_imageList, "", qVariantFromValue(im));
+
+        item->setCheckable(true);
+        item->setChecked(MythUIButtonListItem::NotChecked);
+
+        // assign and display all information about
+        // the current item, like title and subdirectory count
+        UpdateImageItem(item);
+
+        // Reinstate the active button item
+        if (im == selected)
+            m_imageList->SetItemCurrent(item);
+    }
+
+    // Updates all other widgets on the screen that show
+    // information about the selected MythUIButtonListItem
+    SetUiSelection(m_imageList->GetItemCurrent());
+}
+
+
+/*!
+ *  \brief  Initialises a single buttonlist item
+ *  \param  item The buttonlist item
+
+ */
+void GalleryThumbView::UpdateImageItem(MythUIButtonListItem *item)
+{
+    ImageItem *im = item->GetData().value<ImageItem *>();
+    if (!im)
+        return;
+
+    // Allow themes to distinguish between roots, folders, pics, videos
+    switch (im->m_type)
+    {
+        case kUpDirectory:
+            item->DisplayState("upfolder", "buttontype");
+            break;
+
+        case kBaseDirectory:
+        case kSubDirectory:
+            if (im->m_dirCount > 0)
+                item->SetText(QString("%1/%2")
+                              .arg(im->m_fileCount).arg(im->m_dirCount),
+                              "childcount");
+            else
+                item->SetText(QString::number(im->m_fileCount), "childcount");
+
+            item->DisplayState("subfolder", "buttontype");
+            break;
+
+        case kImageFile:
+            item->DisplayState("image", "buttontype");
+            break;
+
+        case kVideoFile:
+            item->DisplayState("video", "buttontype");
+            break;
+
+        default:
+            break;
+    }
+
+    // Allow theme to distinguish visible/hidden nodes
+    QString hideState = (im->m_isHidden) ? "hidden" : "visible";
+    item->DisplayState(hideState, "buttonstate");
+
+    // No text for roots or Upfolders
+    if (im->m_type >= kSubDirectory)
+    {
+        int     show = gCoreContext->GetNumSetting("GalleryShowCaption");
+        QString text;
+        switch (show)
+        {
+            case kNameCaption: text = im->m_name; break;
+            case kDateCaption: text = ImageUtils::ImageDateOf(im); break;
+            case kUserCaption: text = im->m_comment; break;
+            default:
+            case kNoCaption:   text = ""; break;
+        }
+        item->SetText(text);
+    }
+
+    // Set marked state
+    MythUIButtonListItem::CheckState state
+        = m_view->IsMarked(im->m_id)
+          ? MythUIButtonListItem::FullChecked
+          : MythUIButtonListItem::NotChecked;
+
+    item->setChecked(state);
+
+    // Thumbnails required from BE
+    QStringList required = QStringList();
+
+    if (im->m_thumbNails.size() == 1)
+    {
+        // Single thumbnail
+        QString url = CheckThumbnail(item, im, required);
+
+        if (!url.isEmpty())
+            UpdateThumbnail(item, im, url);
+    }
+    else
+    {
+        // Dir showing up to 4 thumbs
+        InfoMap thumbMap;
+        for (int index = 0; index < im->m_thumbNails.size(); ++index)
+        {
+            QString url = CheckThumbnail(item, im, required, index);
+
+            if (!url.isEmpty())
+                thumbMap.insert(QString("thumbimage%1").arg(index), url);
+        }
+
+        // Set multiple images at same time
+        if (!thumbMap.isEmpty())
+            item->SetImageFromMap(thumbMap);
+    }
+
+    // Request BE to create/verify any missing thumbnails.
+    if (!required.isEmpty())
+        GalleryBERequest::CreateThumbnails(required, im->IsDirectory());
+}
+
+
+/*!
+ \brief Verify thumbnail is known to exist
+ \details Thumbnails are only displayed when known to exist on the BE. Otherwise
+ repeated failures to load them severely hinders performance. Note a single
+ specific BE request is much faster than scanning the image cache
+ \param item The buttonlist item being constructed
+ \param im Image data
+ \param request List of ids that are unknown
+ \param index Thumbnail index in buttonlist item (Dirs use 4 thumbnails)
+ \return QString URL of thumbnail
+*/
+QString GalleryThumbView::CheckThumbnail(MythUIButtonListItem *item, ImageItem *im,
+                                         QStringList &request, int index)
+{
+    int id = im->m_thumbIds.at(index);
+
+    // Thumbs are retrieved & cached as urls
+    QString url = m_url.value(id, "");
+
+    if (!url.isEmpty())
+        return url;
+
+    // Request BE thumbnail check if it is not already pending
+    if (!m_pendingMap.contains(id))
+        request << QString::number(id);
+
+    // Note this button is awaiting an update
+    m_pendingMap.insertMulti(id, qMakePair(item, index));
+
+    return "";
+}
+
+
+/*!
+ \brief Update the buttonlist item with a thumbnail
+ \param button Buttonlist item to update
+ \param im Image data
+ \param url URL of the thumbnail
+ \param index Index of the thumbnail on the button
+*/
+void GalleryThumbView::UpdateThumbnail(MythUIButtonListItem *button,
+                                       ImageItem *im, const QString &url,
+                                       int index)
+{
+    if (im->m_thumbNails.size() == 1)
+    {
+        // Pics, dirs & videos use separate widgets
+        QString widget;
+        switch (im->m_type)
+        {
+            case kImageFile: widget = ""; break;
+            case kVideoFile: widget = "videoimage"; break;
+            default:         widget = "folderimage"; break;
+        }
+
+        button->SetImage(url, widget);
+    }
+    else
+        // Dir with 4 thumbnails
+        button->SetImage(url, QString("thumbimage%1").arg(index));
+}
+
+
+/*!
+ \brief Update progressbar with scan status
+ \param mode BE scan state
+ \param current Number of images scanned
+ \param total Total number of images to scan
+*/
+void GalleryThumbView::UpdateScanProgress(QString mode,
+                                          QString current,
+                                          QString total)
+{
+    if (!mode.isEmpty() && !m_scanInProgress)
+    {
+        // Scan just started
+        if (m_scanProgressBar)
+        {
+            m_scanProgressBar->SetVisible(true);
+            m_scanProgressBar->SetStart(0);
+        }
+        if (m_scanProgressText)
+            m_scanProgressText->SetVisible(true);
+    }
+
+    m_scanInProgress = !mode.isEmpty();
+
+    if (m_scanInProgress)
+    {
+        // Scan update
+        if (m_scanProgressBar)
+        {
+            m_scanProgressBar->SetUsed(current.toInt());
+            m_scanProgressBar->SetTotal(total.toInt());
+        }
+        if (m_scanProgressText)
+            m_scanProgressText->SetText(tr("%1 of %3")
+                                        .arg(current, total));
+    }
+    else
+    {
+        // Scan just finished
+        if (m_scanProgressText)
+            m_scanProgressText->SetVisible(false);
+        if (m_scanProgressBar)
+            m_scanProgressBar->SetVisible(false);
+    }
+}
+
+
+/*!
+ *  \brief  Clears all text widgets for selected item
+ */
+void GalleryThumbView::ResetUiSelection()
+{
+    if (m_positionText)
+        m_positionText->Reset();
+
+    if (m_captionText)
+        m_captionText->Reset();
+
+    if (m_crumbsText)
+        m_crumbsText->Reset();
+
+    if (m_hideFilterText)
+        m_hideFilterText->Reset();
+
+    if (m_typeFilterText)
+        m_typeFilterText->Reset();
+}
+
+
+/*!
+ *  \brief  Updates text widgets for selected item
+ *  \param  item The selected buttonlist item
+ */
+void GalleryThumbView::SetUiSelection(MythUIButtonListItem *item)
+{
+    ImageItem *im = item->GetData().value<ImageItem *>();
+    if (im)
+    {
+        if (m_captionText)
+        {
+            // show the date & comment of a node
+            QStringList text;
+            text << ImageUtils::ImageDateOf(im);
+
+            if (!im->m_comment.isEmpty())
+                text << im->m_comment;
+
+            m_captionText->SetText(text.join(" - "));
+        }
+
+        if (m_hideFilterText)
+        {
+            int show = gCoreContext->GetNumSetting("GalleryShowHidden");
+            m_hideFilterText->SetText(show ? tr("Hidden") : "");
+        }
+
+        if (m_typeFilterText)
+        {
+            int type = gCoreContext->GetNumSetting("GalleryShowType");
+            QString text = "";
+            switch (type)
+            {
+            case kPicAndVideo : text = ""; break;
+            case kPicOnly     : text = tr("Pictures"); break;
+            case kVideoOnly   : text = tr("Videos"); break;
+            }
+
+            m_typeFilterText->SetText(text);
+        }
+
+        // show the position of the image
+        if (m_positionText)
+            m_positionText->SetText(QString("%1/%2")
+                                    .arg(m_imageList->GetCurrentPos())
+                                    .arg(m_imageList->GetCount() - 1));
+
+        // show the path of the image
+        if (m_crumbsText)
+        {
+            if (im->m_id == ROOT_DB_ID)
+                m_crumbsText->SetText(tr("Gallery"));
+            else
+            {
+                QString crumbs = im->m_fileName;
+                m_crumbsText->SetText(crumbs.replace("/", " - "));
+            }
+        }
+
+        // Update any file details information
+        m_infoList->Update(im);
+    }
+}
+
+
+/*!
+ *  \brief  Shows the main menu when the MENU button was pressed
+ */
+void GalleryThumbView::MenuMain()
+{
+    // Create the main menu
+    MythMenu *menu = new MythMenu(tr("Gallery Options"), this, "mainmenu");
+
+    // Menu options depend on the marked files and the current node
+    m_menuState = m_view->GetMenuSubjects();
+
+    if (m_menuState.m_selected)
+    {
+        if (m_editsAllowed)
+        {
+            MenuMarked(menu);
+            MenuPaste(menu);
+            MenuTransform(menu);
+            MenuAction(menu);
+        }
+        MenuSlideshow(menu);
+        MenuShow(menu);
+        if (!m_editsAllowed)
+            menu->AddItem(tr("Enable Edits"), SLOT(ShowPassword()));
+    }
+
+    // Scan control depends on current status
+    if (m_scanInProgress)
+        menu->AddItem(tr("Stop Scan"), SLOT(StopScan()));
+    else
+        menu->AddItem(tr("Start Scan"), SLOT(StartScan()));
+
+    menu->AddItem(tr("Settings"), SLOT(ShowSettings()));
+
+    MythDialogBox *popup = new MythDialogBox(menu, m_popupStack, "menuPopup");
+    if (popup->Create())
+        m_popupStack->AddScreen(popup);
+    else
+        delete popup;
+}
+
+
+/*!
+ *  \brief  Adds a Marking submenu
+ *  \param  mainMenu Parent menu
+ */
+void GalleryThumbView::MenuMarked(MythMenu *mainMenu)
+{
+    if (m_menuState.m_childCount == 0)
+        return;
+
+    QString title = tr("%1 marked").arg(m_menuState.m_markedId.size());
+
+    MythMenu *menu = new MythMenu(title, this, "markmenu");
+
+    // Mark/unmark selected
+    if (m_menuState.m_selected->IsFile())
+    {
+        if (m_menuState.m_selectedMarked)
+            menu->AddItem(tr("Unmark File"), SLOT(UnmarkItem()));
+        else
+            menu->AddItem(tr("Mark File"), SLOT(MarkItem()));
+    }
+    // Cannot mark/unmark parent dir from this level
+    else if (m_menuState.m_selected->m_type == kSubDirectory)
+    {
+        if (m_menuState.m_selectedMarked)
+            menu->AddItem(tr("Unmark Directory"), SLOT(UnmarkItem()));
+        else
+            menu->AddItem(tr("Mark Directory"), SLOT(MarkItem()));
+    }
+
+    // Mark All if unmarked files exist
+    if (m_menuState.m_markedId.size() < m_menuState.m_childCount)
+        menu->AddItem(tr("Mark All"), SLOT(MarkAll()));
+
+    // Unmark All if marked files exist
+    if (!m_menuState.m_markedId.isEmpty())
+    {
+        menu->AddItem(tr("Unmark All"), SLOT(UnmarkAll()));
+        menu->AddItem(tr("Invert Marked"), SLOT(MarkInvertAll()));
+    }
+
+    mainMenu->AddItem(tr("Mark"), NULL, menu);
+}
+
+
+/*!
+ \brief Add a Paste submenu
+ \param mainMenu Parent menu
+*/
+void GalleryThumbView::MenuPaste(MythMenu *mainMenu)
+{
+    // Can only copy/move into dirs
+    if (m_menuState.m_selected->IsDirectory())
+    {
+        // Operate on current marked files, if any
+        ImageIdList files = m_menuState.m_markedId;
+        if (files.isEmpty())
+            files = m_menuState.m_prevMarkedId;
+        if (files.isEmpty())
+            return;
+
+        QString title = tr("%1 marked").arg(files.size());
+
+        MythMenu *menu = new MythMenu(title, this, "pastemenu");
+
+        menu->AddItem(tr("Move Marked Into"), SLOT(Move()));
+        menu->AddItem(tr("Copy Marked Into"), SLOT(Copy()));
+
+        mainMenu->AddItem(tr("Paste"), NULL, menu);
+    }
+}
+
+
+/*!
+ \brief Add a Transform submenu
+ \param mainMenu Parent menu
+*/
+void GalleryThumbView::MenuTransform(MythMenu *mainMenu)
+{
+    // Operate on marked files, if any, otherwise selected node
+    if (!m_menuState.m_markedId.isEmpty())
+    {
+        QString title = tr("%1 marked").arg(m_menuState.m_markedId.size());
+
+        MythMenu *menu = new MythMenu(title, this, "");
+
+        menu->AddItem(tr("Rotate Marked CW"), SLOT(RotateCWMarked()));
+        menu->AddItem(tr("Rotate Marked CCW"), SLOT(RotateCCWMarked()));
+        menu->AddItem(tr("Flip Marked Horizontal"), SLOT(FlipHorizontalMarked()));
+        menu->AddItem(tr("Flip Marked Vertical"), SLOT(FlipVerticalMarked()));
+        menu->AddItem(tr("Reset Marked to Exif"), SLOT(ResetExifMarked()));
+
+        mainMenu->AddItem(tr("Transforms"), NULL, menu);
+    }
+    else if (m_menuState.m_selected->IsFile())
+    {
+        MythMenu *menu = new MythMenu(m_menuState.m_selected->m_name, this, "");
+
+        menu->AddItem(tr("Rotate CW"), SLOT(RotateCW()));
+        menu->AddItem(tr("Rotate CCW"), SLOT(RotateCCW()));
+        menu->AddItem(tr("Flip Horizontal"), SLOT(FlipHorizontal()));
+        menu->AddItem(tr("Flip Vertical"), SLOT(FlipVertical()));
+        menu->AddItem(tr("Reset to Exif"), SLOT(ResetExif()));
+
+        mainMenu->AddItem(tr("Transforms"), NULL, menu);
+    }
+}
+
+
+/*!
+ \brief Add a Action submenu
+ \param mainMenu Parent menu
+*/
+void GalleryThumbView::MenuAction(MythMenu *mainMenu)
+{
+    MythMenu *menu;
+
+    // Operate on current marked files, if any
+    if (m_menuState.m_markedId.size() > 0)
+    {
+        QString title = tr("%1 marked").arg(m_menuState.m_markedId.size());
+
+        menu = new MythMenu(title, this, "actionmenu");
+
+        // Only offer Hide/Unhide if relevant
+        if (m_menuState.m_unhiddenMarked)
+            menu->AddItem(tr("Hide Marked"), SLOT(HideMarked()));
+        if (m_menuState.m_hiddenMarked)
+            menu->AddItem(tr("Unhide Marked"), SLOT(UnhideMarked()));
+
+        menu->AddItem(tr("Delete Marked"), SLOT(DeleteMarked()));
+    }
+    else
+    {
+        // Operate on selected file/dir
+        menu = new MythMenu(m_menuState.m_selected->m_name, this, "actionmenu");
+
+        // No actions on Base/Up dirs
+        if (m_menuState.m_selected->m_type >= kSubDirectory)
+        {
+            menu->AddItem(tr("Use as Cover"), SLOT(SetCover()));
+
+            if (m_menuState.m_selected->m_isHidden)
+                menu->AddItem(tr("Unhide"), SLOT(Unhide()));
+            else
+                menu->AddItem(tr("Hide"), SLOT(HideItem()));
+
+            menu->AddItem(tr("Delete"), SLOT(DeleteItem()));
+            menu->AddItem(tr("Rename"), SLOT(ShowRenameInput()));
+        }
+        else if (m_menuState.m_selected->m_userThumbnail)
+            menu->AddItem(tr("Reset Cover"), SLOT(ResetCover()));
+
+        // Can only import/mkdir in a dir
+        if (m_menuState.m_selected->IsDirectory())
+        {
+            menu->AddItem(tr("Create Directory"), SLOT(MakeDir()));
+            MenuImport(menu);
+        }
+        menu->AddItem(tr("Eject media"), SLOT(Eject()));
+    }
+
+    mainMenu->AddItem(tr("Actions"), NULL, menu);
+}
+
+
+/*!
+ \brief Add an Import submenu
+ \param mainMenu Parent menu
+*/
+void GalleryThumbView::MenuImport(MythMenu *parent)
+{
+    MythMenu *menu = new MythMenu(tr("Import Options"), this, "importmenu");
+
+    menu->AddItem(tr("By Moving"), SLOT(ShowMoveImport()));
+    menu->AddItem(tr("By Copying"), SLOT(ShowImport()));
+
+    if (gCoreContext->GetNumSetting("GalleryUseImportCmd"))
+        menu->AddItem(tr("Run Import Command"), SLOT(RunImportCmd()));
+
+    parent->AddItem(tr("Import"), NULL, menu);
+}
+
+
+/*!
+ \brief Add a Slideshow submenu
+ \param mainMenu Parent menu
+*/
+void GalleryThumbView::MenuSlideshow(MythMenu *mainMenu)
+{
+    int order = gCoreContext->GetNumSetting("GallerySlideOrder", kOrdered);
+
+    QString ordering;
+    switch (order)
+    {
+    case 0 : ordering = tr("Ordered\n"); break;
+    case 1 : ordering = tr("Shuffled\n"); break;
+    case 2 : ordering = tr("Random\n"); break;
+    case 3 : ordering = tr("Seasonal\n"); break;
+    default: ordering = tr("Unknown ordering\n"); break;
+    }
+
+    MythMenu *menu = new MythMenu(ordering + tr("Slideshow"), this, "SlideshowMenu");
+
+    // Use selected dir or parent, if image selected
+    if (m_menuState.m_selected->IsDirectory())
+    {
+        menu->AddItem(tr("Directory"), SLOT(Slideshow()));
+
+        if (m_menuState.m_selected->m_dirCount > 0)
+            menu->AddItem(tr("Recursive"), SLOT(RecursiveSlideshow()));
+    }
+    else
+        menu->AddItem(tr("Current Directory"), SLOT(Slideshow()));
+
+    MythMenu *orderMenu = new MythMenu(tr("Slideshow Order"), this, "SlideOrderMenu");
+
+    orderMenu->AddItem(tr("Ordered"),  NULL, NULL, order == kOrdered);
+    orderMenu->AddItem(tr("Shuffled"), NULL, NULL, order == kShuffle);
+    orderMenu->AddItem(tr("Random"),   NULL, NULL, order == kRandom);
+    orderMenu->AddItem(tr("Seasonal"), NULL, NULL, order == kSeasonal);
+
+    menu->AddItem(tr("Change Order"), NULL, orderMenu);
+
+    if (gCoreContext->GetNumSetting("GalleryRepeat", 0))
+        menu->AddItem(tr("Turn Repeat Off"), SLOT(RepeatOff()));
+    else
+        menu->AddItem(tr("Turn Repeat On"), SLOT(RepeatOn()));
+
+    mainMenu->AddItem(tr("Slideshow"), NULL, menu);
+}
+
+
+/*!
+ \brief Add a Show submenu
+ \param mainMenu Parent menu
+*/
+void GalleryThumbView::MenuShow(MythMenu *mainMenu)
+{
+    MythMenu *menu = new MythMenu(tr("Show Options"), this, "showmenu");
+
+    int type = gCoreContext->GetNumSetting("GalleryShowType");
+    if (type == kPicAndVideo)
+    {
+        menu->AddItem(tr("Hide Pictures"), SLOT(HidePictures()));
+        menu->AddItem(tr("Hide Videos"), SLOT(HideVideos()));
+    }
+    else
+        menu->AddItem(type == kPicOnly ? tr("Show Videos") : tr("Show Pictures"),
+                      SLOT(ShowType()));
+
+    int show = gCoreContext->GetNumSetting("GalleryShowCaption");
+    if (show != kNoCaption)
+        menu->AddItem(tr("Hide Captions"), SLOT(ShowCaptions()));
+    if (show != kNameCaption)
+        menu->AddItem(tr("Show Name Captions"), SLOT(CaptionsName()));
+    if (show != kDateCaption)
+        menu->AddItem(tr("Show Date Captions"), SLOT(CaptionsDate()));
+    if (show != kUserCaption)
+        menu->AddItem(tr("Show Comment Captions"), SLOT(CaptionsComment()));
+
+    if (gCoreContext->GetNumSetting("GalleryShowHidden"))
+        menu->AddItem(tr("Hide Hidden Files"), SLOT(HideHidden()));
+    else
+        menu->AddItem(tr("Show Hidden Files"), SLOT(ShowHidden()));
+
+    if (m_zoomLevel > 0)
+        menu->AddItem(tr("Zoom Out"), SLOT(ZoomOut()));
+    if (m_zoomLevel < m_zoomWidgets.size() - 1)
+        menu->AddItem(tr("Zoom In"), SLOT(ZoomIn()));
+
+    mainMenu->AddItem(tr("Show"), NULL, menu);
+}
+
+
+/*!
+ \brief Update item that has been selected
+ \param item Buttonlist item
+*/
+void GalleryThumbView::ItemSelected(MythUIButtonListItem *item)
+{
+    ImageItem *im = item->GetData().value<ImageItem *>();
+    if (!im)
+        return;
+
+    // update the position in the node list
+    m_view->Select(im->m_id);
+
+    // Update other widgets
+    SetUiSelection(item);
+}
+
+
+/*!
+ \brief Select item if it is displayed
+ \param id Image id
+*/
+void GalleryThumbView::SelectImage(int id)
+{
+    // Only update selection if image is currently displayed
+    if (m_view->Select(id, -1))
+        BuildImageList();
+}
+
+
+/*!
+ \brief Action item click
+ \param item Buttonlist item
+*/
+void GalleryThumbView::ItemClicked(MythUIButtonListItem *item)
+{
+    if (!item)
+        return;
+
+    ImageItem *im = item->GetData().value<ImageItem *>();
+    if (!im)
+        return;
+
+    switch (im->m_type)
+    {
+        case kBaseDirectory:
+        case kSubDirectory:     DirSelectDown(); break;
+        case kUpDirectory:      DirSelectUp(); break;
+        case kImageFile:
+        case kVideoFile:        StartSlideshow(kBrowseSlides); break;
+    };
+}
+
+
+/*!
+ \brief Action scan request
+ \param start Start scan, if true. Otherwise stop scan
+*/
+void GalleryThumbView::StartScan(bool start)
+{
+    QString err = GalleryBERequest::ScanImagesAction(start);
+    if (!err.isEmpty())
+        ShowOkPopup(err);
+}
+
+
+/*!
+ \brief Start slideshow screen
+ \param mode Browse, Normal or Recursive
+*/
+void GalleryThumbView::StartSlideshow(ImageSlideShowType mode)
+{
+    ImageItem *selected = m_view->GetSelected();
+    if (!selected)
+        return;
+
+    GallerySlideView *slide = new GallerySlideView(m_mainStack, "galleryslideview");
+    if (slide->Create())
+    {
+        m_mainStack->AddScreen(slide);
+
+        // Pass on thumbnail updates
+        connect(this, SIGNAL(ThumbnailChanged(int)),
+                slide, SLOT(ThumbnailChange(int)));
+
+        // Update selected item when slideshow exits
+        connect(slide, SIGNAL(ImageSelected(int)),
+                this, SLOT(SelectImage(int)));
+
+        if (selected->IsDirectory())
+            // Show selected dir
+            slide->Start(mode, selected->m_id);
+        else
+            // Show current dir starting at selection
+            slide->Start(mode, selected->m_parentId, selected->m_id);
+    }
+    else
+        delete slide;
+}
+
+
+/*!
+ *  \brief Goes up one directory level
+ */
+bool GalleryThumbView::DirSelectUp()
+{
+    ImageItem *im = m_view->GetParent();
+    if (im)
+    {
+        // Select the upfolder in the higher dir
+        m_view->Select(im->m_id);
+
+        // Create tree rooted at parent of the kUpFolder directory node
+        LoadData(im->m_parentId);
+    }
+    return true;
+}
+
+
+/*!
+ *  \brief Goes one directory level down
+ */
+void GalleryThumbView::DirSelectDown()
+{
+    ImageItem *im = m_view->GetSelected();
+    if (im)
+        // Create tree rooted at selected item
+        LoadData(im->m_id);
+}
+
+
+/*!
+ \brief Mark or unmark a single item
+ \param mark Mark if true, otherwise unmark
+*/
+void GalleryThumbView::MarkItem(bool mark)
+{
+    ImageItem *im = m_view->GetSelected();
+    if (im)
+    {
+        // Mark/unmark selected item
+        m_view->Mark(im->m_id, mark);
+
+        // Redisplay buttonlist as a parent dir may have been unmarked by this mark
+        BuildImageList();
+    }
+}
+
+
+/*!
+ \brief Mark or unmark all items
+ \param mark Mark if true, otherwise unmark
+*/
+void GalleryThumbView::MarkAll(bool mark)
+{
+    if (mark)
+        m_view->MarkAll();
+    else
+        m_view->ClearMarked();
+
+    // Redisplay buttonlist
+    BuildImageList();
+}
+
+
+/*!
+ \brief Invert all marked items
+*/
+void GalleryThumbView::MarkInvertAll()
+{
+    m_view->InvertMarked();
+
+    // Redisplay buttonlist
+    BuildImageList();
+}
+
+
+/*!
+ \brief Apply transform to an image
+ \param transform Rotation/Flip
+*/
+void GalleryThumbView::TransformItem(ImageFileTransform transform)
+{
+    ImageItem *im = m_view->GetSelected();
+    if (im && m_editsAllowed)
+    {
+        ImageIdList ids;
+        ids.append(im->m_id);
+        QString err = GalleryBERequest::ChangeOrientation(transform, ids);
+        if (!err.isEmpty())
+            ShowOkPopup(err);
+    }
+}
+
+
+/*!
+ \brief Apply transform to marked images
+ \param transform Rotation/Flip
+*/
+void GalleryThumbView::TransformMarked(ImageFileTransform transform)
+{
+    QString err = GalleryBERequest::ChangeOrientation(transform, m_menuState.m_markedId);
+    if (!err.isEmpty())
+        ShowOkPopup(err);
+}
+
+
+/*!
+ \brief Hide or unhide item
+ \param hide Hide if true; otherwise unhide
+*/
+void GalleryThumbView::HideItem(bool hide)
+{
+    if (m_menuState.m_selected)
+    {
+        ImageIdList ids;
+        ids.append(m_menuState.m_selected->m_id);
+
+        QString err = GalleryBERequest::HideFiles(hide, ids);
+        if (!err.isEmpty())
+
+            ShowOkPopup(err);
+
+        else if (hide)
+
+            // Unmark hidden file
+            m_view->Mark(m_menuState.m_selected->m_id, false);
+    }
+}
+
+
+/*!
+ \brief Hide or unhide marked items
+ \param hide Hide if true; otherwise unhide
+*/
+void GalleryThumbView::HideMarked(bool hide)
+{
+    QString err = GalleryBERequest::HideFiles(hide, m_menuState.m_markedId);
+    if (!err.isEmpty())
+
+        ShowOkPopup(err);
+
+    else if (hide)
+
+        // Unmark hidden files
+        foreach (int id, m_menuState.m_markedId)
+        {
+            m_view->Mark(id, false);
+        }
+}
+
+
+/*!
+ \brief Confirm user deletion of an item
+*/
+void GalleryThumbView::DeleteItem()
+{
+    if (m_menuState.m_selected)
+    {
+        ShowDialog(tr("Do you want to delete\n%1 ?").arg(m_menuState.m_selected->m_name),
+                   "ConfirmDelete");
+    }
+}
+
+
+/*!
+ \brief Confirm user deletion of marked files
+*/
+void GalleryThumbView::DeleteMarked()
+{
+    ShowDialog(tr("Do you want to delete all marked files ?"),
+               "ConfirmDeleteMarked");
+}
+
+
+/*!
+ \brief Show configuration screen
+*/
+void GalleryThumbView::ShowSettings()
+{
+    QString oldExclusions = gCoreContext->GetSetting("GalleryIgnoreFilter");
+    int oldSort = gCoreContext->GetNumSetting("GallerySortOrder");
+
+    // Show settings dialog
+    GalleryConfig config = GalleryConfig(m_editsAllowed);
+    config.exec();
+    gCoreContext->ClearSettingsCache();
+
+    QString exclusions = gCoreContext->GetSetting("GalleryIgnoreFilter");
+    int sort = gCoreContext->GetNumSetting("GallerySortOrder");
+
+    if (exclusions != oldExclusions)
+
+        // Exclusions changed: request rescan
+        GalleryBERequest::IgnoreDirs(exclusions);
+
+    else if (sort != oldSort)
+    {
+        // Order changed: Update db view & reload
+        m_db->SetSortOrder(sort);
+        LoadData();
+    }
+}
+
+
+/*!
+ \brief Show or hide hidden files
+ \param show Show hidden, if true. Otherwise hide hidden
+*/
+void GalleryThumbView::ShowHidden(bool show)
+{
+    // Save setting, update db view & reload
+    gCoreContext->SaveSetting("GalleryShowHidden", show);
+    m_db->SetVisibility(show);
+    LoadData();
+}
+
+
+/*!
+ \brief Show or hide captions
+ \param setting None, Names, Dates or Comments
+*/
+void GalleryThumbView::ShowCaptions(int setting)
+{
+    gCoreContext->SaveSetting("GalleryShowCaption", setting);
+    BuildImageList();
+}
+
+
+/*!
+ \brief Show a confirmation dialog
+ \param msg Text to display
+ \param event Event label
+*/
+void GalleryThumbView::ShowDialog(QString msg, QString event)
+{
+    MythConfirmationDialog *popup =
+        new MythConfirmationDialog(m_popupStack, msg, true);
+
+    if (popup->Create())
+    {
+        popup->SetReturnEvent(this, event);
+        m_popupStack->AddScreen(popup);
+    }
+    else
+        delete popup;
+}
+
+
+/*!
+ \brief Show dialog to allow input
+*/
+void GalleryThumbView::ShowRenameInput()
+{
+    if (m_menuState.m_selected)
+    {
+        QString base =
+            QFileInfo(m_menuState.m_selected->m_name).completeBaseName();
+        QString              msg   = tr("Enter a new name for '%1'.").arg(base);
+        MythTextInputDialog *popup =
+            new MythTextInputDialog(m_popupStack, msg, FilterNone, false, base);
+        if (popup->Create())
+        {
+            popup->SetReturnEvent(this, "FileRename");
+            m_popupStack->AddScreen(popup);
+        }
+        else
+            delete popup;
+    }
+}
+
+
+/*!
+ \brief Shows exif info/details about an item
+ */
+void GalleryThumbView::ShowDetails()
+{
+    m_infoList->Toggle(m_view->GetSelected());
+}
+
+
+/*!
+ \brief Displays dialog to accept password
+*/
+void GalleryThumbView::ShowPassword()
+{
+    QString msg = tr("Enter password:");
+    MythTextInputDialog *popup =
+        new MythTextInputDialog(m_popupStack, msg, FilterNone, true);
+    if (popup->Create())
+    {
+        popup->SetReturnEvent(this, "Password");
+        m_popupStack->AddScreen(popup);
+    }
+    else
+        delete popup;
+}
+
+
+/*!
+ \brief Show/hide pictures or videos
+*/
+void GalleryThumbView::ShowType(int type)
+{
+    gCoreContext->SaveSetting("GalleryShowType", type);
+    m_db->SetType(type);
+    LoadData();
+}
+
+
+/*!
+ \brief Set or reset thumbnails to use for a directory cover
+ \param reset Reset cover if true, otherwise assign selected item as cover of parent
+*/
+void GalleryThumbView::SetCover(bool reset)
+{
+    if (m_menuState.m_selected)
+    {
+        QString err = reset
+                ? GalleryBERequest::SetCover(m_menuState.m_selected->m_id, 0)
+                : GalleryBERequest::SetCover(m_menuState.m_selected->m_parentId,
+                                              m_menuState.m_selected->m_id);
+        if (!err.isEmpty())
+            ShowOkPopup(err);
+    }
+}
+
+
+/*!
+ \brief Use larger buttonlist widgets
+*/
+void GalleryThumbView::ZoomOut()
+{
+    SelectZoomWidget(-1);
+    BuildImageList();
+}
+
+
+/*!
+ \brief Use smaller buttonlist widgets
+*/
+void GalleryThumbView::ZoomIn()
+{
+    SelectZoomWidget(1);
+    BuildImageList();
+}
+
+
+/*!
+ \brief Change buttonlist to use a different size
+ \param change Adjustment, +1 to use bigger buttons, -1 for smaller buttons
+*/
+void GalleryThumbView::SelectZoomWidget(int change)
+{
+    m_zoomLevel += change;
+
+    // constrain to zoom levels supported by theme
+    if (m_zoomLevel < 0)
+        m_zoomLevel = 0;
+    if (m_zoomLevel >= m_zoomWidgets.size())
+        m_zoomLevel = m_zoomWidgets.size() - 1;
+
+    // store any requested change, but not constraining adjustments
+    // Thus, changing to a theme with fewer zoom levels will not overwrite the
+    // setting
+    if (change != 0)
+        gCoreContext->SaveSetting("GalleryZoomLevel", m_zoomLevel);
+
+    // dump the current list widget
+    if (m_imageList)
+    {
+        m_imageList->SetVisible(false);
+        disconnect(m_imageList, 0, this, 0);
+    }
+
+    // initialise new list widget
+    m_imageList = m_zoomWidgets.at(m_zoomLevel);
+
+    m_imageList->SetVisible(true);
+    SetFocusWidget(m_imageList);
+
+    // Monitor list actions (after focus events have been ignored)
+    connect(m_imageList, SIGNAL(itemClicked(MythUIButtonListItem *)),
+            SLOT(ItemClicked(MythUIButtonListItem *)));
+    connect(m_imageList, SIGNAL(itemSelected(MythUIButtonListItem *)),
+            SLOT(ItemSelected(MythUIButtonListItem *)));
+}
+
+
+/*!
+ \brief Show dialog to input new directory name
+*/
+void GalleryThumbView::MakeDir()
+{
+    MythTextInputDialog *popup = new MythTextInputDialog(
+        m_popupStack, tr("Enter name of new directory"), FilterNone, false);
+    if (popup->Create())
+    {
+        popup->SetReturnEvent(this, "MakeDir");
+        m_popupStack->AddScreen(popup);
+    }
+    else
+        delete popup;
+}
+
+
+/*!
+ \brief Move marked files to selected dir. If no marked files, use previously
+ marked files
+*/
+void GalleryThumbView::Move()
+{
+    ImageItem *destIm = m_menuState.m_selected;
+
+    // Destination must be a dir
+    if (!destIm || destIm->IsFile())
+        return;
+
+    // Use current markings, if any. Otherwise use previous markings
+    ImageIdList files = m_menuState.m_markedId;
+    if (files.isEmpty())
+        files = m_menuState.m_prevMarkedId;
+    if (files.isEmpty())
+        return;
+
+    // Move files/dirs in clipboard
+    QString err = GalleryBERequest::MoveFiles(destIm->m_id, files);
+    if (!err.isEmpty())
+        ShowOkPopup(err);
+}
+
+
+/*!
+ \brief Copy marked files to selected dir. If no marked files, use previously
+ marked files
+*/
+void GalleryThumbView::Copy()
+{
+    // Destination must be a dir
+    ImageItem *destIm = m_menuState.m_selected;
+    if (!destIm || destIm->IsFile())
+        return;
+
+    // Use current markings, if any. Otherwise use previous markings
+    ImageIdList files = m_menuState.m_markedId;
+    if (files.isEmpty())
+        files = m_menuState.m_prevMarkedId;
+    if (files.isEmpty())
+        return;
+
+    // Get paste files from clipboard
+    QStringList ids;
+    foreach (int id, files)
+        ids.append(QString::number(id));
+
+    // Create new dir subtree & copy all files within it
+
+    // Get all files/dirs in subtree
+    ImageList images, dirs;
+    m_db->ReadDbTree(images, dirs, ids);
+
+    // Determine root dir of marked items
+    ImageItem *baseIm;
+    // Any dirs will be in hierarchial order so root must be derived from first
+    if (!dirs.isEmpty())
+        baseIm = dirs[0];
+    // If no dirs, root can be derived from any image
+    else if (!images.isEmpty())
+        baseIm = images[0];
+    else // should never happen
+        return;
+
+    QDir base = QDir("/" + baseIm->m_path);
+    QDir destDir(destIm->m_id == ROOT_DB_ID ? "" : destIm->m_fileName);
+
+    // Create dir subtree
+    if (!dirs.isEmpty())
+    {
+        // Build list of destination paths for dirs
+        QStringList newDirs;
+        foreach(const ImageItem *im, dirs)
+            newDirs << destDir.filePath(base.relativeFilePath("/" + im->m_fileName));
+
+        qDeleteAll(dirs);
+
+        // Request BE to create directories first
+        QString err = GalleryBERequest::MakeDirs(newDirs);
+        if (!err.isEmpty())
+        {
+            ShowOkPopup(err);
+            return;
+        }
+    }
+
+    // Build map of source & destination paths for each image
+    NameMap transfer;
+    foreach(const ImageItem *im, images)
+    {
+        ImageSg *sg = ImageSg::getInstance();
+        QString srcName  = sg->GenerateUrl(im->m_fileName);
+        QString destName = sg->GenerateUrl(
+            destDir.filePath(base.relativeFilePath("/" + im->m_fileName)));
+        transfer.insert(srcName, destName);
+    }
+
+    qDeleteAll(images);
+
+    // Create progress dialog
+    MythScreenStack      *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUIProgressDialog *progress   =
+        new MythUIProgressDialog(tr("Copying files"), popupStack, "copydialog");
+    if (progress->Create())
+        popupStack->AddScreen(progress, false);
+    else
+        delete progress;
+
+    // Copy files in a separate thread
+    if (RunWorker(new FileTransferWorker(false, transfer, progress)))
+        // Rescan to detect new files
+        GalleryBERequest::ScanImagesAction(true);
+    else
+        ShowOkPopup(tr("Failed to copy files"));
+}
+
+
+/*!
+ \brief Executes user 'Import command'
+*/
+void GalleryThumbView::RunImportCmd()
+{
+    // Replace tokens
+    QString cmd = gCoreContext->GetSetting("GalleryImportCmd");
+    QString dir = gCoreContext->GetSetting("GalleryImportLocation");
+
+    cmd.replace("%DIR%", QString("'%1'").arg(dir));
+
+    if (cmd.contains("%TMPDIR%"))
+    {
+        // Remove previous temp dir
+        delete m_importTmp;
+        // Create temp dir
+        m_importTmp = new QTemporaryDir();
+        if (!m_importTmp->isValid())
+        {
+            ShowOkPopup(QString(tr("Failed to create temporary directory\n%1"))
+                        .arg(m_importTmp->path()));
+            return;
+        }
+
+        cmd.replace("%TMPDIR%", m_importTmp->path());
+    }
+
+    // Run command in a separate thread
+    MythUIBusyDialog *busy = ShowBusyPopup(tr("Running Import command.\nPlease wait..."));
+
+    int error = RunWorker(new ShellWorker(cmd));
+
+    if (busy)
+        busy->Close();
+
+    if (error != 0)
+        ShowOkPopup(QString(tr("Import command failed: Error %1")).arg(error));
+}
+
+
+/*!
+ \brief Show import dialog
+*/
+void GalleryThumbView::ShowImport(bool deleteAfter)
+{
+    m_deleteAfterImport = deleteAfter;
+
+    // Use temp dir if it exists
+    QString start = m_importTmp
+            ? m_importTmp->path()
+            : gCoreContext->GetSetting("GalleryImportLocation", "/media");
+
+    MythScreenStack        *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUIMultiFileBrowser *fb = new MythUIMultiFileBrowser(popupStack, start);
+
+    // Only browse supported image/video files
+    QDir filters(ImageSg::getInstance()->GetImageFilters());
+    fb->SetNameFilter(filters.nameFilters());
+
+    fb->SetTypeFilter(QDir::AllDirs | QDir::Files | QDir::NoSymLinks | QDir::Readable);
+    if (fb->Create())
+    {
+        fb->SetReturnEvent(this, "ImportFilesSelected");
+        popupStack->AddScreen(fb);
+    }
+    else
+        delete fb;
+}
+
+
+/*!
+ \brief Import files into selected dir
+ \param files List of file names
+*/
+void GalleryThumbView::ImportFiles(QStringList files)
+{
+    // Determine destination dir
+    ImageItem *destIm = m_menuState.m_selected;
+
+    // Destination must be a dir
+    if (!destIm || destIm->IsFile())
+        return;
+
+    QDir    destDir(destIm->m_id == ROOT_DB_ID ? "" : destIm->m_fileName);
+
+    // Build map of source & destination paths.
+    // Assumes all files are images; no dirs permitted
+    NameMap transfer;
+    ImageSg *sg = ImageSg::getInstance();
+    foreach(const QString &source, files)
+    {
+        QFileInfo fi(source);
+        QString   destName(sg->GenerateUrl(destDir.filePath(fi.fileName())));
+        transfer.insert(source, destName);
+    }
+
+    // Create progress dialog
+    MythScreenStack      *popupStack = GetMythMainWindow()->GetStack("popup stack");
+    MythUIProgressDialog *progress   =
+        new MythUIProgressDialog(tr("Importing files"),
+                                 popupStack,
+                                 "importdialog");
+    if (progress->Create())
+        popupStack->AddScreen(progress, false);
+    else
+    {
+        delete progress;
+        progress = NULL;
+    }
+
+    // Import files in a separate thread
+    if (RunWorker(new FileTransferWorker(m_deleteAfterImport, transfer, progress)))
+        // Rescan to detect new files
+        GalleryBERequest::ScanImagesAction(true);
+    else
+        ShowOkPopup(tr("Failed to import files"));
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerythumbview.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerythumbview.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerythumbview.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerythumbview.h	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,207 @@
+//! \file
+//! \brief Implements Gallery Thumbnail screen
+
+#ifndef GALLERYVIEW_H
+#define GALLERYVIEW_H
+
+#include <QMap>
+#include <QHash>
+#include <QList>
+#include <QMutex>
+#include <QPair>
+#include <QEvent>
+#include <QKeyEvent>
+#include <QDir>
+
+#if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
+    #include <QTemporaryDir>
+#else
+
+#define DIRNAME "import"
+class QTemporaryDir
+{
+public:
+    QTemporaryDir() : m_dir(QDir::temp())
+    {
+        m_dir.mkdir(DIRNAME);
+        m_dir.cd(DIRNAME);
+    }
+
+    ~QTemporaryDir()
+    {
+        foreach (const QString &name, m_dir.entryList(QDir::Files | QDir::NoDotAndDotDot))
+            m_dir.remove(name);
+        m_dir.cdUp();
+        m_dir.rmdir(DIRNAME);
+    }
+
+    bool isValid() { return m_dir.exists(); }
+    QString path() { return m_dir.absolutePath(); }
+
+private:
+    QDir m_dir;
+};
+
+#endif
+
+#include <mythuitext.h>
+#include <mythuibuttonlist.h>
+#include <mythdialogbox.h>
+#include <imagemetadata.h>
+#include <mythmediamonitor.h>
+
+#include "galleryviews.h"
+#include "galleryslideview.h"
+
+
+
+//! Type of captions to display
+enum ImageCaptionType {
+    kNoCaption   = 0, //!< None
+    kNameCaption = 1, //!< Filenames
+    kDateCaption = 2, //!< Dates
+    kUserCaption = 3  //!< Exif comments
+};
+
+
+//! Thumbnail screen
+class GalleryThumbView : public MythScreenType
+{
+    Q_OBJECT
+public:
+    GalleryThumbView(MythScreenStack *parent, const char *name);
+    ~GalleryThumbView();
+    bool    Create();
+
+public slots:
+    void    Start();
+
+signals:
+    void    ThumbnailChanged(int);
+
+private:
+    bool    keyPressEvent(QKeyEvent *);
+    void    customEvent(QEvent *);
+    void    BuildImageList();
+    void    ResetUiSelection();
+    void    TransformItem(ImageFileTransform tran = kRotateCW);
+    void    TransformMarked(ImageFileTransform tran = kRotateCW);
+    void    UpdateImageItem(MythUIButtonListItem *);
+    void    UpdateScanProgress(QString, QString, QString);
+    void    StartSlideshow(ImageSlideShowType mode);
+    void    SelectZoomWidget(int change);
+    void    ImportFiles(QStringList);
+    void    SetUiSelection(MythUIButtonListItem *);
+    QString CheckThumbnail(MythUIButtonListItem *, ImageItem *,
+                           QStringList &, int = 0);
+    void    UpdateThumbnail(MythUIButtonListItem *, ImageItem *,
+                            const QString &url, int = 0);
+    void    MenuMain();
+    void    MenuShow(MythMenu *);
+    void    MenuMarked(MythMenu *);
+    void    MenuPaste(MythMenu *);
+    void    MenuTransform(MythMenu *);
+    void    MenuAction(MythMenu *);
+    void    MenuImport(MythMenu *);
+    void    MenuSlideshow(MythMenu *);
+    bool    DirSelectUp();
+    void    DirSelectDown();
+    void    ShowDialog(QString, QString = "");
+
+private slots:
+    void    LoadData(int parent = -1);
+    void    SelectImage(int id);
+    void    ItemClicked(MythUIButtonListItem *);
+    void    ItemSelected(MythUIButtonListItem *);
+    void    Slideshow()            { StartSlideshow(kNormalSlideShow); }
+    void    RecursiveSlideshow()   { StartSlideshow(kRecursiveSlideShow); }
+    void    ShowDetails();
+    void    RotateCW()             { TransformItem(kRotateCW); }
+    void    RotateCCW()            { TransformItem(kRotateCCW); }
+    void    FlipHorizontal()       { TransformItem(kFlipHorizontal); }
+    void    FlipVertical()         { TransformItem(kFlipVertical); }
+    void    ResetExif()            { TransformItem(kResetExif); }
+    void    RotateCWMarked()       { TransformMarked(kRotateCW); }
+    void    RotateCCWMarked()      { TransformMarked(kRotateCCW); }
+    void    FlipHorizontalMarked() { TransformMarked(kFlipHorizontal); }
+    void    FlipVerticalMarked()   { TransformMarked(kFlipVertical); }
+    void    ResetExifMarked()      { TransformMarked(kResetExif); }
+    void    MarkItem(bool = true);
+    void    UnmarkItem()           { MarkItem(false); }
+    void    MarkAll(bool = true);
+    void    UnmarkAll()            { MarkAll(false); }
+    void    MarkInvertAll();
+    void    HideItem(bool hide = true);
+    void    Unhide()               { HideItem(false); }
+    void    HideMarked(bool hide = true);
+    void    UnhideMarked()         { HideMarked(false); }
+    void    ShowRenameInput();
+    void    ShowHidden(bool show = true);
+    void    HideHidden()           { ShowHidden(false); }
+    void    SetCover(bool reset = false);
+    void    ResetCover()           { SetCover(true); }
+    void    ShowCaptions(int = kNoCaption);
+    void    CaptionsName()         { ShowCaptions(kNameCaption); }
+    void    CaptionsDate()         { ShowCaptions(kDateCaption); }
+    void    CaptionsComment()      { ShowCaptions(kUserCaption); }
+    void    ShowType(int = kPicAndVideo);
+    void    HidePictures()         { ShowType(kVideoOnly); }
+    void    HideVideos()           { ShowType(kPicOnly); }
+    void    ZoomIn();
+    void    ZoomOut();
+    void    ShowSettings();
+    void    StartScan(bool start = true);
+    void    StopScan()             { StartScan(false); }
+    void    DeleteItem();
+    void    DeleteMarked();
+    void    ShowImport(bool deleteAfter = false);
+    void    ShowMoveImport()           { ShowImport(true); }
+    void    RunImportCmd();
+    void    MakeDir();
+    void    Eject()  { MediaMonitor::GetMediaMonitor()->ChooseAndEjectMedia(); }
+    void    Copy();
+    void    Move();
+    void    ShowPassword();
+    void    RepeatOn(int on = 1)  { gCoreContext->SaveSetting("GalleryRepeat", on); }
+    void    RepeatOff()        { RepeatOn(0); }
+
+private:
+    ImageDbReader     *m_db;
+    DirectoryView     *m_view;
+    MythScreenStack   *m_popupStack,       *m_mainStack;
+    MythUIButtonList  *m_imageList;
+    MythUIText        *m_captionText,      *m_crumbsText;
+    MythUIText        *m_hideFilterText,   *m_typeFilterText;
+    MythUIText        *m_positionText,     *m_emptyText;
+    MythUIText        *m_scanProgressText;
+    MythUIProgressBar *m_scanProgressBar;
+    bool               m_scanInProgress;
+    int                m_zoomLevel;
+
+    //! Image details overlay
+    InfoList *m_infoList;
+
+    //! Current selection/marked files when menu is invoked
+    MenuSubjects m_menuState;
+
+    //! Theme buttonlist widgets implementing zoom levels
+    QList<MythUIButtonList *> m_zoomWidgets;
+
+    //! Buttons waiting for BE to create thumbnail
+    typedef QPair<MythUIButtonListItem *, int> ThumbLocation;
+    QHash<int, ThumbLocation> m_pendingMap;
+
+    //! Urls of images where thumbnails are known to exist
+    QHash<int, QString> m_url;
+
+    //! Edit privileges
+    bool m_editsAllowed;
+
+    //! Distinguishes Import(Copy) from Import(Move)
+    bool m_deleteAfterImport;
+
+    //! Temporary dir for import commands/scripts
+    QTemporaryDir *m_importTmp;
+};
+
+#endif // GALLERYVIEW_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerytransitions.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerytransitions.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerytransitions.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerytransitions.cpp	2015-04-30 11:17:45.422226492 +0200
@@ -0,0 +1,408 @@
+#include "gallerytransitions.h"
+
+#include <QEasingCurve>
+#include <QPoint>
+
+
+/*!
+ \brief Returns the requested transition or an alternative if it is not suitable for
+ the painter
+ \param setting The user selected transition setting
+ \return Transition The transition object or an alternative
+*/
+Transition* TransitionRegistry::Select(int setting)
+{
+    // If chosen transition isn't viable for painter then use previous ones.
+    // First transition ust always be useable by all painters
+    Transition *result = NULL;
+    do
+        result = m_map.value(setting--, NULL);
+    while (setting >= 0 && !result);
+
+    return result;
+}
+
+
+/*!
+ \brief Constructor.
+ \param includeAnimations Whether to use animated transitions (zoom, rotate)
+*/
+TransitionRegistry::TransitionRegistry(bool includeAnimations)
+{
+    // Create all non-animated transitions to be used by Random
+    m_map.insert(kBlendTransition, new TransitionBlend());
+    m_map.insert(kSlideTransition, new TransitionSlide());
+
+    // Create all animated transitions to be used by Random
+    if (includeAnimations)
+    {
+        m_map.insert(kTwistTransition, new TransitionTwist());
+        m_map.insert(kZoomTransition,  new TransitionZoom());
+        m_map.insert(kSpinTransition,  new TransitionSpin());
+    }
+
+    // Create random set
+    m_map.insert(kRandomTransition, new TransitionRandom(m_map));
+
+    // Create all transitions not to be used by Random
+    m_map.insert(kNoTransition, new TransitionNone());
+}
+
+
+/*!
+ \brief Start base transition
+ \param from Image currently displayed
+ \param to Image to be displayed
+ \param forwards Direction
+ \param speed Unused
+*/
+void Transition::Start(Slide *from, Slide *to,
+                       bool forwards, float speed)
+{
+    LOG(VB_FILE, LOG_DEBUG,
+        QString("Transition: Starting transition from %1 to %2 (forwards= %3, speed= %4)")
+        .arg(from->objectName(), to->objectName()).arg(forwards).arg(speed));
+
+    m_old = from;
+    m_new = to;
+
+    // When playing forwards next image replaces prev image
+    // When playing backwards prev image replaces next image
+    m_prev  = forwards ? from : to;
+    m_next = forwards ? to : from;
+
+    // Set up transition
+    Initialise();
+
+    // Make new image visible
+    m_new->SetVisible(true);
+}
+
+
+/*!
+ \brief Transition has completed
+*/
+void Transition::Finished()
+{
+    // Hide old image before it is reset
+    m_old->SetVisible(false);
+
+    // Undo transition effects
+    Finalise();
+
+    emit finished();
+}
+
+
+/*!
+ \brief Switch images
+ \param from Image currently displayed
+ \param to Image to be displayed
+ \param forwards Direction
+ \param speed Factor, 1.0 = real-time
+*/
+void TransitionNone::Start(Slide *from, Slide *to,
+                           bool forwards, float speed)
+{
+    Transition::Start(from, to, forwards, speed);
+
+    // Finish immediately
+    Finished();
+}
+
+
+/*!
+ \brief Create group transition
+ \param animation Group animation
+*/
+GroupTransition::GroupTransition(GroupAnimation *animation, QString name)
+    : Transition(name), m_animation(animation)
+{
+    // Complete transition when the group finishes
+    connect(m_animation, SIGNAL(finished()), this, SLOT(Finished()));
+}
+
+
+/*!
+ \brief Destroy group transition
+
+*/
+GroupTransition::~GroupTransition()
+{
+    // Group owns animation
+    delete m_animation;
+}
+
+
+/*!
+ \brief Start group transition
+ \param from Image currently displayed
+ \param to Image to be displayed
+ \param forwards Direction
+ \param speed Factor, 1.0 = real-time
+*/
+void GroupTransition::Start(Slide *from, Slide *to,
+                            bool forwards, float speed)
+{
+    // Clear previous transition
+    m_animation->Clear();
+
+    Transition::Start(from, to, forwards, speed);
+
+    // Start group
+    if (m_animation)
+        m_animation->Start(forwards, speed);
+}
+
+
+/*!
+ \brief Change transition speed
+ \param speed Factor, 1x, 2x etc.
+*/
+void GroupTransition::SetSpeed(float speed)
+{
+    if (m_animation)
+    {
+        LOG(VB_FILE, LOG_DEBUG, QString("Transition: Changing speed to %1").arg(speed));
+        m_animation->SetSpeed(speed);
+    }
+}
+
+
+/*!
+ \brief Update group transition
+ \param interval Millisecs since last update
+*/
+void GroupTransition::Pulse(int interval)
+{
+    if (m_animation)
+        m_animation->Pulse(interval);
+}
+
+
+/*!
+ \brief Set up Blend transition
+*/
+void TransitionBlend::Initialise()
+{
+    // Fade out prev image
+    Animation *oldPic = new Animation(m_prev, Animation::Alpha);
+    oldPic->Set(255, 0, m_duration, QEasingCurve::InOutQuad);
+    m_animation->Add(oldPic);
+
+    // Fade in next image
+    Animation *newPic = new Animation(m_next, Animation::Alpha);
+    newPic->Set(0, 255, m_duration, QEasingCurve::InOutQuad);
+    m_animation->Add(newPic);
+
+    // Hide new image until it's needed
+    m_new->SetAlpha(0);
+}
+
+
+/*!
+ \brief Reset Blend transition
+*/
+void TransitionBlend::Finalise()
+{
+    // Undo effects of the transition
+    m_old->SetAlpha(255);
+}
+
+
+/*!
+ \brief Set up Twist transition
+*/
+void TransitionTwist::Initialise()
+{
+    // Reduce hzoom of left image to nothing
+    Animation *oldPic = new Animation(m_prev, Animation::HorizontalZoom);
+    oldPic->Set(1.0, 0.0, m_duration / 2, QEasingCurve::InQuart);
+    m_animation->Add(oldPic);
+
+    // Increase hzoom of right image from nothing to full
+    Animation *newPic = new Animation(m_next, Animation::HorizontalZoom);
+    newPic->Set(0.0, 1.0, m_duration / 2, QEasingCurve::OutQuart);
+    m_animation->Add(newPic);
+
+    // Hide new image until it's needed
+    m_new->SetHorizontalZoom(0);
+}
+
+
+/*!
+ \brief Reset Twist transition
+*/
+void TransitionTwist::Finalise()
+{
+    // Undo effects of the transition
+    m_old->SetHorizontalZoom(1.0);
+}
+
+
+/*!
+ \brief Set up Slide transition
+*/
+void TransitionSlide::Initialise()
+{
+    // Both images are same size
+    int width = m_old->GetArea().width();
+
+    // Slide off to left
+    Animation *oldPic = new Animation(m_prev, Animation::Position);
+    oldPic->Set(QPoint(0, 0), QPoint(-width, 0), m_duration, QEasingCurve::InOutQuart);
+    m_animation->Add(oldPic);
+
+    // Slide in from right
+    Animation *newPic = new Animation(m_next, Animation::Position);
+    newPic->Set(QPoint(width, 0), QPoint(0, 0), m_duration, QEasingCurve::InOutQuart);
+    m_animation->Add(newPic);
+
+    // Hide new image until it's needed
+    m_new->SetPosition(width, 0);
+}
+
+
+/*!
+ \brief Reset Slide transition
+*/
+void TransitionSlide::Finalise()
+{
+    // Undo effects of the transition
+    m_old->SetPosition(0,0);
+}
+
+
+/*!
+ \brief Set up Zoom transition
+*/
+void TransitionZoom::Initialise()
+{
+    // Both images are same size
+    int width = m_old->GetArea().width();
+
+    // Zoom away to left
+    Animation *oldZoom = new Animation(m_prev, Animation::Zoom);
+    oldZoom->Set(1.0, 0.0, m_duration, QEasingCurve::OutQuad);
+    m_animation->Add(oldZoom);
+
+    Animation *oldMove = new Animation(m_prev, Animation::Position);
+    oldMove->Set(QPoint(0, 0), QPoint(-width / 2, 0), m_duration,
+                 QEasingCurve::InQuad);
+    m_animation->Add(oldMove);
+
+    // Zoom in from right
+    Animation *newZoom = new Animation(m_next, Animation::Zoom);
+    newZoom->Set(0.0, 1.0, m_duration, QEasingCurve::InQuad);
+    m_animation->Add(newZoom);
+
+    Animation *newMove = new Animation(m_next, Animation::Position);
+    newMove->Set(QPoint(width / 2, 0), QPoint(0, 0), m_duration,
+                 QEasingCurve::OutQuad);
+    m_animation->Add(newMove);
+
+    // Hide new image until it's needed
+    m_new->SetZoom(0.0);
+}
+
+
+/*!
+ \brief Reset Zoom transition
+
+*/
+void TransitionZoom::Finalise()
+{
+    // Undo effects of the transition
+    m_old->SetZoom(1.0);
+    m_old->SetPosition(0, 0);
+}
+
+
+/*!
+ \brief Set up Spin transition
+*/
+void TransitionSpin::Initialise()
+{
+    // Set up blend
+    TransitionBlend::Initialise();
+
+    // Add simultaneous spin
+    Animation *an = new Animation(m_prev, Animation::Angle);
+    an->Set(0.0, 360.1, m_duration, QEasingCurve::InOutQuad);
+    m_animation->Add(an);
+
+    an = new Animation(m_next, Animation::Angle);
+    an->Set(0.0, 360.1, m_duration, QEasingCurve::InOutQuad);
+    m_animation->Add(an);
+
+    // Zoom prev away, then back
+    SequentialAnimation *seq = new SequentialAnimation();
+    m_animation->Add(seq);
+
+    an = new Animation(m_prev, Animation::Zoom);
+    an->Set(1.0, 0.5, m_duration / 2, QEasingCurve::InOutQuad);
+    seq->Add(an);
+
+    an = new Animation(m_prev, Animation::Zoom);
+    an->Set(0.5, 1.0, m_duration / 2, QEasingCurve::InOutQuad);
+    seq->Add(an);
+
+    // Zoom next away, then back
+    seq = new SequentialAnimation();
+    m_animation->Add(seq);
+
+    an = new Animation(m_next, Animation::Zoom);
+    an->Set(1.0, 0.5, m_duration / 2, QEasingCurve::InOutQuad);
+    seq->Add(an);
+
+    an = new Animation(m_next, Animation::Zoom);
+    an->Set(0.5, 1.0, m_duration / 2, QEasingCurve::InOutQuad);
+    seq->Add(an);
+}
+
+
+/*!
+ \brief Reset Spin transition
+
+*/
+void TransitionSpin::Finalise()
+{
+    // Undo blend
+    TransitionBlend::Finalise();
+
+    // Undo effects of the transition
+    m_old->SetZoom(1.0);
+    m_old->SetAngle(0.0);
+}
+
+
+/*!
+ \brief Starts a random transition from a set of its peer transitions,
+ \param from Image currently displayed
+ \param to Image to be displayed
+ \param forwards Direction
+ \param speed Unused
+*/
+void TransitionRandom::Start(Slide *from, Slide *to, bool forwards, float speed)
+{
+    // Select a random peer.
+    int rand = qrand() % m_peers.size();
+    m_current = m_peers[rand];
+    // Invoke peer
+    connect(m_current, SIGNAL(finished()), this, SLOT(Finished()));
+    m_current->Start(from, to, forwards, speed);
+}
+
+
+/*!
+ \brief Invoked when peer transition completes
+*/
+void TransitionRandom::Finished()
+{
+    // Clean up
+    disconnect(m_current, 0, 0, 0);
+    m_current = NULL;
+    emit finished();
+}
+
+
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerytransitions.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerytransitions.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerytransitions.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerytransitions.h	2015-04-30 11:17:45.425559811 +0200
@@ -0,0 +1,193 @@
+//! \file
+//! \brief Provides transitions for slideshows
+
+#ifndef GALLERYTRANSITIONS_H
+#define GALLERYTRANSITIONS_H
+
+#include <QMap>
+#include <QList>
+
+#include <mythcorecontext.h>
+
+#include "galleryslide.h"
+
+
+//! Available transitions
+enum ImageTransitionType {
+    // First transition must be useable by all painters
+    kNoTransition      = 0,
+    kRandomTransition  = 1,
+    kBlendTransition   = 2,
+    kTwistTransition   = 3,
+    kSlideTransition   = 4,
+    kZoomTransition    = 5,
+    kSpinTransition    = 6,
+};
+
+
+//! Base class of an animated transition that can be accelerated & reversed
+class Transition : public QObject
+{
+    Q_OBJECT
+public:
+    Transition(QString name)
+        : m_duration(gCoreContext->GetNumSetting("GalleryTransitionTime", 1000)),
+          m_name(name)                 {}
+    virtual ~Transition()              {}
+
+    virtual void Start(Slide *from, Slide *to, bool forwards, float speed = 1.0);
+    virtual void SetSpeed(float speed) {}
+    virtual void Pulse(int interval)   = 0;
+    virtual void Initialise()          {}
+    virtual void Finalise()            {}
+    QString GetName()                  { return m_name; }
+
+protected slots:
+    virtual void Finished();
+
+signals:
+    void         finished();
+
+protected:
+    //! Seconds transition will last
+    int m_duration;
+    //! The image currently displayed, which will be replaced
+    //! (whatever the transition direction)
+    Slide *m_old;
+    //! The new image that will replace the current one
+    //! (whatever the transition direction)
+    Slide *m_new;
+    // Transitions play forwards or backwards. Symmetric transitions can
+    // define a one-way transition in terms of "prev" & "next" (as in
+    // position rather than time). The reverse transition can then be
+    // achieved by playing it backwards.
+    // When played forwards next replaces prev, ie. prev = old, next = new
+    // When played backwards prev replaces next, ie. prev = new, next = old
+    //! The image occurring earlier in the slideshow sequence
+    Slide *m_prev;
+    //! The image occurring later in the slideshow sequence
+    Slide *m_next;
+    //! Name that appears in settings
+    QString m_name;
+};
+
+
+typedef QMap<int, Transition*> TransitionMap;
+
+
+//! Switches images instantly with no effects
+class TransitionNone : public Transition
+{
+public:
+    TransitionNone() : Transition("None") {}
+    virtual void Start(Slide *from, Slide *to,
+                       bool forwards, float speed = 1.0);
+    virtual void Pulse(int) {}
+};
+
+
+//! Abstract class implementing sequential & parallel animations
+class GroupTransition : public Transition
+{
+public:
+    GroupTransition(GroupAnimation *animation, QString name);
+    virtual ~GroupTransition();
+    virtual void Start(Slide *from, Slide *to,
+                       bool forwards, float speed = 1.0);
+    virtual void SetSpeed(float speed);
+    virtual void Pulse(int interval);
+    virtual void Initialise() = 0;
+    virtual void Finalise()    = 0;
+
+protected:
+    GroupAnimation *m_animation;
+};
+
+
+//! Image blends into the next by fading
+class TransitionBlend : public GroupTransition
+{
+public:
+    TransitionBlend() : GroupTransition(new ParallelAnimation(), tr("Blend")) {}
+    virtual void Initialise();
+    virtual void Finalise();
+};
+
+
+//! Image twists into the next
+class TransitionTwist : public GroupTransition
+{
+public:
+    TransitionTwist() : GroupTransition(new SequentialAnimation(), tr("Twist")) {}
+    virtual void Initialise();
+    virtual void Finalise();
+};
+
+
+//! Slide on from right, then off to left
+class TransitionSlide : public GroupTransition
+{
+public:
+    TransitionSlide() : GroupTransition(new ParallelAnimation(), tr("Slide")) {}
+    virtual void Initialise();
+    virtual void Finalise();
+};
+
+
+//! Zooms from right, then away to left
+class TransitionZoom : public GroupTransition
+{
+public:
+    TransitionZoom() : GroupTransition(new ParallelAnimation(), tr("Zoom")) {}
+    virtual void Initialise();
+    virtual void Finalise();
+};
+
+
+//! Images blend whilst rotating
+class TransitionSpin : public TransitionBlend
+{
+public:
+    TransitionSpin() : TransitionBlend() { m_name = tr("Spin"); }
+    virtual void Initialise();
+    virtual void Finalise();
+};
+
+
+//! Invokes random transitions
+class TransitionRandom : public Transition
+{
+    Q_OBJECT
+public:
+    TransitionRandom(TransitionMap peers) : Transition(tr("Random")),
+          m_peers(peers.values()), m_current(NULL) {}
+    virtual void Start(Slide *from, Slide *to,
+                       bool forwards, float speed = 1.0);
+    virtual void Pulse(int interval) { if (m_current) m_current->Pulse(interval); }
+    virtual void Initialise()        { if (m_current) m_current->Initialise(); }
+    virtual void Finalise()          { if (m_current) m_current->Finalise(); }
+
+protected slots:
+    void Finished();
+
+protected:
+    QList<Transition*> m_peers;
+    Transition *m_current;
+};
+
+
+//! Manages transitions available to s psinter
+class TransitionRegistry
+{
+public:
+    TransitionRegistry(bool includeAnimations);
+    ~TransitionRegistry()    { qDeleteAll(m_map); }
+    const TransitionMap GetAll() { return m_map; }
+    Transition *Select(int setting);
+
+private:
+    TransitionMap m_map;
+};
+
+
+#endif // GALLERYTRANSITIONS_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerytypedefs.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerytypedefs.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerytypedefs.h	2015-04-30 11:09:02.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerytypedefs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
-#ifndef TYPEDEFS_H
-#define TYPEDEFS_H
-
-
-
-enum ImageLoadStatusType {
-    kStatusOk           = 0,
-    kStatusNoFiles      = 1,
-    kStatusNoBaseDir    = 2
-};
-
-
-enum ImageNodeState {
-    kNodeStateSelect    = 0,
-    kNodeStateDeselect  = 1,
-    kNodeStateInvert    = 2,
-    kNodeStateVisible   = 3,
-    kNodeStateInvisible = 4
-};
-
-
-enum ImageSlideShowType {
-    kNoSlideShow            = 0,
-    kNormalSlideShow        = 1,
-    kRandomSlideShow        = 2,
-    kNormalRecSlideShow     = 3,
-    kRandomRecSlideShow     = 4
-};
-
-
-enum ImageTransitionType {
-    kNoTransition = 0,
-    kFade = 1
-};
-
-
-#endif // TYPEDEFS_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryview.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryview.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryview.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryview.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1354 +0,0 @@
-
-#include "galleryview.h"
-
-// Qt headers
-
-// MythTV headers
-#include "mythcontext.h"
-
-#include "galleryconfig.h"
-#include "gallerytypedefs.h"
-#include "imagescan.h"
-#include "mythuihelper.h"
-
-
-/** \fn     GalleryView::GalleryView(MythScreenStack *, const char *)
- *  \brief  Constructor
- *  \param  parent The screen parent
- *  \param  name The name of the screen
- *  \return void
- */
-GalleryView::GalleryView(MythScreenStack *parent, const char *name)
-    : MythScreenType(parent, name),
-      m_menuPopup(NULL),
-      m_confirmPopup(NULL),
-      m_inputPopup(NULL),
-      m_imageList(NULL),
-      m_captionText(NULL),
-      m_crumbsText(NULL),
-      m_positionText(NULL),
-      m_imageText(NULL),
-      m_syncProgressText(NULL),
-      m_thumbProgressText(NULL)
-{
-    gCoreContext->addListener(this);
-
-    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
-    m_mainStack = GetMythMainWindow()->GetMainStack();
-
-    // interface between the frontend and the data
-    m_galleryViewHelper = new GalleryViewHelper(this);
-
-    // Fetches the syncronization status in the
-    // background and updates a theme widget
-    m_syncStatusThread = new GallerySyncStatusThread();
-
-    connect(m_syncStatusThread,  SIGNAL(UpdateSyncProgress(int, int)),
-            this,   SLOT(UpdateSyncProgress(int, int)));
-
-    connect(m_syncStatusThread,  SIGNAL(SyncComplete()),
-            this,   SLOT(ResetSyncProgress()));
-
-    // Start the sync status thread so that an already
-    // running  background sync can be seen
-    m_syncStatusThread->start();
-}
-
-
-
-/** \fn     GalleryView::~GalleryView()
- *  \brief  Destructor
- *  \return void
- */
-GalleryView::~GalleryView()
-{
-    gCoreContext->removeListener(this);
-
-    if (m_syncStatusThread)
-    {
-        m_syncStatusThread->quit();
-        m_syncStatusThread->wait();
-        delete m_syncStatusThread;
-        m_syncStatusThread = NULL;
-    }
-
-    if (m_galleryViewHelper)
-    {
-        delete m_galleryViewHelper;
-        m_galleryViewHelper = NULL;
-    }
-}
-
-
-
-/** \fn     GalleryView::Create()
- *  \brief  Initialises and shows the graphical elements
- *  \return True if successful, otherwise false
- */
-bool GalleryView::Create()
-{
-    if (!LoadWindowFromXML("image-ui.xml", "gallery", this))
-        return false;
-
-    bool err = false;
-    UIUtilE::Assign(this, m_imageList,     "images", &err);
-    UIUtilW::Assign(this, m_captionText,   "title");
-    UIUtilW::Assign(this, m_imageText,     "noimages");
-    UIUtilW::Assign(this, m_positionText,  "position");
-    UIUtilW::Assign(this, m_crumbsText,    "breadcrumbs");
-
-    UIUtilW::Assign(this, m_syncProgressText, "syncprogresstext");
-    UIUtilW::Assign(this, m_thumbProgressText, "thumbprogresstext");
-
-    if (err)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "Cannot load screen 'gallery'");
-        return false;
-    }
-
-    if (m_syncProgressText)
-        m_syncProgressText->SetVisible(false);
-
-    if (m_thumbProgressText)
-        m_thumbProgressText->SetVisible(false);
-
-    BuildFocusList();
-    SetFocusWidget(m_imageList);
-
-    // connect the widgets with their slot methods
-    connect(m_imageList, SIGNAL(itemClicked(MythUIButtonListItem *)),
-            SLOT(ItemSelected(MythUIButtonListItem *)));
-    connect(m_imageList, SIGNAL(itemSelected(MythUIButtonListItem *)),
-            SLOT(UpdateImageItem(MythUIButtonListItem *)));
-
-    return true;
-}
-
-
-
-/** \fn     GalleryView::keyPressEvent(QKeyEvent *)
- *  \brief  Translates the keypresses and keys bound to the
- *          plugin to specific actions within the plugin
- *  \param  event The pressed key
- *  \return True if key was used, otherwise false
- */
-bool GalleryView::keyPressEvent(QKeyEvent *event)
-{
-    if (GetFocusWidget()->keyPressEvent(event))
-        return true;
-
-    bool handled = false;
-    QStringList actions;
-    handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
-
-    for (int i = 0; i < actions.size() && !handled; i++)
-    {
-        QString action = actions[i];
-        handled = true;
-
-        if (action == "MENU")
-            MenuMain();
-        else if (action == "INFO")
-            MenuInformation();
-        else if (action == "ROTRIGHT")
-            FileRotateCW();
-        else if (action == "ROTLEFT")
-            FileRotateCCW();
-        else if (action == "FLIPHORIZONTAL")
-            FileFlipHorizontal();
-        else if (action == "FLIPVERTICAL")
-            FileFlipVertical();
-        else if (action == "ZOOMIN")
-            FileZoomIn();
-        else if (action == "ZOOMOUT")
-            FileZoomOut();
-        else if (action == "SLIDESHOW")
-            ShowFiles();
-        else if (action == "RANDOMSHOW")
-            ShowRandomFiles();
-        else if (action == "MARK")
-        {
-            ImageMetadata *im = GetImageMetadataFromSelectedButton();
-            if (im)
-            {
-                if (im->m_selected)
-                    FileSelectOne();
-                else
-                    FileDeselectOne();
-            }
-        }
-        else if (action == "ESCAPE")
-        {
-            // If the jumppoint is not active and the first node is of
-            // the type kUpFolder then allow going up one directory
-            if (!GetMythMainWindow()->IsExitingToMain())
-            {
-                ImageMetadata *data = m_galleryViewHelper->GetImageMetadataFromNode(0);
-                if (data && data->m_type == kUpDirectory)
-                    handled = DirSelectUp();
-                else
-                    handled = false;
-            }
-            else
-                handled = false;
-        }
-        else
-            handled = false;
-    }
-
-    if (!handled && MythScreenType::keyPressEvent(event))
-        handled = true;
-
-    return handled;
-}
-
-
-
-/** \fn     GalleryView::customEvent(QEvent *)
- *  \brief  Translates the keypresses to specific actions within the plugin
- *  \param  event The custom event
- *  \return void
- */
-void GalleryView::customEvent(QEvent *event)
-{
-    if ((MythEvent::Type)(event->type()) == MythEvent::MythEventMessage)
-    {
-        MythEvent *me = (MythEvent *)event;
-        QString message = me->Message();
-
-        if (message.startsWith("IMAGE_THUMB_CREATED"))
-        {
-            QStringList tokens = message.simplified().split(" ");
-            int fileid = 0;
-            if (tokens.size() >= 2)
-            {
-                fileid = tokens[1].toUInt();
-
-                // update all widgets using this image
-                QList<MythUIButtonListItem*> itemList = m_imageMap.values(fileid);
-
-                for (int i = 0; i < itemList.size(); ++i)
-                {
-                    MythUIButtonListItem *item = itemList.at(i);
-                    if (!item)
-                        continue;
-
-                    ImageMetadata *im = GetImageMetadataFromButton(item);
-                    if (!im)
-                        continue;
-
-                    UpdateThumbnail(item, im, true);
-                }
-            }
-        }
-    }
-    else if (event->type() == DialogCompletionEvent::kEventType)
-    {
-        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
-
-        QString resultid  = dce->GetId();
-        int     buttonnum = dce->GetResult();
-
-        if (resultid == "filerename")
-        {
-            QString newName = dce->GetResultText();
-            FileRename(newName);
-        }
-        else if (buttonnum == 1)
-        {
-            // Confirm current file deletion
-            if (resultid == "confirmdelete")
-            {
-                m_galleryViewHelper->DeleteCurrentNode();
-                UpdateImageList();
-            }
-            // Confirm all selected file deletion
-            else if (resultid == "confirmdeleteselected")
-            {
-                m_galleryViewHelper->DeleteSelectedNodes();
-                UpdateImageList();
-            }
-            // Synchronize the database
-            else if (resultid == "confirmstartsync")
-            {
-                // Start the sync, the API call will
-                // check if a sync is running already
-                m_galleryViewHelper->m_fileHelper->StartSyncImages();
-
-                if (!m_syncStatusThread->isRunning())
-                    m_syncStatusThread->start();
-            }
-            // Stop the database sync
-            else if (resultid == "confirmstopsync" && buttonnum == 1)
-            {
-                if (m_syncStatusThread->isRunning())
-                    m_syncStatusThread->quit();
-
-                m_galleryViewHelper->m_fileHelper->StopSyncImages();
-            }
-        }
-    }
-}
-
-
-
-/** \fn     GalleryView::ResetImageItems()
- *  \brief  Resets the image related widgets by clearing all
-            visible items and removing any shown text.
- *  \return void
- */
-void GalleryView::ResetImageItems()
-{
-    m_imageList->Reset();
-    m_imageMap.clear();
-
-    if (m_positionText)
-        m_positionText->Reset();
-
-    if (m_captionText)
-        m_captionText->Reset();
-
-    if (m_crumbsText)
-        m_crumbsText->Reset();
-}
-
-
-
-/** \fn     GalleryView::LoadData()
- *  \brief  Loads the available data from the database.
-            If there is no data available the user needs to rescan.
- *  \return void
- */
-void GalleryView::LoadData()
-{
-    ResetImageItems();
-
-    m_imageText->SetText("Loading available images...");
-    m_imageText->SetVisible(true);
-    m_imageList->SetVisible(false);
-
-    // loads the data from the database at the specified path
-    int status = m_galleryViewHelper->LoadData();
-
-    switch (status)
-    {
-    case kStatusNoBaseDir:
-        m_imageText->SetText("No image storage group has been defined.\n"
-                             "Please check the stoage group settings\n"
-                             "and the directory permissions.");
-        break;
-    case kStatusNoFiles:
-        m_imageText->SetText("No images in the database found.\n"
-                             "You need to scan for new images.");
-        break;
-    case kStatusOk:
-        m_imageText->SetText("");
-        m_imageText->SetVisible(false);
-        m_imageList->SetVisible(true);
-
-        // set the first node as the selected node
-        m_galleryViewHelper->m_currentNode->setSelectedChild(m_galleryViewHelper->m_currentNode->getChildAt(0));
-
-        // loads the data from the MythGenericTree into the image list
-        UpdateImageList();
-        break;
-    }
-}
-
-
-
-/** \fn     GalleryView::UpdateImageList()
- *  \brief  Updates the visible items
- *  \return void
- */
-void GalleryView::UpdateImageList()
-{
-    m_imageList->Reset();
-    m_imageMap.clear();
-
-    // get all children from the the selected node
-    MythGenericTree *selectedNode = m_galleryViewHelper->m_currentNode->getSelectedChild();
-    QList<MythGenericTree *> *childs = m_galleryViewHelper->m_currentNode->getAllChildren();
-
-    // go through the entire list and update
-    QList<MythGenericTree *>::const_iterator it;
-    for (it = childs->begin(); it != childs->end(); ++it)
-    {
-        if (*it != NULL)
-        {
-            MythUIButtonListItem *item = new MythUIButtonListItem(
-                    m_imageList, QString(), 0,
-                    true, MythUIButtonListItem::NotChecked);
-            item->SetData(qVariantFromValue(*it));
-
-            // assign and display all information about
-            // the current item, like title and subdirectory count
-            UpdateImageItem(item);
-
-            // set the currently active node as selected in the image list
-            if (*it == selectedNode)
-                m_imageList->SetItemCurrent(item);
-        }
-    }
-
-    // when the UpdateImageItem method is called the current node will also
-    // be set to the current image item. After updating all items in the
-    // image list we need to set the current node back to the on it was before
-    m_galleryViewHelper->m_currentNode->setSelectedChild(selectedNode);
-
-    // Updates all other widgets on the screen that show
-    // information about the selected MythUIButtonListItem
-    UpdateText(m_imageList->GetItemCurrent());
-}
-
-
-
-/** \fn     GalleryView::UpdateImageItem(MythUIButtonListItem *)
- *  \brief  Updates the visible representation of a MythUIButtonListItem
- *  \param  item The item that shall be updated
- *  \return void
- */
-void GalleryView::UpdateImageItem(MythUIButtonListItem *item, bool recreateThumb)
-{
-    if (!item)
-        return;
-
-    MythGenericTree *node = item->GetData().value<MythGenericTree *>();
-    if (!node)
-        return;
-
-    // update the position in the node list
-    m_galleryViewHelper->m_currentNode->setSelectedChild(node);
-
-    ImageMetadata *im = node->GetData().value<ImageMetadata *>();
-    if (!im)
-        return;
-
-    // Depending what the themer has done, display a small
-    // icon that shows if the current item is a file or a folder
-    // Also show an additional background image if required. This is
-    // primarily useful when the item is a folder and a folder background
-    // image shall be shown behind the small preview thumbnail images
-    switch (im->m_type)
-    {
-    case kSubDirectory:
-
-        item->SetText(QString::number(im->m_dirCount), "childcount");
-
-        if (im->m_fileCount > 0)
-            item->SetText(QString("%1/%2")
-                          .arg(im->m_dirCount)
-                          .arg(im->m_fileCount), "childcount");
-
-        item->DisplayState("subfolder", "nodetype");
-        break;
-
-    case kUpDirectory:
-        item->DisplayState("upfolder", "nodetype");
-        break;
-
-    case kImageFile:
-        item->DisplayState("image", "nodetype");
-        break;
-
-    case kVideoFile:
-        item->DisplayState("video", "nodetype");
-        break;
-
-    default:
-        break;
-    }
-
-    // set the image as hidden or visible
-    QString state = (im->m_isHidden) ? "hidden" : "visible";
-    item->DisplayState(state, "nodevisibility");
-
-    item->SetText(im->m_name, "title");
-    item->SetText(im->m_name);
-
-    // set the image as selected
-    item->setChecked(MythUIButtonListItem::NotChecked);
-    item->DisplayState("off", "nodecheck");
-    if (im->m_selected)
-    {
-        item->setChecked(MythUIButtonListItem::FullChecked);
-        item->DisplayState("full", "nodecheck");
-    }
-
-    // update the other widgets in the screen
-    if (item == m_imageList->GetItemCurrent())
-        UpdateText(item);
-
-    // register widget as a user of its images
-    for (int i = 0; i < im->m_thumbFileIdList.size(); ++i)
-        m_imageMap.insert(im->m_thumbFileIdList.at(i), item);
-
-    if (recreateThumb)
-        // remove cache image to force a reload
-        GetMythUI()->RemoveFromCacheByFile(im->m_thumbFileNameList->at(0));
-
-    // set the thumbnail image
-    UpdateThumbnail(item, im, recreateThumb);
-}
-
-
-/** \fn     GalleryView::UpdateThumbnail(MythUIButtonListItem *)
- *  \brief  Updates the thumbnail image of the given item
- *  \param  item The item that shall be updated
- *  \return void
- */
-void GalleryView::UpdateThumbnail(MythUIButtonListItem *item,
-                                  ImageMetadata *im,
-                                  bool forceReload)
-{
-    if (item && im)
-    {
-        // directories show multiple thumbnails
-        if (im->m_type == kUpDirectory || im->m_type == kSubDirectory)
-        {
-            for (int i = 0; i < im->m_thumbFileNameList->size(); ++i)
-                item->SetImage(im->m_thumbFileNameList->at(i),
-                               QString("thumbimage%1").arg(i+1), forceReload);
-        }
-        else
-            item->SetImage(im->m_thumbFileNameList->at(0), "", forceReload);
-    }
-}
-
-
-/** \fn     GalleryView::ResetThumbnailProgress()
- *  \brief  Resets the status of the progress text
- *  \return void
- */
-void GalleryView::ResetThumbnailProgress()
-{
-    if (m_thumbProgressText)
-        m_thumbProgressText->SetVisible(false);
-}
-
-
-
-/** \fn     GalleryView::ResetSyncProgress()
- *  \brief  Resets the status of the progress text
- *  \return void
- */
-void GalleryView::ResetSyncProgress()
-{
-    if (m_syncProgressText)
-        m_syncProgressText->SetVisible(false);
-
-    LoadData();
-}
-
-
-
-/** \fn     GalleryView::UpdateThumbnailProgress(int, int)
- *  \brief  Updates the dialog that shows the thumbnail creation progress
- *  \param  remaining The number of thumbnail still to be created
- *  \param  total The overall number of thumbnail that will be created
- *  \return void
- */
-void GalleryView::UpdateThumbnailProgress(int remaining, int total)
-{
-    int current = total - remaining;
-
-    if (m_thumbProgressText)
-    {
-        m_thumbProgressText->SetVisible(true);
-        m_thumbProgressText->SetText(QString("%1 %2 %3")
-                                     .arg(current)
-                                     .arg(tr("of"))
-                                     .arg(total));
-    }
-}
-
-
-
-/** \fn     GalleryView::UpdateSyncProgress(int, int)
- *  \brief  Updates the widget that shows the sync progress
- *  \param  remaining The number of images still to be synced
- *  \param  total The overall number of images that will be synced
- *  \return void
- */
-void GalleryView::UpdateSyncProgress(int current, int total)
-{
-    if (m_syncProgressText)
-    {
-        m_syncProgressText->SetVisible(true);
-        m_syncProgressText->SetText(QString("%1 %2 %3")
-                                     .arg(current)
-                                     .arg(tr("of"))
-                                     .arg(total));
-    }
-}
-
-
-
-/** \fn     GalleryView::UpdateText(MythUIButtonListItem *)
- *  \brief  Updates all other widgets on the screen that show
- *          information about the selected MythUIButtonListItem.
- *  \param  item The item that shall be updated
- *  \return void.
- */
-void GalleryView::UpdateText(MythUIButtonListItem *item)
-{
-    ImageMetadata *im = GetImageMetadataFromButton(item);
-    if (im)
-    {
-        // show the name of the image
-        if (m_captionText)
-            m_captionText->SetText(im->m_name);
-
-        // show the position of the image
-        if (m_positionText)
-            m_positionText->SetText(QString("%1 of %2")
-                                    .arg(m_imageList->GetCurrentPos()+1)
-                                    .arg(m_imageList->GetCount()));
-
-        // show the path of the image
-        if (m_crumbsText)
-            m_crumbsText->SetText(im->m_path);
-    }
-}
-
-
-
-/** \fn     GalleryView::ConfirmStartSync()
- *  \brief  Shows a confirmation dialog so the user can confirm his request
- *  \return void
- */
-void GalleryView::ConfirmStartSync()
-{
-    QString msg = QString("Do you really want to synchronize?\n"
-                          "This could take some time.");
-    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
-
-    if (m_confirmPopup->Create())
-    {
-        m_confirmPopup->SetReturnEvent(this, "confirmstartsync");
-        m_popupStack->AddScreen(m_confirmPopup);
-    }
-    else
-        delete m_confirmPopup;
-}
-
-
-
-/** \fn     GalleryView::ConfirmStopSync()
- *  \brief  Shows a confirmation dialog so the user can confirm his request
- *  \return void
- */
-void GalleryView::ConfirmStopSync()
-{
-    QString msg = QString("The syncronization of the images with the database "
-                          "is still running. Do you want to stop it or let it "
-                          "run in the background until its complete?");
-    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
-    if (m_confirmPopup->Create())
-    {
-        m_confirmPopup->SetReturnEvent(this, "confirmstopsync");
-        m_popupStack->AddScreen(m_confirmPopup);
-    }
-    else
-        delete m_confirmPopup;
-}
-
-
-
-/** \fn     GalleryView::MenuInformation()
- *  \brief  Shows the menu when the INFO key was pressed
- *  \return void
- */
-void GalleryView::MenuInformation()
-{
-    QString label = tr("Image Information");
-    MythMenu *menu = new MythMenu(label, this, "infomenu");
-
-    // only show the slideshow options and details menu when
-    // the item is a video or image file
-    ImageMetadata *im = GetImageMetadataFromSelectedButton();
-    if (im)
-    {
-        if (im->m_type == kImageFile ||
-            im->m_type == kVideoFile)
-        {
-            menu->AddItem(tr("Normal SlideShow"), SLOT(ShowFiles()));
-            menu->AddItem(tr("Random Slideshow"), SLOT(ShowRandomFiles()));
-        }
-
-        if (im->m_type == kImageFile)
-            menu->AddItem(tr("Show Details"), SLOT(FileDetails()));
-    }
-
-    m_menuPopup = new MythDialogBox(menu, m_popupStack, "menuPopup");
-    if (!m_menuPopup->Create())
-    {
-        delete m_menuPopup;
-        m_menuPopup = NULL;
-        return;
-    }
-
-    m_popupStack->AddScreen(m_menuPopup);
-}
-
-
-
-/** \fn     GalleryView::MenuMain()
- *  \brief  Shows the main menu when the MENU button was pressed
- *  \return void
- */
-void GalleryView::MenuMain()
-{
-    // Create the main menu that
-    // will contain the submenus above
-    MythMenu *menu = new MythMenu(tr("Image Options"), this, "mainmenu");
-
-    // Depending on the status of the sync show either the
-    // start sync or stop sync. The user can decide if he
-    // wants to stop the sync before leaving the main screen.
-    if (!m_syncStatusThread->isSyncRunning())
-        menu->AddItem(tr("Start Syncronization"), SLOT(ConfirmStartSync()));
-    else
-        menu->AddItem(tr("Stop Syncronization"), SLOT(ConfirmStopSync()));
-
-    // Add the available submenus to the main menu. The methods will
-    // check if the requirements for showing the menu item is fulfilled
-    MenuMetadata(menu);
-    MenuSelection(menu);
-    MenuFile(menu);
-
-    menu->AddItem(tr("Settings"), SLOT(MenuSettings()));
-
-    m_menuPopup = new MythDialogBox(menu, m_popupStack, "menuPopup");
-    if (!m_menuPopup->Create())
-    {
-        delete m_menuPopup;
-        m_menuPopup = NULL;
-        return;
-    }
-
-    m_popupStack->AddScreen(m_menuPopup);
-}
-
-
-
-/** \fn     GalleryView::MenuMetadata(MythMenu *)
- *  \brief  Adds a new metadata menu entry into the main menu
- *  \param  mainMenu Parent that will hold the menu entry
- *  \return void
- */
-void GalleryView::MenuMetadata(MythMenu *mainMenu)
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedButton();
-    if (im)
-    {
-        // only show the metadata menu
-        // if the current item is an image
-        if (im->m_type == kImageFile)
-        {
-            MythMenu *menu = new MythMenu(tr("Metadata Options"),
-                                          this, "metadatamenu");
-
-            menu->AddItem(tr("Rotate CW"), SLOT(FileRotateCW()));
-            menu->AddItem(tr("Rotate CCW"), SLOT(FileRotateCCW()));
-            menu->AddItem(tr("Flip Horizontal"), SLOT(FileFlipHorizontal()));
-            menu->AddItem(tr("Flip Vertical"), SLOT(FileFlipVertical()));
-            // menu->AddItem(tr("Zoom In"), SLOT(FileZoomIn()));
-            // menu->AddItem(tr("Zoom Out"), SLOT(FileZoomOut()));
-
-            mainMenu->AddItem(tr("Meta Data Menu"), NULL, menu);
-        }
-    }
-}
-
-
-
-/** \fn     GalleryView::MenuFile(MythMenu *)
- *  \brief  Adds a new file menu entry into the main menu
- *  \param  mainMenu Parent that will hold the menu entry
- *  \return void
- */
-void GalleryView::MenuFile(MythMenu *mainMenu)
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedButton();
-    if (im)
-    {
-        // There are no options available for up folders
-        // They are just there to navigate one level up
-        if (im->m_type == kUpDirectory)
-            return;
-
-        QString type = "Directory";
-        if (im->m_type == kImageFile ||
-            im->m_type == kVideoFile)
-            type = "File";
-
-        MythMenu *menu = new MythMenu(tr("%1 Options").arg(type),
-                                      this, "fileactionmenu");
-
-        // Allow renaming and deletion only for files
-        if (im->m_type == kImageFile ||
-            im->m_type == kVideoFile)
-        {
-            menu->AddItem(tr("Delete File"),
-                          SLOT(ConfirmFileDelete()));
-            menu->AddItem(tr("Delete Selected Files"),
-                          SLOT(ConfirmFileDeleteSelected()));
-            menu->AddItem(tr("Rename File"),
-                          SLOT(FileRenameInput()));
-        }
-
-        if (im->m_isHidden)
-            menu->AddItem(tr("Unhide %1").arg(type), SLOT(FileUnhide()));
-        else
-            menu->AddItem(tr("Hide %1").arg(type), SLOT(FileHide()));
-
-        mainMenu->AddItem(tr("File Menu"), NULL, menu);
-    }
-}
-
-
-
-/** \fn     GalleryView::MenuSelection(MythMenu *)
- *  \brief  Adds a new selection menu entry into the main menu
- *  \param  mainMenu Parent that will hold the menu entry
- *  \return void
- */
-void GalleryView::MenuSelection(MythMenu *mainMenu)
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedButton();
-    if (im)
-    {
-        // Selection / deselection is only
-        // available for images or videos
-        if (im->m_type == kImageFile ||
-            im->m_type == kVideoFile)
-        {
-            MythMenu *menu = new MythMenu(tr("Selection Options"),
-                                          this, "selectionmenu");
-
-            if (!im->m_selected)
-                menu->AddItem(tr("Select File"),
-                              SLOT(FileSelectOne()));
-            else
-                menu->AddItem(tr("Deselect File"),
-                              SLOT(FileDeselectOne()));
-
-            menu->AddItem(tr("Select All Files"), SLOT(FileSelectAll()));
-            menu->AddItem(tr("Deselect All Files"), SLOT(FileDeselectAll()));
-            menu->AddItem(tr("Invert Selection"), SLOT(FileInvertAll()));
-
-            mainMenu->AddItem(tr("Selection Menu"), NULL, menu);
-        }
-    }
-}
-
-
-
-/** \fn     GalleryView::MenuSettings(MythMenu *)
- *  \brief  Adds a new settings menu entry into the main menu
- *  \param  mainMenu Parent that will hold the menu entry
- *  \return void
- */
-void GalleryView::MenuSettings()
-{
-    GalleryConfig *config = new GalleryConfig(m_mainStack, "galleryconfig");
-    connect(config, SIGNAL(configSaved()), this, SLOT(LoadData()));
-
-    if (config->Create())
-    {
-        m_mainStack->AddScreen(config);
-    }
-    else
-        delete config;
-}
-
-
-
-/** \fn     GalleryView::ItemSelected(MythUIButtonListItem *)
- *  \brief  A new MythUIButtonListItem has been selected
- *  \param  item The given button item that has been selected
- *  \return void
- */
-void GalleryView::ItemSelected(MythUIButtonListItem *item)
-{
-    if (!item)
-        return;
-
-    ImageMetadata *dm = GetImageMetadataFromButton(item);
-    if (!dm)
-        return;
-
-    switch (dm->m_type)
-    {
-    case kSubDirectory:
-        DirSelectDown();
-        break;
-    case kUpDirectory:
-        DirSelectUp();
-        break;
-    case kImageFile:
-        ShowFile();
-        break;
-    case kVideoFile:
-        ShowFile();
-        break;
-    default:
-        break;
-    };
-}
-
-
-
-/** \fn     GalleryView::ShowFiles()
- *  \brief  Starts a slideshow with the images in normal order
- *  \return void
- */
-void GalleryView::ShowFiles()
-{
-    GalleryWidget *widget = ShowFile();
-
-    if (widget)
-        widget->StartNormalSlideShow();
-}
-
-
-
-/** \fn     GalleryView::ShowRandomFiles()
- *  \brief  Starts a slide show with the images in random order
- *  \return void
- */
-void GalleryView::ShowRandomFiles()
-{
-    GalleryWidget *widget = ShowFile();
-
-    if (widget)
-        widget->StartRandomSlideShow();
-}
-
-
-
-/** \fn     GalleryView::ShowFile()
- *  \brief  Creates the window that will show the images and slideshows
- *  \return The created window or NULL
- */
-GalleryWidget* GalleryView::ShowFile()
-{
-    GalleryWidget *widget = new GalleryWidget(m_mainStack, "gallerywidget", m_galleryViewHelper);
-    if (widget->Create())
-    {
-        ResetThumbnailProgress();
-        m_mainStack->AddScreen(widget);
-        widget->LoadFile();
-    }
-    else
-    {
-        delete widget;
-        widget = NULL;
-    }
-
-    return widget;
-}
-
-
-
-/** \fn     GalleryView::DirSelectUp()
- *  \brief  Goes up one directory level
- *  \return void
- */
-bool GalleryView::DirSelectUp()
-{
-    // Set the first node (upfolder) active
-    m_galleryViewHelper->m_currentNode->setSelectedChild(m_galleryViewHelper->m_currentNode->getChildAt(0));
-
-    // Get the data and with it the kUpFolder directory node
-    int id = m_galleryViewHelper->GetImageMetadataFromSelectedNode()->m_id;
-
-    m_galleryViewHelper->LoadTreeData();
-    ResetThumbnailProgress();
-    UpdateImageList();
-
-    // Go through the entire list of image items and find
-    // the directory id that matches the saved directory id
-    for (int i = 0; i < m_imageList->GetCount(); i++)
-    {
-        MythUIButtonListItem *item = m_imageList->GetItemAt(i);
-        if (!item)
-            continue;
-
-        ImageMetadata *data = GetImageMetadataFromButton(item);
-        if (!data)
-            continue;
-
-        if (data->m_id == id)
-        {
-            m_imageList->SetItemCurrent(item);
-            break;
-        }
-    }
-
-    return true;
-}
-
-
-
-/** \fn     GalleryView::DirSelectDown()
- *  \brief  Goes one directory level down
- *  \return void
- */
-void GalleryView::DirSelectDown()
-{
-    m_galleryViewHelper->LoadTreeData();
-    m_galleryViewHelper->m_currentNode->setSelectedChild(m_galleryViewHelper->m_currentNode->getChildAt(0));
-
-    ResetThumbnailProgress();
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::FileSelectOne()
- *  \brief  Marks a single file as selected
- *  \return void
- */
-void GalleryView::FileSelectOne()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetNodeSelectionState(kNodeStateSelect, false);
-    UpdateImageItem(item);
-}
-
-
-
-/** \fn     GalleryView::FileDeselectOne()
- *  \brief  Marks a single file as not selected
- *  \return void
- */
-void GalleryView::FileDeselectOne()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetNodeSelectionState(kNodeStateDeselect, false);
-    UpdateImageItem(item);
-}
-
-
-
-/** \fn     GalleryView::FileSelectAll()
- *  \brief  Marks all files as selected
- *  \return void
- */
-void GalleryView::FileSelectAll()
-{
-    m_galleryViewHelper->SetNodeSelectionState(kNodeStateSelect, true);
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::FileDeselectAll()
- *  \brief  Marks all files as not selected
- *  \return void
- */
-void GalleryView::FileDeselectAll()
-{
-    m_galleryViewHelper->SetNodeSelectionState(kNodeStateDeselect, true);
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::FileInvertAll()
- *  \brief  Inverts the current selection for all files
- *  \return void
- */
-void GalleryView::FileInvertAll()
-{
-    m_galleryViewHelper->SetNodeSelectionState(kNodeStateInvert, true);
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::FileRotateCW()
- *  \brief  Rotates the selected file 90 clockwise.
- *          The thumbnail will also be updated.
- *  \return void
- */
-void GalleryView::FileRotateCW()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetFileOrientation(kFileRotateCW);
-
-    UpdateImageItem(item, true);
-}
-
-
-
-/** \fn     GalleryView::FileRotateCCW()
- *  \brief  Rotates the selected file 90 counter clockwise.
- *          The thumbnail will also be updated.
- *  \return void
- */
-void GalleryView::FileRotateCCW()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetFileOrientation(kFileRotateCCW);
-
-    UpdateImageItem(item, true);
-}
-
-
-
-/** \fn     GalleryView::FileFlipHorizontal()
- *  \brief  Flips the file horizontally.
- *          The thumbnail will also be updated.
- *  \return void
- */
-void GalleryView::FileFlipHorizontal()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetFileOrientation(kFileFlipHorizontal);
-
-    UpdateImageItem(item, true);
-}
-
-
-
-/** \fn     GalleryView::FileFlipVertical()
- *  \brief  Flips the file vertically.
- *          The thumbnail will also be updated.
- *  \return void
- */
-void GalleryView::FileFlipVertical()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetFileOrientation(kFileFlipVertical);
-
-    UpdateImageItem(item, true);
-}
-
-
-
-/** \fn     GalleryView::FileZoomIn()
- *  \brief  Zooms into the file. The thumbnail will also be updated.
- *  \return void
- */
-void GalleryView::FileZoomIn()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetFileZoom(kFileZoomIn);
-
-    UpdateImageItem(item);
-}
-
-
-
-/** \fn     GalleryView::FileZoomOut()
- *  \brief  Zooms out of the file. The thumbnail will also be updated.
- *  \return void
- */
-void GalleryView::FileZoomOut()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return;
-
-    m_galleryViewHelper->SetFileZoom(kFileZoomOut);
-
-    UpdateImageItem(item);
-}
-
-
-
-/** \fn     GalleryView::FileHide()
- *  \brief  Marks the file as hidden and hides it from the visible image list
- *  \return void
- */
-void GalleryView::FileHide()
-{
-    m_galleryViewHelper->SetNodeVisibilityState(kNodeStateInvisible);
-
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::FileHide()
- *  \brief  Marks the file as visible and unhides it from the visible image list
- *  \return void
- */
-void GalleryView::FileUnhide()
-{
-    m_galleryViewHelper->SetNodeVisibilityState(kNodeStateVisible);
-
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::ConfirmFileDelete()
- *  \brief  Shows a confirmation dialog before
- *          the user can delete a single file
- *  \return void
- */
-void GalleryView::ConfirmFileDelete()
-{
-    // Create a confirmation dialog to confirm the file deletion
-    // of the currently selected image. This is only a safety precaution.
-    ImageMetadata *data = GetImageMetadataFromSelectedButton();
-    if (!data)
-        return;
-
-    QString msg = QString("Do you want to delete '\n%1'").arg(data->m_name);
-    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
-
-    if (m_confirmPopup->Create())
-    {
-        m_confirmPopup->SetReturnEvent(this, "confirmdelete");
-        m_popupStack->AddScreen(m_confirmPopup);
-    }
-    else
-        delete m_confirmPopup;
-}
-
-
-
-/** \fn     GalleryView::ConfirmFileDeleteSelected()
- *  \brief  Shows a confirmation dialog before the
- *          user can delete all selected files
- *  \return void
- */
-void GalleryView::ConfirmFileDeleteSelected()
-{
-    QString msg = QString("Do you want to delete all selected files");
-    m_confirmPopup = new MythConfirmationDialog(m_popupStack, msg, true);
-
-    if (m_confirmPopup->Create())
-    {
-        m_confirmPopup->SetReturnEvent(this, "confirmdeleteselected");
-        m_popupStack->AddScreen(m_confirmPopup);
-    }
-    else
-        delete m_confirmPopup;
-}
-
-
-
-/** \fn     GalleryView::FileRenameInput()
- *  \brief  Shows a popup where the user can enter a new filename
- *  \return void
- */
-void GalleryView::FileRenameInput()
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedButton();
-    if (im)
-    {
-        QString msg = QString("Enter a new name for '%1'.").arg(im->m_name);
-        m_inputPopup = new MythTextInputDialog(m_popupStack, msg,
-                                               FilterNone, false, im->m_name );
-
-        if (m_inputPopup->Create())
-        {
-            m_inputPopup->SetReturnEvent(this, "filerename");
-            m_popupStack->AddScreen(m_inputPopup);
-        }
-        else
-            delete m_inputPopup;
-    }
-}
-
-
-
-/** \fn     GalleryView::FileRename(QString &)
- *  \brief  Renames the current filename to the new filename
-            if the new filename does not exist already.
- *  \param  New name of the file with the full path
- *  \return void
- */
-void GalleryView::FileRename(QString &newName)
-{
-    m_galleryViewHelper->RenameCurrentNode(newName);
-
-    UpdateImageList();
-}
-
-
-
-/** \fn     GalleryView::FileDetails()
- *  \brief  Shows details about the single file
- *  \return void
- */
-void GalleryView::FileDetails()
-{
-    GalleryWidget *widget = ShowFile();
-
-    if (widget)
-        widget->ShowFileDetails();
-}
-
-
-
-/** \fn     GalleryView::GetImageMetadataFromSelectedButton()
- *  \brief  Returns the data of the currently selected image list item
- *  \return ImageMetadata
- */
-ImageMetadata *GalleryView::GetImageMetadataFromSelectedButton()
-{
-    MythUIButtonListItem *item = m_imageList->GetItemCurrent();
-    if (!item)
-        return NULL;
-
-    MythGenericTree *node = item->GetData().value<MythGenericTree *>();
-    if (!node)
-        return NULL;
-
-    ImageMetadata *data = node->GetData().value<ImageMetadata *>();
-    if (!data)
-        return NULL;
-
-    return data;
-}
-
-
-
-/** \fn     GalleryView::GetImageMetadataFromButton(MythUIButtonListItem *)
- *  \brief  Returns the data of the given image list item
- *  \param  item The given image list item
- *  \return ImageMetadata
- */
-ImageMetadata *GalleryView::GetImageMetadataFromButton(MythUIButtonListItem *item)
-{
-    if (!item)
-        return NULL;
-
-    MythGenericTree *node = item->GetData().value<MythGenericTree *>();
-    if (!node)
-        return NULL;
-
-    ImageMetadata *data = node->GetData().value<ImageMetadata *>();
-    if (!data)
-        return NULL;
-
-    return data;
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryview.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryview.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryview.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryview.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,114 +0,0 @@
-#ifndef GALLERYVIEW_H
-#define GALLERYVIEW_H
-
-// Qt headers
-#include <QMultiMap>
-
-// MythTV headers
-#include "mythscreentype.h"
-#include "mythuitext.h"
-#include "mythuibuttonlist.h"
-#include "mythuiimage.h"
-#include "mythdialogbox.h"
-#include "mythprogressdialog.h"
-#include "mythuitextedit.h"
-#include "imagemetadata.h"
-
-#include "galleryviewhelper.h"
-#include "gallerywidget.h"
-
-class GalleryView : public MythScreenType
-{
-    Q_OBJECT
-
-public:
-    GalleryView(MythScreenStack *parent, const char *name);
-    ~GalleryView();
-    bool Create();
-
-    GalleryViewHelper     *m_galleryViewHelper;
-
-public slots:
-    void LoadData();
-    void ResetThumbnailProgress();
-    void UpdateThumbnailProgress(int, int);
-
-    void ResetSyncProgress();
-    void UpdateSyncProgress(int, int);
-
-private:
-    bool keyPressEvent(QKeyEvent *);
-    void customEvent(QEvent*);
-    void UpdateImageList();
-    void ResetImageItems();
-
-private slots:
-    void ItemSelected(MythUIButtonListItem *);
-    void UpdateImageItem(MythUIButtonListItem *, bool = false);
-    void UpdateText(MythUIButtonListItem *);
-    void UpdateThumbnail(MythUIButtonListItem *,
-                         ImageMetadata *,
-                         bool forceReload = false);
-
-    void MenuMain();
-    void MenuInformation();
-    void MenuMetadata(MythMenu *);
-    void MenuSelection(MythMenu *);
-    void MenuFile(MythMenu *);
-    void MenuSettings();
-
-    void ShowFiles();
-    void ShowRandomFiles();
-    GalleryWidget* ShowFile();
-
-    bool DirSelectUp();
-    void DirSelectDown();
-
-    void FileDetails();
-    void FileRotateCW();
-    void FileRotateCCW();
-    void FileFlipHorizontal();
-    void FileFlipVertical();
-    void FileZoomIn();
-    void FileZoomOut();
-    void FileSelectOne();
-    void FileDeselectOne();
-    void FileSelectAll();
-    void FileDeselectAll();
-    void FileInvertAll();
-    void FileHide();
-    void FileUnhide();
-    void FileRenameInput();
-    void FileRename(QString &);
-
-    void ConfirmStartSync();
-    void ConfirmStopSync();
-    void ConfirmFileDelete();
-    void ConfirmFileDeleteSelected();
-
-private:
-    ImageMetadata         *GetImageMetadataFromSelectedButton();
-    ImageMetadata         *GetImageMetadataFromButton(MythUIButtonListItem *item);
-
-    GallerySyncStatusThread     *m_syncStatusThread;
-
-    // used to show the menus and other popups
-    MythDialogBox           *m_menuPopup;
-    MythConfirmationDialog  *m_confirmPopup;
-    MythTextInputDialog     *m_inputPopup;
-    MythScreenStack         *m_popupStack;
-    MythScreenStack         *m_mainStack;
-
-    MythUIButtonList   *m_imageList;
-    QMultiMap<int, MythUIButtonListItem*> m_imageMap;
-    MythUIText         *m_captionText;
-    MythUIText         *m_crumbsText;
-    MythUIText         *m_positionText;
-    MythUIText         *m_imageText;
-    // TODO: Not implemented
-
-    MythUIText         *m_syncProgressText;
-    MythUIText         *m_thumbProgressText;
-};
-
-#endif // GALLERYVIEW_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviewhelper.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviewhelper.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviewhelper.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviewhelper.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,533 +0,0 @@
-
-#include "galleryviewhelper.h"
-
-// Qt headers
-#include <QFile>
-
-// libmyth headers
-#include "mythcontext.h"
-
-// libmythbase headers
-#include "storagegroup.h"
-
-// libmythmetadata headers
-#include "imageutils.h"
-
-// libmythui headers
-#include "mythuibuttonlist.h"
-#include "mythuihelper.h"
-
-/** \fn     GalleryViewHelper::GalleryViewHelper(MythScreenType *)
- *  \brief  Constructor
- *  \param  parent The screen parent
- */
-GalleryViewHelper::GalleryViewHelper(MythScreenType *parent)
-{
-    m_parent = parent;
-
-    m_sgName    = IMAGE_STORAGE_GROUP;
-    m_sgDirList = StorageGroup::getGroupDirs(m_sgName, "");
-
-    m_dbHelper = new GalleryDatabaseHelper();
-    m_fileHelper  = new GalleryFileHelper();
-
-    // these are the node trees that hold the data and
-    // are used for navigating and finding files
-    m_currentNode = new MythGenericTree("", kBaseDirectory, false);
-
-    m_allNodesVisible = false;
-}
-
-
-
-/** \fn     GalleryViewHelper::~GalleryViewHelper()
- *  \brief  Destructor
- */
-GalleryViewHelper::~GalleryViewHelper()
-{
-    if (m_dbHelper)
-    {
-        delete m_dbHelper;
-        m_dbHelper = NULL;
-    }
-
-    if (m_currentNode)
-    {
-        delete m_currentNode;
-        m_currentNode = NULL;
-    }
-
-    if (m_fileHelper)
-    {
-        // FIXME Triggers segfault
-        // m_fileHelper->StopThumbGen();
-        delete m_fileHelper;
-        m_fileHelper = NULL;
-    }
-}
-
-
-
-/** \fn     GalleryViewHelper::LoadData()
- *  \brief  Checks the prerequisites are fulfilled
- *          before the data can be loaded
- *  \return void
- */
-int GalleryViewHelper::LoadData()
-{
-    // clear all previously loaded data
-    m_currentNode->deleteAllChildren();
-
-    // get the base directories and check if they are valid
-    if (m_sgDirList.isEmpty())
-        return kStatusNoBaseDir;
-
-    // Fill the MythGenericTree with the data of the first level
-    // This method will be called recursively to further fill the tree
-    LoadTreeData();
-
-    // check if there is any data in the database
-    if (m_currentNode->childCount() == 0)
-        return kStatusNoFiles;
-
-    return kStatusOk;
-}
-
-
-/** \fn     GalleryViewHelper::LoadTreeData()
- *  \brief  Load all available data from the database and populates the tree.
- *  \return void
- */
-void GalleryViewHelper::LoadTreeData()
-{
-    QList<ImageMetadata *> *dirList = new QList<ImageMetadata *>;
-    QList<ImageMetadata *> *fileList = new QList<ImageMetadata *>;
-
-    // The parent id is the database index of the
-    // directories which subdirectories and files shall be loaded
-    int id = 0;
-
-    // Get the selected node. If there is no data available then the
-    // plugin has been started for the first time, a synchronization
-    // request was made or the settings have changed. In this case
-    // use default parent id of the storage group directories.
-    ImageMetadata *im = GetImageMetadataFromSelectedNode();
-    if (im)
-    {
-        if (im->m_type == kUpDirectory)
-            id = im->m_parentId;
-
-        if (im->m_type == kSubDirectory)
-            id = im->m_id;
-    }
-
-    // The data from the selected node has used.
-    // Clear the list so that it can be populated with new data.
-    m_currentNode->deleteAllChildren();
-
-    // If the node has a parent (ie. not the top level)
-    // then add a additional directory at the beginning of the list that
-    // is of the type kUpDirectory so that the user can navigate one level up.
-    if (id > 0)
-    {
-        m_dbHelper->LoadParentDirectory(dirList, id);
-        LoadTreeNodeData(dirList, m_currentNode);
-    }
-
-    m_dbHelper->LoadDirectories(dirList, id);
-    LoadTreeNodeData(dirList, m_currentNode);
-
-    // Load all files with the specified sorting criterias
-    m_dbHelper->LoadFiles(fileList, id);
-    LoadTreeNodeData(fileList, m_currentNode);
-
-    // clean up
-    delete dirList;
-    delete fileList;
-}
-
-
-
-/** \fn     GalleryViewHelper::LoadNodeTreeData(QList<ImageMetadata *> *, MythGenericTree *)
- *  \brief  Creates a new generic tree with the information from the database
- *  \param  list The list with the database file information
- *  \param  tree The tree that will be populated and shown
- *  \return void
- */
-void GalleryViewHelper::LoadTreeNodeData(QList<ImageMetadata *> *list,
-                                       MythGenericTree *tree)
-{
-    // Add all items in the list to the tree
-    for (int i = 0; i < list->size(); ++i)
-    {
-        ImageMetadata *im = list->at(i);
-        if (im)
-        {
-            // don't recreate any existing thumbnails
-            m_fileHelper->AddToThumbnailList(im, false);
-
-            // Create a new tree node that will hold the data
-            MythGenericTree *treeItem =
-                    new MythGenericTree(im->m_fileName,
-                                        im->m_type, true);
-
-            treeItem->SetData(qVariantFromValue<ImageMetadata *> (im));
-            tree->addNode(treeItem);
-        }
-    }
-}
-
-
-
-/** \fn     GalleryViewHelper::RenameCurrentNode(QString &)
- *  \brief  Renames the file that belongs to the node and updates the database
- *  \param  New name of the file with the full path
- *  \return void
- */
-void GalleryViewHelper::RenameCurrentNode(QString &newName)
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedNode();
-    if (!im)
-        return;
-
-    if (m_fileHelper->RenameFile(im, newName))
-    {
-        // replace the original filename with the
-        // new one in the pull path + filename variable
-        QString newFileName = im->m_fileName.replace(im->m_name, newName);
-
-        im->m_fileName = newFileName;
-        im->m_name = newName;
-    }
-}
-
-
-/** \fn     GalleryViewHelper::DeleteCurrentNode()
- *  \brief  Deletes the current node from the generic tree
- *  \return void
- */
-void GalleryViewHelper::DeleteCurrentNode()
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedNode();
-
-    // TODO: Remove directories as well
-    if (im && im->m_type >= kImageFile)
-
-        // Delete the file and remove the database entry
-        if (m_fileHelper->RemoveFile(im))
-        {
-            // Remove the entry from the node list
-            m_currentNode->deleteNode(m_currentNode->getSelectedChild());
-
-            // Clean up thumbnail cache
-            GetMythUI()->RemoveFromCacheByFile(im->m_thumbFileNameList->at(0));
-        }
-}
-
-
-/** \fn     GalleryViewHelper::DeleteSelectedNodes()
- *  \brief  Deletes multiple selected nodes from the generic tree
- *  \return void
- */
-void GalleryViewHelper::DeleteSelectedNodes()
-{
-    QList<MythGenericTree *> *nodeTree = m_currentNode->getAllChildren();
-    for (int i = 0; i < nodeTree->size(); i++)
-    {
-        ImageMetadata *im = nodeTree->at(i)->GetData().value<ImageMetadata *>();
-
-        // TODO: Remove directories as well
-        if (im && im->m_selected && im->m_type >= kImageFile)
-        {
-            // Delete the file and remove the database entry
-            if (m_fileHelper->RemoveFile(im))
-            {
-                // Clean up thumbnail cache
-                GetMythUI()->RemoveFromCacheByFile(im->m_thumbFileNameList->at(0));
-
-                // Remove the entry from the node list
-                m_currentNode->deleteNode(nodeTree->at(i));
-            }
-        }
-    }
-}
-
-
-
-/** \fn     GalleryViewHelper::SetNodeSelectionState(int, bool)
- *  \brief  Sets either one or all nodes to the
-            nodeState that the user has specified
- *  \param  nodeState Can be either selected or unselected
- *  \param  allNodes Set the selection state for all nodes or not
- *  \return void
- */
-void GalleryViewHelper::SetNodeSelectionState(int nodeState, bool allNodes)
-{
-    if (!m_currentNode)
-        return;
-
-    if (!allNodes)
-    {
-        SetNodeSelectionState(m_currentNode->getSelectedChild(), nodeState);
-    }
-    else
-    {
-        QList<MythGenericTree *> *nodeTree = m_currentNode->getAllChildren();
-        for (int i = 0; i < nodeTree->size(); i++)
-            SetNodeSelectionState(nodeTree->at(i), nodeState);
-    }
-}
-
-
-
-/** \fn     GalleryViewHelper::SetNodeSelectionState(MythGenericTree *, int)
- *  \brief  Sets the given node to the given nodeState
- *  \param  node The single node that shall be changed
- *  \param  nodeState Can be either selected or unselected
- *  \return void
- */
-void GalleryViewHelper::SetNodeSelectionState(MythGenericTree *node,
-                                            int nodeState)
-{
-    // set the given node as selected / unselected
-    if (node)
-    {
-        ImageMetadata *im = node->GetData().value<ImageMetadata *>();
-
-        // Allow a selection / deselection only for images
-        if (im &&
-            im->m_type == kImageFile)
-        {
-            if (nodeState == kNodeStateSelect)
-                im->m_selected = true;
-
-            if (nodeState == kNodeStateDeselect)
-                im->m_selected = false;
-
-            if (nodeState == kNodeStateInvert)
-                im->m_selected = !im->m_selected;
-        }
-    }
-}
-
-
-
-/** \fn     GalleryViewHelper::SetNodeVisibilityState(int)
- *  \brief  Sets the selected not either to the
-            nodeState that the user has specified
- *  \param  nodeState Can be either visible or invisible
- *  \return void
- */
-void GalleryViewHelper::SetNodeVisibilityState(int nodeState)
-{
-    // set the given node as visible / invisible
-    ImageMetadata *im = GetImageMetadataFromSelectedNode();
-    if (im)
-    {
-        if (nodeState == kNodeStateVisible)
-            im->m_isHidden = false;
-
-        if (nodeState == kNodeStateInvisible)
-            im->m_isHidden = true;
-
-        m_dbHelper->UpdateData(im);
-    }
-}
-
-
-/** \fn     GalleryViewHelper::SetFileOrientation(int)
- *  \brief  Saves the orientation information of the selected node
- *  \param  fileOrientation The orientation value 1-8
- *  \return void
- */
-void GalleryViewHelper::SetFileOrientation(int fileOrientation)
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedNode();
-    if (!im)
-        return;
-
-    int oldFileOrientation = im->GetOrientation();
-
-    // Update the orientation, the new value will
-    // be calculated with this method. This new
-    // value will then be saved in the exif header tag.
-    im->SetOrientation(fileOrientation, false);
-
-    // Request orientation update
-    if (m_fileHelper->SetImageOrientation(im))
-    {
-        // force thumbnail to be regenerated
-        m_fileHelper->AddToThumbnailList(im, true);
-    }
-    else
-    {
-        // Restore previous orientation
-        im->SetOrientation(oldFileOrientation, true);
-
-        LOG(VB_GENERAL, LOG_ERR, QString("Orientation update failed for %1")
-            .arg(im->m_fileName));
-    }
-}
-
-
-/** \fn     GalleryViewHelper::SetFileZoom(int)
- *  \brief  Saves the zoom information of the selected node
- *  \param  zoom The zoom value in percent
- *  \return void
- */
-void GalleryViewHelper::SetFileZoom(int zoom)
-{
-    ImageMetadata *im = GetImageMetadataFromSelectedNode();
-    if (!im)
-        return;
-
-    if (zoom == kFileZoomIn)
-        im->SetZoom(20, false);
-
-    if (zoom == kFileZoomOut)
-        im->SetZoom(-20, false);
-
-    m_dbHelper->UpdateData(im);
-}
-
-
-
-/** \fn     GalleryViewHelper::GetImageMetadataFromSelectedNode()
- *  \brief  Returns the data selected node
- *  \return ImageMetadata
- */
-ImageMetadata *GalleryViewHelper::GetImageMetadataFromSelectedNode()
-{
-    if (!m_currentNode)
-        return NULL;
-
-    MythGenericTree *node = m_currentNode->getSelectedChild();
-    if (!node)
-        return NULL;
-
-    ImageMetadata *im = node->GetData().value<ImageMetadata *>();
-    if (!im)
-        return NULL;
-
-    return im;
-}
-
-
-
-/** \fn     GalleryViewHelper::GetImageMetadataFromNode(MythGenericTree *)
- *  \brief  Returns the data of the given node
- *  \param  node The specified node that shall be used
- *  \return ImageMetadata
- */
-ImageMetadata *GalleryViewHelper::GetImageMetadataFromNode(MythGenericTree *node)
-{
-    if (!node)
-        return NULL;
-
-    ImageMetadata *im = node->GetData().value<ImageMetadata *>();
-    if (!im)
-        return NULL;
-
-    return im;
-}
-
-
-
-/** \fn     GalleryViewHelper::GetImageMetadataFromNode(int)
- *  \brief  Returns the data of the given node id
- *  \param  id The specified node id that shall be used
- *  \return ImageMetadata
- */
-ImageMetadata *GalleryViewHelper::GetImageMetadataFromNode(int i)
-{
-    if (!m_currentNode)
-        return NULL;
-
-    MythGenericTree *node = m_currentNode->getChildAt(i);
-    if (!node)
-        return NULL;
-
-    ImageMetadata *im = node->GetData().value<ImageMetadata *>();
-    if (!im)
-        return NULL;
-
-    return im;
-}
-
-
-
-/** \fn     GallerySyncStatusThread::GallerySyncStatusThread()
- *  \brief  Constructor
- *  \return void
- */
-GallerySyncStatusThread::GallerySyncStatusThread()
-{
-
-}
-
-/**
- * @brief GallerySyncStatusThread::isSyncRunning
- * @return void
- */
-bool GallerySyncStatusThread::isSyncRunning()
-{
-    GalleryFileHelper *fh = new GalleryFileHelper();
-    GallerySyncStatus status = fh->GetSyncStatus();
-
-    LOG(VB_GENERAL, LOG_DEBUG,
-        QString("GallerySyncStatusThread: Sync status is running: %1").arg(status.running));
-
-    delete fh;
-
-    return status.running;
-}
-
-/** \fn     GallerySyncStatusThread::run()
- *  \brief  Called when the thread is started. Calls the service
-            api to start the syncing and checks the status every 2s.
- *  \return void
- */
-void GallerySyncStatusThread::run()
-{
-    bool syncDetected = false;
-
-    GalleryFileHelper *fh = new GalleryFileHelper();
-
-    // Internal counter that tracks how many
-    // times we have been in the while loop
-    int loopCounter = 0;
-
-    while (true)
-    {
-        GallerySyncStatus status = fh->GetSyncStatus();
-
-        LOG(VB_GENERAL, LOG_DEBUG,
-            QString("GallerySyncStatusThread: Sync status is running: %1, "
-                    "Syncing image '%2' of '%3'")
-            .arg(status.running).arg(status.current).arg(status.total));
-
-        // Update the progress text whilst the sync is running
-        if (status.running)
-        {
-            syncDetected = true;
-            emit UpdateSyncProgress(status.current, status.total);
-        }
-        // Check at least twice before quitting
-        else if (loopCounter >= 1)
-        {
-            // only refresh UI after syncs
-            if (syncDetected)
-                emit SyncComplete();
-
-            // die
-            break;
-        }
-        // Wait some time before trying to get and update the status
-        // This also avoids too many calls to the service api.
-        usleep(500000);
-
-        ++loopCounter;
-    }
-
-    delete fh;
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviewhelper.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviewhelper.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviewhelper.h	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviewhelper.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,79 +0,0 @@
-#ifndef GALLERYVIEWHELPER_H
-#define GALLERYVIEWHELPER_H
-
-// Qt headers
-#include <QString>
-#include <QList>
-#include <QMap>
-#include <QThread>
-
-// libmythui
-#include "mythgenerictree.h"
-#include "mythscreentype.h"
-
-// libmythmetadata
-#include "imagemetadata.h"
-
-// frontend
-#include "galleryfilehelper.h"
-#include "gallerydatabasehelper.h"
-
-class GalleryViewHelper : public QObject
-{
-    Q_OBJECT
-
-  public:
-    GalleryViewHelper(MythScreenType *);
-    ~GalleryViewHelper();
-
-    MythGenericTree         *m_currentNode;
-
-    QStringList m_sgDirList;
-    QString     m_sgName;
-
-    int     LoadData();
-    void    LoadTreeData();
-    void    LoadTreeNodeData(QList<ImageMetadata *>*, MythGenericTree*);
-    void    UpdateAllData();
-    void    RenameCurrentNode(QString &);
-    void    DeleteCurrentNode();
-    void    DeleteSelectedNodes();
-    void    SetNodeSelectionState(int, bool);
-    void    SetNodeVisibilityState(int);
-    void    SetFileOrientation(int);
-    void    SetFileZoom(int);
-
-    ImageMetadata*  GetImageMetadataFromSelectedNode();
-    ImageMetadata*  GetImageMetadataFromNode(MythGenericTree *);
-    ImageMetadata*  GetImageMetadataFromNode(int);
-
-    GalleryFileHelper       *m_fileHelper;
-
-  private:
-    void    SetNodeSelectionState(MythGenericTree *, int);
-
-    MythScreenType          *m_parent;
-    GalleryDatabaseHelper   *m_dbHelper;
-
-    bool    m_allNodesVisible;
-};
-
-
-
-class GallerySyncStatusThread : public QThread
-{
-    Q_OBJECT
-
-  public:
-    GallerySyncStatusThread();
-    bool isSyncRunning();
-
-  protected:
-    void run();
-
-  signals:
-    void UpdateSyncProgress(int, int);
-    void SyncComplete();
-};
-
-#endif // GALLERYVIEWHANDLER_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviews.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviews.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviews.cpp	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviews.cpp	2015-04-30 11:17:45.425559811 +0200
@@ -0,0 +1,1051 @@
+#include "galleryviews.h"
+
+#include <cmath> // for qsrand
+
+#include <QTime>
+
+#include "gallerycommhelper.h"
+
+
+/*!
+ \brief Number of thumbnails to use for folders
+*/
+const static int   kMaxFolderThumbnails = 4;
+
+/*!
+ \brief Exif data with these titles comprise the Basic file info
+*/
+static QStringList kBasicInfoFields = QStringList()
+                                      // Exif tags
+                                      << "Date and Time"
+                                      << "Exposure Time"
+                                      << "FNumber"
+                                      << "Focal Length"
+                                      << "Image Description"
+                                      << "User Comment"
+                                      << "Manufacturer"
+                                      << "Max Aperture Value"
+                                      << "Model"
+                                      << "Orientation"
+                                      << "Pixel X Dimension"
+                                      << "Pixel Y Dimension"
+                                      // Video tags
+                                      << "model"
+                                      << "encoder";
+
+/*!
+ \brief 
+ Tuning parameter for seasonal weights, between 0 and 1, where lower numbers
+ give greater weight to seasonal photos. The leading beta shape controls
+ dates that are approaching and the trailing beta shape controls dates that
+ just passed. When these are set to 0.175 and 0.31, respectively, about one
+ quarter of the photos are from the upcoming week in prior years and about one
+ quarter of the photos are from the preceding month in prior years.
+*/
+const double LEADING_BETA_SHAPE  = 0.175;
+/*!
+ \brief See LEADING_BETA_SHAPE
+*/
+const double TRAILING_BETA_SHAPE = 0.31;
+/*!
+ \brief Photos without an exif timestamp will default to the mode of the beta distribution.
+*/
+const double DEFAULT_WEIGHT = std::pow(0.5, TRAILING_BETA_SHAPE - 1) *
+                              std::pow(0.5, LEADING_BETA_SHAPE - 1);
+/*!
+ \brief The edges of the distribution get clipped to avoid a singularity.
+*/
+const qint64 BETA_CLIP = 60 * 60 * 24;
+
+/*!
+ \brief Reset menu state
+*/
+void MenuSubjects::Clear()
+{
+    m_selected       = NULL;
+    m_selectedMarked = false;
+    m_childCount     = 0;
+    m_markedId.clear();
+    m_prevMarkedId.clear();
+    m_hiddenMarked   = false;
+    m_unhiddenMarked = false;
+}
+
+
+/*!
+ \brief Factory for initialising an info/details buttonlist
+
+ \param container The Screen widget
+ \param focusable Set if info list should be focusable (for scrolling)
+ \param undefined Text to display for tags with no value
+ \return InfoList The info buttonlist
+*/
+InfoList* InfoList::Create(MythScreenType *container,
+                           bool focusable,
+                           QString undefined)
+{
+    MythUIButtonList *btnList;
+    bool              err = false;
+    UIUtilE::Assign(container, btnList, "infolist", &err);
+    if (err)
+        return NULL;
+
+    return new InfoList(container, focusable, undefined, btnList);
+}
+
+
+/*!
+ \brief Info/details buttonlist constructor
+
+ \param container The Screen widget
+ \param focusable Set if info list should be focusable (for scrolling)
+ \param undefined Text to display for tags with no value
+ \param btnList Buttonlist provided by the theme
+*/
+InfoList::InfoList(MythScreenType *container, bool focusable, QString undefined,
+                   MythUIButtonList *btnList)
+    : m_screen(container),
+    m_btnList(btnList),
+    m_infoVisible(kNoInfo),
+    m_undefinedText(undefined)
+{
+    m_btnList->SetVisible(false);
+    m_btnList->SetCanTakeFocus(focusable);
+}
+
+
+/*!
+ \brief Toggle infolist state for an image. Focusable widgets toggle between
+ Basic & Full info. Non-focusable widgets toggle between Basic & Off.
+ \param im The image/dir for which info is shown
+*/
+void InfoList::Toggle(const ImageItem *im)
+{
+    // Only focusable lists have an extra 'full' state as they can
+    // be scrolled to view it all
+    if (m_btnList->CanTakeFocus())
+
+        // Start showing basic info then toggle between basic/full
+        m_infoVisible = m_infoVisible == kBasicInfo ? kFullInfo : kBasicInfo;
+
+    // Toggle between off/basic
+    else if (m_infoVisible == kBasicInfo)
+    {
+        m_infoVisible = kNoInfo;
+        m_btnList->SetVisible(false);
+        return;
+    }
+    else
+        m_infoVisible = kBasicInfo;
+
+    Update(im);
+
+    m_btnList->SetVisible(true);
+}
+
+
+/*!
+ \brief Remove infolist from display
+ \return bool True if buttonlist was displayed/removed
+*/
+bool InfoList::Hide()
+{
+    // Only handle event if info currently displayed
+    bool handled = (m_infoVisible != kNoInfo);
+    m_infoVisible = kNoInfo;
+
+    m_btnList->SetVisible(false);
+
+    return handled;
+}
+
+
+/*!
+ \brief Populate a buttonlist item with exif tag name & value
+ \param name Exif tag name
+ \param value Exif tag value
+*/
+void InfoList::CreateButton(QString name, QString value)
+{
+    MythUIButtonListItem *item = new MythUIButtonListItem(m_btnList, "");
+
+    InfoMap               infoMap;
+    infoMap.insert("name", name);
+    infoMap.insert("value", value.isEmpty() ? m_undefinedText : value);
+
+    item->SetTextFromMap(infoMap);
+}
+
+
+/*!
+ \brief Populates available exif details for the current image/dir.
+ \param im An image or dir
+*/
+void InfoList::Update(const ImageItem *im)
+{
+    if (!im || m_infoVisible == kNoInfo)
+        return;
+
+    // Clear info
+    m_btnList->Reset();
+
+    if (im->IsFile())
+    {
+        // File stats
+        CreateButton("Filename", im->m_name);
+        CreateButton("File Modified",
+                     QDateTime::fromTime_t(im->m_modTime).toString());
+        CreateButton("File size", QString("%1 Kb").arg(im->m_size / 1024));
+        CreateButton("Path", im->m_path);
+
+        NameMap tags = GalleryBERequest::GetMetaData(im);
+
+        // Now go through the info list and create a map for the buttonlist
+        NameMap::const_iterator i = tags.constBegin();
+        while (i != tags.constEnd())
+        {
+            if (m_infoVisible == kFullInfo || kBasicInfoFields.contains(i.key()))
+                CreateButton(i.key(), i.value());
+            ++i;
+        }
+
+        // Only give list focus if requested
+        if (m_btnList->CanTakeFocus())
+            m_screen->SetFocusWidget(m_btnList);
+    }
+    else if (im->m_id == ROOT_DB_ID)
+    {
+        // Gallery stats
+        CreateButton("Last scan", QDateTime::fromTime_t(
+                         im->m_modTime).toString());
+        CreateButton("Contains", QString("%1 Images, %2 Directories")
+                     .arg(im->m_fileCount).arg(im->m_dirCount));
+    }
+    else // dir
+    {
+        // File stats
+        CreateButton("Dirname", im->m_name);
+        CreateButton("Dir Modified",
+                     QDateTime::fromTime_t(im->m_modTime).toString());
+        CreateButton("Path", im->m_path);
+        CreateButton("Contains", QString("%1 Images, %2 Directories")
+                     .arg(im->m_fileCount).arg(im->m_dirCount));
+    }
+}
+
+
+/*!
+ \brief Get current displayed state of buttonlist
+ \return InfoVisibleState
+*/
+InfoVisibleState InfoList::GetState()
+{
+    return m_infoVisible;
+}
+
+
+/*!
+ \brief Get all images/dirs in view
+ \return ImageList List of images/dirs
+*/
+ImageList FlatView::GetAllNodes() const
+{
+    ImageList files;
+    foreach (ImageRef ptr, m_sequence)
+        files.append(*ptr);
+    return files;
+}
+
+
+/*!
+ \brief Get current selection
+ \return ImageItem* An image or NULL
+*/
+ImageItem* FlatView::GetSelected() const
+{
+    return m_active < 0 || m_active >= m_sequence.size()
+           ? NULL : *m_sequence[m_active];
+}
+
+
+/*!
+ \brief Get positional status
+ \return QString "m/n" where m is selected index, n is total count in view
+*/
+QString FlatView::GetPosition() const
+{
+    return QString("%1/%2").arg(m_active + 1).arg(m_sequence.size());
+}
+
+
+/*!
+ \brief Peeks at next image in view but does not advance iterator
+ \return ImageItem The next image or NULL
+*/
+ImageItem* FlatView::HasNext() const
+{
+    return m_sequence.isEmpty() || m_active >= m_sequence.size() - 1
+           ? NULL : *m_sequence[m_active + 1];
+}
+
+
+/*!
+ \brief Peeks at previous image in view but does not decrement iterator
+ \return ImageItem The previous image or NULL
+*/
+ImageItem* FlatView::HasPrev() const
+{
+    return m_sequence.isEmpty() || m_active <= 0
+           ? NULL : *m_sequence[m_active - 1];
+}
+
+
+/*!
+ \brief Updates view with images that have been updated.
+ \param idList List of image ids that have been updated
+ \return bool True if the current selection has been updated
+*/
+bool FlatView::Update(int id)
+{
+    bool activeUpdated = false;
+
+    // Replace old version of image
+    for (int j=0; j < m_images.size(); ++j)
+    {
+        if (m_images.at(j)->m_id == id)
+        {
+            // Get updated image
+            ImageList files;
+            m_db->ReadDbFilesById(files, QString::number(id), false);
+
+            if (files.size() == 1)
+            {
+                activeUpdated = GetSelected() == m_images.at(j);
+
+                // Replace image
+                delete m_images.at(j);
+                m_images.replace(j, files.at(0));
+
+                LOG(VB_FILE, LOG_DEBUG, QString("Views: Modified id %1 @ index %2")
+                    .arg(id).arg(j));
+            }
+            else
+                qDeleteAll(files);
+
+            break;
+        }
+    }
+    return activeUpdated;
+}
+
+
+/*!
+ \brief Select image
+ \param id Image id
+ \param fallback View index to select if image is not in view. Defaults to first
+ image. If negative then current selection is not changed if the image is not found
+ \return bool True if the image was found
+*/
+bool FlatView::Select(int id, int fallback)
+{
+    // Select first appearance of image
+    for (int i = 0; i < m_sequence.size(); ++i)
+    {
+        ImageItem *im = *m_sequence.at(i);
+        if (im->m_id == id)
+        {
+            m_active = i;
+            return true;
+        }
+    }
+
+    if (fallback >= 0)
+        m_active = fallback;
+
+    return false;
+}
+
+
+/*!
+ \brief Reset view
+ \param resetParent parent id is only reset to root when this is set
+*/
+void FlatView::Clear(bool resetParent)
+{
+    if (!m_images.isEmpty())
+        qDeleteAll(m_images);
+    m_images.clear();
+    m_sequence.clear();
+    m_active = -1;
+    if (resetParent)
+        m_parentId = ROOT_DB_ID;
+}
+
+
+/*!
+ \brief Advance iterator and return next image. Wraps at end and regenerates
+ view order on wrap, if necessary
+ \return ImageItem Next image or NULL if empty
+*/
+ImageItem *FlatView::Next()
+{
+    if (m_sequence.isEmpty())
+        return NULL;
+
+    // wrap at end
+    if (m_active >= m_sequence.size() - 1)
+    {
+        if (m_order == kOrdered)
+            m_active = -1;
+        // Regenerate unordered views on every repeat
+        else if (!LoadFromDb())
+            // Images have disappeared
+            return NULL;
+    }
+
+    return *m_sequence[++m_active];
+}
+
+
+/*!
+ \brief Decrements iterator and returns previous image. Wraps at start.
+ \return ImageItem Previous image or NULL if empty
+*/
+ImageItem *FlatView::Prev()
+{
+    if (m_sequence.isEmpty())
+        return NULL;
+
+    if (m_active <= 0)
+        m_active = m_sequence.size();
+
+    return *m_sequence[--m_active];
+}
+
+
+/*!
+ \brief Fills view with Db images, re-ordering them as required
+ \param files List of images from database
+*/
+void FlatView::Populate(ImageList &files)
+{
+    // Do not reset parent
+    Clear(false);
+
+    if (files.isEmpty())
+        return;
+
+    // Store available images for view
+    m_images = files;
+
+    if (m_images.size() == 1 || m_order == kOrdered || m_order == kShuffle)
+    {
+        // Default sequence is ordered
+        for (int i = 0; i < m_images.size(); ++i)
+            m_sequence.append(&m_images.at(i));
+    }
+
+    if (m_images.size() > 1)
+    {
+        // Modify viewing sequence
+        if (m_order == kShuffle)
+        {
+            std::random_shuffle(m_sequence.begin(), m_sequence.end());
+        }
+        else if (m_order == kRandom)
+        {
+            qsrand(QTime::currentTime().msec());
+            int range = m_images.size() - 1;
+            int rand, slot = range;
+            for (int i = 0; i < m_images.size(); ++i)
+            {
+                rand = qrand() % range;
+                // Avoid consecutive repeats
+                slot = (rand < slot) ? rand : rand + 1;
+                m_sequence.append(&m_images.at(slot));
+//                LOG(VB_FILE, LOG_DEBUG, QString("Rand %1").arg(slot));
+            }
+        }
+        else if (m_order == kSeasonal)
+        {
+            WeightList weights   = CalculateSeasonalWeights(m_images);
+            double     maxWeight = weights.last();
+
+            qsrand(QTime::currentTime().msec());
+            for (int i = 0; i < m_images.size(); ++i)
+            {
+                double               randWeight = qrand() * maxWeight / RAND_MAX;
+                WeightList::iterator it =
+                        std::upper_bound(weights.begin(), weights.end(), randWeight);
+                int                  slot = std::distance(weights.begin(), it);
+                m_sequence.append(&m_images.at(slot));
+            }
+        }
+    }
+}
+
+
+/*!
+ \brief 
+ * This method calculates a weight for the item based on how closely it was
+ * taken to the current time of year. This means that New Year's pictures will
+ * be displayed very frequently on every New Year's, and that anniversary
+ * pictures will be favored again every anniversary. The weights are chosen
+ * using a beta distribution with a tunable shape parameter.
+ \param files List of database images
+ \return WeightList Corresponding list of weightings
+*/
+WeightList FlatView::CalculateSeasonalWeights(ImageList &files)
+{
+    WeightList weights(files.size());
+    double     totalWeight = 0;
+    QDateTime  now         = QDateTime::currentDateTime();
+
+    for (int i = 0; i < files.size(); ++i)
+    {
+        ImageItem *im      = files.at(i);
+        double         weight;
+
+        if (im->m_date == 0)
+            weight = DEFAULT_WEIGHT;
+        else
+        {
+            QDateTime      timestamp = QDateTime::fromTime_t(im->m_date);
+            QDateTime curYearAnniversary =
+                QDateTime(QDate(now.date().year(),
+                                timestamp.date().month(),
+                                timestamp.date().day()),
+                          timestamp.time());
+
+            bool      isAnniversaryPast = curYearAnniversary < now;
+
+            QDateTime adjacentYearAnniversary =
+                QDateTime(QDate(now.date().year() +
+                                (isAnniversaryPast ? 1 : -1),
+                                timestamp.date().month(),
+                                timestamp.date().day()),
+                          timestamp.time());
+
+            double range = std::abs(
+                curYearAnniversary.secsTo(adjacentYearAnniversary)) + BETA_CLIP;
+
+            // This calculation is not normalized, because that would require the
+            // beta function, which isn't part of the C++98 libraries. Weights
+            // that aren't normalized work just as well relative to each other.
+            weight = std::pow(abs(now.secsTo(
+                                      isAnniversaryPast ? curYearAnniversary
+                                      : adjacentYearAnniversary
+                                      ) + BETA_CLIP) / range,
+                              TRAILING_BETA_SHAPE - 1) *
+                     std::pow(abs(now.secsTo(
+                                      isAnniversaryPast ?
+                                      adjacentYearAnniversary :
+                                      curYearAnniversary
+                                      ) + BETA_CLIP) / range,
+                              LEADING_BETA_SHAPE - 1);
+        }
+        totalWeight += weight;
+        weights[i]   = totalWeight;
+    }
+    return weights;
+}
+
+
+/*!
+ \brief Populate view with database images from a directory
+ \param parentId The dir id, if positive. Otherwise the view is refreshed using the
+ existing parent dir
+ \return bool True if resulting view is not empty
+*/
+bool FlatView::LoadFromDb(int parentId)
+{
+    if (parentId > 0)
+        m_parentId = parentId;
+
+    // Load child images of the parent
+    ImageList files;
+    m_db->ReadDbChildFiles(files, QString::number(m_parentId), false, true);
+
+    // Load gallery datastore with current dir
+    Populate(files);
+
+    return !files.isEmpty();
+}
+
+
+/*!
+ \brief Rotate view so that starting image is at front.
+ \param id The image to be positioned
+ \param offset Distance the image will be from element 0
+*/
+void FlatView::Rotate(int id, int offset)
+{
+    // Rotate sequence so that (first appearance of) specified image is
+    // at offset from front
+    for (int i = 0; i < m_sequence.size(); ++i)
+    {
+        ImageItem *im = *m_sequence.at(i);
+        if (im->m_id == id)
+        {
+            int first = (i + offset) % m_sequence.size();
+            if (first > 0)
+                m_sequence = m_sequence.mid(first) + m_sequence.mid(0, first);
+            break;
+        }
+    }
+}
+
+
+/*!
+ \brief Constructs a view of images & directories that can be marked
+ \param order Ordering to use for view
+*/
+DirectoryView::DirectoryView(SlideOrderType order, ImageDbReader *db)
+    : FlatView(order, db)
+{
+    m_marked.Reset(ROOT_DB_ID);
+    m_prevMarked.Reset();
+}
+
+
+/*!
+ \brief Get all view items except the first (the parent dir)
+ \return ImageIdList List of images/dirs
+*/
+ImageIdList DirectoryView::GetChildren() const
+{
+    ImageIdList children;
+    for (int i = 1; i < m_sequence.size(); ++i)
+    {
+        ImageItem *im = *m_sequence.at(i);
+        children.append(im->m_id);
+    }
+    return children;
+}
+
+
+/*!
+ \brief Populate view from database as images/subdirs of a directory.
+View is ordered: Parent dir, sub-dirs, images. Dir thumbnails are derived from their
+subtree.
+ \param parentId The dir id, if positive. Otherwise the view is refreshed using the
+ existing parent dir
+ \return bool True if resulting view is not empty
+*/
+bool DirectoryView::LoadFromDb(int parentId)
+{
+    // Invalid id signifies a refresh of the current view
+    if (parentId > 0)
+        SetDirectory(parentId);
+    else
+        parentId = m_parentId;
+
+    // Load visible parent or root
+    ImageItem *parent = GetDbParent(parentId);
+    if (!parent)
+    {
+        Clear();
+        return false;
+    }
+
+    m_parentId = parent->m_id;
+
+    // Preserve current selection
+    ImageItem *selected = GetSelected();
+    int activeId = selected ? selected->m_id : 0;
+
+    // Load db data for this parent dir
+    ImageList dirs, images;
+    GetDbTree(images, dirs, parent);
+
+    // Construct view as:
+    //  Parent kUpDirectory at start for navigating up.
+    //  Ordered dirs
+    //  Ordered files
+    ImageList files = dirs + images;
+    files.prepend(parent);
+
+    Populate(files);
+
+    // Reinstate selection, falling back to parent
+    Select(activeId);
+
+    return true;
+}
+
+
+/*!
+ \brief Resets view
+ \param resetParent parent id is only reset to root when this is set
+*/
+void DirectoryView::Clear(bool resetParent)
+{
+    ClearMarked();
+    FlatView::Clear(resetParent);
+}
+
+
+/*!
+ \brief Mark all images/dirs
+*/
+void DirectoryView::MarkAll()
+{
+    // Any marking clears previous marks
+    m_prevMarked.Reset();
+
+    m_marked.Add(GetChildren());
+}
+
+
+/*!
+ \brief Mark/unmark an image/dir
+ \param id The image/dir
+ \param mark If true, mark item. Otherwise unmark
+*/
+void DirectoryView::Mark(int id, bool mark)
+{
+    if (mark)
+    {
+        // Any marking clears previous marks
+        m_prevMarked.Reset();
+        m_marked.Add(id);
+    }
+    else
+        m_marked.Remove(id);
+}
+
+
+/*!
+ \brief Mark all unmarked items, unmark all marked items
+*/
+void DirectoryView::InvertMarked()
+{
+    // Any marking clears previous marks
+    m_prevMarked.Reset();
+
+    m_marked.Invert(GetChildren());
+}
+
+
+/*!
+ \brief Unmark all items
+*/
+void DirectoryView::ClearMarked()
+{
+    m_marked.Reset();
+    m_prevMarked.Reset();
+}
+
+
+/*!
+ \brief Manage markings on tree navigation
+ \param newParent Id of new parent dir
+*/
+void DirectoryView::SetDirectory(int newParent)
+{
+    // Markings are cleared on every dir change
+    // Any current markings become previous markingsConfirmDeleteSelected
+    // Only 1 set of previous markings are preserved
+    if (m_prevMarked.IsFor(newParent))
+    {
+        // Returned to dir of previous markings: reinstate them
+        m_marked = m_prevMarked;
+        m_prevMarked.Reset();
+        return;
+    }
+
+    if (!m_marked.IsEmpty())
+        // Preserve current markings
+        m_prevMarked = m_marked;
+
+    // Initialise current markings for new dir
+    m_marked.Reset(newParent);
+}
+
+
+/*!
+ \brief Determine current selection, markings & various info to support menu display
+ \return MenuSubjects Current state
+*/
+MenuSubjects DirectoryView::GetMenuSubjects()
+{
+    MenuSubjects state;
+    state.Clear();
+
+    state.m_selected       = GetSelected();
+    state.m_selectedMarked = state.m_selected
+                             && m_marked.Contains(state.m_selected->m_id);
+
+    // At least one set will be empty
+    state.m_markedId     = m_marked.GetIds();
+    state.m_prevMarkedId = m_prevMarked.GetIds();
+
+    state.m_childCount   = m_sequence.size() - 1;
+
+    // Only inspect children
+    for (int i = 1; i < m_sequence.size(); ++i)
+    {
+        ImageItem *im = *m_sequence.at(i);
+
+        if (m_marked.Contains(im->m_id))
+        {
+            state.m_hiddenMarked   = state.m_hiddenMarked || im->m_isHidden;
+            state.m_unhiddenMarked = state.m_unhiddenMarked || !im->m_isHidden;
+        }
+    }
+    return state;
+}
+
+
+/*!
+ \brief Get parent dir from database
+ \param parentId Id of dir
+ \return ImageItem Dir image info
+*/
+ImageItem *DirectoryView::GetDbParent(int parentId) const
+{
+    ImageList dirs;
+    m_db->ReadDbDirsById(dirs, QString::number(parentId), false, false);
+
+    if (dirs.isEmpty())
+    {
+        // Fallback to top level if parent dir no longer exists
+        // If no root then Db is empty
+        return parentId == ROOT_DB_ID ? NULL : GetDbParent(ROOT_DB_ID);
+    }
+
+    // Override parent type
+    if (dirs[0]->m_id != ROOT_DB_ID)
+        dirs[0]->m_type = kUpDirectory;
+    return dirs[0];
+}
+
+
+/*!
+ \brief Get all dirs & images from database, populate stats and determine thumbnails
+ for parent & sub-dirs as follows: Use user cover, if assigned. Otherwise derive
+4 thumbnails from: first 4 images, then 1st thumbnail from first 4 sub-dirs,
+then 2nd thumbnail from sub-dirs etc
+ \param files List to fill with images
+ \param dirs List to fill with sub-dirs
+ \param parent Parent dir
+*/
+void DirectoryView::GetDbTree(ImageList &files,
+                              ImageList &dirs,
+                              ImageItem *parent) const
+{
+    if (!parent)
+        return;
+
+    // Load child images & dirs and set parent stats
+    parent->m_fileCount = m_db->ReadDbChildFiles(
+        files, QString::number(parent->m_id), false, true);
+    parent->m_dirCount = m_db->ReadDbChildDirs(
+        dirs, QString::number(parent->m_id), false, true);
+
+    const ImageItem *userIm = NULL;
+
+    // Load thumbs for child dirs
+    foreach (ImageItem *im, dirs)
+    {
+        // Load sufficient thumbs from each dir as subsequent dirs may be empty
+        GetDbSubTree(im, kMaxFolderThumbnails);
+
+        // Locate user thumbnail amongst dirs
+        if (!userIm && im->m_id == parent->m_userThumbnail)
+            userIm = im;
+    }
+
+    // Try user assigned thumb, if defined
+    if (parent->m_userThumbnail != 0)
+    {
+        if (!userIm)
+            // Locate user thumb amongst images
+            foreach (ImageItem *im, files)
+            {
+                if (im->m_id == parent->m_userThumbnail)
+                {
+                    userIm = im;
+                    break;
+                }
+            }
+
+        if (userIm)
+        {
+            // Using user assigned thumbnail
+            parent->m_thumbIds   = userIm->m_thumbIds;
+            parent->m_thumbNails = userIm->m_thumbNails;
+            return;
+        }
+    }
+
+    // Fill parent thumbs from images
+    foreach (const ImageItem *im, files.mid(0, kMaxFolderThumbnails))
+    {
+        parent->m_thumbIds.append(im->m_id);
+        parent->m_thumbNails.append(im->m_thumbNails.at(0));
+    }
+
+    // If sufficient images, we're done
+    int thumbsNeeded = kMaxFolderThumbnails - files.size();
+    if (thumbsNeeded <= 0)
+        return;
+
+    // Resort to dirs. Use 1st thumb from each dir, then 2nd from each, etc.
+    for (int i = 0; i < kMaxFolderThumbnails; ++i)
+        foreach (const ImageItem *im, dirs)
+        {
+            if (i < im->m_thumbIds.size())
+            {
+                parent->m_thumbIds.append(im->m_thumbIds.at(i));
+                parent->m_thumbNails.append(im->m_thumbNails.at(i));
+                if (--thumbsNeeded == 0)
+                    // Found enough
+                    return;
+            }
+        }
+}
+
+
+/*!
+ \brief Populate directory stats & thumbnails recursively from database as follows:
+Use user cover, if assigned. Otherwise derive 4 thumbnails from: first 4 images,
+then 1st thumbnail from first 4 sub-dirs, then 2nd thumbnail from sub-dirs etc
+ \param parent The parent dir
+ \param limit Number of thumbnails required
+ \param level Recursion level (to detect recursion deadlocks)
+*/
+void DirectoryView::GetDbSubTree(ImageItem *parent, int limit, int level) const
+{
+    // Load child images & dirs
+    ImageList files, dirs;
+    int       imageCount = m_db->ReadDbChildFiles(
+                files, QString::number(parent->m_id), false, true);
+    int       dirCount = m_db->ReadDbChildDirs(
+                dirs, QString::number(parent->m_id), false, true);
+
+    // Set parent stats
+    parent->m_fileCount = imageCount;
+    parent->m_dirCount  = dirCount;
+
+    // Try user assigned thumb, if defined
+    if (parent->m_userThumbnail != 0)
+    {
+        // Locate user thumb amongst images
+        bool found = false;
+        for (int i = 0; i < files.size(); ++i)
+            if (files.at(i)->m_id == parent->m_userThumbnail)
+            {
+                // Only need this image so move it to front
+                found = true;
+                limit = 1;
+                if (i != 0)
+                    files.move(i, 0);
+                break;
+            }
+
+        if (!found)
+        {
+            // Locate user thumb amongst dirs
+            foreach (const ImageItem *im, dirs)
+            {
+                if (im->m_id == parent->m_userThumbnail)
+                {
+                    // Discard all children & use this dir only
+                    ImageItem *tmp = new ImageItem(*im);
+                    qDeleteAll(files);
+                    files.clear();
+                    qDeleteAll(dirs);
+                    dirs.clear();
+                    dirs.append(tmp);
+                    break;
+                }
+            }
+        }
+
+    }
+
+    // Fill parent thumbs from images
+    foreach (const ImageItem *im, files)
+    {
+        parent->m_thumbIds.append(im->m_id);
+        parent->m_thumbNails.append(im->m_thumbNails.at(0));
+        if (--limit == 0)
+            break;
+    }
+
+    if (limit > 0)
+    {
+        // Prevent lengthy/infinite recursion due to deep/cyclic folder
+        // structures
+        if (++level > 10)
+            LOG(VB_GENERAL, LOG_NOTICE,
+                "Directory thumbnails are more than 10 levels deep");
+        else
+        {
+            // Recursively load subdir thumbs to try to get 1 thumb from each
+            foreach (ImageItem *im, dirs)
+            {
+                // Load sufficient thumbs from each dir as subsequent dirs may
+                // be empty
+                GetDbSubTree(im, limit, level);
+
+                if (im->m_thumbIds.size() > 0)
+                {
+                    // Add first thumbnail to parent thumb
+                    parent->m_thumbIds.append(im->m_thumbIds.at(0));
+                    parent->m_thumbNails.append(im->m_thumbNails.at(0));
+
+                    // Quit when we have sufficient thumbs
+                    if (--limit == 0)
+                        break;
+                }
+            }
+
+            if (limit > 0)
+                // Insufficient dirs to supply 1 thumb per dir so use other dir
+                // thumbs as well
+                for (int i = 1; i < kMaxFolderThumbnails; ++i)
+                    foreach (const ImageItem *im, dirs)
+                    {
+                        if (i < im->m_thumbIds.size())
+                        {
+                            parent->m_thumbIds.append(im->m_thumbIds.at(i));
+                            parent->m_thumbNails.append(im->m_thumbNails.at(i));
+                            if (--limit == 0)
+                                break;
+                        }
+                    }
+        }
+    }
+    qDeleteAll(files);
+    qDeleteAll(dirs);
+}
+
+
+/*!
+ \brief Populate view from database as images of a directory sub-tree. Default
+order of a tree is depth-first traversal
+ \param parentId The dir id, if valid. Otherwise the view is refreshed using the
+ existing parent dir
+ \return bool True if resulting view is not empty
+*/
+bool TreeView::LoadFromDb(int parentId)
+{
+    if (parentId > 0)
+        m_parentId = parentId;
+
+    // Load visible subtree of the parent
+    // Ordered images of parent first, then depth-first recursion of ordered dirs
+    ImageList  files, dirs;
+    QStringList root = QStringList() << QString::number(m_parentId);
+    m_db->ReadDbTree(files, dirs, root, false, true);
+
+    // Load view
+    Populate(files);
+
+    // Discard dirs
+    qDeleteAll(dirs);
+
+    return !files.isEmpty();
+}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviews.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviews.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/galleryviews.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/galleryviews.h	2015-04-30 11:17:45.425559811 +0200
@@ -0,0 +1,196 @@
+/*!
+  \file
+  \brief Provides view datastores for Gallery screens
+
+  Manages lists of images and directories that constitute the items displayed by
+  Thumbnail & Slideshow screens. A view populates itself from the database, manages
+  its own ordering, selections and marked items, and provides iterators for navigation.
+  Also provides the image details overlay.
+*/
+
+#ifndef GALLERYVIEWS_H
+#define GALLERYVIEWS_H
+
+#include <QVector>
+
+#include <mythscreentype.h>
+#include <mythuibuttonlist.h>
+#include <imagemetadata.h>
+#include <imageutils.h>
+
+
+//! Order of images in slideshow
+enum SlideOrderType {
+    kOrdered  = 0, //!< Ordered as per user setting GallerySortOrder
+    kShuffle  = 1, //!< Each image appears exactly once, but in random order
+    kRandom   = 2, //!< Random selection from view. An image may be absent or appear multiple times
+    kSeasonal = 3  //!< Biased random selection so that images are more likely to appear on anniversaries
+};
+
+//! Displayed info/details about an image.
+enum InfoVisibleState { kNoInfo,    //!< Details not displayed
+                        kBasicInfo, //!< Shows just the most useful exif tags
+                        kFullInfo   //!< Shows all exif tags
+                      };
+
+//! Seasonal weightings for images in a view
+typedef QVector<double> WeightList;
+
+//! The image info/details buttonlist overlay that displays exif tags
+class InfoList
+{
+public:
+    static InfoList *Create(MythScreenType *, bool, QString);
+
+    void             Toggle(const ImageItem *);
+    bool             Hide();
+    void             Update(const ImageItem *);
+    InfoVisibleState GetState();
+
+private:
+    InfoList(MythScreenType *, bool, QString, MythUIButtonList *infoList);
+    void              CreateButton(QString, QString);
+
+    MythScreenType   *m_screen;
+    MythUIButtonList *m_btnList;
+    InfoVisibleState  m_infoVisible;
+    QString           m_undefinedText;
+};
+
+
+//! A snapshot of current selection, markings & dir info when menu is invoked
+class MenuSubjects
+{
+public:
+    void Clear();
+
+    ImageItem   *m_selected;       //!< Selected item
+    bool         m_selectedMarked; //!< Is selected item marked ?
+    ImageIdList  m_markedId;       //!< Ids of all marked items
+    ImageIdList  m_prevMarkedId;   //!< Ids of marked items in previous dir
+    int          m_childCount;     //!< Number of images & dirs excl parent
+    bool         m_hiddenMarked;   //!< Is any marked item hidden ?
+    bool         m_unhiddenMarked; //!< Is any marked item unhidden ?
+};
+
+
+//! A manager of images/dirs that have been marked
+class MarkedFiles
+{
+public:
+    void        Reset(int id = -1)      { ids.clear(); parent = id; }
+    void        Add(int id)             { ids.insert(id); }
+    void        Add(ImageIdList newIds) { ids += newIds.toSet(); }
+    void        Remove(int id)          { ids.remove(id); }
+    void        Invert(ImageIdList all) { ids = all.toSet() - ids; }
+    bool        Contains(int id) const  { return ids.contains(id); }
+    bool        IsEmpty()               { return ids.isEmpty(); }
+    bool        IsFor(int id)           { return parent == id; }
+    ImageIdList GetIds()                { return ids.toList(); }
+private:
+    int       parent;
+    QSet<int> ids;
+};
+
+
+
+/*!
+ \brief A datastore of images for display by a screen.
+ \details A flat view provides a list of ordered images (no dirs) from a single
+directory, as required by a Normal Slideshow.
+*/
+class FlatView
+{
+public:
+    FlatView(SlideOrderType order, ImageDbReader *db)
+        : m_parentId(-1), m_order(order), m_db(db), m_images(), m_sequence(), m_active(0) {}
+    virtual ~FlatView()             { Clear(); }
+
+    int           GetParentId() const { return m_parentId; }
+    ImageList     GetAllNodes() const;
+    ImageItem    *GetSelected() const;
+    ImageItem    *HasNext() const;
+    ImageItem    *HasPrev() const;
+    ImageItem    *Next();
+    ImageItem    *Prev();
+    QString       GetPosition() const;
+    bool          Select(int id, int fallback = 0);
+    virtual bool  LoadFromDb(int parentId = -1);
+    bool          Remove(const QStringList);
+    bool          Update(int);
+    void          Rotate(int id, int offset = 0);
+    void          Clear(bool resetParent = true);
+
+protected:
+    static WeightList CalculateSeasonalWeights(ImageList &files);
+
+    void              Populate(ImageList &files);
+
+    //! A pointer to a list slot that contains a pointer to an image
+    typedef ImageItem *const *ImageRef;
+
+    int             m_parentId;
+    SlideOrderType  m_order;
+    ImageDbReader  *m_db;
+    //! The set of images (from Db) used by this view. Ordered as per GallerySortOrder
+    ImageList       m_images;
+    //! The sequence in which to display images. References slots in m_images as
+    //! random sequences may contain a specific image many times
+    QList<ImageRef> m_sequence;
+    int             m_active;   //!< Sequence index of current selected image
+};
+
+
+/*!
+ \brief A datastore of images for display by a screen.
+
+Provides an ordered list of dirs & images from a single directory, as
+required by a Thumbnail view. Permits marking of items and populates dir
+thumbnails from their subtree
+*/
+class DirectoryView : public FlatView
+{
+public:
+    DirectoryView(SlideOrderType, ImageDbReader *);
+
+    ImageItem   *GetParent() const { return m_sequence.isEmpty() ? NULL : *m_sequence[0]; }
+    bool         LoadFromDb(int parentId = -1);
+    void         Clear(bool resetParent = true);
+    void         MarkAll();
+    void         Mark(int, bool);
+    void         InvertMarked();
+    void         ClearMarked();
+    bool         IsMarked(int id) const
+    { return m_marked.Contains(id) || m_prevMarked.Contains(id); }
+
+    MenuSubjects GetMenuSubjects();
+
+protected:
+    void         SetDirectory(int);
+    ImageIdList  GetChildren() const;
+    ImageItem   *GetDbParent(int ) const;
+    void         GetDbTree(ImageList &, ImageList &, ImageItem * = NULL) const;
+    void         GetDbSubTree(ImageItem *, int limit, int level = 0) const;
+
+    MarkedFiles m_marked;       //!< Marked items in current dir/view
+    MarkedFiles m_prevMarked;   //!< Marked items in previous dir
+};
+
+
+/*!
+ \brief A datastore of images for display by a screen.
+
+Provides an ordered list of images (no dirs) from a directory subtree.
+Default ordering is a depth-first traversal of the tree
+*/
+class TreeView : public FlatView
+{
+public:
+    TreeView(SlideOrderType order, ImageDbReader *db)
+        : FlatView(order, db) {}
+
+    bool LoadFromDb(int parentId = -1);
+};
+
+
+#endif // GALLERYVIEWS_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerywidget.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerywidget.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerywidget.cpp	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerywidget.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,817 +0,0 @@
-
-#include "gallerywidget.h"
-
-// Qt headers
-
-// MythTV headers
-#include "mythcontext.h"
-#include "mythmainwindow.h"
-#include "mythuihelper.h"
-#include "mythuiimage.h"
-#include "mythuitext.h"
-
-ImageLoadingThread::ImageLoadingThread() :
-    m_image(NULL),
-    m_imageData(NULL),
-    m_url()
-{
-}
-
-void ImageLoadingThread::setImage(MythUIImage *image,
-                                  ImageMetadata *imageData,
-                                  QString &url)
-{
-    m_image = image;
-    m_imageData = imageData;
-    m_url = url;
-}
-
-void ImageLoadingThread::run()
-{
-    if (m_image && m_imageData)
-    {
-        m_image->SetFilename(m_url);
-        m_image->SetOrientation(m_imageData->GetOrientation());
-        m_image->SetZoom(static_cast<float>(m_imageData->GetZoom()) / 100);
-        m_image->Load(false);
-    }
-}
-
-
-/** \fn     GalleryWidget::GalleryWidget(MythScreenStack *,
- *                       const char *, GalleryViewHelper *
- *  \brief  Constructor
- *  \param  parent The screen parent
- *  \param  name The name of the screen
- *  \param  ivh Main helper class of the image plugin
- *  \return void
- */
-GalleryWidget::GalleryWidget(MythScreenStack *parent,
-                         const char *name,
-                         GalleryViewHelper *ivh) : MythScreenType(parent, name),
-    m_menuPopup(NULL),
-    m_image1(NULL),
-    m_image2(NULL),
-    m_status(NULL),
-    m_infoList(NULL),
-    m_fileList(NULL),
-    m_fileDataList(NULL)
-{
-    m_gvh = ivh;
-    m_fh = new GalleryFileHelper();
-
-    m_ilt = new ImageLoadingThread();
-    connect(m_ilt, SIGNAL(finished()),
-            this, SLOT(HandleImageTransition()));
-
-    m_backendHost = gCoreContext->GetSetting("BackendServerIP","localhost");
-    m_backendPort = gCoreContext->GetSetting("BackendServerPort", "6543");
-
-    m_slideShowType = kNoSlideShow;
-    m_slideShowTime = gCoreContext->GetNumSetting("GallerySlideShowTime", 3000);
-    m_transitionType = gCoreContext->GetNumSetting("GalleryTransitionType", kFade);
-
-    // calculate the alphachange from the specified transition time.
-    // an alphachange of 1 would take approx. 3,64s because the alpha value is
-    // changed 70 times per second. 3,64 * 70 = 255 (max alpha).
-    // example: 2 = abs(36400 / 15000) with transition time of 1500
-    m_transitionTime = abs(((255 / 70) * 10000) /
-                           (gCoreContext->GetNumSetting("GalleryTransitionTime", 1000) * 10));
-
-    m_popupStack = GetMythMainWindow()->GetStack("popup stack");
-
-    // Save the selected image in the gallery view
-    // so that the initially selected image can be
-    // restored when the GalleryWidget is detroyed.
-    m_selectedNode = m_gvh->m_currentNode->getSelectedChild();
-
-    // this timer is used for the slideshow
-    m_timer = new QTimer();
-    m_timer->setSingleShot(true);
-    m_timer->setInterval(m_slideShowTime);
-
-    m_infoVisible = false;
-    m_index = 0;
-}
-
-
-
-/** \fn     GalleryWidget::~GalleryWidget()
- *  \brief  Destructor
- */
-GalleryWidget::~GalleryWidget()
-{
-    if (m_timer)
-        m_timer->stop();
-
-    delete m_timer;
-    m_timer = NULL;
-
-    delete m_fileList;
-    m_fileList = NULL;
-
-    delete m_fileDataList;
-    m_fileDataList = NULL;
-
-    delete m_fh;
-    m_fh = NULL;
-
-    if (m_ilt)
-        m_ilt->wait();
-
-    delete m_ilt;
-    m_ilt = NULL;
-
-    // Set the selected image in the gallery view to the saved one
-    // so that the initially selected image is the correct one again.
-    m_gvh->m_currentNode->setSelectedChild(m_selectedNode);
-}
-
-
-
-/** \fn     GalleryWidget::Create()
- *  \brief  Initialises and shows the graphical elements
- *  \return True if successful otherwise false
- */
-bool GalleryWidget::Create()
-{
-    if (!LoadWindowFromXML("image-ui.xml", "slideshow", this))
-        return false;
-
-    bool err = false;
-
-    // Widget for showing the images
-    UIUtilE::Assign(this, m_image1, "first_image", &err);
-    UIUtilE::Assign(this, m_image2, "second_image", &err);
-    UIUtilW::Assign(this, m_status, "status");
-
-    // Widgets to show the details to an image
-    UIUtilE::Assign(this, m_infoList, "infolist", &err);
-
-    if (err)
-    {
-        LOG(VB_GENERAL, LOG_ERR, "Cannot load screen 'slideshow'");
-        return false;
-    }
-
-    HideFileDetails();
-    BuildFocusList();
-    SetFocusWidget(m_image1);
-
-    m_fileDataList = new QList<ImageMetadata *>();
-    m_fileDataList->append(new ImageMetadata());
-    m_fileDataList->append(new ImageMetadata());
-
-    m_fileList = new QList<MythUIImage *>();
-    m_fileList->append(m_image1);
-    m_fileList->append(m_image2);
-
-    return true;
-}
-
-
-
-/** \fn     GalleryWidget::keyPressEvent(QKeyEvent *)
- *  \brief  Translates the keypresses and keys bound to the
- *          plugin to specific actions within the plugin
- *  \param  event The pressed key
- *  \return True if key was used, otherwise false
- */
-bool GalleryWidget::keyPressEvent(QKeyEvent *event)
-{
-    if (GetFocusWidget()->keyPressEvent(event))
-        return true;
-
-    bool handled = false;
-    QStringList actions;
-    handled = GetMythMainWindow()->TranslateKeyPress("Images", event, actions);
-
-    for (int i = 0; i < actions.size() && !handled; i++)
-    {
-        QString action = actions[i];
-        handled = true;
-
-        if (action == "LEFT")
-            ShowPrevFile();
-        else if (action == "RIGHT")
-            ShowNextFile();
-        else if (action == "INFO")
-            ShowFileDetails();
-        else if (action == "MENU")
-            MenuMain();
-        else if (action == "PLAY")
-        {
-            // If no slideshow is active and the user presses the play
-            // button then start a normal slideshow. But if a slideshow
-            // is already running then start or pause it.
-            if (m_slideShowType == kNoSlideShow)
-                StartNormalSlideShow();
-            else
-            {
-                if (m_timer->isActive())
-                    PauseSlideShow();
-                else
-                    ResumeSlideShow();
-            }
-        }
-        else if (action == "PAUSE")
-            PauseSlideShow();
-        else if (action == "STOP")
-            StopSlideShow();
-        else if (action == "ROTRIGHT")
-        {
-            m_gvh->SetFileOrientation(kFileRotateCW);
-            LoadFile();
-        }
-        else if (action == "ROTLEFT")
-        {
-            m_gvh->SetFileOrientation(kFileRotateCCW);
-            LoadFile();
-        }
-        else if (action == "FLIPHORIZONTAL")
-        {
-            m_gvh->SetFileOrientation(kFileFlipHorizontal);
-            LoadFile();
-        }
-        else if (action == "FLIPVERTICAL")
-        {
-            m_gvh->SetFileOrientation(kFileFlipVertical);
-            LoadFile();
-        }
-        else if (action == "ZOOMIN")
-        {
-            m_gvh->SetFileZoom(kFileZoomIn);
-            LoadFile();
-        }
-        else if (action == "ZOOMOUT")
-        {
-            m_gvh->SetFileZoom(kFileZoomOut);
-            LoadFile();
-        }
-        else if (action == "ESCAPE")
-        {
-            if (m_infoVisible)
-                HideFileDetails();
-            else
-                handled = false;
-        }
-    }
-
-    if (!handled && MythScreenType::keyPressEvent(event))
-        handled = true;
-
-    return handled;
-}
-
-
-/** \fn     GalleryWidget::customEvent(QEvent *event)
- *  \brief  Translates the keypresses to
- *          specific actions within the plugin
- *  \param  event The custom event
- */
-void GalleryWidget::customEvent(QEvent *event)
-{
-    if (event->type() == DialogCompletionEvent::kEventType)
-    {
-        DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
-
-        QString resultid  = dce->GetId();
-        int     buttonnum = dce->GetResult();
-
-        if (resultid == "metadatamenu")
-        {
-            switch (buttonnum)
-            {
-            case 0 :
-                m_gvh->SetFileOrientation(kFileRotateCW);
-                LoadFile(true);
-                break;
-            case 1 :
-                m_gvh->SetFileOrientation(kFileRotateCCW);
-                LoadFile(true);
-                break;
-            case 2 :
-                m_gvh->SetFileOrientation(kFileFlipHorizontal);
-                LoadFile(true);
-                break;
-            case 3 :
-                m_gvh->SetFileOrientation(kFileFlipVertical);
-                LoadFile(true);
-                break;
-            case 4 :
-                m_gvh->SetFileZoom(kFileZoomIn);
-                LoadFile();
-                break;
-            case 5 :
-                m_gvh->SetFileZoom(kFileZoomOut);
-                LoadFile();
-                break;
-            }
-        }
-
-        m_menuPopup = NULL;
-    }
-}
-
-
-/** \fn     GalleryView::MenuMain()
- *  \brief  Shows a dialog popup with the main menu
- *  \return void
- */
-void GalleryWidget::MenuMain()
-{
-    // Create the main menu that will contain the submenus above
-    MythMenu *menu = new MythMenu(tr("Image Information"), this, "mainmenu");
-
-    // If no slideshow type was given show the item to start it
-    // otherwise show the items to stop or resume a slideshow.
-    if (m_slideShowType == kNoSlideShow)
-    {
-        menu->AddItem(tr("Start Normal SlideShow"),
-                      SLOT(StartNormalSlideShow()));
-        menu->AddItem(tr("Start Random SlideShow"),
-                      SLOT(StartRandomSlideShow()));
-    }
-    else
-    {
-        if (m_timer->isActive())
-            menu->AddItem(tr("Pause SlideShow"), SLOT(PauseSlideShow()));
-        else
-        {
-            if (m_slideShowType == kNormalSlideShow)
-                menu->AddItem(tr("Resume SlideShow"),
-                              SLOT(StartNormalSlideShow()));
-
-            if (m_slideShowType == kRandomSlideShow)
-                menu->AddItem(tr("Resume SlideShow"),
-                              SLOT(StartRandomSlideShow()));
-        }
-    }
-
-    MenuMetadata(menu);
-    menu->AddItem(tr("Show Details"),   SLOT(FileDetails()));
-
-    m_menuPopup = new MythDialogBox(menu, m_popupStack, "menuPopup");
-    if (!m_menuPopup->Create())
-    {
-        delete m_menuPopup;
-        m_menuPopup = NULL;
-        return;
-    }
-
-    m_popupStack->AddScreen(m_menuPopup);
-}
-
-
-
-/** \fn     GalleryWidget::MenuMetadata(MythMenu *)
- *  \brief  Adds a new metadata menu entry into the main menu
- *  \param  mainMenu Parent that will hold the menu entry
- *  \return void
- */
-void GalleryWidget::MenuMetadata(MythMenu *mainMenu)
-{
-    MythMenu *menu = new MythMenu(tr("Metadata Options"),
-                                  this, "metadatamenu");
-
-    menu->AddItem(tr("Rotate CW"));
-    menu->AddItem(tr("Rotate CCW"));
-    menu->AddItem(tr("Flip Horizontal"));
-    menu->AddItem(tr("Flip Vertical"));
-
-    if (m_fileDataList->at(m_index))
-    {
-        if (m_fileDataList->at(m_index)->GetZoom() < 300)
-            menu->AddItem(tr("Zoom In"));
-
-        if (m_fileDataList->at(m_index)->GetZoom() > 20)
-            menu->AddItem(tr("Zoom Out"));
-    }
-
-    mainMenu->AddItem(tr("Meta Data Menu"), NULL, menu);
-}
-
-
-
-/** \fn     GalleryWidget::HideFileDetails()
- *  \brief  Hides the details of the current file
- *  \return void
- */
-void GalleryWidget::HideFileDetails()
-{
-    m_infoList->SetVisible(false);
-    m_infoVisible = false;
-    SetFocusWidget(m_image1);
-}
-
-
-
-/** \fn     GalleryWidget::ShowFileDetails()
- *  \brief  Shows the available details of the current image file.
-            The details will only be shown if the file is an image.
- *  \return void
- */
-void GalleryWidget::ShowFileDetails()
-{
-    ImageMetadata *im = m_fileDataList->at(m_index);
-    if (!im)
-        return;
-
-    if (im->m_type != kImageFile)
-    {
-        delete im;
-        return;
-    }
-
-    // First remove all entries
-    m_infoList->Reset();
-
-    // This map holds all the exif tag values
-    QMap<QString, QString> infoList = m_fh->GetExifValues(im);
-
-    // Now go through the info list and create a map for the mythui buttonlist
-    QMap<QString, QString>::const_iterator i = infoList.constBegin();
-    while (i != infoList.constEnd())
-    {
-        MythUIButtonListItem *item = new MythUIButtonListItem(m_infoList, "");
-        InfoMap infoMap;
-        infoMap.insert("name", i.key());
-
-        QString value = tr("Not defined");
-        if (!i.value().isEmpty())
-            value = i.value();
-
-        infoMap.insert("value", value);
-
-        item->SetTextFromMap(infoMap);
-
-        ++i;
-    }
-
-    m_infoList->SetVisible(true);
-
-    // All widgets are visible, remember this
-    m_infoVisible = true;
-    SetFocusWidget(m_infoList);
-}
-
-
-/** \fn     GalleryWidget::LoadFile()
- *  \brief  Stops any slideshow and loads the file
- *          from disk or memory in the background.
- *  \return void
- */
-void GalleryWidget::LoadFile(bool refresh)
-{
-    // Pause the slideshow so that the timer can't fire
-    // until the image loading thread has finished
-    PauseSlideShow();
-
-    // Switch the index
-    m_index = (m_index == 0) ? 1 : 0;
-
-    // Load the new data into the new index, this will be
-    // the new image which will be shown in the foreground
-    m_fileDataList->replace(m_index, m_gvh->GetImageMetadataFromSelectedNode());
-
-    if (m_fileDataList->at(m_index))
-    {
-        // Show an information that
-        // the image is being loaded
-        if (m_status)
-            m_status->SetVisible(true);
-
-        m_fileList->at(m_index)->SetAlpha(0);
-
-        // Get the full path and name of the image
-        // or if its a video the first preview image
-        QString fileName = m_fileDataList->at(m_index)->m_fileName;
-        if (m_fileDataList->at(m_index)->m_type == kVideoFile)
-            fileName = m_fileDataList->at(m_index)->m_thumbFileNameList->at(0);
-
-        QString url = CreateImageUrl(fileName);
-
-        if (refresh)
-            // remove cache image to force a reload
-            GetMythUI()->RemoveFromCacheByFile(fileName);
-
-        // This thread will load the image so the UI is not blocked.
-        m_ilt->setImage(m_fileList->at(m_index),
-                        m_fileDataList->at(m_index), url);
-        m_ilt->start();
-    }
-}
-
-
-
-/** \fn     GalleryWidget::CreateImageUrl(QString &fileName)
- *  \brief
- *  \return QString
- */
-QString GalleryWidget::CreateImageUrl(QString &fileName)
-{
-    QString url = gCoreContext->GenMythURL(gCoreContext->GetMasterHostName(),
-                                           gCoreContext->GetMasterServerPort(),
-                                           fileName,
-                                           m_gvh->m_sgName);
-
-    LOG(VB_FILE, LOG_INFO, QString("Loading image from url '%1'").arg(url));
-
-    return url;
-}
-
-
-
-/** \fn     GalleryWidget::HandleImageTransition()
- *  \brief  Handles any specified effects between two
- *          images when the file loading was completed
- *  \return void
- */
-void GalleryWidget::HandleImageTransition()
-{
-    // If the image loading is done then resume the slideshow which was
-    // only paused to not to interfere with the loading process.
-    ResumeSlideShow();
-
-    // Also update the file details information in case its visible.
-    if (m_infoVisible)
-        ShowFileDetails();
-
-    // Hide the status information
-    // that can be displayed in the themes
-    if (m_status)
-        m_status->SetVisible(false);
-
-    switch (m_transitionType)
-    {
-    case kFade:
-        HandleFadeTransition();
-        break;
-
-    default:
-        HandleNoTransition();
-        break;
-    }
-}
-
-
-
-/** \fn     GalleryWidget::HandleFadeTransition()
- *  \brief  Handles the fading between two images
- *  \return void
- */
-void GalleryWidget::HandleFadeTransition()
-{
-    int index = (m_index == 0) ? 1 : 0;
-
-    // Fade out the old image if its loaded. This will not be done when
-    // called for the first time because there is no object at this index
-    if (m_fileDataList->at(index))
-        m_fileList->at(index)->AdjustAlpha(1, (m_transitionTime * -1), 0, 255);
-
-    // Fade in the new image and if the next
-    // file is a video then start playing it
-    if (m_fileDataList->at(m_index))
-    {
-        m_fileList->at(m_index)->AdjustAlpha(1, m_transitionTime, 0, 255);
-        if (m_fileDataList->at(m_index)->m_type == kVideoFile)
-        {
-            if (m_fileDataList->at(index))
-                m_fileList->at(index)->SetAlpha(0);
-
-            PauseSlideShow();
-            GetMythMainWindow()->HandleMedia("Internal",
-                                             m_fileDataList->at(m_index)->m_fileName);
-        }
-    }
-}
-
-
-
-/** \fn     GalleryWidget::HandleNoTransition()
- *  \brief  Just like the HandleFadeTransition() method but without any effects.
- *  \return void
- */
-void GalleryWidget::HandleNoTransition()
-{
-    int index = (m_index == 0) ? 1 : 0;
-
-    // Hide the old image if its loaded. This will not be done when
-    // called for the first time because there is no object at this index
-    if (m_fileDataList->at(index))
-        m_fileList->at(index)->SetAlpha(0);
-
-    // Immediately show the new image and if the next
-    // file is a video then start playing it
-    if (m_fileDataList->at(m_index))
-    {
-        m_fileList->at(m_index)->SetAlpha(255);
-        if (m_fileDataList->at(m_index)->m_type == kVideoFile)
-        {
-            PauseSlideShow();
-            GetMythMainWindow()->HandleMedia("Internal",
-                                             m_fileDataList->at(m_index)->m_fileName);
-        }
-    }
-}
-
-
-
-/** \fn     GalleryWidget::ShowPrevFile()
- *  \brief  Loads the previous image file if possible
- *  \return void
- */
-void GalleryWidget::ShowPrevFile()
-{
-    MythGenericTree *node = m_gvh->m_currentNode->getSelectedChild()->prevSibling(1);
-    ImageMetadata *im = m_gvh->GetImageMetadataFromNode(node);
-
-    // If a data object exists then a node must also exist
-    if (im && (im->m_type == kImageFile ||
-                 im->m_type == kVideoFile))
-    {
-        m_gvh->m_currentNode->setSelectedChild(node);
-        LoadFile();
-    }
-    else
-    {
-        QString msg = "You have reached the beginning of the gallery.";
-        ShowInformation(msg);
-    }
-}
-
-
-
-/** \fn     GalleryWidget::ShowNextFile()
- *  \brief  Loads the next image file if possible
- *  \return void
- */
-void GalleryWidget::ShowNextFile()
-{
-    PauseSlideShow();
-
-    MythGenericTree *node = m_gvh->m_currentNode->getSelectedChild()->nextSibling(1);
-    ImageMetadata *im = m_gvh->GetImageMetadataFromNode(node);
-
-    // If a data object exists then a node must also exist
-    if (im && (im->m_type == kImageFile ||
-                 im->m_type == kVideoFile))
-    {
-        m_gvh->m_currentNode->setSelectedChild(node);
-        LoadFile();
-    }
-    else
-    {
-        QString msg = "You have reached the end of the gallery.";
-        ShowInformation(msg);
-    }
-}
-
-
-
-/** \fn     GalleryWidget::ShowRandomFile()
- *  \brief  Loads a random image
- *  \return void
- */
-void GalleryWidget::ShowRandomFile()
-{
-    volatile bool exit = false;
-
-    int size = m_gvh->m_currentNode->getSelectedChild()->siblingCount();
-    int counter = 0;
-    int position = 0;
-
-    MythGenericTree *node = NULL;
-    ImageMetadata *im = NULL;
-
-    PauseSlideShow();
-
-    // Get a random node from the list. If its not an image or
-    // video continue and try to get a new one until its an image
-    // or all siblings have been checked.
-    if (size > 0)
-    {
-        while (!exit)
-        {
-            position = (qrand() % size);
-            counter++;
-
-            node = m_gvh->m_currentNode->getChildAt(position);
-            im = m_gvh->GetImageMetadataFromNode(node);
-
-            if ((im && (im->m_type == kImageFile ||
-                          im->m_type == kVideoFile)) || counter == size)
-                exit = true;
-        }
-
-        // If we have data then is is already an image or
-        // video. This has been checked in the while loop
-        if (im)
-        {
-            m_gvh->m_currentNode->setSelectedChild(node);
-            LoadFile();
-        }
-    }
-    else
-    {
-        QString msg = "There are no images in the current directory.";
-        ShowInformation(msg);
-    }
-}
-
-
-
-/** \fn     GalleryWidget::ShowInformation(QString &msg)
- *  \brief  Shows a message to the user
- *  \param  msg The message that shall be shown
- *  \return void
- */
-void GalleryWidget::ShowInformation(QString &msg)
-{
-    MythConfirmationDialog *okPopup =
-            new MythConfirmationDialog(m_popupStack, msg, false);
-
-    if (okPopup->Create())
-        m_popupStack->AddScreen(okPopup);
-    else
-        delete okPopup;
-}
-
-
-
-/** \fn     GalleryWidget::StartNormalSlideShow()
- *  \brief  Starts a slideshow where the images are shown in normal order
- *  \return void
- */
-void GalleryWidget::StartNormalSlideShow()
-{
-    if (!m_timer)
-        return;
-
-    StopSlideShow();
-    m_slideShowType = kNormalSlideShow;
-    connect(m_timer, SIGNAL(timeout()), this, SLOT(ShowNextFile()));
-    ResumeSlideShow();
-}
-
-
-
-/** \fn     GalleryWidget::StartRandomSlideShow()
- *  \brief  Starts a slideshow where the images are shown randomly
- *  \return void
- */
-void GalleryWidget::StartRandomSlideShow()
-{
-    if (!m_timer)
-        return;
-
-    StopSlideShow();
-    m_slideShowType = kRandomSlideShow;
-    connect(m_timer, SIGNAL(timeout()), this, SLOT(ShowRandomFile()));
-    ResumeSlideShow();
-}
-
-
-
-/** \fn     GalleryWidget::ResumeSlideShow()
- *  \brief  Resumes a paused slideshow
- *  \return void
- */
-void GalleryWidget::ResumeSlideShow()
-{
-    if (!m_timer)
-        return;
-
-    m_timer->start();
-}
-
-
-
-/** \fn     GalleryWidget::PauseSlideShow()
- *  \brief  Pauses an active slideshow
- *  \return void
- */
-void GalleryWidget::PauseSlideShow()
-{
-    if (!m_timer)
-        return;
-
-    m_timer->stop();
-}
-
-
-
-/** \fn     GalleryWidget::StopSlideShow()
- *  \brief  Stops an active slideshow
- *  \return void
- */
-void GalleryWidget::StopSlideShow()
-{
-    if (!m_timer)
-        return;
-
-    m_timer->stop();
-    m_timer->disconnect();
-
-    m_slideShowType = kNoSlideShow;
-}
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerywidget.h mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerywidget.h
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/gallerywidget.h	2015-04-30 11:09:02.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/gallerywidget.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-#ifndef GALLERYWIDGET_H
-#define GALLERYWIDGET_H
-
-// Qt headers
-#include <QTimer>
-
-// libmythui headers
-#include "mythscreentype.h"
-#include "mythdialogbox.h"
-#include "mythgenerictree.h"
-#include "mythuibuttonlist.h"
-
-// libmythmetadata headers
-#include "imagemetadata.h"
-
-// frontend headers
-#include "galleryviewhelper.h"
-#include "galleryfilehelper.h"
-
-class ImageLoadingThread : public QThread
-{
-public:
-    ImageLoadingThread();
-    void setImage(MythUIImage *image,
-                  ImageMetadata *imageData,
-                  QString &url);
-    void run();
-
-private:
-    MythUIImage     *m_image;
-    ImageMetadata   *m_imageData;
-    QString          m_url;
-};
-
-
-
-class GalleryWidget : public MythScreenType
-{
-    Q_OBJECT
-public:
-    GalleryWidget(MythScreenStack *parent,
-                const char *name,
-                GalleryViewHelper*);
-    ~GalleryWidget();
-
-    bool Create();
-    bool keyPressEvent(QKeyEvent *);
-    void customEvent(QEvent *);
-    void LoadFile(bool refresh = false);
-    void ShowFileDetails();
-
-public slots:
-    void StartNormalSlideShow();
-    void StartRandomSlideShow();
-
-private:
-    void HandleFadeTransition();
-    void HandleNoTransition();
-    void ShowInformation(QString &);
-    void HideFileDetails();
-
-    QString CreateImageUrl(QString &);
-
-private slots:
-    void MenuMain();
-    void MenuMetadata(MythMenu *);
-    void ShowPrevFile();
-    void ShowNextFile();
-    void ShowRandomFile();
-    void HandleImageTransition();
-
-    void StopSlideShow();
-    void PauseSlideShow();
-    void ResumeSlideShow();
-
-private:
-    MythDialogBox      *m_menuPopup;
-    MythScreenStack    *m_popupStack;
-    MythUIImage        *m_image1;
-    MythUIImage        *m_image2;
-    MythUIText         *m_status;
-
-    MythUIButtonList       *m_infoList;
-    QList<MythUIImage *>   *m_fileList;
-    QList<ImageMetadata *>       *m_fileDataList;
-
-    GalleryFileHelper  *m_fh;
-    GalleryViewHelper  *m_gvh;
-    MythGenericTree    *m_selectedNode;
-    ImageLoadingThread *m_ilt;
-
-    int                 m_index;
-    int                 m_slideShowType;
-    int                 m_slideShowTime;
-    int                 m_transitionTime;
-    int                 m_transitionType;
-    QTimer             *m_timer;
-
-    QString             m_backendHost;
-    QString             m_backendPort;
-
-    bool                m_infoVisible;
-};
-
-#endif // GALLERYWIDGET_H
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/main.cpp mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/main.cpp
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/main.cpp	2015-04-30 11:09:02.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/main.cpp	2015-04-30 11:17:45.428893130 +0200
@@ -92,7 +92,7 @@
 #include "videolist.h"
 
 // Gallery
-#include "galleryview.h"
+#include "gallerythumbview.h"
 
 // DVD
 #include "DVD/dvdringbuffer.h"
@@ -684,11 +684,11 @@
 static void RunGallery()
 {
     MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
-    GalleryView *galleryView = new GalleryView(mainStack, "galleryview");
+    GalleryThumbView *galleryView = new GalleryThumbView(mainStack, "galleryview");
     if (galleryView->Create())
     {
         mainStack->AddScreen(galleryView);
-        galleryView->LoadData();
+        galleryView->Start();
     }
     else
     {
@@ -1401,30 +1401,40 @@
          "Display Item Detail Popup"), "");
 
      // Gallery keybindings
-     REG_KEY("Images", "PLAY", QT_TRANSLATE_NOOP("MythControls",
+     REG_KEY("Images", "SLIDESHOW", QT_TRANSLATE_NOOP("MythControls",
          "Start Slideshow"), "P");
      REG_KEY("Images", "PAUSE", QT_TRANSLATE_NOOP("MythControls",
          "Pause Slideshow"), "Ctrl+P");
      REG_KEY("Images", "STOP", QT_TRANSLATE_NOOP("MythControls",
          "Stop Slideshow"), "Alt+P");
-     REG_KEY("Images", "SLIDESHOW", QT_TRANSLATE_NOOP("MythControls",
-         "Start Slideshow in thumbnail view"), "S");
-     REG_KEY("Images", "RANDOMSHOW", QT_TRANSLATE_NOOP("MythControls",
-         "Start Random Slideshow in thumbnail view"), "R");
+     REG_KEY("Images", "RECURSIVESHOW", QT_TRANSLATE_NOOP("MythControls",
+         "Start Recursive Slideshow"), "R");
      REG_KEY("Images", "ROTRIGHT", QT_TRANSLATE_NOOP("MythControls",
          "Rotate image right 90 degrees"), "],3");
      REG_KEY("Images", "ROTLEFT", QT_TRANSLATE_NOOP("MythControls",
          "Rotate image left 90 degrees"), "[,1");
-     REG_KEY("Images", "ZOOMOUT", QT_TRANSLATE_NOOP("MythControls",
-         "Zoom image out"), "7");
-     REG_KEY("Images", "ZOOMIN", QT_TRANSLATE_NOOP("MythControls",
-         "Zoom image in"), "9");
      REG_KEY("Images", "FLIPHORIZONTAL", QT_TRANSLATE_NOOP("MythControls",
          "Flip image horizontally"), "");
      REG_KEY("Images", "FLIPVERTICAL", QT_TRANSLATE_NOOP("MythControls",
          "Flip image vertically"), "");
+     REG_KEY("Images", "ZOOMOUT", QT_TRANSLATE_NOOP("MythControls",
+         "Zoom image out"), "7");
+     REG_KEY("Images", "ZOOMIN", QT_TRANSLATE_NOOP("MythControls",
+         "Zoom image in"), "9");
+     REG_KEY("Images", "FULLSIZE", QT_TRANSLATE_NOOP("MythControls",
+         "Full-size (un-zoom) image"), "0");
      REG_KEY("Images", "MARK", QT_TRANSLATE_NOOP("MythControls",
          "Mark image"), "T");
+     REG_KEY("Images", "SCROLLUP", QT_TRANSLATE_NOOP("MythControls",
+         "Scroll image up"), "2");
+     REG_KEY("Images", "SCROLLLEFT", QT_TRANSLATE_NOOP("MythControls",
+         "Scroll image left"), "4");
+     REG_KEY("Images", "SCROLLRIGHT", QT_TRANSLATE_NOOP("MythControls",
+         "Scroll image right"), "6");
+     REG_KEY("Images", "SCROLLDOWN", QT_TRANSLATE_NOOP("MythControls",
+         "Scroll image down"), "8");
+     REG_KEY("Images", "RECENTER", QT_TRANSLATE_NOOP("MythControls",
+         "Recenter image"), "5");
 }
 
 static void ReloadKeys(void)
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/mythfrontend.pro mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/mythfrontend.pro
--- mythtv-master-20150430-g70ae25d-old/mythtv/programs/mythfrontend/mythfrontend.pro	2015-04-30 11:09:03.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/programs/mythfrontend/mythfrontend.pro	2015-04-30 11:17:45.428893130 +0200
@@ -52,10 +52,10 @@
 HEADERS += videoplayersettings.h        videodlg.h
 HEADERS += videoglobalsettings.h        upnpscanner.h
 HEADERS += commandlineparser.h          idlescreen.h
-HEADERS += galleryview.h                galleryviewhelper.h
-HEADERS += galleryconfig.h              galleryfilehelper.h
-HEADERS += gallerydatabasehelper.h      gallerywidget.h
-HEADERS += gallerytypedefs.h
+HEADERS += gallerythumbview.h           galleryslideview.h
+HEADERS += galleryconfig.h              galleryviews.h
+HEADERS += gallerycommhelper.h          gallerytransitions.h
+HEADERS += galleryslide.h
 
 SOURCES += main.cpp playbackbox.cpp viewscheduled.cpp audiogeneralsettings.cpp
 SOURCES += globalsettings.cpp manualschedule.cpp programrecpriority.cpp
@@ -77,9 +77,10 @@
 SOURCES += videoplayersettings.cpp      videodlg.cpp
 SOURCES += videoglobalsettings.cpp      upnpscanner.cpp
 SOURCES += commandlineparser.cpp        idlescreen.cpp
-SOURCES += galleryview.cpp              gallerywidget.cpp
-SOURCES += galleryviewhelper.cpp        galleryconfig.cpp
-SOURCES += gallerydatabasehelper.cpp    galleryfilehelper.cpp
+SOURCES += gallerythumbview.cpp         galleryslideview.cpp
+SOURCES += galleryconfig.cpp            galleryviews.cpp
+SOURCES += gallerycommhelper.cpp        gallerytransitions.cpp
+SOURCES += galleryslide.cpp
 
 HEADERS += serviceHosts/frontendServiceHost.h
 HEADERS += services/frontend.h
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/themes/default/base.xml mythtv-master-20150430-g70ae25d-new/mythtv/themes/default/base.xml
--- mythtv-master-20150430-g70ae25d-old/mythtv/themes/default/base.xml	2015-04-30 11:08:43.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/themes/default/base.xml	2015-04-30 11:17:45.428893130 +0200
@@ -85,8 +85,8 @@
     <shape name="basebackground">
         <area>0,0,10,10</area>
         <type>roundbox</type>
-        <fill color="#000000" alpha="120" />
-        <line color="#FFFFFF" alpha="255" width="2" />
+        <fill color="#000000" alpha="120"/>
+        <line color="#FFFFFF" alpha="255" width="2"/>
         <cornerradius>12</cornerradius>
     </shape>
 
@@ -95,12 +95,12 @@
         <area>0,0,100%,100%</area>
         <type>roundbox</type>
         <cornerradius>4</cornerradius>
-        <fill color="#CCCCCC" alpha="120" />
-        <line color="#FFFFFF" width="3" />
+        <fill color="#CCCCCC" alpha="120"/>
+        <line color="#FFFFFF" width="3"/>
     </shape>
 
     <shape name="baseselectedwidgetshape" from="basewidgetshape">
-        <fill color="#43b038" alpha="200" />
+        <fill color="#43b038" alpha="200"/>
     </shape>
 
     <buttonlist name="basebuttonlist">
@@ -115,7 +115,7 @@
                 <shape name="buttonbackground">
                     <area>0,0,100%,100%</area>
                     <fill style="gradient">
-                        <gradient start="#505050" end="#000000" alpha="200" direction="vertical"  />
+                        <gradient start="#505050" end="#000000" alpha="200" direction="vertical"/>
                     </fill>
                 </shape>
                 <textarea name="buttontext">
@@ -150,14 +150,14 @@
             <state name="selectedactive" from="active">
                 <shape name="buttonbackground">
                     <fill style="gradient">
-                        <gradient start="#52CA38" end="#349838" alpha="255" />
+                        <gradient start="#52CA38" end="#349838" alpha="255"/>
                     </fill>
                 </shape>
             </state>
             <state name="selectedinactive" from="active">
                 <shape name="buttonbackground">
                     <fill style="gradient">
-                        <gradient start="#52CA38" end="#349838" alpha="100" />
+                        <gradient start="#52CA38" end="#349838" alpha="100"/>
                     </fill>
                 </shape>
                 <textarea name="buttontext">
@@ -229,7 +229,7 @@
                             <filename>schedule_recording.png</filename>
                         </imagetype>
                     </state>
-                    <state name="marked"></state>
+                    <state name="marked"/>
                 </statetype>
                 <textarea name="buttontext">
                     <area>33,1,730,24</area>
@@ -246,11 +246,11 @@
                 <shape name="selectbar">
                     <area>25,0,735,25</area>
                     <type>roundbox</type>
-                    <line color="#999999" alpha="255" width="2" />
+                    <line color="#999999" alpha="255" width="2"/>
                     <cornerradius>13</cornerradius>
                 </shape>
             </state>
-            <state name="selectedinactive" from="active" />
+            <state name="selectedinactive" from="active"/>
         </statetype>
         <statetype name="upscrollarrow">
             <position>710,285</position>
@@ -301,7 +301,7 @@
                     <filename>button_selected_background.png</filename>
                 </imagetype>
             </state>
-            <state name="disabled" from="active" />
+            <state name="disabled" from="active"/>
             <state name="pushed" from="active">
                 <imagetype name="background">
                     <filename>button_pushed_background.png</filename>
@@ -334,7 +334,7 @@
                     <filename>wide_button_selected_background.png</filename>
                 </imagetype>
             </state>
-            <state name="disabled" from="active" />
+            <state name="disabled" from="active"/>
             <state name="pushed" from="active">
                 <imagetype name="background">
                     <filename>wide_button_pushed_background.png</filename>
@@ -367,7 +367,7 @@
                     <filename>very_wide_button_selected_background.png</filename>
                 </imagetype>
             </state>
-            <state name="disabled" from="active" />
+            <state name="disabled" from="active"/>
             <state name="pushed" from="active">
                 <imagetype name="background">
                     <filename>very_wide_button_pushed_background.png</filename>
@@ -394,7 +394,7 @@
                     <filename>blankbutton_on.png</filename>
                 </imagetype>
             </state>
-            <state name="disabled" from="active" />
+            <state name="disabled" from="active"/>
             <state name="pushed" from="active">
                 <imagetype name="background">
                     <filename>blankbutton_pushed.png</filename>
@@ -417,11 +417,11 @@
                     <filename>checkbox_background_selected.png</filename>
                 </imagetype>
             </state>
-            <state name="disabled" />
+            <state name="disabled"/>
         </statetype>
         <statetype name="checkstate">
             <position>3,3</position>
-            <state type="off" />
+            <state type="off"/>
             <state type="half">
                 <imagetype name="background">
                     <filename>checkbox_halfcheck.png</filename>
@@ -442,7 +442,7 @@
         <statetype name="buttonitem">
             <state name="active">
                 <area>0,0,70,40</area>
-                <shape name="background" from="basewidgetshape" />
+                <shape name="background" from="basewidgetshape"/>
                 <textarea name="buttontext">
                     <area>5,5,55,30</area>
                     <font>basesmall</font>
@@ -451,9 +451,9 @@
                 </textarea>
             </state>
             <state name="selectedactive" from="active">
-                <shape name="background" from="baseselectedwidgetshape" />
+                <shape name="background" from="baseselectedwidgetshape"/>
             </state>
-            <state name="selectedinactive" from="active" />
+            <state name="selectedinactive" from="active"/>
         </statetype>
         <statetype name="downscrollarrow">
             <position>75,2</position>
@@ -496,9 +496,9 @@
                 </textarea>
             </state>
             <state name="selectedactive" from="active">
-                <shape name="background" from="baseselectedwidgetshape" />
+                <shape name="background" from="baseselectedwidgetshape"/>
             </state>
-            <state name="selectedinactive" from="active" />
+            <state name="selectedinactive" from="active"/>
         </statetype>
         <statetype name="downscrollarrow">
             <position>380,2</position>
@@ -516,7 +516,7 @@
         <statetype name="buttonitem">
             <state name="active">
                 <area>0,0,200,40</area>
-                <shape name="background" from="basewidgetshape" />
+                <shape name="background" from="basewidgetshape"/>
                 <textarea name="buttontext">
                     <area>5,5,190,30</area>
                     <font>basesmall</font>
@@ -525,9 +525,9 @@
                 </textarea>
             </state>
             <state name="selectedactive" from="active">
-                <shape name="background" from="baseselectedwidgetshape" />
+                <shape name="background" from="baseselectedwidgetshape"/>
             </state>
-            <state name="selectedinactive" from="active" />
+            <state name="selectedinactive" from="active"/>
         </statetype>
         <statetype name="downscrollarrow">
             <position>205,2</position>
@@ -569,9 +569,9 @@
                 </textarea>
             </state>
             <state name="selectedactive" from="active">
-                <shape name="background" from="baseselectedwidgetshape" />
+                <shape name="background" from="baseselectedwidgetshape"/>
             </state>
-            <state name="selectedinactive" from="active" />
+            <state name="selectedinactive" from="active"/>
         </statetype>
         <statetype name="downscrollarrow">
             <position>380,2</position>
@@ -595,21 +595,21 @@
         <statetype name="background">
             <state name="active">
                 <area>0,0,375,50</area>
-                <shape name="background" from="basewidgetshape" />
+                <shape name="background" from="basewidgetshape"/>
                 <shape name="textbackground">
                     <area>10,10,355,30</area>
                     <type>roundbox</type>
                     <cornerradius>4</cornerradius>
-                    <fill color="#FFFFFF" alpha="200" />
+                    <fill color="#FFFFFF" alpha="200"/>
                 </shape>
             </state>
             <state name="selected" from="active">
-                <shape name="background" from="baseselectedwidgetshape" />
+                <shape name="background" from="baseselectedwidgetshape"/>
                 <shape name="textbackground">
-                    <fill color="#FFFFFF" alpha="255" />
+                    <fill color="#FFFFFF" alpha="255"/>
                 </shape>
             </state>
-            <state name="inactive" from="active" />
+            <state name="inactive" from="active"/>
         </statetype>
         <imagetype name="cursor">
             <filename>cursor.png</filename>
@@ -626,21 +626,21 @@
         <statetype name="background">
             <state name="active">
                 <area>0,0,375,110</area>
-                <shape name="background" from="basewidgetshape" />
+                <shape name="background" from="basewidgetshape"/>
                 <shape name="textbackground">
                     <area>10,10,355,90</area>
                     <type>roundbox</type>
                     <cornerradius>4</cornerradius>
-                    <fill color="#FFFFFF" alpha="200" />
+                    <fill color="#FFFFFF" alpha="200"/>
                 </shape>
             </state>
             <state name="selected" from="active">
-                <shape name="background" from="baseselectedwidgetshape" />
+                <shape name="background" from="baseselectedwidgetshape"/>
                 <shape name="textbackground">
-                    <fill color="#FFFFFF" alpha="255" />
+                    <fill color="#FFFFFF" alpha="255"/>
                 </shape>
             </state>
-            <state name="inactive" from="active" />
+            <state name="inactive" from="active"/>
         </statetype>
         <imagetype name="cursor">
             <filename>cursor.png</filename>
@@ -727,6 +727,217 @@
         </state>
     </statetype>
 
+    <!-- Extra small text for Gallery images -->
+    <fontdef name="gallerytext" from="basesmall">
+        <pixelsize>18</pixelsize>
+        <outlinecolor>#000000</outlinecolor>
+        <outlinesize>2</outlinesize>
+    </fontdef>
+
+    <!-- A gallery button showing a picture, video or folder -->
+    <group name="galleryactivebutton">
+        <area>0,0,100%,100%</area>
+        <!-- Show a background image depending on node type -->
+        <statetype name="buttontype">
+            <area>0,0,100%,100%</area>
+            <state name="subfolder">
+                <area>0,0,100%,100%</area>
+                <imagetype name="background">
+                    <area>0,0,100%,100%</area>
+                    <filename>shared/folder-reg.png</filename>
+                </imagetype>
+            </state>
+            <state name="root" from="subfolder"/>
+            <state name="upfolder" from="subfolder">
+                <imagetype name="icon">
+                    <area>10%,2%,40%,13%</area>
+                    <filename>shared/updirectory.png</filename>
+                    <preserveaspect>yes</preserveaspect>
+                </imagetype>
+            </state>
+            <state name="image">
+                <area>0,0,100%,100%</area>
+                <imagetype name="background">
+                    <area>0,0,100%,100%</area>
+                    <filename>shared/grid_back_reg.png</filename>
+                    <alpha>64</alpha>
+                </imagetype>
+            </state>
+            <state name="video">
+                <area>0,0,100%,100%</area>
+                <imagetype name="background">
+                    <area>0,0,100%,100%</area>
+                    <filename>shared/movie-reg.png</filename>
+                </imagetype>
+            </state>
+        </statetype>
+        <!-- Show how many images / directories are in this directory -->
+        <textarea name="childcount" from="basetextarea">
+            <area>0,0,55%,15%</area>
+            <font>gallerytext</font>
+            <align>allcenter</align>
+        </textarea>
+        <!-- Shows a picture image -->
+        <imagetype name="buttonimage">
+            <area>2%,2%,98%,98%</area>
+            <preserveaspect>yes</preserveaspect>
+        </imagetype>
+        <!-- Shows a single folder image -->
+        <imagetype name="folderimage">
+            <area>4%,15%,97%,98%</area>
+            <preserveaspect>yes</preserveaspect>
+        </imagetype>
+        <!-- Shows a video image -->
+        <imagetype name="videoimage">
+            <area>4%,10%,97%,90%</area>
+            <preserveaspect>yes</preserveaspect>
+        </imagetype>
+        <!-- Shows 4 images for default folder -->
+        <imagetype name="thumbimage0">
+            <area>4%,15%,47%,47%</area>
+            <preserveaspect>false</preserveaspect>
+        </imagetype>
+        <imagetype name="thumbimage1">
+            <area>51%,15%,92%,47%</area>
+            <preserveaspect>false</preserveaspect>
+        </imagetype>
+        <imagetype name="thumbimage2">
+            <area>4%,57%,47%,93%</area>
+            <preserveaspect>false</preserveaspect>
+        </imagetype>
+        <imagetype name="thumbimage3">
+            <area>51%,57%,92%,93%</area>
+            <preserveaspect>false</preserveaspect>
+        </imagetype>
+        <!-- Darken hidden files/ folders -->
+        <statetype name="buttonstate">
+            <area>0,0,100%,100%</area>
+            <state name="visible"/>
+            <state name="hidden">
+                <area>0,0,100%,100%</area>
+                <shape name="hidden_background_shape">
+                    <area>0,0,100%,100%</area>
+                    <type>box</type>
+                    <fill color="#000000" alpha="128"/>
+                </shape>
+            </state>
+        </statetype>
+        <!-- Shows that the image was marked/selected and
+        might be manipulated with other images -->
+        <statetype name="buttoncheck">
+            <area>0,0,100%,100%</area>
+            <state type="full">
+                <area>42%,49%,26%,26%</area>
+                <shape name="marked_background">
+                    <area>0,0,100%,100%</area>
+                    <type>ellipse</type>
+                    <fill color="#000000"/>
+                </shape>
+                <imagetype name="marked">
+                    <area>0,0,100%,100%</area>
+                    <filename>schedule_recording.png</filename>
+                </imagetype>
+            </state>
+        </statetype>
+        <textarea name="buttontext">
+            <area>0,100%-22,100%,22</area>
+            <font>gallerytext</font>
+            <align>allcenter</align>
+        </textarea>
+    </group>
+
+    <!-- A selected gallery button of a picture, video or folder -->
+    <group name="galleryselectedbutton" from="galleryactivebutton">
+        <area>0,0,100%,100%</area>
+        <statetype name="buttontype">
+            <area>0,0,100%,100%</area>
+            <state name="subfolder">
+                <area>0,0,100%,100%</area>
+                <imagetype name="background">
+                    <area>0,0,100%,100%</area>
+                    <filename>shared/folder-sel.png</filename>
+                </imagetype>
+            </state>
+            <state name="root" from="subfolder"/>
+            <state name="upfolder" from="subfolder">
+                <imagetype name="icon">
+                    <area>10%,2%,40%,13%</area>
+                    <filename>shared/updirectory.png</filename>
+                    <preserveaspect>yes</preserveaspect>
+                </imagetype>
+            </state>
+            <state name="image">
+                <area>0,0,100%,100%</area>
+                <imagetype name="background">
+    <area>0,0,100%,100%</area>
+    <filename>shared/grid_back_sel.png</filename>
+    <alpha>255</alpha>
+    </imagetype>
+            </state>
+            <state name="video">
+                <area>0,0,100%,100%</area>
+                <imagetype name="background">
+                    <area>0,0,100%,100%</area>
+                    <filename>shared/movie-sel.png</filename>
+                </imagetype>
+            </state>
+        </statetype>
+    </group>
+
+    <!--Image information used by multiple windows-->
+    <buttonlist name="galleryinfolist">
+        <area>1%,0,99%,100%-30</area>
+        <layout>vertical</layout>
+        <spacing>0</spacing>
+        <wrapstyle>selection</wrapstyle>
+        <buttonarea>0,5%,100%,98%</buttonarea>
+        <statetype name="buttonitem">
+            <area>0,0,100%,100%</area>
+            <state name="active">
+                <area>0,0,100%,34</area>
+                <shape name="buttonbackground">
+                    <area>0,0,100%,100%</area>
+                    <fill style="gradient">
+                        <gradient start="#505050" end="#000000" alpha="128" direction="vertical"/>
+                    </fill>
+                </shape>
+                <textarea name="name" from="basetextarea">
+                    <area>2%,0%,35%,100%</area>
+                    <align>vcenter</align>
+                </textarea>
+                <textarea name="value" from="name">
+                    <area>40%,0%,98%,100%</area>
+                </textarea>
+                </state>
+            <state name="selectedactive" from="active">
+                <shape name="buttonbackground">
+                    <area>0,0,100%,100%</area>
+                    <fill style="gradient">
+                        <gradient start="#52CA38" end="#349838" alpha="255"/>
+                    </fill>
+                </shape>
+            </state>
+            <state name="inactive" from="active"/>
+            <state name="selectedinactive" from="active"/>
+        </statetype>
+        <statetype name="upscrollarrow">
+            <position>46%,2%</position>
+            <state type="full">
+                <imagetype name="upoff">
+                    <filename>lb-uparrow-sel.png</filename>
+                </imagetype>
+            </state>
+        </statetype>
+        <statetype name="downscrollarrow">
+            <position>46%,97%</position>
+            <state type="full">
+                <imagetype name="dnoff">
+                     <filename>lb-dnarrow-sel.png</filename>
+                </imagetype>
+            </state>
+        </statetype>
+    </buttonlist>
+
     <!-- Popup Dialogue Box -->
     <window name="MythPopupBox">
         <area>-1,-1,500,500</area>
@@ -773,7 +984,7 @@
 
         <shape name="background" from="basebackground">
             <area>10,10,780,580</area>
-            <fill color="#333333" alpha="255" />
+            <fill color="#333333" alpha="255"/>
         </shape>
 
         <textarea name="title" from="basetextarea">
@@ -1017,7 +1228,7 @@
             <statetype name="buttonitem">
                 <state name="active">
                     <area>0,0,165,105</area>
-                    <shape name="buttonbackground" />
+                    <shape name="buttonbackground"/>
                     <statetype name="nodetype">
                         <state name="folder">
                             <imagetype name="icon">
@@ -1051,12 +1262,13 @@
                         <align>allcenter</align>
                     </textarea>
                 </state>
-                <state name="selectedinactive" from="active" />
+                <state name="inactive" from="active"/>
+                <state name="selectedinactive" from="active"/>
                 <state name="selectedactive" from="active">
                     <shape name="buttonbackground">
                         <area>0,0,165,105</area>
                         <fill style="gradient">
-                            <gradient start="#999999" end="#666666" alpha="220" />
+                            <gradient start="#999999" end="#666666" alpha="220"/>
                         </fill>
                     </shape>
                 </state>
@@ -1095,6 +1307,165 @@
 
     </window>
 
+    <window name="MythMultiFileBrowser">
+        <area>0,0,100%,100%</area>
+        <imagetype name="backimg">
+            <area>0,0,100%,100%</area>
+            <filename>mythfilebrowser-background.png</filename>
+        </imagetype>
+
+        <textedit name="location" from="basetextedit">
+            <area>4%,20,60%,50</area>
+        </textedit>
+
+        <buttonlist name="filelist">
+            <area>0,0,100%,100%</area>
+            <layout>grid</layout>
+            <buttonarea>2%,78,72%,100%-80</buttonarea>
+            <spacing>2</spacing>
+            <statetype name="buttonitem">
+                <state name="active">
+                    <area>0,0,176,126</area>
+                    <shape name="buttonbackground"/>
+                    <statetype name="nodetype">
+                        <area>0,0,100%,100%</area>
+                        <state name="folder">
+                            <area>4%,4%,92%,66%</area>
+                            <imagetype name="icon">
+                                <area>0,0,100%,100%</area>
+                                <filename>shared/directory.png</filename>
+                                <preserveaspect>yes</preserveaspect>
+                            </imagetype>
+                        </state>
+                        <state name="upfolder" from="folder">
+                            <area>4%,4%,92%,66%</area>
+                            <imagetype name="icon">
+                                <area>0,0,100%,100%</area>
+                                <filename>shared/updirectory.png</filename>
+                            </imagetype>
+                        </state>
+                        <state name="executable" from="folder">
+                            <area>4%,4%,92%,66%</area>
+                            <imagetype name="icon">
+                                <area>0,0,100%,100%</area>
+                                <filename>shared/executable.png</filename>
+                            </imagetype>
+                        </state>
+                        <state name="file" from="folder">
+                            <area>4%,4%,92%,66%</area>
+                            <imagetype name="icon">
+                                <area>0,0,100%,100%</area>
+                                <filename>shared/file.png</filename>
+                            </imagetype>
+                        </state>
+                    </statetype>
+                    <imagetype name="buttonimage">
+                        <area>2%,3%,96%,97%-30</area>
+                        <preserveaspect>true</preserveaspect>
+                    </imagetype>
+                    <textarea name="buttontext" from="basetextarea">
+                        <area>0,100%-28,100%,26</area>
+                        <align>allcenter</align>
+                    </textarea>
+            <statetype name="buttoncheck">
+                <area>0,0,100%,100%</area>
+                <state type="full">
+                    <area>40%,35%,40%,40%</area>
+                    <imagetype name="marked">
+                        <area>0,0,100%,100%</area>
+                        <filename>playlist_yes.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+                </state>
+                <state name="inactive" from="active"/>
+                <state name="selectedinactive" from="active"/>
+                <state name="selectedactive" from="active">
+                    <area>0,0,176,126</area>
+                    <shape name="buttonbackground">
+                        <area>0,0,100%,100%</area>
+                        <fill style="gradient">
+                            <gradient start="#999999" end="#666666" alpha="220"/>
+                        </fill>
+                    </shape>
+                </state>
+            </statetype>
+            <statetype name="upscrollarrow">
+                <position>73%,78</position>
+                <state type="off">
+                    <imagetype name="upon">
+                        <filename>lb-uparrow-reg.png</filename>
+                    </imagetype>
+                </state>
+                <state type="full">
+                    <imagetype name="upoff">
+                        <filename>lb-uparrow-sel.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+            <statetype name="downscrollarrow">
+                <position>73%,100%-100</position>
+                <state type="off">
+                    <imagetype name="dnon">
+                        <filename>lb-dnarrow-reg.png</filename>
+                    </imagetype>
+                </state>
+                <state type="full">
+                    <imagetype name="dnoff">
+                        <filename>lb-dnarrow-sel.png</filename>
+                    </imagetype>
+                </state>
+            </statetype>
+        </buttonlist>
+
+        <!--<button name="back" from="basebutton">
+            <position>79%,20</position>
+            <value>Up Level</value>
+        </button>-->
+
+        <!--<button name="home" from="basebutton">
+            <position>79%,70</position>
+            <value>Home</value>
+        </button>-->
+
+        <button name="selectall" from="basebutton">
+            <position>79%,3%</position>
+            <value>Select All</value>
+        </button>
+
+        <button name="clearall" from="basebutton">
+            <position>79%,10%</position>
+            <value>Clear All</value>
+        </button>
+
+        <textarea name="selectcount" from="basetextarea">
+            <area>72%,19%,92%,30</area>
+            <align>allcenter</align>
+            <template>%n selection(s)</template>
+        </textarea>
+
+        <imagetype name="preview">
+            <area>72%,23%,92%,70%</area>
+            <preserveaspect>true</preserveaspect>
+        </imagetype>
+
+        <textarea name="info" from="basetextarea">
+            <area>72%,78%,100%,30</area>
+            <align>allcenter</align>
+        </textarea>
+
+        <button name="cancel" from="basebutton">
+            <position>79%,83%</position>
+            <value>Cancel</value>
+        </button>
+
+        <button name="ok" from="basebutton">
+            <position>79%,90%</position>
+            <value>Import</value>
+        </button>
+
+    </window>
+
     <window name="MythTimeInputDialog">
         <area>-1,-1,580,165</area>
 
@@ -1130,7 +1501,7 @@
         <shape name="shape1">
             <area>0,0,800,600</area>
             <type>box</type>
-            <fill color="#000000" alpha="255" />
+            <fill color="#000000" alpha="255"/>
         </shape>
 
         <textarea name="title" from="basetextarea">
@@ -1179,7 +1550,7 @@
                     <shape name="buttonbackground">
                         <area>0,0,100%,100%</area>
                         <fill style="gradient">
-                            <gradient start="#505050" end="#000000" alpha="200" direction="vertical"  />
+                            <gradient start="#505050" end="#000000" alpha="200" direction="vertical"/>
                         </fill>
                     </shape>
                     <imagetype name="buttonimage">
@@ -1196,14 +1567,14 @@
                 <state name="selectedactive" from="active">
                     <shape name="buttonbackground">
                         <fill style="gradient">
-                            <gradient start="#52CA38" end="#349838" alpha="255" />
+                            <gradient start="#52CA38" end="#349838" alpha="255"/>
                         </fill>
                     </shape>
                 </state>
                 <state name="selectedinactive" from="active">
                     <shape name="buttonbackground">
                         <fill style="gradient">
-                            <gradient start="#52CA38" end="#349838" alpha="100" />
+                            <gradient start="#52CA38" end="#349838" alpha="100"/>
                         </fill>
                     </shape>
                     <textarea name="resolution">
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/themes/default/image-ui.xml mythtv-master-20150430-g70ae25d-new/mythtv/themes/default/image-ui.xml
--- mythtv-master-20150430-g70ae25d-old/mythtv/themes/default/image-ui.xml	2015-04-30 11:08:43.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/themes/default/image-ui.xml	2015-04-30 11:17:45.428893130 +0200
@@ -4,367 +4,77 @@
 
     <window name="gallery">
 
-        <!-- The heading (name) of the screen -->
-        <textarea name="heading" from="basetextarea">
-            <position>0,0</position>
-            <textarea name="text">
-            <value>Image Gallery</value>
-            </textarea>
-        </textarea>
-
-        <textarea name="syncprogresstext" from="basetextarea">
-            <area>300,20,200,30</area>
+        <!--Shows scan progress-->
+        <progressbar name="scanprogressbar" from="baseprogressbar">
+            <area>25%,5,50%,40</area>
+            <imagetype name="background">
+                <area>0,0,100%,100%</area>
+            </imagetype>
+            <imagetype name="progressimage">
+                <area>0,0,100%,100%</area>
+            </imagetype>
+        </progressbar>
+
+        <!--Shows numerical scan progress-->
+        <textarea name="scanprogresstext" from="basetextarea">
+            <area>25%,10,50%,30</area>
             <align>center</align>
         </textarea>
 
-        <!-- the shape where the imagelist is displayed -->
-        <shape name="gallerybackground">
-            <area>10,60,780,533</area>
-            <type>roundbox</type>
-            <fill color="#000000" alpha="130" />
-            <line color="#AAAAAA" alpha="150" width="1" />
-            <cornerradius>2</cornerradius>
-        </shape>
+        <!--shows path to current image -->
+        <textarea name="breadcrumbs" from="basetextarea">
+            <area>20,5,70%,30</area>
+            <font>title</font>
+            <cutdown>yes</cutdown>
+        </textarea>
 
         <!-- shows the name of the folder or image -->
-        <textarea name="title" from="basetextarea">
-            <area>45,70,500,30</area>
+        <textarea name="caption" from="basetextarea">
+            <area>20,30,70%,30</area>
             <cutdown>yes</cutdown>
             <font>title</font>
-            <align>left,vcenter</align>
+            <align>left</align>
         </textarea>
 
-        <!-- optional - shows current position in grid eg '1 of 123' -->
-        <textarea name="position" from="basetextarea">
-            <area>680,70,100,30</area>
-            <align>right,vcenter</align>
+        <!-- shows state of hidden filter -->
+        <textarea name="hidefilter" from="basetextarea">
+            <area>65%,5,120,30</area>
         </textarea>
 
-        <!-- shows path to current image -->
-        <textarea name="breadcrumbs" from="basetextarea">
-            <area>45,100,600,30</area>
-            <font>text_very_small</font>
-            <cutdown>yes</cutdown>
+        <!-- shows state of type filter -->
+        <textarea name="typefilter" from="basetextarea">
+            <area>75%,5,130,30</area>
         </textarea>
 
-        <textarea name="thumbprogresstext" from="basetextarea">
-            <area>550,85,100,20</area>
-            <align>right,vcenter</align>
+        <!-- shows current position in grid eg '1/123' -->
+        <textarea name="position" from="basetextarea">
+            <area>100%-160,5,140,30</area>
+            <font>title</font>
+            <align>right</align>
         </textarea>
 
-        <!-- the list that shows the images in the screen -->
-        <buttonlist name="images">
-            <area>50,155,750,435</area>
-            <buttonarea>0,0,750,435</buttonarea>
+        <!-- Mandatory: the image list 10 columns x 6 rows -->
+        <buttonlist name="images0">
+            <area>10,30,100%-10,100%-30</area>
+            <buttonarea>0,25,100%,100%</buttonarea>
             <wrapstyle>flowing</wrapstyle>
             <layout>grid</layout>
-            <spacing>17</spacing>
+            <arrange>fixed</arrange>
+            <align>allcenter</align>
+            <spacing>0</spacing>
             <statetype name="buttonitem">
-
-                <state name="active">
-                    <area>0,0,164,124</area>
-
-                    <!-- This is the dark background behind each image -->
-                    <shape name="buttonimage_background_shape">
-                        <area>0,0,164,124</area>
-                        <type>box</type>
-                        <line color="#000000" alpha="0" width="1" />
-                        <fill color="#000000" alpha="130" />
-                    </shape>
-
-                    <!-- Show an additional background image if required. This is
-                    primarily useful when the item is a folder and a folder background
-                    image shall be shown behind the small preview thumbnail images -->
-                    <statetype name="buttonbackground">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <imagetype name="icon">
-                                <area>2,2,160,120</area>
-                                <filename>gallery-folder-reg.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <imagetype name="icon">
-                                <area>2,2,160,120</area>
-                                <filename>gallery-folder-reg.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                        <state name="video">
-                        </state>
-                    </statetype>
-
-                    <!-- this shows the actual image -->
-                    <imagetype name="buttonimage">
-                        <area>2,2,160,120</area>
-                        <preserveaspect>yes</preserveaspect>
-                    </imagetype>
-
-                    <imagetype name="thumbimage1">
-                        <area>2,2,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage2">
-                        <area>82,2,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage3">
-                        <area>82,62,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage4">
-                        <area>2,62,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-
-                    <!-- This is the border around the image. Its placed here
-                         draw over the edges of the image -->
-                    <shape name="buttonimage_border_shape">
-                        <area>0,0,164,124</area>
-                        <type>box</type>
-                        <fill color="#000000" alpha="0" />
-                        <line color="#AAAAAA" alpha="150" width="1" />
-                    </shape>
-
-                    <!-- shows that the image was marked/selected and
-                        might be manipulated with other images -->
-                    <statetype name="buttoncheck">
-                        <position>2,2</position>
-                        <state type="full">
-                            <shape name="marked_background">
-                                <area>0,0,33,33</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="marked">
-                                <filename>gallery-mark.png</filename>
-                            </imagetype>
-                        </state>
-                    </statetype>
-
-                    <!-- Shows an indication if a file or folder is hidden
-                         or not. It will be marked and darkened -->
-                    <statetype name="buttonstate">
-                        <position>0,0</position>
-                        <state name="hidden">
-                            <shape name="hidden_background_shape">
-                                <area>1,1,162,122</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="210" />
-                            </shape>
-                        </state>
-                        <state name="visible">
-                        </state>
-                    </statetype>
-
-                    <!-- show additional information about the selected item.
-                         Shows a small folder or video icon -->
-                    <statetype name="buttontype">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,93,162,30</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>7,97,24,24</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,93,162,30</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>7,97,24,24</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="video">
-                            <shape name="buttonimage_shape">
-                                <area>120,80,43,43</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>122,83,37,37</area>
-                                <filename>gallery-moviethumb.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                    </statetype>
-
-                    <!-- show how many images / directories are in this directory -->
-                    <textarea name="childcount" from="basetextarea">
-                        <area>37,95,90,30</area>
-                        <font>text_small</font>
-                        <align>left,vcenter</align>
-                    </textarea>
-                </state>
-
-                <state name="selectedactive">
-                    <area>-38,-28,240,180</area>
-
-                    <shape name="buttonimage_background_shape">
-                        <area>0,0,240,180</area>
-                        <type>box</type>
-                        <line color="#000000" alpha="0" width="1" />
-                        <fill color="#000000" alpha="130" />
-                    </shape>
-
-                    <statetype name="buttonbackground">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <imagetype name="icon">
-                                <area>2,2,235,176</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <imagetype name="icon">
-                                <area>2,2,235,176</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                        <state name="video">
-                        </state>
-                    </statetype>
-
-                    <imagetype name="buttonimage">
-                        <area>2,2,235,176</area>
-                        <preserveaspect>yes</preserveaspect>
-                    </imagetype>
-
-                    <imagetype name="thumbimage1">
-                        <area>2,2,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage2">
-                        <area>119,2,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage3">
-                        <area>119,90,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage4">
-                        <area>2,90,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-
-                    <shape name="buttonimage_border_shape">
-                        <area>0,0,240,180</area>
-                        <type>box</type>
-                        <fill color="#000000" alpha="0" />
-                        <line color="#AAAAAA" alpha="150" width="2" />
-                    </shape>
-
-                    <statetype name="buttoncheck">
-                        <position>2,2</position>
-                        <state type="full">
-                            <shape name="marked_background">
-                                <area>0,0,33,33</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="210" />
-                            </shape>
-                            <imagetype name="marked">
-                                <filename>gallery-mark.png</filename>
-                            </imagetype>
-                        </state>
-                    </statetype>
-
-                    <statetype name="buttonstate">
-                        <position>0,0</position>
-                        <state name="hidden">
-                            <shape name="hidden_background_shape">
-                                <area>1,1,162,122</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="210" />
-                            </shape>
-                        </state>
-                        <state name="visible">
-                        </state>
-                    </statetype>
-
-                    <statetype name="buttontype">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,139,238,40</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>9,144,32,32</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,139,238,40</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>9,144,32,32</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="video">
-                            <shape name="buttonimage_shape">
-                                <area>181,121,58,58</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>183,124,52,52</area>
-                                <filename>gallery-moviethumb.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                    </statetype>
-
-                    <textarea name="childcount" from="basetextarea">
-                        <area>49,145,90,30</area>
-                        <font>text_small</font>
-                        <align>left,vcenter</align>
-                    </textarea>
-
+                <area>0,0,100%,100%</area>
+                <state name="active" from="galleryactivebutton">
+                    <area>0,0,10%,16%</area>
                 </state>
+                <state name="selectedactive" from="galleryselectedbutton">
+                    <area>0,0,10%,16%</area>
+                </state>
+                <state name="inactive" from="active"/>
+                <state name="selectedinactive" from="active"/>
             </statetype>
-
-            <!-- Show the arrow image that indicates that there are
-                more menu entries above the first visible menu -->
             <statetype name="upscrollarrow">
-                <position>690,-50</position>
+                <position>100%-70,5</position>
                 <state type="off">
                     <imagetype name="upon">
                         <filename>lb-uparrow-reg.png</filename>
@@ -378,9 +88,9 @@
             </statetype>
 
             <!-- Show the arrow image that indicates that there are
-                more menu entries below the last visible menu -->
+                more images below -->
             <statetype name="downscrollarrow">
-                <position>715,-50</position>
+                <position>100%-30,5</position>
                 <state type="off">
                     <imagetype name="dnon">
                         <filename>lb-dnarrow-reg.png</filename>
@@ -395,195 +105,106 @@
 
         </buttonlist>
 
+        <!-- the image list 8 columns x 4 rows -->
+        <buttonlist name="images1" from="images0">
+            <statetype name="buttonitem">
+                <state name="active" from="galleryactivebutton">
+                    <area>0,0,12%,25%</area>
+                </state>
+                <state name="selectedactive" from="galleryselectedbutton">
+                    <area>0,0,12%,25%</area>
+                </state>
+            </statetype>
+        </buttonlist>
+
+        <!-- the image list 6 columns x 3 rows -->
+        <buttonlist name="images2" from="images0">
+            <statetype name="buttonitem">
+                <state name="active" from="galleryactivebutton">
+                    <area>0,0,16%,33%</area>
+                </state>
+                <state name="selectedactive" from="galleryselectedbutton">
+                    <area>0,0,16%,33%</area>
+                </state>
+            </statetype>
+        </buttonlist>
+
+        <!-- the image list 4 columns x 2 rows -->
+        <buttonlist name="images3" from="images0">
+            <statetype name="buttonitem">
+                <state name="active" from="galleryactivebutton">
+                    <area>0,0,25%,50%</area>
+                </state>
+                <state name="selectedactive" from="galleryselectedbutton">
+                    <area>0,0,25%,50%</area>
+                </state>
+            </statetype>
+        </buttonlist>
+
         <!-- shows a message when no images are available
              in the current directory -->
          <textarea name="noimages" from="basetextarea">
-             <area>225,60,830,633</area>
+             <area>0,0,100%,100%</area>
              <align>allcenter</align>
+             <multiline>yes</multiline>
          </textarea>
 
-    </window>
-
-
-
-
-
-
-    <!-- Configuration dialog. This is currently
-         used by the MythImage plugin only -->
-    <window name="galleryconfig">
-
-        <!-- The heading (name) of the screen -->
-        <textarea name="heading" from="basetextarea">
-            <position>0,0</position>
-            <textarea name="text">
-            <value>Gallery Settings</value>
-            </textarea>
-        </textarea>
-
-        <!-- the shape where the imagelist is displayed -->
-        <shape name="galleryconfig_background">
-            <area>40,70,740,460</area>
-            <type>roundbox</type>
-            <fill color="#000000" alpha="130" />
-            <line color="#AAAAAA" alpha="150" width="1" />
-            <cornerradius>2</cornerradius>
-        </shape>
-
-        <textarea name="sortorder_label" from="basetextarea">
-            <area>80,90,440,40</area>
-            <align>right,vcenter</align>
-            <value>Sorting order of the shown images:</value>
-        </textarea>
-        <textarea name="slideshowtime_label" from="sortorder_label">
-            <position>40,140</position>
-            <value>Time to display each image during a slideshow (ms):</value>
-        </textarea>
-        <textarea name="transitiontype_label" from="sortorder_label">
-            <position>80,190</position>
-            <value>Type of transition between two images:</value>
-        </textarea>
-        <textarea name="transitiontime_label" from="sortorder_label">
-            <position>80,240</position>
-            <value>Duration of an image transition (ms):</value>
-        </textarea>
-        <textarea name="showhiddenfiles_label" from="sortorder_label">
-            <position>80,290</position>
-            <value>Show files that are marked as hidden:</value>
-        </textarea>
-        <textarea name="cleardatabase_label" from="sortorder_label">
-            <position>80,340</position>
-            <value>Clear database contents (Resync required):</value>
-        </textarea>
-
-        <buttonlist name="sortorder" from="basewideselector">
-            <area>530,90,240,40</area>
-        </buttonlist>
-        <spinbox name="slideshowtime" from="basespinbox">
-            <position>530,140</position>
-        </spinbox>
-        <buttonlist name="transitiontype" from="baseselector">
-            <position>530,190</position>
+      <!-- Mandatory: Shows file info overlay -->
+        <buttonlist name="infolist" from="galleryinfolist">
+            <drawfrombottom>true</drawfrombottom>
         </buttonlist>
-        <spinbox name="transitiontime" from="basespinbox">
-            <position>530,240</position>
-        </spinbox>
-        <checkbox name="showhiddenfiles" from="basecheckbox">
-            <position>530,295</position>
-        </checkbox>
-        <button name="cleardatabase" from="basebutton">
-            <area>530,340,140,40</area>
-            <value>Clear</value>
-        </button>
-
-        <shape name="description_separator">
-            <area>80,450,640,1</area>
-            <type>box</type>
-            <line color="#AAAAAA" alpha="150" width="1" />
-        </shape>
-
-        <button name="save" from="basebutton">
-            <position>250,470</position>
-            <value>Save</value>
-        </button>
-        <button name="cancel" from="basebutton">
-            <position>480,470</position>
-            <value>Cancel</value>
-        </button>
 
     </window>
 
-
-
-
-
-
-    <!-- Slideshow window which shows the a single image only or a slideshow.
-         This is currently used by the MythImage plugin only -->
+    <!-- Gallery Slideshow window which shows the a single image only or a slideshow. -->
     <window name="slideshow">
 
-        <!-- the background behind the images (black) -->
+        <!-- Extra small text for Gallery images -->
+        <fontdef name="gallerytext" from="basesmall">
+            <outlinecolor>#000000</outlinecolor>
+            <outlinesize>2</outlinesize>
+        </fontdef>
+
+        <!-- the background behind the images -->
         <shape name="background_shape">
-            <area>0,0,800,600</area>
-            <fill color="#000000" alpha="255" />
-            <line color="#000000" alpha="255" />
-            <type>roundbox</type>
-            <cornerradius>2</cornerradius>
+            <area>0,0,100%,100%</area>
+            <fill color="#000000" alpha="30"/>
         </shape>
 
-        <!-- this is the image that shown in the foreground.
-             when fading is enabled this image is faded out. -->
-        <imagetype name="first_image">
-            <area>-2,-2,804,604</area>
+        <!-- an image  -->
+        <imagetype name="image">
+            <area>0,0,100%,100%</area>
             <preserveaspect>yes</preserveaspect>
         </imagetype>
 
-        <!-- this is the image that shown in the background
-             when fading is enabled this image is faded in. -->
-        <imagetype name="second_image">
-            <area>-2,-2,804,604</area>
-            <preserveaspect>yes</preserveaspect>
-        </imagetype>
+        <!-- Represents "Show Captions" state for use as a dependancy by other widgets
+         Set = Hide; empty = Show  -->
+        <textarea name="hidecaptions" from="basetextarea">
+            <area>0,0,0,0</area>
+        </textarea>
 
-        <!-- shows some information if required -->
-        <textarea name="status" from="basetextarea">
-            <area>500,-4,280,30</area>
-            <shape name="background">
-                <area>0,0,280,40</area>
-                <fill color="#000000" alpha="255" />
-                <line color="#000000" alpha="255" />
-                <type>roundbox</type>
-                <cornerradius>2</cornerradius>
-            </shape>
-            <textarea name="status_text" from="basetextarea">
-                <area>0,0,280,40</area>
-                <align>allcenter</align>
-                <value>Image Loading...</value>
-            </textarea>
+        <!-- End/Loading/Failed to load status -->
+        <textarea name="status" from="basetextarea" depends="!hidecaptions">
+            <area>10,0,400,30</area>
+            <font>gallerytext</font>
         </textarea>
 
+        <!-- Slide count -->
+        <textarea name="slidecount" from="basetextarea" depends="!hidecaptions">
+            <area>100%-200,0,190,30</area>
+            <font>gallerytext</font>
+            <align>right, vcentre</align>
+        </textarea>
 
-        <!-- This list shows all the file information -->
-        <buttonlist name="infolist">
-            <area>115,180,450,348</area>
-            <layout>vertical</layout>
-            <spacing>5</spacing>
-            <wrapstyle>selection</wrapstyle>
-            <buttonarea>0,0,100%,97%</buttonarea>
-            <statetype name="buttonitem">
-                <state name="active">
-                    <shape name="buttonbackground">
-                        <area>0,0,450,40</area>
-                        <fill style="gradient">
-                            <gradient start="#505050" end="#000000" alpha="200" direction="vertical"  />
-                        </fill>
-                    </shape>
-                    <textarea name="name" from="basetextarea">
-                        <area>8,5,250,30</area>
-                    </textarea>
-                    <textarea name="value" from="basetextarea">
-                        <area>270,5,370,30</area>
-                    </textarea>
-                </state>
-                <state name="inactive" from="active"/>
-                <state name="selectedactive" from="active">
-                    <shape name="buttonbackground">
-                        <area>0,0,450,40</area>
-                        <fill style="gradient">
-                            <gradient start="#52CA38" end="#349838" alpha="255" />
-                        </fill>
-                    </shape>
-                </state>
-                <state name="selectedinactive" from="active">
-                    <shape name="buttonbackground">
-                        <area>0,0,450,40</area>
-                        <fill style="gradient">
-                            <gradient start="#52CA38" end="#349838" alpha="100" />
-                        </fill>
-                    </shape>
-                </state>
-            </statetype>
-        </buttonlist>
+        <!-- Name/date/Comment -->
+        <textarea name="caption" from="basetextarea" depends="!hidecaptions">
+            <area>10,100%-30,100%-20,30</area>
+            <font>gallerytext</font>
+            <align>centre, vcentre</align>
+        </textarea>
+
+      <!-- Shows file info overlay -->
+        <buttonlist name="infolist" from="galleryinfolist"/>
 
     </window>
 
diff -Naur mythtv-master-20150430-g70ae25d-old/mythtv/themes/default-wide/image-ui.xml mythtv-master-20150430-g70ae25d-new/mythtv/themes/default-wide/image-ui.xml
--- mythtv-master-20150430-g70ae25d-old/mythtv/themes/default-wide/image-ui.xml	2015-04-30 11:08:43.000000000 +0200
+++ mythtv-master-20150430-g70ae25d-new/mythtv/themes/default-wide/image-ui.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,592 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!DOCTYPE mythuitheme SYSTEM "http://www.mythtv.org/schema/mythuitheme.dtd">
-<mythuitheme>
-
-    <window name="gallery">
-
-        <!-- The heading (name) of the screen -->
-        <textarea name="heading" from="basetextarea">
-            <position>0,0</position>
-            <textarea name="text">
-            <value>Image Gallery</value>
-            </textarea>
-        </textarea>
-
-        <textarea name="syncprogresstext" from="basetextarea">
-            <area>540,20,200,30</area>
-            <align>center</align>
-        </textarea>
-
-        <!-- the shape where the imagelist is displayed -->
-        <shape name="gallerybackground">
-            <area>25,60,1230,633</area>
-            <type>roundbox</type>
-            <fill color="#000000" alpha="130" />
-            <line color="#AAAAAA" alpha="150" width="1" />
-            <cornerradius>2</cornerradius>
-        </shape>
-
-        <!-- shows the name of the folder or image -->
-        <textarea name="title" from="basetextarea">
-            <area>45,70,900,30</area>
-            <cutdown>yes</cutdown>
-            <font>title</font>
-            <align>left,vcenter</align>
-        </textarea>
-
-        <!-- optional - shows current position in grid eg '1 of 123' -->
-        <textarea name="position" from="basetextarea">
-            <area>1055,70,180,30</area>
-            <align>right,vcenter</align>
-        </textarea>
-
-        <!-- shows path to current image -->
-        <textarea name="breadcrumbs" from="basetextarea">
-            <area>45,100,900,30</area>
-            <font>text_very_small</font>
-            <cutdown>yes</cutdown>
-        </textarea>
-
-        <textarea name="thumbprogresstext" from="basetextarea">
-            <area>950,85,100,20</area>
-            <align>right,vcenter</align>
-        </textarea>
-
-        <!-- the list that shows the images in the screen -->
-        <buttonlist name="images">
-            <area>45,155,1170,535</area>
-            <buttonarea>0,0,1190,535</buttonarea>
-            <wrapstyle>flowing</wrapstyle>
-            <layout>grid</layout>
-            <spacing>7</spacing>
-            <statetype name="buttonitem">
-
-                <state name="active">
-                    <area>0,0,164,124</area>
-
-                    <!-- This is the dark background behind each image -->
-                    <shape name="buttonimage_background_shape">
-                        <area>0,0,164,124</area>
-                        <type>box</type>
-                        <line color="#000000" alpha="0" width="1" />
-                        <fill color="#000000" alpha="130" />
-                    </shape>
-
-                    <!-- Show an additional background image if required. This is
-                    primarily useful when the item is a folder and a folder background
-                    image shall be shown behind the small preview thumbnail images -->
-                    <statetype name="buttonbackground">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <imagetype name="icon">
-                                <area>2,2,160,120</area>
-                                <filename>gallery-folder-reg.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <imagetype name="icon">
-                                <area>2,2,160,120</area>
-                                <filename>gallery-folder-reg.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                        <state name="video">
-                        </state>
-                    </statetype>
-
-                    <!-- this shows the actual image -->
-                    <imagetype name="buttonimage">
-                        <area>2,2,160,120</area>
-                        <preserveaspect>yes</preserveaspect>
-                    </imagetype>
-
-                    <imagetype name="thumbimage1">
-                        <area>2,2,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage2">
-                        <area>82,2,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage3">
-                        <area>82,62,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage4">
-                        <area>2,62,80,60</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-
-                    <!-- This is the border around the image. Its placed here
-                         draw over the edges of the image -->
-                    <shape name="buttonimage_border_shape">
-                        <area>0,0,164,124</area>
-                        <type>box</type>
-                        <fill color="#000000" alpha="0" />
-                        <line color="#AAAAAA" alpha="150" width="1" />
-                    </shape>
-
-                    <!-- shows that the image was marked/selected and
-                        might be manipulated with other images -->
-                    <statetype name="buttoncheck">
-                        <position>2,2</position>
-                        <state type="full">
-                            <shape name="marked_background">
-                                <area>0,0,33,33</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="marked">
-                                <filename>gallery-mark.png</filename>
-                            </imagetype>
-                        </state>
-                    </statetype>
-
-                    <!-- Shows an indication if a file or folder is hidden
-                         or not. It will be marked and darkened -->
-                    <statetype name="buttonstate">
-                        <position>0,0</position>
-                        <state name="hidden">
-                            <shape name="hidden_background_shape">
-                                <area>1,1,162,122</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="210" />
-                            </shape>
-                        </state>
-                        <state name="visible">
-                        </state>
-                    </statetype>
-
-                    <!-- show additional information about the selected item.
-                         Shows a small folder or video icon -->
-                    <statetype name="buttontype">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,93,162,30</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>7,97,24,24</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,93,162,30</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>7,97,24,24</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="video">
-                            <shape name="buttonimage_shape">
-                                <area>120,80,43,43</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>122,83,37,37</area>
-                                <filename>gallery-moviethumb.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                    </statetype>
-
-                    <!-- show how many images / directories are in this directory -->
-                    <textarea name="childcount" from="basetextarea">
-                        <area>37,95,90,30</area>
-                        <font>text_small</font>
-                        <align>left,vcenter</align>
-                    </textarea>
-                </state>
-
-                <state name="selectedactive">
-                    <area>-38,-28,240,180</area>
-
-                    <shape name="buttonimage_background_shape">
-                        <area>0,0,240,180</area>
-                        <type>box</type>
-                        <line color="#000000" alpha="0" width="1" />
-                        <fill color="#000000" alpha="130" />
-                    </shape>
-
-                    <statetype name="buttonbackground">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <imagetype name="icon">
-                                <area>2,2,235,176</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <imagetype name="icon">
-                                <area>2,2,235,176</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                        <state name="video">
-                        </state>
-                    </statetype>
-
-                    <imagetype name="buttonimage">
-                        <area>2,2,235,176</area>
-                        <preserveaspect>yes</preserveaspect>
-                    </imagetype>
-
-                    <imagetype name="thumbimage1">
-                        <area>2,2,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage2">
-                        <area>119,2,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage3">
-                        <area>119,90,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-                    <imagetype name="thumbimage4">
-                        <area>2,90,117,88</area>
-                        <preserveaspect>false</preserveaspect>
-                    </imagetype>
-
-                    <shape name="buttonimage_border_shape">
-                        <area>0,0,240,180</area>
-                        <type>box</type>
-                        <fill color="#000000" alpha="0" />
-                        <line color="#AAAAAA" alpha="150" width="2" />
-                    </shape>
-
-                    <statetype name="buttoncheck">
-                        <position>2,2</position>
-                        <state type="full">
-                            <shape name="marked_background">
-                                <area>0,0,33,33</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="210" />
-                            </shape>
-                            <imagetype name="marked">
-                                <filename>gallery-mark.png</filename>
-                            </imagetype>
-                        </state>
-                    </statetype>
-
-                    <statetype name="buttonstate">
-                        <position>0,0</position>
-                        <state name="hidden">
-                            <shape name="hidden_background_shape">
-                                <area>1,1,162,122</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="210" />
-                            </shape>
-                        </state>
-                        <state name="visible">
-                        </state>
-                    </statetype>
-
-                    <statetype name="buttontype">
-                        <position>0,0</position>
-                        <state name="subfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,139,238,40</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>9,144,32,32</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="upfolder">
-                            <shape name="buttonimage_shape">
-                                <area>1,139,238,40</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>9,144,32,32</area>
-                                <filename>gallery-folder-sel.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="video">
-                            <shape name="buttonimage_shape">
-                                <area>181,121,58,58</area>
-                                <type>box</type>
-                                <line color="#000000" alpha="0" width="1" />
-                                <fill color="#000000" alpha="130" />
-                            </shape>
-                            <imagetype name="icon">
-                                <area>183,124,52,52</area>
-                                <filename>gallery-moviethumb.png</filename>
-                                <preserveaspect>yes</preserveaspect>
-                            </imagetype>
-                        </state>
-                        <state name="image">
-                        </state>
-                    </statetype>
-
-                    <textarea name="childcount" from="basetextarea">
-                        <area>49,145,90,30</area>
-                        <font>text_small</font>
-                        <align>left,vcenter</align>
-                    </textarea>
-
-                </state>
-            </statetype>
-
-            <!-- Show the arrow image that indicates that there are
-                more menu entries above the first visible menu -->
-            <statetype name="upscrollarrow">
-                <position>1135,-50</position>
-                <state type="off">
-                    <imagetype name="upon">
-                        <filename>lb-uparrow-reg.png</filename>
-                    </imagetype>
-                </state>
-                <state type="full">
-                    <imagetype name="upoff">
-                        <filename>lb-uparrow-sel.png</filename>
-                    </imagetype>
-                </state>
-            </statetype>
-
-            <!-- Show the arrow image that indicates that there are
-                more menu entries below the last visible menu -->
-            <statetype name="downscrollarrow">
-                <position>1160,-50</position>
-                <state type="off">
-                    <imagetype name="dnon">
-                        <filename>lb-dnarrow-reg.png</filename>
-                    </imagetype>
-                </state>
-                <state type="full">
-                    <imagetype name="dnoff">
-                        <filename>lb-dnarrow-sel.png</filename>
-                    </imagetype>
-                </state>
-            </statetype>
-
-        </buttonlist>
-
-        <!-- shows a message when no images are available
-             in the current directory -->
-         <textarea name="noimages" from="basetextarea">
-             <area>225,60,830,633</area>
-             <align>allcenter</align>
-         </textarea>
-
-    </window>
-
-
-
-
-
-
-    <!-- Configuration dialog. This is currently
-         used by the MythImage plugin only -->
-    <window name="galleryconfig">
-
-        <!-- The heading (name) of the screen -->
-        <textarea name="heading" from="basetextarea">
-            <position>0,0</position>
-            <textarea name="text">
-            <value>Gallery Settings</value>
-            </textarea>
-        </textarea>
-
-        <!-- the shape where the imagelist is displayed -->
-        <shape name="galleryconfig_background">
-            <area>160,170,960,460</area>
-            <type>roundbox</type>
-            <fill color="#000000" alpha="130" />
-            <line color="#AAAAAA" alpha="150" width="1" />
-            <cornerradius>2</cornerradius>
-        </shape>
-
-        <textarea name="sortorder_label" from="basetextarea">
-            <area>180,240,540,40</area>
-            <align>right,vcenter</align>
-            <value>Sorting order of the shown images:</value>
-        </textarea>
-        <textarea name="slideshowtime_label" from="sortorder_label">
-            <position>180,290</position>
-            <value>Time to display each image during a slideshow (ms):</value>
-        </textarea>
-        <textarea name="transitiontype_label" from="sortorder_label">
-            <position>180,340</position>
-            <value>Type of transition between two images:</value>
-        </textarea>
-        <textarea name="transitiontime_label" from="sortorder_label">
-            <position>180,390</position>
-            <value>Duration of an image transition (ms):</value>
-        </textarea>
-        <textarea name="showhiddenfiles_label" from="sortorder_label">
-            <position>180,440</position>
-            <value>Show files that are marked as hidden:</value>
-        </textarea>
-        <textarea name="cleardatabase_label" from="sortorder_label">
-            <position>180,490</position>
-            <value>Clear database contents (Resync required):</value>
-        </textarea>
-
-        <buttonlist name="sortorder" from="baseselector">
-            <area>730,240,380,40</area>
-        </buttonlist>
-        <spinbox name="slideshowtime" from="basespinbox">
-            <position>730,290</position>
-        </spinbox>
-        <buttonlist name="transitiontype" from="baseselector">
-            <position>730,340</position>
-        </buttonlist>
-        <spinbox name="transitiontime" from="basespinbox">
-            <position>730,390</position>
-        </spinbox>
-        <checkbox name="showhiddenfiles" from="basecheckbox">
-            <position>730,445</position>
-        </checkbox>
-        <button name="cleardatabase" from="basebutton">
-            <area>730,490,140,40</area>
-            <value>Clear</value>
-        </button>
-
-        <shape name="description_separator">
-            <area>180,550,920,1</area>
-            <type>box</type>
-            <line color="#AAAAAA" alpha="150" width="1" />
-        </shape>
-
-        <button name="save" from="basebutton">
-            <position>450,570</position>
-            <value>Save</value>
-        </button>
-        <button name="cancel" from="basebutton">
-            <position>680,570</position>
-            <value>Cancel</value>
-        </button>
-
-    </window>
-
-
-
-
-
-
-    <!-- Slideshow window which shows the a single image only or a slideshow.
-         This is currently used by the MythImage plugin only -->
-    <window name="slideshow">
-
-        <!-- the background behind the images (black) -->
-        <shape name="background_shape">
-            <area>0,0,1280,720</area>
-            <fill color="#000000" alpha="255" />
-            <line color="#000000" alpha="255" />
-            <type>roundbox</type>
-            <cornerradius>2</cornerradius>
-        </shape>
-
-        <!-- this is the image that shown in the foreground.
-             when fading is enabled this image is faded out. -->
-        <imagetype name="first_image">
-            <area>-2,-2,1284,724</area>
-            <preserveaspect>yes</preserveaspect>
-        </imagetype>
-
-        <!-- this is the image that shown in the background
-             when fading is enabled this image is faded in. -->
-        <imagetype name="second_image">
-            <area>-2,-2,1284,724</area>
-            <preserveaspect>yes</preserveaspect>
-        </imagetype>
-
-        <!-- shows some information if required -->
-        <textarea name="status" from="basetextarea">
-            <area>500,-4,280,30</area>
-            <shape name="background">
-                <area>0,0,280,40</area>
-                <fill color="#000000" alpha="255" />
-                <line color="#000000" alpha="255" />
-                <type>roundbox</type>
-                <cornerradius>2</cornerradius>
-            </shape>
-            <textarea name="status_text" from="basetextarea">
-                <area>0,0,280,40</area>
-                <align>allcenter</align>
-                <value>Image Loading...</value>
-            </textarea>
-        </textarea>
-
-
-        <!-- This list shows all the file information -->
-        <buttonlist name="infolist">
-            <area>315,180,650,348</area>
-            <layout>vertical</layout>
-            <spacing>5</spacing>
-            <wrapstyle>selection</wrapstyle>
-            <buttonarea>0,0,100%,97%</buttonarea>
-            <statetype name="buttonitem">
-                <state name="active">
-                    <shape name="buttonbackground">
-                        <area>0,0,650,40</area>
-                        <fill style="gradient">
-                            <gradient start="#505050" end="#000000" alpha="200" direction="vertical"  />
-                        </fill>
-                    </shape>
-                    <textarea name="name" from="basetextarea">
-                        <area>8,5,250,30</area>
-                    </textarea>
-                    <textarea name="value" from="basetextarea">
-                        <area>270,5,370,30</area>
-                    </textarea>
-                </state>
-                <state name="inactive" from="active"/>
-                <state name="selectedactive" from="active">
-                    <shape name="buttonbackground">
-                        <area>0,0,650,40</area>
-                        <fill style="gradient">
-                            <gradient start="#52CA38" end="#349838" alpha="255" />
-                        </fill>
-                    </shape>
-                </state>
-                <state name="selectedinactive" from="active">
-                    <shape name="buttonbackground">
-                        <area>0,0,650,40</area>
-                        <fill style="gradient">
-                            <gradient start="#52CA38" end="#349838" alpha="100" />
-                        </fill>
-                    </shape>
-                </state>
-            </statetype>
-        </buttonlist>
-
-    </window>
-
-</mythuitheme>
-
-
