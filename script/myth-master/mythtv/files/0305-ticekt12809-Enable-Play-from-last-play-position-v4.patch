diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmyth/programinfo.cpp mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmyth/programinfo.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmyth/programinfo.cpp	2018-04-17 09:57:35.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmyth/programinfo.cpp	2018-04-17 09:58:57.736666672 +0200
@@ -222,6 +222,7 @@
 
     // everything below this line is not serialized
     availableStatus(asAvailable),
+    progressPercent(0),
     spread(-1),
     startCol(-1),
     sortTitle(),
@@ -305,6 +306,7 @@
 
     // everything below this line is not serialized
     availableStatus(other.availableStatus),
+    progressPercent(other.progressPercent),
     spread(other.spread),
     startCol(other.startCol),
     sortTitle(other.sortTitle),
@@ -492,6 +494,7 @@
 
     // everything below this line is not serialized
     availableStatus(asAvailable),
+    progressPercent(0),
     spread(-1),
     startCol(-1),
     sortTitle(),
@@ -609,6 +612,7 @@
 
     // everything below this line is not serialized
     availableStatus(asAvailable),
+    progressPercent(0),
     spread(-1),
     startCol(-1),
     sortTitle(),
@@ -739,6 +743,7 @@
 
     // everything below this line is not serialized
     availableStatus(asAvailable),
+    progressPercent(0),
     spread(-1),
     startCol(-1),
     sortTitle(),
@@ -895,6 +900,7 @@
 
     // everything below this line is not serialized
     availableStatus(asAvailable),
+    progressPercent(0),
     spread(-1),
     startCol(-1),
     sortTitle(),
@@ -1247,6 +1253,7 @@
     spread = -1;
     startCol = -1;
     availableStatus = asAvailable;
+    progressPercent = 0;
 
     // Private
     inUseForWhat.clear();
@@ -1858,6 +1865,9 @@
         progMap["lentime"] = QObject::tr("%n hour(s)","", hours);
     }
 
+    progMap["progresspercent"] =
+            GetProgressPercent() > 0 ? QString::number(GetProgressPercent()) : "";
+
     progMap["rectypechar"] = toQChar(GetRecordingRuleType());
     progMap["rectype"] = ::toString(GetRecordingRuleType());
     QString tmp_rec = progMap["rectype"];
@@ -2820,6 +2830,31 @@
 
     set_flag(programflags, FL_BOOKMARK, is_valid);
 
+    UpdateMarkTimeStamp(is_valid);
+    SendUpdateEvent();
+}
+
+void ProgramInfo::SaveLastPlayPos(uint64_t frame, bool notify)
+{
+    LOG(VB_PLAYBACK, LOG_DEBUG,
+        QString("LastPlayPos frame=%1").arg(frame));
+    ClearMarkupMap(MARK_UTIL_LASTPLAYPOS);
+
+    if (frame > 0)
+    {
+        frm_dir_map_t lastPlayPosMap;
+        lastPlayPosMap[frame] = MARK_UTIL_LASTPLAYPOS;
+        SaveMarkupMap(lastPlayPosMap, MARK_UTIL_LASTPLAYPOS);
+    }
+
+    UpdateMarkTimeStamp(IsBookmarkSet());
+
+    if (notify)
+        SendUpdateEvent();
+}
+
+void ProgramInfo::UpdateMarkTimeStamp(bool bookmarked)
+{
     if (IsRecording())
     {
         MSqlQuery query(MSqlQuery::InitCon());
@@ -2827,17 +2862,13 @@
             "UPDATE recorded "
             "SET bookmarkupdate = CURRENT_TIMESTAMP, "
             "    bookmark       = :BOOKMARKFLAG "
-            "WHERE chanid    = :CHANID AND "
-            "      starttime = :STARTTIME");
+            "WHERE recordedid = :RECORDEDID");
 
-        query.bindValue(":BOOKMARKFLAG", is_valid);
-        query.bindValue(":CHANID",       chanid);
-        query.bindValue(":STARTTIME",    recstartts);
+        query.bindValue(":BOOKMARKFLAG", bookmarked);
+        query.bindValue(":RECORDEDID",   recordedid);
 
         if (!query.exec())
             MythDB::DBError("bookmark flag update", query);
-
-        SendUpdateEvent();
     }
 }
 
@@ -2924,6 +2955,23 @@
     return (bookmarkmap.isEmpty()) ? 0 : bookmarkmap.begin().key();
 }
 
+uint64_t ProgramInfo::QueryStartMark(void) const
+{
+    uint64_t start = 0;
+    if ((start = QueryLastPlayPos()) > 0)
+        LOG(VB_PLAYBACK, LOG_INFO, QString("Using last position @ %1").arg(start));
+    else if ((start = QueryBookmark()) > 0)
+        LOG(VB_PLAYBACK, LOG_INFO, QString("Using bookmark @ %1").arg(start));
+    else if (HasCutlist())
+        // Disable progstart if the program has a cutlist.
+        LOG(VB_PLAYBACK, LOG_INFO, "Ignoring progstart as cutlist exists");
+    else if ((start = QueryProgStart()) > 0)
+        LOG(VB_PLAYBACK, LOG_INFO, QString("Using progstart @ %1").arg(start));
+    else
+        LOG(VB_PLAYBACK, LOG_INFO, "Using file start");
+    return start;
+}
+
 /** \brief Gets any lastplaypos position in database,
  *         unless the ignore lastplaypos flag is set.
  *
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmyth/programinfo.h mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmyth/programinfo.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmyth/programinfo.h	2018-04-17 09:57:35.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmyth/programinfo.h	2018-04-17 09:58:57.736666672 +0200
@@ -554,6 +554,9 @@
     void SetPositionMapDBReplacement(PMapDBReplacement *pmap)
         { positionMapDBReplacement = pmap; }
 
+    uint GetProgressPercent() const        { return progressPercent; }
+    void SetProgressPercent(uint progress) { progressPercent = progress; }
+
     // Slow DB gets
     QString     QueryBasename(void) const;
 //  uint64_t    QueryFilesize(void) const; // TODO Remove
@@ -562,6 +565,7 @@
     uint64_t    QueryBookmark(void) const;
     uint64_t    QueryProgStart(void) const;
     uint64_t    QueryLastPlayPos(void) const;
+    uint64_t    QueryStartMark(void) const;
     CategoryType QueryCategoryType(void) const;
     QStringList QueryDVDBookmark(const QString &serialid) const;
     QStringList QueryBDBookmark(const QString &serialid) const;
@@ -587,6 +591,7 @@
 
     // Slow DB sets
     virtual void SaveFilesize(uint64_t fsize); /// TODO Move to RecordingInfo
+    void SaveLastPlayPos(uint64_t frame, bool notify = true);
     void SaveBookmark(uint64_t frame);
     void SaveDVDBookmark(const QStringList &fields) const;
     void SaveBDBookmark(const QStringList &fields) const;
@@ -712,6 +717,8 @@
     bool FromStringList(QStringList::const_iterator &it,
                         QStringList::const_iterator  end);
 
+    void UpdateMarkTimeStamp(bool bookmarked);
+
     static void QueryMarkupMap(
         const QString &video_pathname,
         frm_dir_map_t&, MarkTypes type, bool merge = false);
@@ -791,6 +798,8 @@
 
 // everything below this line is not serialized
     uint8_t availableStatus; // only used for playbackbox.cpp
+    uint  progressPercent; // only used by UI
+
   public:
     void SetAvailableStatus(AvailableStatusType status, const QString &where);
     AvailableStatusType GetAvailableStatus(void) const
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythbase/libmythbase.pro mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythbase/libmythbase.pro
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythbase/libmythbase.pro	2018-04-17 08:57:49.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythbase/libmythbase.pro	2018-04-17 09:58:57.736666672 +0200
@@ -10,7 +10,7 @@
 QMAKE_CLEAN += $(TARGET) $(TARGETA) $(TARGETD) $(TARGET0) $(TARGET1) $(TARGET2)
 
 # Input
-HEADERS += mthread.h mthreadpool.h
+HEADERS += mthread.h mthreadpool.h mconcurrent.h
 HEADERS += mythsocket.h mythsocket_cb.h
 HEADERS += mythbaseexp.h mythdbcon.h mythdb.h mythdbparams.h
 HEADERS += verbosedefs.h mythversion.h compat.h mythconfig.h
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythbase/mconcurrent.h mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythbase/mconcurrent.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythbase/mconcurrent.h	1970-01-01 01:00:00.000000000 +0100
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythbase/mconcurrent.h	2018-04-17 09:58:57.736666672 +0200
@@ -0,0 +1,175 @@
+#ifndef MCONCURRENT_H
+#define MCONCURRENT_H
+
+#include "mthreadpool.h"
+#include "logging.h"
+
+
+/// Provides a simple version of QtConcurrent::run() that uses MThreadPool rather
+/// than QThreadPool. Useful for starting background threads in 1 line.
+///
+/// Given a class method of:
+///
+///   void Class::fn(arg1, arg2...)
+///
+/// you can run it in a different thread using:
+///
+///   MConcurrent::run("thread name", &Class instance, &Class::fn, arg1, arg2...)
+///
+/// Refer to QtConcurrent::run for further details
+///
+/// Restrictions:
+/// 1. Accepts 0-5 arguments
+/// 2. Only class methods are supported (most typical in Myth)
+/// 3. Only non-const classes & methods are supported (most typical in Myth)
+/// 4. The method must have return type of void (QFuture is not easily ported to
+/// MThreadPool. Use signals/events instead)
+///
+namespace MConcurrent {
+
+class RunFunctionTask : public QRunnable
+{
+public:
+    void start(QString name)
+    {
+        MThreadPool::globalInstance()->start(this, name, /*m_priority*/ 0);
+    }
+
+    virtual void runFunctor() = 0;
+
+    void run()
+    {
+        try
+        {
+            this->runFunctor();
+        }
+        catch (...)
+        {
+            LOG(VB_GENERAL, LOG_ERR, "An exception occurred");
+        }
+    }
+};
+
+template <typename Class>
+class VoidStoredMemberFunctionPointerCall0 : public RunFunctionTask
+{
+public:
+    VoidStoredMemberFunctionPointerCall0(void (Class::*_fn)() , Class *_object)
+    : fn(_fn), object(_object) { }
+
+    void runFunctor() { (object->*fn)(); }
+private:
+    void (Class::*fn)();
+    Class *object;
+};
+
+template <typename Class, typename Param1, typename Arg1>
+class VoidStoredMemberFunctionPointerCall1 : public RunFunctionTask
+{
+public:
+    VoidStoredMemberFunctionPointerCall1(void (Class::*_fn)(Param1) , Class *_object, const Arg1 &_arg1)
+    : fn(_fn), object(_object), arg1(_arg1){ }
+
+    void runFunctor() { (object->*fn)(arg1); }
+private:
+    void (Class::*fn)(Param1);
+    Class *object;
+    Arg1 arg1;
+};
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+class VoidStoredMemberFunctionPointerCall2 : public RunFunctionTask
+{
+public:
+    VoidStoredMemberFunctionPointerCall2(void (Class::*_fn)(Param1, Param2) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2){ }
+
+    void runFunctor() { (object->*fn)(arg1, arg2); }
+private:
+    void (Class::*fn)(Param1, Param2);
+    Class *object;
+    Arg1 arg1; Arg2 arg2;
+};
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+class VoidStoredMemberFunctionPointerCall3 : public RunFunctionTask
+{
+public:
+    VoidStoredMemberFunctionPointerCall3(void (Class::*_fn)(Param1, Param2, Param3) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3){ }
+
+    void runFunctor() { (object->*fn)(arg1, arg2, arg3); }
+private:
+    void (Class::*fn)(Param1, Param2, Param3);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3;
+};
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+class VoidStoredMemberFunctionPointerCall4 : public RunFunctionTask
+{
+public:
+    VoidStoredMemberFunctionPointerCall4(void (Class::*_fn)(Param1, Param2, Param3, Param4) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4){ }
+
+    void runFunctor() { (object->*fn)(arg1, arg2, arg3, arg4); }
+private:
+    void (Class::*fn)(Param1, Param2, Param3, Param4);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4;
+};
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+class VoidStoredMemberFunctionPointerCall5 : public RunFunctionTask
+{
+public:
+    VoidStoredMemberFunctionPointerCall5(void (Class::*_fn)(Param1, Param2, Param3, Param4, Param5) , Class *_object, const Arg1 &_arg1, const Arg2 &_arg2, const Arg3 &_arg3, const Arg4 &_arg4, const Arg5 &_arg5)
+    : fn(_fn), object(_object), arg1(_arg1), arg2(_arg2), arg3(_arg3), arg4(_arg4), arg5(_arg5){ }
+
+    void runFunctor() { (object->*fn)(arg1, arg2, arg3, arg4, arg5); }
+private:
+    void (Class::*fn)(Param1, Param2, Param3, Param4, Param5);
+    Class *object;
+    Arg1 arg1; Arg2 arg2; Arg3 arg3; Arg4 arg4; Arg5 arg5;
+};
+
+template <typename Class>
+void run(const QString &name, Class *object, void (Class::*fn)())
+{
+    (new VoidStoredMemberFunctionPointerCall0<Class>(fn, object))->start(name);
+}
+
+template <typename Class, typename Param1, typename Arg1>
+void run(const QString &name, Class *object, void (Class::*fn)(Param1), const Arg1 &arg1)
+{
+    (new VoidStoredMemberFunctionPointerCall1<Class, Param1, Arg1>(fn, object, arg1))->start(name);
+}
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2>
+void run(const QString &name, Class *object, void (Class::*fn)(Param1, Param2), const Arg1 &arg1, const Arg2 &arg2)
+{
+    (new VoidStoredMemberFunctionPointerCall2<Class, Param1, Arg1, Param2, Arg2>(fn, object, arg1, arg2))->start(name);
+}
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3>
+void run(const QString &name, Class *object, void (Class::*fn)(Param1, Param2, Param3), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3)
+{
+    (new VoidStoredMemberFunctionPointerCall3<Class, Param1, Arg1, Param2, Arg2, Param3, Arg3>(fn, object, arg1, arg2, arg3))->start(name);
+}
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4>
+void run(const QString &name, Class *object, void (Class::*fn)(Param1, Param2, Param3, Param4), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4)
+{
+    (new VoidStoredMemberFunctionPointerCall4<Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4>(fn, object, arg1, arg2, arg3, arg4))->start(name);
+}
+
+template <typename Class, typename Param1, typename Arg1, typename Param2, typename Arg2, typename Param3, typename Arg3, typename Param4, typename Arg4, typename Param5, typename Arg5>
+void run(const QString &name, Class *object, void (Class::*fn)(Param1, Param2, Param3, Param4, Param5), const Arg1 &arg1, const Arg2 &arg2, const Arg3 &arg3, const Arg4 &arg4, const Arg4 &arg5)
+{
+    (new VoidStoredMemberFunctionPointerCall5<Class, Param1, Arg1, Param2, Arg2, Param3, Arg3, Param4, Arg4, Param5, Arg5>(fn, object, arg1, arg2, arg3, arg4, arg5))->start(name);
+}
+
+
+} //namespace QtConcurrent
+
+#endif // MCONCURRENT_H
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/mythplayer.cpp mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/mythplayer.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/mythplayer.cpp	2018-04-17 09:57:36.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/mythplayer.cpp	2018-04-17 09:58:57.736666672 +0200
@@ -249,7 +249,6 @@
     captionsEnabledbyDefault = gCoreContext->GetNumSetting("DefaultCCMode");
     decode_extra_audio = gCoreContext->GetNumSetting("DecodeExtraAudio", 0);
     itvEnabled         = gCoreContext->GetNumSetting("EnableMHEG", 0);
-    clearSavedPosition = gCoreContext->GetNumSetting("ClearSavedPosition", 1);
     endExitPrompt      = gCoreContext->GetNumSetting("EndOfRecordingExitPrompt");
     pip_default_loc    = (PIPLocation)gCoreContext->GetNumSetting("PIPLocation", kPIPTopLeft);
 
@@ -2972,8 +2971,6 @@
     if (bookmarkseek > 30)
     {
         DoJumpToFrame(bookmarkseek, kInaccuracyNone);
-        if (clearSavedPosition && !player_ctx->IsPIP())
-            SetBookmark(true);
     }
 }
 
@@ -3746,12 +3743,7 @@
         player_ctx->LockPlayingInfo(__FILE__, __LINE__);
         if (const ProgramInfo *pi = player_ctx->playingInfo)
         {
-            bookmark = pi->QueryBookmark();
-            // Disable progstart if the program has a cutlist.
-            if (bookmark == 0 && !pi->HasCutlist())
-                bookmark = pi->QueryProgStart();
-            if (bookmark == 0)
-                bookmark = pi->QueryLastPlayPos();
+            bookmark = pi->QueryStartMark();
         }
         player_ctx->UnlockPlayingInfo(__FILE__, __LINE__);
     }
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/mythplayer.h mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/mythplayer.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/mythplayer.h	2018-04-17 08:57:50.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/mythplayer.h	2018-04-17 09:58:57.736666672 +0200
@@ -682,7 +682,6 @@
 
     // Bookmark stuff
     uint64_t bookmarkseek;
-    int      clearSavedPosition;
     int      endExitPrompt;
 
     // Seek
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/previewgenerator.cpp mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/previewgenerator.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/previewgenerator.cpp	2018-04-17 08:57:51.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/previewgenerator.cpp	2018-04-17 09:58:57.736666672 +0200
@@ -627,8 +627,9 @@
 bool PreviewGenerator::LocalPreviewRun(void)
 {
     m_programInfo.MarkAsInUse(true, kPreviewGeneratorInUseID);
-    m_programInfo.SetIgnoreProgStart(true);
-    m_programInfo.SetAllowLastPlayPos(false);
+    m_programInfo.SetIgnoreProgStart(false);
+    m_programInfo.SetIgnoreBookmark(false);
+    m_programInfo.SetAllowLastPlayPos(true);
 
     float aspect = 0;
     int   width, height, sz;
@@ -641,15 +642,14 @@
 
     if (captime < 0)
     {
-        captime = m_programInfo.QueryBookmark();
-        if (captime > 0)
+        uint64_t markFrame = m_programInfo.QueryStartMark();
+        LOG(VB_GENERAL, LOG_INFO,
+            QString("Preview from start mark (frame %1)").arg(markFrame));
+        if (markFrame > 0)
         {
             m_timeInSeconds = false;
-            LOG(VB_GENERAL, LOG_INFO,
-                QString("Preview from bookmark (frame %1)").arg(captime));
+            captime         = markFrame;
         }
-        else
-            captime = -1;
     }
 
     if (captime <= 0)
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/tv_play.cpp mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/tv_play.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/tv_play.cpp	2018-04-17 09:57:36.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/tv_play.cpp	2018-04-17 09:58:57.740000005 +0200
@@ -37,6 +37,7 @@
 #include "compat.h"
 #include "mythdirs.h"
 #include "mythmedia.h"
+#include "mconcurrent.h"
 
 // libmyth
 #include "programinfo.h"
@@ -1055,7 +1056,6 @@
       db_playback_exit_prompt(0),   db_autoexpire_default(0),
       db_auto_set_watched(false),   db_end_of_rec_exit_prompt(false),
       db_jump_prefer_osd(true),     db_use_gui_size_for_tv(false),
-      db_clear_saved_position(false),
       db_run_jobs_on_remote(false), db_continue_embedded(false),
       db_use_fixed_size(true),      db_browse_always(false),
       db_browse_all_tuners(false),
@@ -1079,6 +1079,7 @@
       requestDelete(false),  allowRerecord(false),
       doSmartForward(false),
       queuedTranscode(false),
+      savePosOnExit(false),
       adjustingPicture(kAdjustingPicture_None),
       adjustingPictureAttribute(kPictureAttribute_None),
       askAllowLock(QMutex::Recursive),
@@ -1162,7 +1163,6 @@
     kv["EndOfRecordingExitPrompt"] = "0";
     kv["JumpToProgramOSD"]         = "1";
     kv["GuiSizeForTV"]             = "0";
-    kv["ClearSavedPosition"]       = "1";
     kv["JobsRunOnRecordHost"]      = "0";
     kv["ContinueEmbeddedTVPlay"]   = "0";
     kv["UseFixedWindowSize"]       = "1";
@@ -1212,7 +1212,6 @@
     db_end_of_rec_exit_prompt = kv["EndOfRecordingExitPrompt"].toInt();
     db_jump_prefer_osd     = kv["JumpToProgramOSD"].toInt();
     db_use_gui_size_for_tv = kv["GuiSizeForTV"].toInt();
-    db_clear_saved_position= kv["ClearSavedPosition"].toInt();
     db_run_jobs_on_remote  = kv["JobsRunOnRecordHost"].toInt();
     db_continue_embedded   = kv["ContinueEmbeddedTVPlay"].toInt();
     db_use_fixed_size      = kv["UseFixedWindowSize"].toInt();
@@ -1397,6 +1396,8 @@
     speedChangeTimerId   = StartTimer(kSpeedChangeCheckFrequency, __LINE__);
     saveLastPlayPosTimerId = StartTimer(kSaveLastPlayPosTimeout, __LINE__);
 
+    savePosOnExit = false;
+
     LOG(VB_PLAYBACK, LOG_DEBUG, LOC + "-- end");
     return true;
 }
@@ -3399,51 +3400,22 @@
     SetExitPlayer(true, true);
 }
 
-void TV::PrepareToExitPlayer(PlayerContext *ctx, int line, BookmarkAction bookmark)
+void TV::PrepareToExitPlayer(PlayerContext *ctx, int line)
 {
-    bool bm_allowed = IsBookmarkAllowed(ctx);
     ctx->LockDeletePlayer(__FILE__, line);
-    if (ctx->player)
+    if (savePosOnExit && ctx->player && ctx->playingInfo)
     {
-        if (bm_allowed)
-        {
-            // If we're exiting in the middle of the recording, we
-            // automatically save a bookmark when "Action on playback
-            // exit" is set to "Save position and exit".
-            bool allow_set_before_end =
-                (bookmark == kBookmarkAlways ||
-                 (bookmark == kBookmarkAuto &&
-                  db_playback_exit_prompt == 2));
-            // If we're exiting at the end of the recording, we
-            // automatically clear the bookmark when "Action on
-            // playback exit" is set to "Save position and exit" and
-            // "Clear bookmark on playback" is set to true.
-            bool allow_clear_at_end =
-                (bookmark == kBookmarkAlways ||
-                 (bookmark == kBookmarkAuto &&
-                  db_playback_exit_prompt == 2 &&
-                  db_clear_saved_position));
-            // Whether to set/clear a bookmark depends on whether we're
-            // exiting at the end of a recording.
-            bool at_end = (ctx->player->IsNearEnd() || getEndOfRecording());
-            // Don't consider ourselves at the end if the recording is
-            // in-progress.
-            at_end &= !StateIsRecording(GetState(ctx));
-            bool clear_lastplaypos = false;
-            if (at_end && allow_clear_at_end)
-            {
-                SetBookmark(ctx, true);
-                // Tidy up the lastplaypos mark only when we clear the
-                // bookmark due to exiting at the end.
-                clear_lastplaypos = true;
-            }
-            else if (!at_end && allow_set_before_end)
-            {
-                SetBookmark(ctx, false);
-            }
-            if (clear_lastplaypos && ctx->playingInfo)
-                ctx->playingInfo->ClearMarkupMap(MARK_UTIL_LASTPLAYPOS);
-        }
+        // Clear last play position when we're at the end of a recording.
+        // unless the recording is in-progress.
+        bool at_end = !StateIsRecording(GetState(ctx)) &&
+                (getEndOfRecording() || ctx->player->IsNearEnd());
+
+        // Clear/Save play position without notification
+        // The change must be broadcast when file is no longer in use
+        // to update previews, ie. with the MarkNotInUse notification
+        uint64_t frame = at_end ? 0 : ctx->player->GetFramesPlayed();
+        ctx->playingInfo->SaveLastPlayPos(frame, false);
+
         if (db_auto_set_watched)
             ctx->player->SetWatched();
     }
@@ -5144,7 +5116,7 @@
     {
         NormalSpeed(ctx);
         StopFFRew(ctx);
-        SetBookmark(ctx);
+        PrepareToExitPlayer(ctx, __LINE__);
         ShowOSDPromptDeleteRecording(ctx, tr("Are you sure you want to delete:"));
     }
     else if (has_action(ACTION_JUMPTODVDROOTMENU, actions) && isdisc)
@@ -5366,11 +5338,7 @@
     }
     else if (tokens.size() == 2 && tokens[1] == "STOP")
     {
-        SetBookmark(ctx);
-        ctx->LockDeletePlayer(__FILE__, __LINE__);
-        if (ctx->player && db_auto_set_watched)
-            ctx->player->SetWatched();
-        ctx->UnlockDeletePlayer(__FILE__, __LINE__);
+        PrepareToExitPlayer(ctx, __LINE__);
         SetExitPlayer(true, true);
     }
     else if (tokens.size() >= 3 && tokens[1] == "SEEK" && ctx->HasPlayer())
@@ -9488,7 +9456,7 @@
             for (uint i = 0; mctx && (i < player.size()); i++)
             {
                 PlayerContext *ctx = GetPlayer(mctx, i);
-                PrepareToExitPlayer(ctx, __LINE__, kBookmarkAuto);
+                PrepareToExitPlayer(ctx, __LINE__);
             }
 
             SetExitPlayer(true, true);
@@ -13302,16 +13270,8 @@
         osd->DialogShow(OSD_DLG_VIDEOEXIT,
                         tr("You are exiting %1").arg(videotype));
 
-        if (IsBookmarkAllowed(ctx))
-        {
-            osd->DialogAddButton(tr("Save this position and go to the menu"),
-                                 "DIALOG_VIDEOEXIT_SAVEPOSITIONANDEXIT_0");
-            osd->DialogAddButton(tr("Do not save, just exit to the menu"),
-                                 ACTION_STOP);
-        }
-        else
-            osd->DialogAddButton(tr("Exit %1").arg(videotype),
-                                 ACTION_STOP);
+        osd->DialogAddButton(tr("Exit %1").arg(videotype),
+                             ACTION_STOP);
 
         if (IsDeleteAllowed(ctx))
             osd->DialogAddButton(tr("Delete this recording"),
@@ -13456,7 +13416,6 @@
 
     bool hide        = true;
     bool delete_ok   = IsDeleteAllowed(ctx);
-    bool bookmark_ok = IsBookmarkAllowed(ctx);
 
     ctx->LockDeletePlayer(__FILE__, __LINE__);
     bool near_end = ctx->player && ctx->player->IsNearEnd();
@@ -13466,11 +13425,13 @@
     {
         allowRerecord = true;
         requestDelete = true;
+        PrepareToExitPlayer(ctx, __LINE__);
         SetExitPlayer(true, true);
     }
     else if (action == "JUSTDELETE" && delete_ok)
     {
         requestDelete = true;
+        PrepareToExitPlayer(ctx, __LINE__);
         SetExitPlayer(true, true);
     }
     else if (action == "CONFIRMDELETE")
@@ -13479,11 +13440,6 @@
         ShowOSDPromptDeleteRecording(ctx, tr("Are you sure you want to delete:"),
                                      true);
     }
-    else if (action == "SAVEPOSITIONANDEXIT" && bookmark_ok)
-    {
-        PrepareToExitPlayer(ctx, __LINE__, kBookmarkAlways);
-        SetExitPlayer(true, true);
-    }
     else if (action == "KEEPWATCHING" && !near_end)
     {
         DoTogglePause(ctx, true);
@@ -13494,29 +13450,6 @@
 
 void TV::HandleSaveLastPlayPosEvent(void)
 {
-    // Helper class to save the latest playback position (in a background thread
-    // to avoid playback glitches).  The ctor makes a copy of the ProgramInfo
-    // struct to avoid race conditions if playback ends and deletes objects
-    // before or while the background thread runs.
-    class PositionSaver : public QRunnable
-    {
-    public:
-        PositionSaver(const ProgramInfo &pginfo, uint64_t frame) :
-            m_pginfo(pginfo), m_frame(frame) {}
-        virtual void run(void)
-        {
-            LOG(VB_PLAYBACK, LOG_DEBUG,
-                QString("PositionSaver frame=%1").arg(m_frame));
-            frm_dir_map_t lastPlayPosMap;
-            lastPlayPosMap[m_frame] = MARK_UTIL_LASTPLAYPOS;
-            m_pginfo.ClearMarkupMap(MARK_UTIL_LASTPLAYPOS);
-            m_pginfo.SaveMarkupMap(lastPlayPosMap, MARK_UTIL_LASTPLAYPOS);
-        }
-    private:
-        const ProgramInfo m_pginfo;
-        const uint64_t m_frame;
-    };
-
     PlayerContext *mctx = GetPlayerReadLock(0, __FILE__, __LINE__);
     for (uint i = 0; mctx && i < player.size(); ++i)
     {
@@ -13525,10 +13458,11 @@
         bool playing = ctx->player && !ctx->player->IsPaused();
         if (playing) // Don't bother saving lastplaypos while paused
         {
+            // Save the latest playback position in a background thread
+            // to avoid playback glitches.
             uint64_t framesPlayed = ctx->player->GetFramesPlayed();
-            MThreadPool::globalInstance()->
-                start(new PositionSaver(*ctx->playingInfo, framesPlayed),
-                      "PositionSaver");
+            MConcurrent::run("PositionSaver", ctx->playingInfo,
+                             &ProgramInfo::SaveLastPlayPos, framesPlayed, true);
         }
         ctx->UnlockDeletePlayer(__FILE__, __LINE__);
     }
@@ -13537,6 +13471,8 @@
     QMutexLocker locker(&timerIdLock);
     KillTimer(saveLastPlayPosTimerId);
     saveLastPlayPosTimerId = StartTimer(kSaveLastPlayPosTimeout, __LINE__);
+
+    savePosOnExit = true;
 }
 
 void TV::SetLastProgram(const ProgramInfo *rcinfo)
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/tv_play.h mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/tv_play.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythtv/tv_play.h	2018-04-17 08:57:52.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythtv/tv_play.h	2018-04-17 09:58:57.740000005 +0200
@@ -365,7 +365,7 @@
     bool Init(bool createWindow = true);
     void InitFromDB(void);
     QList<QKeyEvent> ConvertScreenPressKeyMap(const QString& keyList);
-    
+
     // Top level playback methods
     bool LiveTV(bool showDialogs, const ChannelInfoList &selection);
     int  Playback(const ProgramInfo &rcinfo);
@@ -374,7 +374,7 @@
     // Private event handling
     bool ProcessKeypressOrGesture(PlayerContext*, QEvent *e);
     bool TranslateKeyPressOrGesture(const QString &context, QEvent *e,
-                                    QStringList &actions, bool isLiveTV, 
+                                    QStringList &actions, bool isLiveTV,
                                     bool allowJumps = true);
     bool TranslateGesture(const QString &context, MythGestureEvent *e,
                           QStringList &actions, bool isLiveTV);
@@ -477,8 +477,7 @@
         kBookmarkNever,
         kBookmarkAuto // set iff db_playback_exit_prompt==2
     };
-    void PrepareToExitPlayer(PlayerContext*, int line,
-                             BookmarkAction bookmark = kBookmarkAuto);
+    void PrepareToExitPlayer(PlayerContext*, int line);
     void SetExitPlayer(bool set_it, bool wants_to);
 
     bool RequestNextRecorder(PlayerContext *, bool,
@@ -795,7 +794,6 @@
     bool    db_jump_prefer_osd;
     bool    db_use_gui_size_for_tv;
     bool    db_start_in_guide;
-    bool    db_clear_saved_position;
     bool    db_run_jobs_on_remote;
     bool    db_continue_embedded;
     bool    db_use_fixed_size;
@@ -838,6 +836,7 @@
     bool allowRerecord;  ///< User wants to rerecord the last video if deleted
     bool doSmartForward;
     bool queuedTranscode;
+    bool savePosOnExit;  ///< False until first timer event
     /// Picture attribute type to modify.
     PictureAdjustType adjustingPicture;
     /// Picture attribute to modify (on arrow left or right)
@@ -898,7 +897,7 @@
     static const int screenPressRegionCount = 12;
     QList<QKeyEvent>    screenPressKeyMapPlayback;
     QList<QKeyEvent>    screenPressKeyMapLiveTV;
-    
+
     // Channel changing timeout notification variables
     QTime   lockTimer;
     bool    lockTimerOn;
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuibuttonlist.cpp mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuibuttonlist.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuibuttonlist.cpp	2018-04-17 08:57:52.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuibuttonlist.cpp	2018-04-17 09:58:57.740000005 +0200
@@ -21,6 +21,7 @@
 #include "mythuigroup.h"
 #include "mythuiimage.h"
 #include "mythgesture.h"
+#include "mythuiprogressbar.h"
 
 #define LOC     QString("MythUIButtonList(%1): ").arg(objectName())
 
@@ -3255,6 +3256,9 @@
     m_data      = 0;
     m_isVisible = false;
     m_enabled   = true;
+    m_progress  = 0;
+    m_progressStart = 0;
+    m_progressTotal = 0;
 
     if (state >= NotChecked)
         m_checkable = true;
@@ -3281,6 +3285,9 @@
     m_showArrow = false;
     m_isVisible = false;
     m_enabled   = true;
+    m_progress  = 0;
+    m_progressStart = 0;
+    m_progressTotal = 0;
 
     if (m_parent)
         m_parent->InsertItem(this, listPosition);
@@ -3536,6 +3543,16 @@
     return QString();
 }
 
+void MythUIButtonListItem::SetProgress(int start, int total, int used)
+{
+    m_progress      = used;
+    m_progressStart = start;
+    m_progressTotal = total;
+
+    if (m_parent && m_isVisible)
+        m_parent->Update();
+}
+
 void MythUIButtonListItem::DisplayState(const QString &state,
                                         const QString &name)
 {
@@ -3844,6 +3861,11 @@
     // There is no need to check the return value here, since we already
     // checked that the state exists with GetState() earlier
     button->DisplayState(state);
+
+    MythUIProgressBar *progress = dynamic_cast<MythUIProgressBar *>
+                                  (buttonstate->GetChild("buttonprogress"));
+    if (progress)
+        progress->Set(m_progressStart, m_progressTotal, m_progress);
 }
 
 //---------------------------------------------------------
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuibuttonlist.h mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuibuttonlist.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuibuttonlist.h	2018-04-17 08:57:52.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuibuttonlist.h	2018-04-17 09:58:57.740000005 +0200
@@ -81,6 +81,8 @@
     void SetImageFromMap(const InfoMap &imageMap);
     QString GetImageFilename(const QString &name="") const;
 
+    void SetProgress(int start, int total, int used);
+
     void DisplayState(const QString &state, const QString &name);
     void SetStatesFromMap(const InfoMap &stateMap);
 
@@ -117,6 +119,9 @@
     bool            m_showArrow;
     bool            m_isVisible;
     bool            m_enabled;
+    int             m_progress;
+    int             m_progressStart;
+    int             m_progressTotal;
 
     QMap<QString, TextProperties> m_strings;
     QMap<QString, MythImage*> m_images;
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuiprogressbar.cpp mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuiprogressbar.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuiprogressbar.cpp	2018-04-17 08:57:52.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuiprogressbar.cpp	2018-04-17 09:58:57.740000005 +0200
@@ -58,6 +58,16 @@
     return true;
 }
 
+void MythUIProgressBar::Set(int start, int total, int used)
+{
+    if (used != m_current || start != m_start || total != m_total)
+    {
+        m_start = start;
+        m_total = total;
+        SetUsed(used);
+    }
+}
+
 void MythUIProgressBar::SetStart(int value)
 {
     m_start = value;
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuiprogressbar.h mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuiprogressbar.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/libs/libmythui/mythuiprogressbar.h	2018-04-17 08:57:52.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/libs/libmythui/mythuiprogressbar.h	2018-04-17 09:58:57.740000005 +0200
@@ -20,6 +20,7 @@
     enum LayoutType { LayoutVertical, LayoutHorizontal };
     enum EffectType { EffectReveal, EffectSlide, EffectAnimate };
 
+    void Set(int start, int total, int used);
     void SetStart(int);
     void SetUsed(int);
     void SetTotal(int);
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/globalsettings.cpp mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/globalsettings.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/globalsettings.cpp	2018-04-17 09:57:35.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/globalsettings.cpp	2018-04-17 09:58:57.740000005 +0200
@@ -1586,23 +1586,6 @@
     return gc;
 }
 
-static HostCheckBoxSetting *ClearSavedPosition()
-{
-    HostCheckBoxSetting *gc = new HostCheckBoxSetting("ClearSavedPosition");
-
-    gc->setLabel(PlaybackSettings::tr("Clear bookmark on playback"));
-
-    gc->setValue(true);
-
-    gc->setHelpText(PlaybackSettings::tr("If enabled, automatically clear the "
-                                         "bookmark on a recording when the "
-                                         "recording is played back. If "
-                                         "disabled, you can mark the "
-                                         "beginning with rewind then save "
-                                         "position."));
-    return gc;
-}
-
 static HostCheckBoxSetting *UseProgStartMark()
 {
     HostCheckBoxSetting *gc = new HostCheckBoxSetting("UseProgStartMark");
@@ -1627,7 +1610,6 @@
     gc->setLabel(PlaybackSettings::tr("Action on playback exit"));
 
     gc->addSelection(PlaybackSettings::tr("Just exit"), "0");
-    gc->addSelection(PlaybackSettings::tr("Save position and exit"), "2");
     gc->addSelection(PlaybackSettings::tr("Always prompt (excluding Live TV)"),
                      "1");
     gc->addSelection(PlaybackSettings::tr("Always prompt (including Live TV)"),
@@ -1637,9 +1619,8 @@
     gc->setHelpText(PlaybackSettings::tr("If set to prompt, a menu will be "
                                          "displayed when you exit playback "
                                          "mode. The options available will "
-                                         "allow you to save your position, "
-                                         "delete the recording, or continue "
-                                         "watching."));
+                                         "allow you to delete the recording, "
+                                         "continue watching or exit."));
     return gc;
 }
 
@@ -3945,7 +3926,6 @@
     general->addChild(RealtimePriority());
     general->addChild(AudioReadAhead());
     general->addChild(JumpToProgramOSD());
-    general->addChild(ClearSavedPosition());
     general->addChild(UseProgStartMark());
     general->addChild(AutomaticSetWatched());
     general->addChild(ContinueEmbeddedTVPlay());
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/main.cpp mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/main.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/main.cpp	2018-04-17 09:57:36.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/main.cpp	2018-04-17 09:58:57.740000005 +0200
@@ -203,17 +203,23 @@
         Q_DECLARE_TR_FUNCTIONS(BookmarkDialog)
 
       public:
-        BookmarkDialog(ProgramInfo *pginfo, MythScreenStack *parent) :
+        BookmarkDialog(ProgramInfo *pginfo, MythScreenStack *parent,
+                       bool bookmarkPresent, bool lastPlayPresent) :
                 MythScreenType(parent, "bookmarkdialog"),
-                pgi(pginfo)
+                pgi(pginfo),
+                bookmarked(bookmarkPresent),
+                lastPlayed(lastPlayPresent),
+                btnPlayBookmark(tr("Play from bookmark")),
+                btnClearBookmark(tr("Clear bookmark")),
+                btnPlayBegin(tr("Play from beginning")),
+                btnPlayLast(tr("Play from last played position")),
+                btnClearLastPlay(tr("Clear last played position"))
         {
         }
 
         bool Create()
         {
             QString msg = tr("DVD/Video contains a bookmark");
-            QString btn0msg = tr("Play from bookmark");
-            QString btn1msg = tr("Play from beginning");
 
             MythDialogBox *popup = new MythDialogBox(msg, GetScreenStack(), "bookmarkdialog");
             if (!popup->Create())
@@ -225,8 +231,19 @@
             GetScreenStack()->AddScreen(popup);
 
             popup->SetReturnEvent(this, "bookmarkdialog");
-            popup->AddButton(btn0msg);
-            popup->AddButton(btn1msg);
+            if (bookmarked)
+            {
+                popup->AddButton(btnPlayBookmark);
+                popup->AddButton(btnClearBookmark);
+            }
+
+            popup->AddButton(btnPlayBegin);
+
+            if (lastPlayed)
+            {
+                popup->AddButton(btnPlayLast);
+                popup->AddButton(btnClearLastPlay);
+            }
             return true;
         }
 
@@ -235,22 +252,30 @@
             if (event->type() == DialogCompletionEvent::kEventType)
             {
                 DialogCompletionEvent *dce = (DialogCompletionEvent*)(event);
-                int buttonnum = dce->GetResult();
+                QString buttonText = dce->GetResultText();
 
                 if (dce->GetId() == "bookmarkdialog")
                 {
-                    uint flags = kStartTVNoFlags;
-                    if (buttonnum == 1)
+                    if (buttonText == btnPlayBookmark)
                     {
-                        flags |= kStartTVIgnoreBookmark;
+                        TV::StartTV(pgi, kStartTVNoFlags );
                     }
-                    else if (buttonnum != 0)
+                    else if (buttonText == btnPlayBegin)
                     {
-                        delete pgi;
-                        return;
+                        TV::StartTV(pgi, kStartTVNoFlags | kStartTVIgnoreBookmark);
+                    }
+                    else if (buttonText == btnPlayLast)
+                    {
+                        TV::StartTV(pgi, kStartTVNoFlags | kStartTVAllowLastPlayPos);
+                    }
+                    else if (buttonText == btnClearBookmark)
+                    {
+                        pgi->SaveBookmark(0);
+                    }
+                    else if (buttonText == btnClearLastPlay)
+                    {
+                        pgi->SaveLastPlayPos(0);
                     }
-
-                    TV::StartTV(pgi, flags);
 
                     delete pgi;
                 }
@@ -259,6 +284,10 @@
 
       private:
         ProgramInfo* pgi;
+        bool bookmarked, lastPlayed;
+        QString btnPlayBookmark, btnClearBookmark;
+        QString btnPlayBegin;
+        QString btnPlayLast, btnClearLastPlay;
     };
 
     void cleanup()
@@ -1293,6 +1322,7 @@
     pginfo->SetProgramInfoType(pginfo->DiscoverProgramInfoType());
 
     bool bookmarkPresent = false;
+    bool lastPlayPresent = false;
 
     if (pginfo->IsVideoDVD())
     {
@@ -1343,13 +1373,20 @@
             return res;
         }
     }
-    else if (pginfo->IsVideo())
-        bookmarkPresent = (pginfo->QueryBookmark() > 0);
+    else if (useBookmark && pginfo->IsVideo())
+    {
+        pginfo->SetAllowLastPlayPos(true);
+        pginfo->SetIgnoreBookmark(false);
+        bookmarkPresent = pginfo->QueryBookmark() > 0;
+        lastPlayPresent = pginfo->QueryLastPlayPos() > 0;
+    }
 
-    if (useBookmark && bookmarkPresent)
+    if (useBookmark && (bookmarkPresent || lastPlayPresent))
     {
         MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
-        BookmarkDialog *bookmarkdialog = new BookmarkDialog(pginfo, mainStack);
+        BookmarkDialog *bookmarkdialog = new BookmarkDialog(pginfo, mainStack,
+                                                            bookmarkPresent,
+                                                            lastPlayPresent);
         if (!bookmarkdialog->Create())
         {
             delete bookmarkdialog;
@@ -1776,7 +1813,7 @@
 }
 
 // from https://www.raspberrypi.org/forums/viewtopic.php?f=33&t=16897
-// The old way of revoking root with setuid(getuid()) 
+// The old way of revoking root with setuid(getuid())
 // causes system hang in certain cases on raspberry pi
 
 static int revokeRoot (void)
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/playbackbox.cpp mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/playbackbox.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/playbackbox.cpp	2018-04-17 09:57:35.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/playbackbox.cpp	2018-04-17 09:58:57.743333338 +0200
@@ -41,6 +41,7 @@
 #include "mythdb.h"
 #include "mythdate.h"
 #include "tv.h"
+#include "mconcurrent.h"
 
 #ifdef _MSC_VER
 #  include "compat.h"                   // for random
@@ -573,7 +574,7 @@
     connect(m_recordingList, SIGNAL(itemSelected(MythUIButtonListItem*)),
             SLOT(ItemSelected(MythUIButtonListItem*)));
     connect(m_recordingList, SIGNAL(itemClicked(MythUIButtonListItem*)),
-            SLOT(PlayFromBookmarkOrProgStart(MythUIButtonListItem*)));
+            SLOT(PlayFromAnyMark(MythUIButtonListItem*)));
     connect(m_recordingList, SIGNAL(itemVisible(MythUIButtonListItem*)),
             SLOT(ItemVisible(MythUIButtonListItem*)));
     connect(m_recordingList, SIGNAL(itemLoaded(MythUIButtonListItem*)),
@@ -1024,6 +1025,8 @@
     // Flagging status (queued, running, no, yes)
     item->DisplayState(extract_commflag_state(*pginfo), "commflagged");
 
+    item->SetProgress(0, 100, pginfo->GetProgressPercent());
+
     MythUIButtonListItem *sel_item = item->parent()->GetItemCurrent();
     if ((item != sel_item) && item->GetImageFilename("preview").isEmpty() &&
         (asAvailable == pginfo->GetAvailableStatus()))
@@ -2275,7 +2278,7 @@
         this, new MythEvent("PLAY_PLAYLIST"));
 }
 
-void PlaybackBox::PlayFromBookmarkOrProgStart(MythUIButtonListItem *item)
+void PlaybackBox::PlayFromAnyMark(MythUIButtonListItem *item)
 {
     if (!item)
         item = m_recordingList->GetItemCurrent();
@@ -2287,7 +2290,7 @@
 
     const bool ignoreBookmark = false;
     const bool ignoreProgStart = false;
-    const bool ignoreLastPlayPos = true;
+    const bool ignoreLastPlayPos = false;
     const bool underNetworkControl = false;
     if (pginfo)
         PlayX(*pginfo, ignoreBookmark, ignoreProgStart, ignoreLastPlayPos,
@@ -2383,6 +2386,20 @@
         pginfo->SaveBookmark(0);
 }
 
+//void PlaybackBox::ClearBookmark()
+//{
+//    ProgramInfo *pginfo = GetCurrentProgram();
+//    if (pginfo)
+//        pginfo->SaveBookmark(0);
+//}
+//
+void PlaybackBox::ClearLastPlayPos()
+{
+    ProgramInfo *pginfo = GetCurrentProgram();
+    if (pginfo)
+        pginfo->SaveLastPlayPos(0);
+}
+
 void PlaybackBox::StopSelected(void)
 {
     ProgramInfo *pginfo = GetCurrentProgram();
@@ -2461,7 +2478,7 @@
     if (!item)
         return;
 
-    PlayFromBookmarkOrProgStart(item);
+    PlayFromAnyMark(item);
 }
 
 void PlaybackBox::popupClosed(QString which, int result)
@@ -2608,14 +2625,6 @@
         QCoreApplication::postEvent(
             this, new MythEvent("PLAY_PLAYLIST"));
     }
-    else
-    {
-        // User may have saved or deleted a bookmark
-        // requiring update of bookmark icon..
-        ProgramInfo *pginfo = m_programInfoCache.GetRecordingInfo(tvrec.GetRecordingID());
-        if (pginfo)
-            UpdateUIListItem(pginfo, true);
-    }
 
     if (m_needUpdate)
         ScheduleUpdateUIList();
@@ -3068,8 +3077,12 @@
         menu->AddItem(tr("Play from bookmark"), SLOT(PlayFromBookmark()));
 
     if (pginfo->QueryLastPlayPos())
+    {
         menu->AddItem(tr("Play from last played position"),
                       SLOT(PlayFromLastPlayPos()));
+        menu->AddItem(tr("Clear last played position"),
+                      SLOT(ClearLastPlayPos()));
+    }
 
     menu->AddItem(tr("Play from beginning"), SLOT(PlayFromBeginning()));
 
@@ -3320,7 +3333,7 @@
             m_popupMenu->AddItem(tr("Play from..."), NULL, createPlayFromMenu());
         else
             m_popupMenu->AddItem(tr("Play"),
-                                 SLOT(PlayFromBookmarkOrProgStart()));
+                                 SLOT(PlayFromAnyMark()));
     }
 
     if (!m_player)
@@ -4070,7 +4083,7 @@
             if (action == "DELETE")
                 deleteSelected(m_recordingList->GetItemCurrent());
             else if (action == ACTION_PLAYBACK)
-                PlayFromBookmarkOrProgStart();
+                PlayFromAnyMark();
             else if (action == "DETAILS" || action == "INFO")
                 ShowDetails();
             else if (action == "CUSTOMEDIT")
@@ -4126,7 +4139,11 @@
             {
                 ProgramInfo evinfo(me->ExtraDataList());
                 if (evinfo.HasPathname() || evinfo.GetChanID())
-                    HandleUpdateProgramInfoEvent(evinfo);
+                {
+                    uint32_t flags = m_programInfoCache.Update(evinfo);
+                    if (flags != PIC_NO_ACTION)
+                        HandleUpdateItemEvent(evinfo.GetRecordingID(), flags);
+                }
             }
             else if (recordingID && (tokens[1] == "ADD"))
             {
@@ -4177,18 +4194,18 @@
         else if (message.startsWith("UPDATE_FILE_SIZE"))
         {
             QStringList tokens = message.simplified().split(" ");
-            bool ok = false;
-            uint recordingID = 0;
-            uint64_t filesize = 0ULL;
             if (tokens.size() >= 3)
             {
-                recordingID = tokens[1].toUInt();
-                filesize   = tokens[2].toLongLong(&ok);
-            }
-            if (recordingID && ok)
-            {
-
-                HandleUpdateProgramInfoFileSizeEvent(recordingID, filesize);
+                bool ok = false;
+                uint recordingID  = tokens[1].toUInt();
+                uint64_t filesize = tokens[2].toLongLong(&ok);
+                if (ok)
+                {
+                    // Delegate to background thread
+                    MConcurrent::run("UpdateFileSize", &m_programInfoCache,
+                                     &ProgramInfoCache::UpdateFileSize,
+                                     recordingID, filesize, PIC_NONE);
+                }
             }
         }
         else if (message == "UPDATE_UI_LIST")
@@ -4201,6 +4218,18 @@
                 m_helper.ForceFreeSpaceUpdate();
             }
         }
+        else if (message.startsWith("UPDATE_UI_ITEM"))
+        {
+            QStringList tokens = message.simplified().split(" ");
+            if (tokens.size() < 3)
+                return;
+
+            uint recordingID  = tokens[1].toUInt();
+            UpdateState flags = static_cast<UpdateState>(tokens[2].toUInt());
+
+            if (flags != PIC_NO_ACTION)
+                HandleUpdateItemEvent(recordingID, flags);
+        }
         else if (message == "UPDATE_USAGE_UI")
         {
             UpdateUsageUI();
@@ -4519,35 +4548,22 @@
     ScheduleUpdateUIList();
 }
 
-void PlaybackBox::HandleUpdateProgramInfoEvent(const ProgramInfo &evinfo)
+void PlaybackBox::HandleUpdateItemEvent(uint recordingId, uint flags)
 {
-    QString old_recgroup = m_programInfoCache.GetRecGroup(
-        evinfo.GetRecordingID());
-
-    if (!m_programInfoCache.Update(evinfo))
-        return;
-
-    // If the recording group has changed, reload lists from the recently
-    // updated cache; if not, only update UI for the updated item
-    if (evinfo.GetRecordingGroup() == old_recgroup)
+    // Changing recording group full reload
+    if (flags & PIC_RECGROUP_CHANGED)
     {
-        ProgramInfo *dst = FindProgramInUILists(evinfo);
-        if (dst)
-            UpdateUIListItem(dst, true);
-        return;
+        ScheduleUpdateUIList();
+    }
+    else
+    {
+        ProgramInfo *pginfo = FindProgramInUILists(recordingId);
+        if (pginfo)
+        {
+            bool genPreview = (flags & PIC_MARK_CHANGED);
+            UpdateUIListItem(pginfo, genPreview);
+        }
     }
-
-    ScheduleUpdateUIList();
-}
-
-void PlaybackBox::HandleUpdateProgramInfoFileSizeEvent(uint recordingID,
-                                                       uint64_t filesize)
-{
-    m_programInfoCache.UpdateFileSize(recordingID, filesize);
-
-    ProgramInfo *dst = FindProgramInUILists(recordingID);
-    if (dst)
-        UpdateUIListItem(dst, false);
 }
 
 void PlaybackBox::ScheduleUpdateUIList(void)
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/playbackbox.h mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/playbackbox.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/playbackbox.h	2018-04-17 09:57:35.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/playbackbox.h	2018-04-17 10:00:55.643333328 +0200
@@ -143,12 +143,13 @@
     void ItemLoaded(MythUIButtonListItem *item);
     void selected(MythUIButtonListItem *item);
     void updateRecGroup(MythUIButtonListItem *sel_item);
-    void PlayFromBookmarkOrProgStart(MythUIButtonListItem *item = NULL);
+    void PlayFromAnyMark(MythUIButtonListItem *item = NULL);
     void PlayFromBookmark(MythUIButtonListItem *item = NULL);
     void PlayFromBeginning(MythUIButtonListItem *item = NULL);
     void PlayFromLastPlayPos(MythUIButtonListItem *item = NULL);
     void deleteSelected(MythUIButtonListItem *item);
     void ClearBookmark();
+    void ClearLastPlayPos();
     void SwitchList(void);
 
     void ShowGroupPopup(void);
@@ -332,8 +333,7 @@
     void HandlePreviewEvent(const QStringList &list);
     void HandleRecordingRemoveEvent(uint recordingID);
     void HandleRecordingAddEvent(const ProgramInfo &evinfo);
-    void HandleUpdateProgramInfoEvent(const ProgramInfo &evinfo);
-    void HandleUpdateProgramInfoFileSizeEvent(uint recordingID, uint64_t filesize);
+    void HandleUpdateItemEvent(uint recordingId, uint flags);
 
     void ScheduleUpdateUIList(void);
     void ShowMenu(void);
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/programinfocache.cpp mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/programinfocache.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/programinfocache.cpp	2018-04-17 08:57:53.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/programinfocache.cpp	2018-04-17 09:58:57.743333338 +0200
@@ -10,6 +10,8 @@
 #include "programinfo.h"
 #include "remoteutil.h"
 #include "mythevent.h"
+#include "mythdb.h"
+#include "mconcurrent.h"
 
 #include <QCoreApplication>
 #include <QRunnable>
@@ -73,6 +75,35 @@
     }
 }
 
+void ProgramInfoCache::CalculateProgress(ProgramInfo &pg, int pos)
+{
+    uint lastPlayPercent = 0;
+    if (pos > 0)
+    {
+        int total = 0;
+
+        switch (pg.GetRecordingStatus())
+        {
+        case RecStatus::Recorded:
+            total = pg.QueryTotalFrames();
+            break;
+        case RecStatus::Recording:
+            // Active recordings won't have total frames set yet.
+            total = pg.QueryLastFrameInPosMap();
+            break;
+        default:
+            break;
+        }
+
+        lastPlayPercent = (total > pos) ? (100 * pos) / total : 0;
+
+        LOG(VB_GUI, LOG_DEBUG, QString("%1 %2  %3/%4 = %5%")
+            .arg(pg.GetRecordingID()).arg(pg.GetTitle())
+            .arg(pos).arg(total).arg(lastPlayPercent));
+    }
+    pg.SetProgressPercent(lastPlayPercent);
+}
+
 void ProgramInfoCache::Load(const bool updateUI)
 {
     QMutexLocker locker(&m_lock);
@@ -84,6 +115,45 @@
     // we sort the list later anyway.
     vector<ProgramInfo*> *tmp = RemoteGetRecordedList(0);
     /**/
+
+    // Calculate play positions for UI
+    if (tmp)
+    {
+        // Played progress
+        typedef QPair<uint, QDateTime> ProgId;
+        QHash<ProgId, uint> lastPlayFrames;
+
+        // Get all lastplaypos marks in a single lookup
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare("SELECT chanid, starttime, mark "
+                      "FROM recordedmarkup "
+                      "WHERE type = :TYPE ");
+        query.bindValue(":TYPE", MARK_UTIL_LASTPLAYPOS);
+
+        if (query.exec())
+        {
+            while (query.next())
+            {
+                ProgId id = qMakePair(query.value(0).toUInt(),
+                                      MythDate::as_utc(query.value(1).toDateTime()));
+                lastPlayFrames[id] = query.value(2).toUInt();
+            }
+
+            // Determine progress of each prog
+            foreach (ProgramInfo* pg, *tmp)
+            {
+                // Enable last play pos for all recordings
+                pg->SetAllowLastPlayPos(true);
+
+                ProgId id = qMakePair(pg->GetChanID(),
+                                      pg->GetRecordingStartTime());
+                CalculateProgress(*pg, lastPlayFrames.value(id));
+            }
+        }
+        else
+            MythDB::DBError("Watched progress", query);
+    }
+
     locker.relock();
 
     free_vec(m_next_cache);
@@ -157,54 +227,80 @@
 
 /** \brief Updates a ProgramInfo in the cache.
  *  \note This must only be called from the UI thread.
- *  \return True iff the ProgramInfo was in the cache and was updated.
+ *  \return Flags indicating the result of the update
  */
-bool ProgramInfoCache::Update(const ProgramInfo &pginfo)
+uint32_t ProgramInfoCache::Update(const ProgramInfo& pginfo)
 {
     QMutexLocker locker(&m_lock);
 
-    Cache::iterator it = m_cache.find(pginfo.GetRecordingID());
+    uint recordingId = pginfo.GetRecordingID();
+    Cache::iterator it = m_cache.find(recordingId);
 
-    if (it != m_cache.end())
-        (*it)->clone(pginfo, true);
+    if (it == m_cache.end())
+        return PIC_NO_ACTION;
 
-    return it != m_cache.end();
-}
+    ProgramInfo& pg = **it;
+    uint32_t flags = PIC_NONE;
 
-/** \brief Updates a ProgramInfo in the cache.
- *  \note This must only be called from the UI thread.
- *  \return True iff the ProgramInfo was in the cache and was updated.
- */
-bool ProgramInfoCache::UpdateFileSize(uint recordingID, uint64_t filesize)
-{
-    QMutexLocker locker(&m_lock);
+    if (pginfo.GetBookmarkUpdate() != pg.GetBookmarkUpdate())
+        flags |= PIC_MARK_CHANGED;
+
+    if (pginfo.GetRecordingGroup() != pg.GetRecordingGroup())
+        flags |= PIC_RECGROUP_CHANGED;
 
-    Cache::iterator it = m_cache.find(recordingID);
+    pg.clone(pginfo, true);
+    pg.SetAllowLastPlayPos(true);
 
-    if (it != m_cache.end())
+    if (flags & PIC_MARK_CHANGED)
     {
-        (*it)->SetFilesize(filesize);
-        if (filesize)
-            (*it)->SetAvailableStatus(asAvailable, "PIC::UpdateFileSize");
+        // Delegate this update to a background task
+        MConcurrent::run("UpdateProg", this, &ProgramInfoCache::UpdateFileSize,
+                         recordingId, 0, flags);
+        // Ignore this update
+        flags = PIC_NO_ACTION;
     }
 
-    return it != m_cache.end();
+    LOG(VB_GUI, LOG_DEBUG, QString("Pg %1 %2 update state %3")
+        .arg(recordingId).arg(pg.GetTitle()).arg(flags));
+    return flags;
 }
 
-/** \brief Returns the ProgramInfo::recgroup or an empty string if not found.
- *  \note This must only be called from the UI thread.
+/** \brief Updates file size calculations of a ProgramInfo in the cache.
+ *  \note This should only be run by a non-UI thread as it contains multiple
+ *   Db queries
+ *  \return True iff the ProgramInfo was in the cache and was updated.
  */
-QString ProgramInfoCache::GetRecGroup(uint recordingID) const
+void ProgramInfoCache::UpdateFileSize(uint recordingId, uint64_t filesize,
+                                      uint32_t flags)
 {
     QMutexLocker locker(&m_lock);
 
-    Cache::const_iterator it = m_cache.find(recordingID);
+    Cache::iterator it = m_cache.find(recordingId);
+    if (it == m_cache.end())
+        return;
 
-    QString recgroup;
-    if (it != m_cache.end())
-        recgroup = (*it)->GetRecordingGroup();
+    ProgramInfo& pg = **it;
 
-    return recgroup;
+    CalculateProgress(pg, pg.QueryLastPlayPos());
+
+    if (filesize > 0)
+    {
+        // Filesize update
+        pg.SetFilesize(filesize);
+        pg.SetAvailableStatus(asAvailable, "PIC::UpdateFileSize");
+    }
+    else // Info update
+    {
+        // Don't keep regenerating previews of files being played
+        QString byWhom;
+        if (pg.QueryIsInUse(byWhom) && byWhom.contains(QObject::tr("Playing")))
+            flags &= ~PIC_MARK_CHANGED;
+    }
+
+    QString mesg = QString("UPDATE_UI_ITEM %1 %2").arg(recordingId).arg(flags);
+    QCoreApplication::postEvent(m_listener, new MythEvent(mesg));
+
+    LOG(VB_GUI, LOG_DEBUG, mesg);
 }
 
 /** \brief Adds a ProgramInfo to the cache.
@@ -212,10 +308,14 @@
  */
 void ProgramInfoCache::Add(const ProgramInfo &pginfo)
 {
-    if (!pginfo.GetRecordingID() || Update(pginfo))
+    if (!pginfo.GetRecordingID() || Update(pginfo) != PIC_NO_ACTION)
         return;
 
-    m_cache[pginfo.GetRecordingID()] = new ProgramInfo(pginfo);
+    QMutexLocker locker(&m_lock);
+
+    ProgramInfo* pg = new ProgramInfo(pginfo);
+    pg->SetAllowLastPlayPos(true);
+    m_cache[pginfo.GetRecordingID()] = pg;
 }
 
 /** \brief Marks a ProgramInfo in the cache for deletion on the next
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/programinfocache.h mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/programinfocache.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/programinfocache.h	2018-04-17 08:57:53.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/programinfocache.h	2018-04-17 09:58:57.743333338 +0200
@@ -20,6 +20,13 @@
 class ProgramInfo;
 class QObject;
 
+typedef enum {
+    PIC_NONE              = 0x00,
+    PIC_MARK_CHANGED      = 0x01,
+    PIC_RECGROUP_CHANGED  = 0x02,
+    PIC_NO_ACTION         = 0x80,
+} UpdateState;
+
 class ProgramInfoCache
 {
     friend class ProgramInfoLoader;
@@ -35,9 +42,8 @@
     void Refresh(void);
     void Add(const ProgramInfo&);
     bool Remove(uint recordingID);
-    bool Update(const ProgramInfo&);
-    bool UpdateFileSize(uint recordingID, uint64_t filesize);
-    QString GetRecGroup(uint recordingID) const;
+    uint32_t Update(const ProgramInfo& pginfo);
+    void UpdateFileSize(uint recordingID, uint64_t filesize, uint32_t flags);
     void GetOrdered(vector<ProgramInfo*> &list, bool newest_first = false);
     /// \note This must only be called from the UI thread.
     bool empty(void) const { return m_cache.empty(); }
@@ -46,6 +52,8 @@
   private:
     void Load(const bool updateUI = true);
     void Clear(void);
+    void CalculateProgress(ProgramInfo &pg, int playPos);
+    void LoadProgressMarks();
 
   private:
     // NOTE: Hash would be faster for lookups and updates, but we need a sorted
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/viewscheduled.cpp mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/viewscheduled.cpp
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/viewscheduled.cpp	2018-04-17 08:57:53.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/viewscheduled.cpp	2018-04-17 09:58:57.743333338 +0200
@@ -280,13 +280,16 @@
     if (!useExistingData)
         LoadFromScheduler(m_recList, m_conflictBool);
 
-    ProgramList::iterator pit = m_recList.begin();
-    QString currentDate;
     m_recgroupList[m_defaultGroup] = ProgramList(false);
     m_recgroupList[m_defaultGroup].setAutoDelete(false);
+
+    ProgramList::iterator pit = m_recList.begin();
     while (pit != m_recList.end())
     {
         ProgramInfo *pginfo = *pit;
+
+        CalcRecordedPercent(*pginfo);
+
         const RecStatus::Type recstatus = pginfo->GetRecordingStatus();
         if ((pginfo->GetRecordingEndTime() >= now ||
              pginfo->GetScheduledEndTime() >= now ||
@@ -390,6 +393,58 @@
         FillList();
 }
 
+void ViewScheduled::UpdateUIListItem(MythUIButtonListItem* item,
+                                     const ProgramInfo &pginfo)
+{
+    QString state;
+
+    const RecStatus::Type recstatus = pginfo.GetRecordingStatus();
+    if (recstatus == RecStatus::Recording      ||
+        recstatus == RecStatus::Tuning)
+        state = "running";
+    else if (recstatus == RecStatus::Conflict  ||
+             recstatus == RecStatus::Offline   ||
+             recstatus == RecStatus::TunerBusy ||
+             recstatus == RecStatus::Failed    ||
+             recstatus == RecStatus::Failing   ||
+             recstatus == RecStatus::Aborted   ||
+             recstatus == RecStatus::Missed)
+        state = "error";
+    else if (recstatus == RecStatus::WillRecord ||
+             recstatus == RecStatus::Pending)
+    {
+        if (m_curinput == 0 || pginfo.GetInputID() == m_curinput)
+        {
+            if (pginfo.GetRecordingPriority2() < 0)
+                state = "warning";
+            else
+                state = "normal";
+        }
+    }
+    else if (recstatus == RecStatus::Repeat ||
+             recstatus == RecStatus::NeverRecord ||
+             recstatus == RecStatus::DontRecord ||
+             (recstatus != RecStatus::DontRecord &&
+              recstatus <= RecStatus::EarlierShowing))
+        state = "disabled";
+    else
+        state = "warning";
+
+    InfoMap infoMap;
+    pginfo.ToMap(infoMap);
+
+    infoMap["progresspercent"] = ProgressString(pginfo);
+
+    item->SetTextFromMap(infoMap, state);
+
+    if (!infoMap["progresspercent"].isEmpty())
+        item->SetProgress(0, 100, pginfo.GetProgressPercent());
+
+    QString rating = QString::number(pginfo.GetStars(10));
+    item->DisplayState(rating, "ratingstate");
+    item->DisplayState(state, "status");
+}
+
 void ViewScheduled::FillList()
 {
     m_schedulesList->Reset();
@@ -413,59 +468,14 @@
     ProgramList::iterator pit = plist.begin();
     while (pit != plist.end())
     {
-        ProgramInfo *pginfo = *pit;
-        if (!pginfo)
+        ProgramInfo* pginfo = *pit;
+        if (pginfo)
         {
-            ++pit;
-            continue;
+            MythUIButtonListItem *item =
+                    new MythUIButtonListItem(m_schedulesList,"",
+                                             qVariantFromValue(pginfo));
+            UpdateUIListItem(item, *pginfo);
         }
-
-        QString state;
-
-        const RecStatus::Type recstatus = pginfo->GetRecordingStatus();
-        if (recstatus == RecStatus::Recording      ||
-            recstatus == RecStatus::Tuning)
-            state = "running";
-        else if (recstatus == RecStatus::Conflict  ||
-                 recstatus == RecStatus::Offline   ||
-                 recstatus == RecStatus::TunerBusy ||
-                 recstatus == RecStatus::Failed    ||
-                 recstatus == RecStatus::Failing   ||
-                 recstatus == RecStatus::Aborted   ||
-                 recstatus == RecStatus::Missed)
-            state = "error";
-        else if (recstatus == RecStatus::WillRecord ||
-                 recstatus == RecStatus::Pending)
-        {
-            if (m_curinput == 0 || pginfo->GetInputID() == m_curinput)
-            {
-                if (pginfo->GetRecordingPriority2() < 0)
-                    state = "warning";
-                else
-                    state = "normal";
-            }
-        }
-        else if (recstatus == RecStatus::Repeat ||
-                 recstatus == RecStatus::NeverRecord ||
-                 recstatus == RecStatus::DontRecord ||
-                 (recstatus != RecStatus::DontRecord &&
-                  recstatus <= RecStatus::EarlierShowing))
-            state = "disabled";
-        else
-            state = "warning";
-
-        MythUIButtonListItem *item =
-                                new MythUIButtonListItem(m_schedulesList,"",
-                                                    qVariantFromValue(pginfo));
-
-        InfoMap infoMap;
-        pginfo->ToMap(infoMap);
-        item->SetTextFromMap(infoMap, state);
-
-        QString rating = QString::number(pginfo->GetStars(10));
-        item->DisplayState(rating, "ratingstate");
-        item->DisplayState(state, "status");
-
         ++pit;
     }
 
@@ -509,6 +519,13 @@
     }
 }
 
+QString ViewScheduled::ProgressString(const ProgramInfo &pg)
+{
+    // Only show progress value for active recordings
+    return pg.GetRecordingStatus() == RecStatus::Recording
+            ? QString::number(pg.GetProgressPercent()) : "";
+}
+
 void ViewScheduled::updateInfo(MythUIButtonListItem *item)
 {
     if (!item)
@@ -519,6 +536,9 @@
     {
         InfoMap infoMap;
         pginfo->ToMap(infoMap);
+
+        infoMap["progresspercent"] = ProgressString(*pginfo);
+
         SetTextFromMap(infoMap);
 
         MythUIStateType *ratingState = dynamic_cast<MythUIStateType*>
@@ -599,19 +619,62 @@
         MythEvent *me = (MythEvent *)event;
         QString message = me->Message();
 
-        if (message != "SCHEDULE_CHANGE")
-            return;
-
-        m_needFill = true;
+        if (message == "SCHEDULE_CHANGE")
+        {
+            m_needFill = true;
 
-        if (m_inEvent)
-            return;
+            if (m_inEvent)
+                return;
 
-        m_inEvent = true;
+            m_inEvent = true;
 
-        LoadList();
+            LoadList();
 
-        m_inEvent = false;
+            m_inEvent = false;
+        }
+        else if (message.startsWith("UPDATE_FILE_SIZE"))
+        {
+            QStringList tokens = message.simplified().split(" ");
+            if (tokens.size() < 3)
+                return;
+
+            bool ok;
+            uint recordingID  = tokens[1].toUInt();
+            uint64_t filesize = tokens[2].toLongLong(&ok);
+
+            // Locate program
+            ProgramList::iterator pit = m_recList.begin();
+            while (pit != m_recList.end())
+            {
+                ProgramInfo* pginfo = *pit;
+                if (pginfo && pginfo->GetRecordingID() == recordingID)
+                {
+                    // Update size & progress
+                    pginfo->SetFilesize(filesize);
+                    uint current = pginfo->GetProgressPercent();
+                    CalcRecordedPercent(*pginfo);
+                    if (pginfo->GetProgressPercent() != current)
+                    {
+                        // Update display, if it's shown
+                        MythUIButtonListItem *item =
+                                m_schedulesList->
+                                GetItemByData(qVariantFromValue(pginfo));
+                        if (item)
+                        {
+                            UpdateUIListItem(item, *pginfo);
+
+                            // Update selected item if necessary
+                            MythUIButtonListItem *selected =
+                                    m_schedulesList->GetItemCurrent();
+                            if (item == selected)
+                                updateInfo(selected);
+                        }
+                    }
+                    break;
+                }
+                ++pit;
+            }
+        }
     }
     else if (event->type() == DialogCompletionEvent::kEventType)
     {
@@ -693,6 +756,23 @@
     }
 }
 
+void ViewScheduled::CalcRecordedPercent(ProgramInfo &pg)
+{
+    QDateTime start = pg.GetRecordingStartTime();
+    int current = start.secsTo(MythDate::current());
+    uint recordedPercent = 0;
+    int duration = 0;
+    if (current > 0)
+    {
+        // Recording stops at end of the final minute
+        duration        = start.secsTo(pg.GetRecordingEndTime()) + 60;
+        recordedPercent = duration > current ? current * 100 / duration : 100;
+    }
+    pg.SetProgressPercent(recordedPercent);
+    LOG(VB_GUI, LOG_DEBUG, QString("%1  %2/%3 = %4%")
+        .arg(pg.GetTitle()).arg(current).arg(duration).arg(recordedPercent));
+}
+
 ProgramInfo *ViewScheduled::GetCurrentProgram(void) const
 {
     MythUIButtonListItem *item = m_schedulesList->GetItemCurrent();
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/viewscheduled.h mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/viewscheduled.h
--- mythtv-master-20180417-gda1dc48-old/mythtv/programs/mythfrontend/viewscheduled.h	2018-04-17 08:57:53.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/programs/mythfrontend/viewscheduled.h	2018-04-17 09:58:57.743333338 +0200
@@ -59,6 +59,11 @@
 
     void EmbedTVWindow(void);
 
+    void CalcRecordedPercent(ProgramInfo &pg);
+    void UpdateUIListItem(MythUIButtonListItem* item,
+                          const ProgramInfo &pginfo);
+    QString ProgressString(const ProgramInfo &pg);
+
     bool m_conflictBool;
     QDate m_conflictDate;
 
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/themes/MythCenter-wide/recordings-ui.xml mythtv-master-20180417-gda1dc48-new/mythtv/themes/MythCenter-wide/recordings-ui.xml
--- mythtv-master-20180417-gda1dc48-old/mythtv/themes/MythCenter-wide/recordings-ui.xml	2018-04-17 09:57:35.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/themes/MythCenter-wide/recordings-ui.xml	2018-04-17 09:58:57.743333338 +0200
@@ -193,6 +193,16 @@
             <statetype name="buttonitem">
                 <state name="active">
                 <area>0,0,880,30</area>
+                <progressbar name="buttonprogress">
+                    <area>0,0,100%,100%</area>
+                    <layout>horizontal</layout>
+                    <style>reveal</style>
+                    <shape name="progressimage">
+                        <area>0,1,100%,100%-1</area>
+                        <type>box</type>
+                        <fill color="#000000" alpha="128"/>
+                    </shape>
+                </progressbar>
                 <statetype name="status">
                     <position>3,2</position>
                     <state name="disabled">
@@ -225,8 +235,9 @@
                     <textarea name="titlesubtitle" from="buttontext">
                         <area>32,2,656,28</area>
                         <align>vcenter</align>
+                        <template>%titlesubtitle%% (|progresspercent|%)%</template>
                     </textarea>
-                    <textarea name="shortstartdate" from="titlesubtitle">
+                    <textarea name="shortstartdate" from="buttontext">
                         <area>634,2,120,28</area>
                         <align>right,vcenter</align>
                     </textarea>
@@ -262,8 +273,7 @@
                     <shape name="selectbar">
                         <area>0,0,100%,30</area>
                     </shape>
-                    <textarea name="titlesubtitle" from="buttontext">
-                        <area>32,2,656,28</area>
+                    <textarea name="fonts" from="buttontext">
                         <font>basesmall_normal_selected</font>
                         <font state="disabled">basesmall_disabled_selected</font>
                         <font state="error">basesmall_error_selected</font>
@@ -272,13 +282,16 @@
                         <font state="running">basesmall_running_selected</font>
                         <align>vcenter</align>
                     </textarea>
-                    <textarea name="shortstartdate" from="titlesubtitle">
+                    <textarea name="titlesubtitle" from="fonts">
+                        <area>32,2,656,28</area>
+                        <template>%titlesubtitle%% (|progresspercent|%)%</template>
+                    </textarea>
+                    <textarea name="shortstartdate" from="fonts">
                         <area>634,2,120,28</area>
                         <align>right,vcenter</align>
                     </textarea>
                     <textarea name="starttime" from="shortstartdate">
                         <area>760,2,114,28</area>
-                        <align>right,vcenter</align>
                     </textarea>
                 </state>
             </statetype>
@@ -399,6 +412,7 @@
             <font>baselarge</font>
             <cutdown>yes</cutdown>
             <align>vcenter</align>
+            <template>%title%% (|progresspercent|%)%</template>
         </textarea>
 
         <textarea name="channel" from="basetextarea">
diff -Naur mythtv-master-20180417-gda1dc48-old/mythtv/themes/MythCenter-wide/schedule-ui.xml mythtv-master-20180417-gda1dc48-new/mythtv/themes/MythCenter-wide/schedule-ui.xml
--- mythtv-master-20180417-gda1dc48-old/mythtv/themes/MythCenter-wide/schedule-ui.xml	2018-04-17 08:57:54.000000000 +0200
+++ mythtv-master-20180417-gda1dc48-new/mythtv/themes/MythCenter-wide/schedule-ui.xml	2018-04-17 09:58:57.743333338 +0200
@@ -513,6 +513,16 @@
             <statetype name="buttonitem">
                 <area>0,0,1200,24</area>
                 <state name="active">
+                    <progressbar name="buttonprogress">
+                        <area>10,2,1200,24</area>
+                        <layout>horizontal</layout>
+                        <style>reveal</style>
+                        <shape name="progressimage">
+                            <area>0,0,100%,100%</area>
+                            <type>box</type>
+                            <fill color="#000000" alpha="128"/>
+                        </shape>
+                    </progressbar>
                     <textarea name="shortstarttimedate" from="buttontext">
                         <area>10,2,250,24</area>
                     </textarea>
@@ -521,6 +531,7 @@
                     </textarea>
                     <textarea name="title" from="shortstarttimedate">
                         <area>480,2,655,24</area>
+                        <template>%title%% (|progresspercent|%)%</template>
                     </textarea>
                     <textarea name="card" from="shortstarttimedate">
                         <area>1145,2,40,24</area>
@@ -542,6 +553,7 @@
                     </textarea>
                     <textarea name="title" from="shortstarttimedate">
                         <area>480,2,655,24</area>
+                        <template>%title%% (|progresspercent|%)%</template>
                     </textarea>
                     <textarea name="card" from="shortstarttimedate">
                         <area>1145,2,40,24</area>
@@ -562,10 +574,16 @@
         </buttonlist>
 
         <textarea name="title" from="basetextarea">
-            <area>30,454,1200,50</area>
+            <area>30,454,1000,50</area>
             <font>baselarge</font>
         </textarea>
 
+        <textarea name="progresspercent" from="basetextarea">
+            <area>1180,454,70,50</area>
+            <align>right,vcenter</align>
+            <template>%progresspercent|%%</template>
+        </textarea>
+
         <textarea name="channel" from="basetextarea">
             <area>30,494,360,30</area>
         </textarea>
