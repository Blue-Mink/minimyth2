diff -Naur mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_buffers.c mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_buffers.c
--- mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_buffers.c	2020-09-25 09:21:46.083333335 +0200
+++ mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_buffers.c	2020-09-25 09:21:48.153333334 +0200
@@ -21,11 +21,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "config.h"
-#if CONFIG_LIBDRM
 #include <drm_fourcc.h>
-#endif
-
 #include <linux/videodev2.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
@@ -34,9 +30,8 @@
 #include <poll.h>
 #include "libavcodec/avcodec.h"
 #include "libavcodec/internal.h"
-#include "libavutil/avassert.h"
-#include "libavutil/hwcontext.h"
 #include "libavutil/pixdesc.h"
+#include "libavutil/hwcontext.h"
 #include "v4l2_context.h"
 #include "v4l2_buffers.h"
 #include "v4l2_m2m.h"
@@ -236,52 +231,7 @@
     return AVCOL_TRC_UNSPECIFIED;
 }
 
-static void v4l2_free_buffer(void *opaque, uint8_t *unused)
-{
-    V4L2Buffer* avbuf = opaque;
-    V4L2m2mContext *s = buf_to_m2mctx(avbuf);
-
-    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {
-        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);
-
-        if (s->reinit) {
-            if (!atomic_load(&s->refcount))
-                sem_post(&s->refsync);
-        } else {
-            if (s->draining && V4L2_TYPE_IS_OUTPUT(avbuf->context->type)) {
-                /* no need to queue more buffers to the driver */
-                avbuf->status = V4L2BUF_AVAILABLE;
-            }
-            else if (avbuf->context->streamon)
-                ff_v4l2_buffer_enqueue(avbuf);
-        }
-
-        av_buffer_unref(&avbuf->context_ref);
-    }
-}
-
-static int v4l2_buf_increase_ref(V4L2Buffer *in)
-{
-    V4L2m2mContext *s = buf_to_m2mctx(in);
-
-    if (in->context_ref)
-        atomic_fetch_add(&in->context_refcount, 1);
-    else {
-        in->context_ref = av_buffer_ref(s->self_ref);
-        if (!in->context_ref)
-            return AVERROR(ENOMEM);
-
-        in->context_refcount = 1;
-    }
-
-    in->status = V4L2BUF_RET_USER;
-    atomic_fetch_add_explicit(&s->refcount, 1, memory_order_relaxed);
-
-    return 0;
-}
-
-#if CONFIG_LIBDRM
-static uint8_t *v4l2_get_drm_frame(V4L2Buffer *avbuf)
+static uint8_t * v4l2_get_drm_frame(V4L2Buffer *avbuf)
 {
     AVDRMFrameDescriptor *drm_desc = &avbuf->drm_frame;
     AVDRMLayerDescriptor *layer;
@@ -299,8 +249,9 @@
         layer->planes[i].pitch = avbuf->plane_info[i].bytesperline;
     }
 
-    switch (avbuf->context->sw_pix_fmt) {
+    switch (avbuf->context->av_pix_fmt) {
     case AV_PIX_FMT_YUYV422:
+
         layer->format = DRM_FORMAT_YUYV;
         layer->nb_planes = 1;
 
@@ -308,6 +259,7 @@
 
     case AV_PIX_FMT_NV12:
     case AV_PIX_FMT_NV21:
+
         layer->format = avbuf->context->av_pix_fmt == AV_PIX_FMT_NV12 ?
             DRM_FORMAT_NV12 : DRM_FORMAT_NV21;
 
@@ -323,6 +275,7 @@
         break;
 
     case AV_PIX_FMT_YUV420P:
+
         layer->format = DRM_FORMAT_YUV420;
 
         if (avbuf->num_planes > 1)
@@ -347,7 +300,31 @@
         break;
     }
 
-    return (uint8_t *)drm_desc;
+    return (uint8_t *) drm_desc;
+}
+
+static void v4l2_free_buffer(void *opaque, uint8_t *data)
+{
+    V4L2Buffer* avbuf = opaque;
+    V4L2m2mContext *s = buf_to_m2mctx(avbuf);
+
+    if (atomic_fetch_sub(&avbuf->context_refcount, 1) == 1) {
+        atomic_fetch_sub_explicit(&s->refcount, 1, memory_order_acq_rel);
+
+        if (s->reinit) {
+            if (!atomic_load(&s->refcount))
+                sem_post(&s->refsync);
+        } else {
+            if (s->draining && V4L2_TYPE_IS_OUTPUT(avbuf->context->type)) {
+                /* no need to queue more buffers to the driver */
+                avbuf->status = V4L2BUF_AVAILABLE;
+            }
+            else if (avbuf->context->streamon)
+                ff_v4l2_buffer_enqueue(avbuf);
+        }
+
+        av_buffer_unref(&avbuf->context_ref);
+    }
 }
 
 static int v4l2_buffer_export_drm(V4L2Buffer* avbuf)
@@ -382,6 +359,26 @@
     return 0;
 }
 
+static int v4l2_buf_increase_ref(V4L2Buffer *in)
+{
+    V4L2m2mContext *s = buf_to_m2mctx(in);
+
+    if (in->context_ref)
+        atomic_fetch_add(&in->context_refcount, 1);
+    else {
+        in->context_ref = av_buffer_ref(s->self_ref);
+        if (!in->context_ref)
+            return AVERROR(ENOMEM);
+
+        in->context_refcount = 1;
+    }
+
+    in->status = V4L2BUF_RET_USER;
+    atomic_fetch_add_explicit(&s->refcount, 1, memory_order_relaxed);
+
+    return 0;
+}
+
 static int v4l2_buf_to_bufref_drm(V4L2Buffer *in, AVBufferRef **buf)
 {
     int ret;
@@ -399,7 +396,6 @@
 
     return ret;
 }
-#endif
 
 static int v4l2_buf_to_bufref(V4L2Buffer *in, int plane, AVBufferRef **buf)
 {
@@ -408,7 +404,7 @@
     if (plane >= in->num_planes)
         return AVERROR(EINVAL);
 
-    /* most encoders return 0 in data_offset but vp8 does require this value */
+    /* even though most encoders return 0 in data_offset encoding vp8 does require this value */
     *buf = av_buffer_create((char *)in->plane_info[plane].mm_addr + in->planes[plane].data_offset,
                             in->plane_info[plane].length, v4l2_free_buffer, in, 0);
     if (!*buf)
@@ -560,21 +556,6 @@
 {
     v4l2_set_pts(out, frame->pts);
 
-    if (frame->format == AV_PIX_FMT_DRM_PRIME) {
-        AVDRMFrameDescriptor *drm_desc = (AVDRMFrameDescriptor *)frame->data[0];
-        int i;
-        av_assert0(out->buf.memory == V4L2_MEMORY_DMABUF);
-
-        if (V4L2_TYPE_IS_MULTIPLANAR(out->buf.type)) {
-            for (i = 0; i < drm_desc->nb_objects; i++) {
-                out->buf.m.planes[i].m.fd = drm_desc->objects[i].fd;
-            }
-        } else {
-            out->buf.m.fd = drm_desc->objects[0].fd;
-        }
-        return 0;
-    }
-
     return v4l2_buffer_swframe_to_buf(frame, out);
 }
 
@@ -585,16 +566,15 @@
     av_frame_unref(frame);
 
     /* 1. get references to the actual data */
-    if (avbuf->context->av_pix_fmt == AV_PIX_FMT_DRM_PRIME) {
-#if CONFIG_LIBDRM
+    if (buf_to_m2mctx(avbuf)->output_drm) {
+        /* 1. get references to the actual data */
         ret = v4l2_buf_to_bufref_drm(avbuf, &frame->buf[0]);
         if (ret)
             return ret;
 
-        frame->data[0] = (uint8_t *)v4l2_get_drm_frame(avbuf);
+        frame->data[0] = (uint8_t *) v4l2_get_drm_frame(avbuf);
         frame->format = AV_PIX_FMT_DRM_PRIME;
         frame->hw_frames_ctx = av_buffer_ref(avbuf->context->frames_ref);
-#endif
     } else {
         ret = v4l2_buffer_buf_to_swframe(frame, avbuf);
         if (ret)
@@ -671,11 +651,31 @@
     V4L2Context *ctx = avbuf->context;
     int ret, i;
 
-    avbuf->buf.memory = ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME && V4L2_TYPE_IS_OUTPUT(ctx->type) ?
-        V4L2_MEMORY_DMABUF : V4L2_MEMORY_MMAP;
+    avbuf->buf.memory = V4L2_MEMORY_MMAP;
     avbuf->buf.type = ctx->type;
     avbuf->buf.index = index;
 
+    if (buf_to_m2mctx(avbuf)->output_drm) {
+        AVHWFramesContext *hwframes;
+
+        av_buffer_unref(&ctx->frames_ref);
+
+        ctx->frames_ref = av_hwframe_ctx_alloc(buf_to_m2mctx(avbuf)->device_ref);
+        if (!ctx->frames_ref) {
+            ret = AVERROR(ENOMEM);
+            return ret;
+        }
+
+        hwframes = (AVHWFramesContext*)ctx->frames_ref->data;
+        hwframes->format = AV_PIX_FMT_DRM_PRIME;
+        hwframes->sw_format = ctx->av_pix_fmt;
+        hwframes->width = ctx->width;
+        hwframes->height = ctx->height;
+        ret = av_hwframe_ctx_init(ctx->frames_ref);
+        if (ret < 0)
+            return ret;
+    }
+
     if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {
         avbuf->buf.length = VIDEO_MAX_PLANES;
         avbuf->buf.m.planes = avbuf->planes;
@@ -704,21 +704,21 @@
         if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {
             avbuf->plane_info[i].length = avbuf->buf.m.planes[i].length;
 
-            if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME)
-                continue;
-
-            avbuf->plane_info[i].mm_addr = mmap(NULL, avbuf->buf.m.planes[i].length,
-                                           PROT_READ | PROT_WRITE, MAP_SHARED,
-                                           buf_to_m2mctx(avbuf)->fd, avbuf->buf.m.planes[i].m.mem_offset);
+            if ((V4L2_TYPE_IS_OUTPUT(ctx->type) && buf_to_m2mctx(avbuf)->output_drm) ||
+                !buf_to_m2mctx(avbuf)->output_drm) {
+                avbuf->plane_info[i].mm_addr = mmap(NULL, avbuf->buf.m.planes[i].length,
+                                               PROT_READ | PROT_WRITE, MAP_SHARED,
+                                               buf_to_m2mctx(avbuf)->fd, avbuf->buf.m.planes[i].m.mem_offset);
+            }
         } else {
             avbuf->plane_info[i].length = avbuf->buf.length;
 
-            if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME)
-                continue;
-
-            avbuf->plane_info[i].mm_addr = mmap(NULL, avbuf->buf.length,
-                                          PROT_READ | PROT_WRITE, MAP_SHARED,
-                                          buf_to_m2mctx(avbuf)->fd, avbuf->buf.m.offset);
+            if ((V4L2_TYPE_IS_OUTPUT(ctx->type) && buf_to_m2mctx(avbuf)->output_drm) ||
+                !buf_to_m2mctx(avbuf)->output_drm) {
+                avbuf->plane_info[i].mm_addr = mmap(NULL, avbuf->buf.length,
+                                              PROT_READ | PROT_WRITE, MAP_SHARED,
+                                              buf_to_m2mctx(avbuf)->fd, avbuf->buf.m.offset);
+            }
         }
 
         if (avbuf->plane_info[i].mm_addr == MAP_FAILED)
@@ -730,7 +730,6 @@
     if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {
         avbuf->buf.m.planes = avbuf->planes;
         avbuf->buf.length   = avbuf->num_planes;
-
     } else {
         avbuf->buf.bytesused = avbuf->planes[0].bytesused;
         avbuf->buf.length    = avbuf->planes[0].length;
@@ -739,12 +738,10 @@
     if (V4L2_TYPE_IS_OUTPUT(ctx->type))
         return 0;
 
-    if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME) {
-#if CONFIG_LIBDRM
+    if (buf_to_m2mctx(avbuf)->output_drm) {
         ret = v4l2_buffer_export_drm(avbuf);
         if (ret)
             return ret;
-#endif
     }
 
     return ff_v4l2_buffer_enqueue(avbuf);
diff -Naur mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_context.c mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_context.c
--- mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_context.c	2020-09-25 09:21:46.103333335 +0200
+++ mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_context.c	2020-09-25 09:21:48.156666668 +0200
@@ -29,7 +29,6 @@
 #include <poll.h>
 #include "libavcodec/avcodec.h"
 #include "libavcodec/internal.h"
-#include "libavutil/avassert.h"
 #include "v4l2_buffers.h"
 #include "v4l2_fmt.h"
 #include "v4l2_m2m.h"
@@ -127,12 +126,8 @@
 {
     ctx->format.type = ctx->type;
 
-    if (fmt->update_avfmt) {
-        if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME)
-            ctx->sw_pix_fmt = fmt->av_fmt;
-        else
-            ctx->av_pix_fmt = fmt->av_fmt;
-    }
+    if (fmt->update_avfmt)
+        ctx->av_pix_fmt = fmt->av_fmt;
 
     if (V4L2_TYPE_IS_MULTIPLANAR(ctx->type)) {
         /* update the sizes to handle the reconfiguration of the capture stream at runtime */
@@ -462,7 +457,7 @@
     struct v4l2_requestbuffers req = {
         .memory = V4L2_MEMORY_MMAP,
         .type = ctx->type,
-        .count = 0, /* 0 -> unmap all buffers from the driver */
+        .count = 0, /* 0 -> unmaps buffers from the driver */
     };
     int ret, i, j;
 
@@ -472,17 +467,23 @@
         for (j = 0; j < buffer->num_planes; j++) {
             struct V4L2Plane_info *p = &buffer->plane_info[j];
 
-            if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME && !V4L2_TYPE_IS_OUTPUT(ctx->type)) {
+            if (V4L2_TYPE_IS_OUTPUT(ctx->type)) {
+                /* output buffers are not EXPORTED */
+                goto unmap;
+            }
+
+            if (ctx_to_m2mctx(ctx)->output_drm) {
                 /* use the DRM frame to close */
                 if (buffer->drm_frame.objects[j].fd >= 0) {
                     if (close(buffer->drm_frame.objects[j].fd) < 0) {
-                        av_log(logger(ctx), AV_LOG_ERROR, "%s close drm fd [buffer=%2d, plane=%d, fd=%2d] - %s \n",
+                        av_log(logger(ctx), AV_LOG_ERROR, "%s close drm fd "
+                            "[buffer=%2d, plane=%d, fd=%2d] - %s \n",
                             ctx->name, i, j, buffer->drm_frame.objects[j].fd,
                             av_err2str(AVERROR(errno)));
                     }
                 }
             }
-
+unmap:
             if (p->mm_addr && p->length)
                 if (munmap(p->mm_addr, p->length) < 0)
                     av_log(logger(ctx), AV_LOG_ERROR, "%s unmap plane (%s))\n", ctx->name, av_err2str(AVERROR(errno)));
@@ -494,7 +495,7 @@
             av_log(logger(ctx), AV_LOG_ERROR, "release all %s buffers (%s)\n",
                 ctx->name, av_err2str(AVERROR(errno)));
 
-            if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME)
+            if (ctx_to_m2mctx(ctx)->output_drm)
                 av_log(logger(ctx), AV_LOG_ERROR,
                     "Make sure the DRM client releases all FB/GEM objects before closing the codec (ie):\n"
                     "for all buffers: \n"
@@ -538,8 +539,6 @@
     memset(&fdesc, 0, sizeof(fdesc));
     fdesc.type = ctx->type;
 
-    if (pixfmt == AV_PIX_FMT_DRM_PRIME)
-        pixfmt = ctx->sw_pix_fmt;
     if (pixfmt != AV_PIX_FMT_NONE) {
         ret = v4l2_try_raw_format(ctx, pixfmt);
         if (!ret)
@@ -741,7 +740,6 @@
 
 void ff_v4l2_context_release(V4L2Context* ctx)
 {
-    V4L2m2mContext *s = ctx_to_m2mctx(ctx);
     int ret;
 
     if (!ctx->buffers)
@@ -752,8 +750,6 @@
         av_log(logger(ctx), AV_LOG_WARNING, "V4L2 failed to unmap the %s buffers\n", ctx->name);
 
     av_freep(&ctx->buffers);
-    av_buffer_unref(&ctx->frames_ref);
-    av_buffer_unref(&s->device_ref);
 }
 
 int ff_v4l2_context_init(V4L2Context* ctx)
@@ -767,35 +763,13 @@
         return AVERROR_PATCHWELCOME;
     }
 
-    if (ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME) {
-        AVHWFramesContext *hwframes;
-
-        av_assert0(s->device_ref);
-        av_buffer_unref(&ctx->frames_ref);
-        ctx->frames_ref = av_hwframe_ctx_alloc(s->device_ref);
-        if (!ctx->frames_ref) {
-            ret = AVERROR(ENOMEM);
-            return ret;
-        }
-
-        hwframes = (AVHWFramesContext*)ctx->frames_ref->data;
-        hwframes->format = ctx->av_pix_fmt;
-        hwframes->sw_format = ctx->sw_pix_fmt;
-        hwframes->width = ctx->width;
-        hwframes->height = ctx->height;
-        ret = av_hwframe_ctx_init(ctx->frames_ref);
-        if (ret < 0)
-            return ret;
-    }
-
     ret = ioctl(s->fd, VIDIOC_G_FMT, &ctx->format);
     if (ret)
         av_log(logger(ctx), AV_LOG_ERROR, "%s VIDIOC_G_FMT failed\n", ctx->name);
 
     memset(&req, 0, sizeof(req));
     req.count = ctx->num_buffers;
-    req.memory = ctx->av_pix_fmt == AV_PIX_FMT_DRM_PRIME && V4L2_TYPE_IS_OUTPUT(ctx->type) ?
-        V4L2_MEMORY_DMABUF : V4L2_MEMORY_MMAP;
+    req.memory = V4L2_MEMORY_MMAP;
     req.type = ctx->type;
     ret = ioctl(s->fd, VIDIOC_REQBUFS, &req);
     if (ret < 0) {
@@ -819,10 +793,9 @@
         }
     }
 
-    av_log(logger(ctx), AV_LOG_DEBUG, "%s: %s %02d %s buffers initialized: %04ux%04u, sizeimage %08u, bytesperline %08u\n", ctx->name,
+    av_log(logger(ctx), AV_LOG_DEBUG, "%s: %s %02d buffers initialized: %04ux%04u, sizeimage %08u, bytesperline %08u\n", ctx->name,
         V4L2_TYPE_IS_MULTIPLANAR(ctx->type) ? av_fourcc2str(ctx->format.fmt.pix_mp.pixelformat) : av_fourcc2str(ctx->format.fmt.pix.pixelformat),
         req.count,
-        req.memory == V4L2_MEMORY_DMABUF ? "DMA" : "MMAP",
         v4l2_get_width(&ctx->format),
         v4l2_get_height(&ctx->format),
         V4L2_TYPE_IS_MULTIPLANAR(ctx->type) ? ctx->format.fmt.pix_mp.plane_fmt[0].sizeimage : ctx->format.fmt.pix.sizeimage,
diff -Naur mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_context.h mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_context.h
--- mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_context.h	2020-09-25 09:21:46.073333334 +0200
+++ mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_context.h	2020-09-25 09:21:48.156666668 +0200
@@ -51,7 +51,6 @@
      * AV_PIX_FMT_NONE means this is an encoded stream.
      */
     enum AVPixelFormat av_pix_fmt;
-    enum AVPixelFormat sw_pix_fmt;
 
     /**
      * AVCodecID corresponding to this buffer context.
diff -Naur mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.c mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.c
--- mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.c	2020-09-25 09:21:46.086666668 +0200
+++ mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.c	2020-09-25 09:21:48.156666668 +0200
@@ -149,15 +149,13 @@
 
     ofmt = s->output.format;
     cfmt = s->capture.format;
-    av_log(log_ctx, AV_LOG_INFO, "requesting formats: output=%s/%s capture=%s/%s\n",
+    av_log(log_ctx, AV_LOG_INFO, "requesting formats: output=%s capture=%s\n",
                                  av_fourcc2str(V4L2_TYPE_IS_MULTIPLANAR(ofmt.type) ?
                                                ofmt.fmt.pix_mp.pixelformat :
                                                ofmt.fmt.pix.pixelformat),
-                                 av_get_pix_fmt_name(s->output.av_pix_fmt) ?: "none",
                                  av_fourcc2str(V4L2_TYPE_IS_MULTIPLANAR(cfmt.type) ?
                                                cfmt.fmt.pix_mp.pixelformat :
-                                               cfmt.fmt.pix.pixelformat),
-                                 av_get_pix_fmt_name(s->capture.av_pix_fmt) ?: "none");
+                                               cfmt.fmt.pix.pixelformat));
 
     ret = ff_v4l2_context_set_format(&s->output);
     if (ret) {
@@ -308,9 +306,7 @@
         goto error;
     }
 
-    /* decoder's capture buffers are updated during v4l2_try_start once we find
-     * the valid format.
-     */
+    /* decoder's buffers need to be updated at a later stage */
     if (s->avctx && !av_codec_is_decoder(s->avctx->codec)) {
         ret = ff_v4l2_context_init(&s->capture);
         if (ret) {
diff -Naur mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_m2m_dec.c mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_m2m_dec.c
--- mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_m2m_dec.c	2020-09-25 09:21:46.070000001 +0200
+++ mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_m2m_dec.c	2020-09-25 09:21:48.156666668 +0200
@@ -31,8 +31,8 @@
 #include "libavutil/opt.h"
 #include "libavcodec/avcodec.h"
 #include "libavcodec/decode.h"
-#include "libavcodec/hwconfig.h"
 #include "libavcodec/internal.h"
+#include "libavcodec/hwconfig.h"
 
 #include "v4l2_context.h"
 #include "v4l2_m2m.h"
@@ -44,7 +44,7 @@
     V4L2Context *const capture = &s->capture;
     V4L2Context *const output = &s->output;
     struct v4l2_selection selection = { 0 };
-    int ret, pix_fmt;
+    int ret;
 
     /* 1. start the output process */
     if (!output->streamon) {
@@ -67,13 +67,8 @@
     }
 
     /* 2.1 update the AVCodecContext */
-    pix_fmt = ff_v4l2_format_v4l2_to_avfmt(capture->format.fmt.pix_mp.pixelformat, AV_CODEC_ID_RAWVIDEO);
-    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME)
-        avctx->pix_fmt = pix_fmt;
-    else
-        avctx->sw_pix_fmt = pix_fmt;;
+    avctx->pix_fmt = ff_v4l2_format_v4l2_to_avfmt(capture->format.fmt.pix_mp.pixelformat, AV_CODEC_ID_RAWVIDEO);
     capture->av_pix_fmt = avctx->pix_fmt;
-    capture->sw_pix_fmt = avctx->sw_pix_fmt;
 
     /* 3. set the crop parameters */
     selection.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
@@ -214,44 +209,43 @@
     output->av_codec_id = avctx->codec_id;
     output->av_pix_fmt  = AV_PIX_FMT_NONE;
 
-    /* negotiate drm vs software pixel formats */
-    avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
-    switch (avctx->pix_fmt) {
+    capture->av_codec_id = AV_CODEC_ID_RAWVIDEO;
+    capture->av_pix_fmt = avctx->pix_fmt;
+
+    /* the client requests the codec to generate DRM frames:
+     *   - data[0] will therefore point to the returned AVDRMFrameDescriptor
+     *       check the ff_v4l2_buffer_to_avframe conversion function.
+     *   - the DRM frame format is passed in the DRM frame descriptor layer.
+     *       check the v4l2_get_drm_frame function.
+     */
+    switch (ff_get_format(avctx, avctx->codec->pix_fmts)) {
     case AV_PIX_FMT_DRM_PRIME:
-        avctx->sw_pix_fmt = AV_PIX_FMT_NV12;
+        s->output_drm = 1;
         break;
-
     case AV_PIX_FMT_NONE:
         return 0;
         break;
-
     default:
         break;
     }
 
-    capture->av_codec_id = AV_CODEC_ID_RAWVIDEO;
-    capture->av_pix_fmt = avctx->pix_fmt;
-    capture->sw_pix_fmt = avctx->sw_pix_fmt;
-
-    if (avctx->hw_device_ctx) {
-        s->device_ref = av_buffer_ref(avctx->hw_device_ctx);
-    } else {
-        s->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
-        if (!s->device_ref)
-            return AVERROR(ENOMEM);
-
-        ret = av_hwdevice_ctx_init(s->device_ref);
-        if (ret < 0) {
-            av_buffer_unref(&s->device_ref);
-            return ret;
-        }
+    s->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
+    if (!s->device_ref) {
+        ret = AVERROR(ENOMEM);
+        return ret;
     }
 
     s->avctx = avctx;
+    ret = av_hwdevice_ctx_init(s->device_ref);
+    if (ret < 0)
+        return ret;
 
     ret = ff_v4l2_m2m_codec_init(priv);
     if (ret) {
         av_log(avctx, AV_LOG_ERROR, "can't configure decoder\n");
+        s->self_ref = NULL;
+        av_buffer_unref(&priv->context_ref);
+
         return ret;
     }
 
@@ -287,15 +281,7 @@
 };
 
 static const AVCodecHWConfigInternal *v4l2_m2m_hw_configs[] = {
-    &(const AVCodecHWConfigInternal) {
-        .public = {
-            .pix_fmt     = AV_PIX_FMT_DRM_PRIME,
-            .methods     = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX |
-                           AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
-            .device_type = AV_HWDEVICE_TYPE_DRM
-        },
-        .hwaccel = NULL,
-    },
+    HW_CONFIG_INTERNAL(DRM_PRIME),
     NULL
 };
 
diff -Naur mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.h mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.h
--- mythtv-master-20200924-gb00d7c3-old/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.h	2020-09-25 09:21:46.083333335 +0200
+++ mythtv-master-20200924-gb00d7c3-new/mythtv/external/FFmpeg/libavcodec/v4l2_m2m.h	2020-09-25 09:21:48.156666668 +0200
@@ -64,8 +64,10 @@
     /* reference back to V4L2m2mPriv */
     void *priv;
 
-    /* generate DRM frames */
     AVBufferRef *device_ref;
+
+    /* generate DRM frames */
+    int output_drm;
 } V4L2m2mContext;
 
 typedef struct V4L2m2mPriv {
