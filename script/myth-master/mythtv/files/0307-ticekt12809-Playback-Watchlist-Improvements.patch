From 709b83a9aee22d88501cfcf1d9a0b94aec11e652 Mon Sep 17 00:00:00 2001
From: Roger Siddons <rsiddons@mythtv.org>
Date: Fri, 29 Dec 2017 12:47:44 -0500
Subject: [PATCH 03/22] Playback: Watchlist Improvements

Watchlist: Refactor & remove debug info

The watchlist abuses ProgramInfo::recpriority2 to cache scores for display on the Info/ProgDetails screen.
The score/state is of no interest to the user, who cannot alter it. It is debug information that belongs in the logs and has been removed from the screens.
Themes should remove WATCH_LIST_SCORE & WATCH_LIST_STATUS widgets from htmls/progdetails*.html. However they are set as empty to prevent breakage for now.

Refs #12296

Watchlist: Group by title rather than record rule

Watchlist groups titles using the record rule id.
Thus different titles recorded by a one rule are confusingly grouped together.
And the same title recorded by different rules are shown in different groups.
Also a pre-requisite for selection by episode number.

Grouping ignores title case, whitespace and punctuation.

Ref #12296

Watchlist: Use season/episode when selecting an episode

Watchlist always selects the earliest/oldest episode, so the wrong recording is shown when episodes are recorded out of order.
This patch uses season/episode data to override the oldest selection, where appropriate.

Refs #12296

Watchlist: Add theme widget to show watchlist episode count

A new UI widget "watchtotal" enables the watchlist to show the number of episodes available for each title.
For example a "recordings" buttonlist specification of:

<textarea name="title">
  <template>%title%% (|watchtotal| episodes)%% - "|subtitle|"%</template>
</textarea>

will produce:

The Simpsons (15 episodes) - "Homer does something stupid"

This widget is only set when the Watchlist group is selected in the groups list - for other groups it will show the usual:

The Simpsons - "Homer does something stupid"

Refs #12296

Watchlist: Add 'Limited Oldest' strategy

Adds a new simplified sort strategy "LimitedOldest" that is more stable, intuitive & useful than the current 'Classic' one.
Titles are ordered by record date (oldest first) so the list is predictable and does not spontaneously shuffle.
Optionally new titles & quickly-watched titles can be promoted to the top and titles that remain unwatched for a long period can be relegated to the bottom.
Two new settings "PlaybackWLRecentLimit" & "PlaybackWLOldLimit" are introduced so the user can adjust this behaviour.

User can choose between this and the 'classic' sort strategy via a new setting "PlaybackWLOrder"

Fixes #12296

Watchlist: Update watchlist after metadata edits

Prevent metadata edits updating the recording list directly.
They must be processed by a ProgInfo update in order to update watchlist.

Watchlist: Place part-watched shows at top

Signed-off-by: Peter Bennett <pbennett@mythtv.org>
---
 mythtv/libs/libmyth/programtypes.h                 |   7 -
 mythtv/programs/mythfrontend/globalsettings.cpp    |  54 +-
 mythtv/programs/mythfrontend/globalsettings.h      |   1 -
 mythtv/programs/mythfrontend/playbackbox.cpp       | 785 ++++++++++++---------
 mythtv/programs/mythfrontend/playbackbox.h         |  74 +-
 mythtv/programs/mythfrontend/progdetails.cpp       |  32 +-
 mythtv/programs/mythfrontend/programinfocache.cpp  |  12 +
 mythtv/programs/mythfrontend/programinfocache.h    |   2 +
 .../MythCenter-wide/htmls/progdetails_page2.html   |   2 -
 mythtv/themes/MythCenter-wide/recordings-ui.xml    |   4 +-
 .../themes/MythCenter/htmls/progdetails_page2.html |   2 -
 mythtv/themes/MythCenter/recordings-ui.xml         |  14 +-
 mythtv/themes/Terra/htmls/progdetails_page2.html   |   2 -
 mythtv/themes/Terra/recordings-ui.xml              |   7 +
 mythtv/themes/default/htmls/progdetails_page2.html |   2 -
 15 files changed, 606 insertions(+), 394 deletions(-)

diff --git a/mythtv/libs/libmyth/programtypes.h b/mythtv/libs/libmyth/programtypes.h
index bcbb886..0e28ffb 100644
--- a/mythtv/libs/libmyth/programtypes.h
+++ b/mythtv/libs/libmyth/programtypes.h
@@ -222,13 +222,6 @@ typedef enum AvailableStatusTypes {
 } AvailableStatusType; // note stored in uint8_t in ProgramInfo
 MPUBLIC QString toString(AvailableStatusType);
 
-enum WatchListStatus {
-    wlDeleted = -4,
-    wlEarlier = -3,
-    wlWatched = -2,
-    wlExpireOff = -1
-};
-
 typedef enum AutoExpireTypes {
     kDisableAutoExpire = 0,
     kNormalAutoExpire  = 1,
diff --git a/mythtv/programs/mythfrontend/globalsettings.cpp b/mythtv/programs/mythfrontend/globalsettings.cpp
index b262af9..d44a217 100644
--- a/mythtv/programs/mythfrontend/globalsettings.cpp
+++ b/mythtv/programs/mythfrontend/globalsettings.cpp
@@ -3214,13 +3214,28 @@ static HostCheckBoxSetting *PlaybackWatchList()
     gc->setValue(true);
 
     gc->setHelpText(WatchListSettings::tr("The 'Watch List' is an abbreviated "
-                                          "list of recordings sorted to "
+                                          "list of recordings filtered to "
                                           "highlight series and shows that "
                                           "need attention in order to keep up "
                                           "to date."));
     return gc;
 }
 
+static HostComboBoxSetting *PlaybackWLStrategy()
+{
+    HostComboBoxSetting *gc = new HostComboBoxSetting("PlaybackWLOrder");
+
+    gc->setLabel(WatchListSettings::tr("Sort method"));
+    gc->addSelection(WatchListSettings::tr("Classic", "Watchlist"), "Classic");
+    gc->addSelection(WatchListSettings::tr(
+                         "Limited Oldest", "Watchlist"), "LimitedOldest");
+    gc->setHelpText(WatchListSettings::tr("The watchlist ordering method. "
+                         "'Classic' learns your viewing habits. "
+                         "'Limited Oldest' simply lists shows by age, but "
+                         "promotes new/popular titles and demotes old ones."));
+    return gc;
+}
+
 static HostCheckBoxSetting *PlaybackWLStart()
 {
     HostCheckBoxSetting *gc = new HostCheckBoxSetting("PlaybackWLStart");
@@ -3253,6 +3268,7 @@ static HostCheckBoxSetting *PlaybackWLAutoExpire()
     return gc;
 }
 
+
 static HostSpinBoxSetting *PlaybackWLMaxAge()
 {
     HostSpinBoxSetting *gs = new HostSpinBoxSetting("PlaybackWLMaxAge", 30, 180, 10);
@@ -3288,6 +3304,39 @@ static HostSpinBoxSetting *PlaybackWLBlackOut()
     return gs;
 }
 
+static HostSpinBoxSetting *PlaybackWLRecentLimit()
+{
+    HostSpinBoxSetting *gs = new HostSpinBoxSetting("PlaybackWLRecentLimit", 0, 168, 6, true);
+
+    gs->setLabel(WatchListSettings::tr("Hours to keep at top"));
+
+    gs->setValue(6);
+
+    gs->setHelpText(WatchListSettings::tr(
+                        "Titles are promoted to the top when they are younger "
+                        "than, or previous episodes have been watched "
+                        "(on average) within, this interval. "
+                        "0 disables this behaviour."));
+    return gs;
+}
+
+static HostSpinBoxSetting *PlaybackWLOldLimit()
+{
+    HostSpinBoxSetting *gs = new HostSpinBoxSetting("PlaybackWLOldLimit", 7, 3650, 7, true);
+
+    gs->setLabel(WatchListSettings::tr("Days before relegating to bottom"));
+
+    gs->setValue(28);
+
+    gs->setHelpText(WatchListSettings::tr(
+                        "Titles are relegated to the bottom when they "
+                        "are older than, and previous episodes have not "
+                        "been watched (on average), within this interval. "
+                        "Use a high value to prevent this behaviour."));
+
+    return gs;
+}
+
 static HostCheckBoxSetting *EnableMediaMon()
 {
     HostCheckBoxSetting *gc = new HostCheckBoxSetting("MonitorDrives");
@@ -4029,10 +4078,13 @@ void PlaybackSettings::Load(void)
     pbox->addChild(DisplayGroupTitleSort());
 
     StandardSetting *playbackWatchList = PlaybackWatchList();
+    playbackWatchList->addTargetedChild("1", PlaybackWLStrategy());
     playbackWatchList->addTargetedChild("1", PlaybackWLStart());
     playbackWatchList->addTargetedChild("1", PlaybackWLAutoExpire());
     playbackWatchList->addTargetedChild("1", PlaybackWLMaxAge());
     playbackWatchList->addTargetedChild("1", PlaybackWLBlackOut());
+    playbackWatchList->addTargetedChild("1", PlaybackWLRecentLimit());
+    playbackWatchList->addTargetedChild("1", PlaybackWLOldLimit());
     pbox->addChild(playbackWatchList);
     addChild(pbox);
 
diff --git a/mythtv/programs/mythfrontend/globalsettings.h b/mythtv/programs/mythfrontend/globalsettings.h
index 9e6b7df..ebc9a4b 100644
--- a/mythtv/programs/mythfrontend/globalsettings.h
+++ b/mythtv/programs/mythfrontend/globalsettings.h
@@ -62,7 +62,6 @@ class LcdSettings
     Q_DECLARE_TR_FUNCTIONS(LcdSettings)
 };
 
-
 class WatchListSettings
 {
     Q_DECLARE_TR_FUNCTIONS(WatchListSettings)
diff --git a/mythtv/programs/mythfrontend/playbackbox.cpp b/mythtv/programs/mythfrontend/playbackbox.cpp
index c98bff2..8150904 100644
--- a/mythtv/programs/mythfrontend/playbackbox.cpp
+++ b/mythtv/programs/mythfrontend/playbackbox.cpp
@@ -101,16 +101,6 @@ static int comp_originalAirDate_rev(const ProgramInfo *a, const ProgramInfo *b)
         return (dt1 > dt2 ? 1 : -1);
 }
 
-static int comp_recpriority2(const ProgramInfo *a, const ProgramInfo *b)
-{
-    if (a->GetRecordingPriority2() == b->GetRecordingPriority2())
-        return (a->GetRecordingStartTime() <
-                b->GetRecordingStartTime() ? 1 : -1);
-    else
-        return (a->GetRecordingPriority2() <
-                b->GetRecordingPriority2() ? 1 : -1);
-}
-
 static int comp_recordDate(const ProgramInfo *a, const ProgramInfo *b)
 {
     if (a->GetScheduledStartTime().date() == b->GetScheduledStartTime().date())
@@ -179,12 +169,6 @@ static bool comp_originalAirDate_rev_less_than(
     return comp_originalAirDate_rev(a, b) < 0;
 }
 
-static bool comp_recpriority2_less_than(
-    const ProgramInfo *a, const ProgramInfo *b)
-{
-    return comp_recpriority2(a, b) < 0;
-}
-
 static bool comp_recordDate_less_than(
     const ProgramInfo *a, const ProgramInfo *b)
 {
@@ -408,8 +392,6 @@ PlaybackBox::PlaybackBox(MythScreenStack *parent, QString name,
       m_titleView(false),
       m_useCategories(false),
       m_useRecGroups(false),
-      m_watchListAutoExpire(false),
-      m_watchListMaxAge(60),              m_watchListBlackOut(2),
       m_listOrder(1),
       // Recording Group settings
       m_groupDisplayName(ProgramInfo::i18n("All Programs")),
@@ -452,11 +434,7 @@ PlaybackBox::PlaybackBox(MythScreenStack *parent, QString name,
     int pbOrder        = gCoreContext->GetNumSetting("PlayBoxOrdering", 1);
     // Split out sort order modes, wacky order for backward compatibility
     m_listOrder = (pbOrder >> 1) ^ (m_allOrder = pbOrder & 1);
-    m_watchListStart     = gCoreContext->GetNumSetting("PlaybackWLStart", 0);
-
-    m_watchListAutoExpire= gCoreContext->GetNumSetting("PlaybackWLAutoExpire", 0);
-    m_watchListMaxAge    = gCoreContext->GetNumSetting("PlaybackWLMaxAge", 60);
-    m_watchListBlackOut  = gCoreContext->GetNumSetting("PlaybackWLBlackOut", 2);
+    m_watchListStart  = gCoreContext->GetNumSetting("PlaybackWLStart", 0);
 
     bool displayCat  = gCoreContext->GetNumSetting("DisplayRecGroupIsCategory", 0);
 
@@ -961,6 +939,11 @@ void PlaybackBox::ItemLoaded(MythUIButtonListItem *item)
         item->SetFontState(state);
 
         InfoMap infoMap;
+
+        // watchlist episode count only set when watchlist group is selected
+        if (groupname == m_watchGroupLabel)
+            infoMap["watchtotal"] = m_watchlist.GetTotal(*pginfo);
+
         pginfo->ToMap(infoMap);
         item->SetTextFromMap(infoMap);
 
@@ -1634,6 +1617,7 @@ bool PlaybackBox::UpdateUILists(void)
     m_progsInDB = 0;
     m_titleList.clear();
     m_progLists.clear();
+    m_watchlist.Clear();
     m_recordingList->Reset();
     m_groupList->Reset();
     if (m_recgroupList)
@@ -1648,7 +1632,6 @@ bool PlaybackBox::UpdateUILists(void)
 
     QMap<QString, QString> sortedList;
     QMap<int, QString> searchRule;
-    QMap<int, int> recidEpisodes;
 
     m_programInfoCache.Refresh();
 
@@ -1802,37 +1785,7 @@ bool PlaybackBox::UpdateUILists(void)
             if ((m_viewMask & VIEW_WATCHLIST) &&
                 !isLiveTVProg && pRecgroup != "Deleted")
             {
-                if (m_watchListAutoExpire && !p->IsAutoExpirable())
-                {
-                    p->SetRecordingPriority2(wlExpireOff);
-                    LOG(VB_FILE, LOG_INFO, QString("Auto-expire off:  %1")
-                        .arg(p->GetTitle()));
-                }
-                else if (p->IsWatched())
-                {
-                    p->SetRecordingPriority2(wlWatched);
-                    LOG(VB_FILE, LOG_INFO,
-                        QString("Marked as 'watched':  %1")
-                        .arg(p->GetTitle()));
-                }
-                else
-                {
-                    if (p->GetRecordingRuleID())
-                        recidEpisodes[p->GetRecordingRuleID()] += 1;
-                    if (recidEpisodes[p->GetRecordingRuleID()] == 1 ||
-                            !p->GetRecordingRuleID())
-                    {
-                        m_progLists[m_watchGroupLabel].push_front(p);
-                        m_progLists[m_watchGroupLabel].setAutoDelete(false);
-                    }
-                    else
-                    {
-                        p->SetRecordingPriority2(wlEarlier);
-                        LOG(VB_FILE, LOG_INFO,
-                            QString("Not the earliest:  %1")
-                            .arg(p->GetTitle()));
-                    }
-                }
+                m_watchlist.Add(p);
             }
         }
     }
@@ -1907,244 +1860,13 @@ bool PlaybackBox::UpdateUILists(void)
         }
     }
 
-    if (!m_progLists[m_watchGroupLabel].empty())
+    if (!m_watchlist.Empty())
     {
-        QDateTime now = MythDate::current();
-        int baseValue = m_watchListMaxAge * 2 / 3;
-
-        QMap<int, int> recType;
-        QMap<int, int> maxEpisodes;
-        QMap<int, int> avgDelay;
-        QMap<int, int> spanHours;
-        QMap<int, int> delHours;
-        QMap<int, int> nextHours;
-
-        MSqlQuery query(MSqlQuery::InitCon());
-        query.prepare("SELECT recordid, type, maxepisodes, avg_delay, "
-                      "next_record, last_record, last_delete FROM record;");
-
-        if (query.exec())
-        {
-            while (query.next())
-            {
-                int recid = query.value(0).toInt();
-                recType[recid] = query.value(1).toInt();
-                maxEpisodes[recid] = query.value(2).toInt();
-                avgDelay[recid] = query.value(3).toInt();
-
-                QDateTime next_record =
-                    MythDate::as_utc(query.value(4).toDateTime());
-                QDateTime last_record =
-                    MythDate::as_utc(query.value(5).toDateTime());
-                QDateTime last_delete =
-                    MythDate::as_utc(query.value(6).toDateTime());
-
-                // Time between the last and next recordings
-                spanHours[recid] = 1000;
-                if (last_record.isValid() && next_record.isValid())
-                    spanHours[recid] =
-                        last_record.secsTo(next_record) / 3600 + 1;
-
-                // Time since the last episode was deleted
-                delHours[recid] = 1000;
-                if (last_delete.isValid())
-                    delHours[recid] = last_delete.secsTo(now) / 3600 + 1;
-
-                // Time until the next recording if any
-                if (next_record.isValid())
-                    nextHours[recid] = now.secsTo(next_record) / 3600 + 1;
-            }
-        }
-
-        ProgramList::iterator pit = m_progLists[m_watchGroupLabel].begin();
-        while (pit != m_progLists[m_watchGroupLabel].end())
-        {
-            int recid = (*pit)->GetRecordingRuleID();
-            int avgd =  avgDelay[recid];
-
-            if (avgd == 0)
-                avgd = 100;
-
-            // Set the intervals beyond range if there is no record entry
-            if (spanHours[recid] == 0)
-            {
-                spanHours[recid] = 1000;
-                delHours[recid] = 1000;
-            }
-
-            // add point equal to baseValue for each additional episode
-            if (!(*pit)->GetRecordingRuleID() || maxEpisodes[recid] > 0)
-                (*pit)->SetRecordingPriority2(0);
-            else
-            {
-                (*pit)->SetRecordingPriority2(
-                    (recidEpisodes[(*pit)->GetRecordingRuleID()] - 1) *
-                    baseValue);
-            }
-
-            // add points every 3hr leading up to the next recording
-            if (nextHours[recid] > 0 && nextHours[recid] < baseValue * 3)
-            {
-                (*pit)->SetRecordingPriority2(
-                    (*pit)->GetRecordingPriority2() +
-                    (baseValue * 3 - nextHours[recid]) / 3);
-            }
-
-            int hrs = (*pit)->GetScheduledEndTime().secsTo(now) / 3600;
-            if (hrs < 1)
-                hrs = 1;
-
-            // add points for a new recording that decrease each hour
-            if (hrs < 42)
-            {
-                (*pit)->SetRecordingPriority2(
-                    (*pit)->GetRecordingPriority2() + 42 - hrs);
-            }
-
-            // add points for how close the recorded time of day is to 'now'
-            (*pit)->SetRecordingPriority2(
-                (*pit)->GetRecordingPriority2() + abs((hrs % 24) - 12) * 2);
-
-            // Daily
-            if (spanHours[recid] < 50 ||
-                recType[recid] == kDailyRecord)
-            {
-                if (delHours[recid] < m_watchListBlackOut * 4)
-                {
-                    (*pit)->SetRecordingPriority2(wlDeleted);
-                    LOG(VB_FILE, LOG_INFO,
-                        QString("Recently deleted daily:  %1")
-                            .arg((*pit)->GetTitle()));
-                    pit = m_progLists[m_watchGroupLabel].erase(pit);
-                    continue;
-                }
-                else
-                {
-                    LOG(VB_FILE, LOG_INFO, QString("Daily interval:  %1")
-                            .arg((*pit)->GetTitle()));
-
-                    if (maxEpisodes[recid] > 0)
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            (baseValue / 2) + (hrs / 24));
-                    }
-                    else
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            (baseValue / 5) + hrs);
-                    }
-                }
-            }
-            // Weekly
-            else if (nextHours[recid] ||
-                     recType[recid] == kWeeklyRecord)
-
-            {
-                if (delHours[recid] < (m_watchListBlackOut * 24) - 4)
-                {
-                    (*pit)->SetRecordingPriority2(wlDeleted);
-                    LOG(VB_FILE, LOG_INFO,
-                        QString("Recently deleted weekly:  %1")
-                            .arg((*pit)->GetTitle()));
-                    pit = m_progLists[m_watchGroupLabel].erase(pit);
-                    continue;
-                }
-                else
-                {
-                    LOG(VB_FILE, LOG_INFO, QString("Weekly interval: %1")
-                            .arg((*pit)->GetTitle()));
-
-                    if (maxEpisodes[recid] > 0)
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            (baseValue / 2) + (hrs / 24));
-                    }
-                    else
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            (baseValue / 3) + (baseValue * hrs / 24 / 4));
-                    }
-                }
-            }
-            // Not recurring
-            else
-            {
-                if (delHours[recid] < (m_watchListBlackOut * 48) - 4)
-                {
-                    (*pit)->SetRecordingPriority2(wlDeleted);
-                    pit = m_progLists[m_watchGroupLabel].erase(pit);
-                    continue;
-                }
-                else
-                {
-                    // add points for a new Single or final episode
-                    if (hrs < 36)
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            baseValue * (36 - hrs) / 36);
-                    }
-
-                    if (avgd != 100)
-                    {
-                        if (maxEpisodes[recid] > 0)
-                        {
-                            (*pit)->SetRecordingPriority2(
-                                (*pit)->GetRecordingPriority2() +
-                                (baseValue / 2) + (hrs / 24));
-                        }
-                        else
-                        {
-                            (*pit)->SetRecordingPriority2(
-                                (*pit)->GetRecordingPriority2() +
-                                (baseValue / 3) + (baseValue * hrs / 24 / 4));
-                        }
-                    }
-                    else if ((hrs / 24) < m_watchListMaxAge)
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            hrs / 24);
-                    }
-                    else
-                    {
-                        (*pit)->SetRecordingPriority2(
-                            (*pit)->GetRecordingPriority2() +
-                            m_watchListMaxAge);
-                    }
-                }
-            }
-
-            // Factor based on the average time shift delay.
-            // Scale the avgd range of 0 thru 200 hours to 133% thru 67%
-            int delaypct = avgd / 3 + 67;
-
-            if (avgd < 100)
-            {
-                (*pit)->SetRecordingPriority2(
-                    (*pit)->GetRecordingPriority2() * (200 - delaypct) / 100);
-            }
-            else if (avgd > 100)
-            {
-                (*pit)->SetRecordingPriority2(
-                    (*pit)->GetRecordingPriority2() * 100 / delaypct);
-            }
-
-            LOG(VB_FILE, LOG_INFO, QString(" %1  %2  %3")
-                    .arg(MythDate::toString((*pit)->GetScheduledStartTime(),
-                                            MythDate::kDateShort))
-                    .arg((*pit)->GetRecordingPriority2())
-                    .arg((*pit)->GetTitle()));
+        // Shows with same score will appear in reverse alphabetic order
+        foreach (ProgramInfo* wp, m_watchlist.Order())
+            m_progLists[m_watchGroupLabel].push_front(wp);
 
-            ++pit;
-        }
-        std::stable_sort(m_progLists[m_watchGroupLabel].begin(),
-                         m_progLists[m_watchGroupLabel].end(),
-                         comp_recpriority2_less_than);
+        m_progLists[m_watchGroupLabel].setAutoDelete(false);
     }
 
     m_titleList = QStringList("");
@@ -4457,8 +4179,9 @@ void PlaybackBox::HandleRecordingAddEvent(const ProgramInfo &evinfo)
 
 void PlaybackBox::HandleUpdateItemEvent(uint recordingId, uint flags)
 {
-    // Changing recording group full reload
-    if (flags & PIC_RECGROUP_CHANGED)
+    // Changing recording group or watchlist-dependent metadata requires full reload
+    if ((flags & PIC_RECGROUP_CHANGED) ||
+            ((flags & PIC_WATCHLIST_CHANGED) && (m_viewMask & VIEW_WATCHLIST)))
     {
         ScheduleUpdateUIList();
     }
@@ -4905,47 +4628,12 @@ void PlaybackBox::saveRecMetadata(const QString &newTitle,
     {
         m_recordingList->RemoveItem(item);
     }
-    else
-    {
-        QString tempSubTitle = newTitle;
-        if (!newSubtitle.trimmed().isEmpty())
-            tempSubTitle = QString("%1 - \"%2\"")
-                            .arg(tempSubTitle).arg(newSubtitle);
-
-        QString seasone;
-        QString seasonx;
-        QString season;
-        QString episode;
-        if (newSeason > 0 || newEpisode > 0)
-        {
-            season = format_season_and_episode(newSeason, 1);
-            episode = format_season_and_episode(newEpisode, 1);
-            seasone = QString("s%1e%2")
-                .arg(format_season_and_episode(newSeason, 2))
-                .arg(format_season_and_episode(newEpisode, 2));
-            seasonx = QString("%1x%2")
-                .arg(format_season_and_episode(newSeason, 1))
-                .arg(format_season_and_episode(newEpisode, 2));
-        }
-
-        item->SetText(tempSubTitle, "titlesubtitle");
-        item->SetText(newTitle, "title");
-        item->SetText(newSubtitle, "subtitle");
-        item->SetText(newInetref, "inetref");
-        item->SetText(seasonx, "00x00");
-        item->SetText(seasone, "s00e00");
-        item->SetText(season, "season");
-        item->SetText(episode, "episode");
-        if (newDescription != NULL)
-            item->SetText(newDescription, "description");
-    }
 
     pginfo->SaveInetRef(newInetref);
     pginfo->SaveSeasonEpisode(newSeason, newEpisode);
 
     RecordingInfo ri(*pginfo);
     ri.ApplyRecordRecTitleChange(newTitle, newSubtitle, newDescription);
-    *pginfo = ri;
 }
 
 void PlaybackBox::setRecGroup(QString newRecGroup)
@@ -4999,10 +4687,8 @@ void PlaybackBox::setRecGroup(QString newRecGroup)
 
             RecordingInfo ri(*p);
             ri.ApplyRecordRecGroupChange(newRecGroup);
-            *p = ri;
         }
         doClearPlaylist();
-        UpdateUILists();
         return;
     }
 
@@ -5017,8 +4703,6 @@ void PlaybackBox::setRecGroup(QString newRecGroup)
 
     RecordingInfo ri(*p);
     ri.ApplyRecordRecGroupChange(newRecGroup);
-    *p = ri;
-    UpdateUILists();
 }
 
 void PlaybackBox::setPlayGroup(QString newPlayGroup)
@@ -5042,7 +4726,6 @@ void PlaybackBox::setPlayGroup(QString newPlayGroup)
             {
                 RecordingInfo ri(*tmpItem);
                 ri.ApplyRecordPlayGroupChange(newPlayGroup);
-                *tmpItem = ri;
             }
         }
         doClearPlaylist();
@@ -5051,7 +4734,6 @@ void PlaybackBox::setPlayGroup(QString newPlayGroup)
     {
         RecordingInfo ri(*tmpItem);
         ri.ApplyRecordPlayGroupChange(newPlayGroup);
-        *tmpItem = ri;
     }
 }
 
@@ -5650,4 +5332,439 @@ bool PlaybackBox::PbbJobQueue::IsJobQueuedOrRunning(int jobType, uint chanid,
         IsJobRunning(jobType, chanid, recstartts);
 }
 
+////////////////////////////////////////////////////////
+
+ProgramInfo* WatchGroup::GetFirst() const
+{
+    // Use earliest episode of the 3 variants
+    ProgramInfo* earliest = m_season;
+
+    if (m_episode && (!earliest || m_episode->GetScheduledStartTime()
+                      < earliest->GetScheduledStartTime()))
+        earliest = m_episode;
+
+    if (m_date && (!earliest || m_date->GetScheduledStartTime()
+                   < earliest->GetScheduledStartTime()))
+        earliest = m_date;
+
+    return earliest;
+}
+
+/*!
+ * \brief Insert episode into watchlist
+ * \param current Current earliest episode of a variant
+ * \param p Episode being added
+ */
+void WatchGroup::Add(ProgramInfo* &current, ProgramInfo* p)
+{
+    ++m_count;
+
+    uint      ps(p->GetSeason());
+    uint      pe(p->GetEpisode());
+    QDateTime pt(p->GetScheduledStartTime());
+
+    if (!current)
+    {
+        // first episode with this title
+        current = p;
+
+        LOG(VB_GUI, LOG_DEBUG,
+            QString("Watchlist: New      - %1 %2 (%3x%4)")
+            .arg(MythDate::toString(pt, Qt::ISODate))
+            .arg(p->GetTitle()).arg(ps).arg(pe));
+        return;
+    }
+
+    // duplicate title
+    uint      cs(current->GetSeason());
+    uint      ce(current->GetEpisode());
+    QDateTime ct(current->GetScheduledStartTime());
+
+    // succeed earliest if;
+    // - earlier season, or
+    // - same season, both with episodes and earlier episode, or
+    // - same season, at least one episode undefined and earlier recording
+    if (ps < cs
+            || (ps == cs
+                && ((pe > 0 && ce > 0 && pe < ce)
+                    || ((pe == 0 || ce == 0) && pt < ct))))
+    {
+        // replace existing episode
+        current = p;
+
+        LOG(VB_GUI, LOG_DEBUG,
+            QString("Watchlist: Replace  - %1 %2 (%3x%4) "
+                    "succeeding %5 (%6x%7)")
+            .arg(MythDate::toString(pt, Qt::ISODate))
+            .arg(p->GetTitle())
+            .arg(ps).arg(pe)
+            .arg(MythDate::toString(ct, Qt::ISODate))
+            .arg(cs).arg(ce));
+    }
+    else
+        LOG(VB_GUI, LOG_DEBUG,
+            QString("Watchlist: Earlier  - %1 %2 (%3x%4)")
+            .arg(MythDate::toString(pt, Qt::ISODate))
+            .arg(p->GetTitle())
+            .arg(ps).arg(pe));
+}
+
+WatchList::WatchList()
+    : m_list(),
+      m_watchListAutoExpire(gCoreContext->GetNumSetting("PlaybackWLAutoExpire", 0)),
+      m_watchListMaxAge(gCoreContext->GetNumSetting("PlaybackWLMaxAge", 60)),
+      m_watchListBlackOut(gCoreContext->GetNumSetting("PlaybackWLBlackOut", 2)),
+      m_watchListRecentLimit(gCoreContext->GetNumSetting("PlaybackWLRecentLimit", 2)),
+      m_watchListOldLimit(gCoreContext->GetNumSetting("PlaybackWLOldLimit", 30)),
+      m_watchListStrategy(gCoreContext->GetSetting("PlaybackWLOrder", "Classic"))
+{}
+
+// Group titles ignore case, punctuation & whitespace
+QString WatchList::GroupOf(const ProgramInfo &pginfo)
+{
+    QRegExp chaff("\\W");
+    return pginfo.GetTitle().remove(chaff).toLower();
+}
+
+/// Add episode to watchlist
+void WatchList::Add(ProgramInfo *p)
+{
+    if (!p)
+        return;
+
+    if (p->IsWatched())
+    {
+        // Ignore watched
+        LOG(VB_GUI, LOG_DEBUG,
+            QString("Watchlist: Watched  - %1 %2 (%3x%4)")
+            .arg(MythDate::toString(p->GetScheduledStartTime(), Qt::ISODate))
+            .arg(p->GetTitle())
+            .arg(p->GetSeason())
+            .arg(p->GetEpisode()));
+    }
+    else if (m_watchListAutoExpire && !p->IsAutoExpirable())
+    {
+        LOG(VB_GUI, LOG_DEBUG,
+            QString("Watchlist: No expire - %1 %2 (%3x%4)")
+            .arg(MythDate::toString(p->GetScheduledStartTime(),
+                                    Qt::ISODate))
+            .arg(p->GetTitle())
+            .arg(p->GetSeason())
+            .arg(p->GetEpisode()));
+    }
+    else
+    {
+        // Create group if it doesn't exist
+        WatchGroup &group = m_list[GroupOf(*p)];
+
+        // Process according to variant
+        if (p->GetSeason() > 0)
+            group.AddSeason(p);
+        else if (p->GetEpisode() > 0)
+            group.AddEpisode(p);
+        else
+            group.AddDate(p);
+    }
+}
+
+/// Return sorted watchlist
+WatchList::ProgramOrder WatchList::Order()
+{
+     if (m_watchListStrategy == "Classic")
+         return OrderByClassicStrategy();
+
+     if (m_watchListStrategy == "LimitedOldest")
+         return OrderByOldestStrategy();
+
+     return ProgramOrder();
+}
+
+/// Sort programs by original Watchlist rules
+WatchList::ProgramOrder WatchList::OrderByClassicStrategy()
+{
+    QDateTime now = MythDate::current();
+    int baseValue = m_watchListMaxAge * 2 / 3;
+
+    QMap<int, int> recType;
+    QMap<int, int> maxEpisodes;
+    QMap<int, int> avgDelay;
+    QMap<int, int> spanHours;
+    QMap<int, int> delHours;
+    QMap<int, int> nextHours;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT recordid, type, maxepisodes, avg_delay, "
+                  "next_record, last_record, last_delete FROM record;");
+
+    if (query.exec())
+    {
+        while (query.next())
+        {
+            int recid = query.value(0).toInt();
+            recType[recid] = query.value(1).toInt();
+            maxEpisodes[recid] = query.value(2).toInt();
+            avgDelay[recid] = query.value(3).toInt();
+
+            QDateTime next_record =
+                    MythDate::as_utc(query.value(4).toDateTime());
+            QDateTime last_record =
+                    MythDate::as_utc(query.value(5).toDateTime());
+            QDateTime last_delete =
+                    MythDate::as_utc(query.value(6).toDateTime());
+
+            // Time between the last and next recordings
+            spanHours[recid] = 1000;
+            if (last_record.isValid() && next_record.isValid())
+                spanHours[recid] =
+                        last_record.secsTo(next_record) / 3600 + 1;
+
+            // Time since the last episode was deleted
+            delHours[recid] = 1000;
+            if (last_delete.isValid())
+                delHours[recid] = last_delete.secsTo(now) / 3600 + 1;
+
+            // Time until the next recording if any
+            if (next_record.isValid())
+                nextHours[recid] = now.secsTo(next_record) / 3600 + 1;
+        }
+    }
+
+    ProgramOrder ordered;
+    foreach (const WatchGroup &group, m_list)
+    {
+        ProgramInfo* p = group.GetFirst();
+        uint score = 0;
+        int recid = p->GetRecordingRuleID();
+        int avgd =  avgDelay[recid];
+
+        if (avgd == 0)
+            avgd = 100;
+
+        // Set the intervals beyond range if there is no record entry
+        if (spanHours[recid] == 0)
+        {
+            spanHours[recid] = 1000;
+            delHours[recid] = 1000;
+        }
+
+        // add point equal to baseValue for each additional episode
+        if (recid && maxEpisodes[recid] == 0)
+            score += (group.GetCount() - 1) * baseValue;
+
+        // add points every 3hr leading up to the next recording
+        if (nextHours[recid] > 0 && nextHours[recid] < baseValue * 3)
+            score += (baseValue * 3 - nextHours[recid]) / 3;
+
+        int hrs = p->GetScheduledEndTime().secsTo(now) / 3600;
+        if (hrs < 1)
+            hrs = 1;
+
+        // add points for a new recording that decrease each hour
+        if (hrs < 42)
+            score += 42 - hrs;
+
+        // add points for how close the recorded time of day is to 'now'
+        score += abs((hrs % 24) - 12) * 2;
+
+        // Daily
+        if (spanHours[recid] < 50 ||
+                recType[recid] == kDailyRecord)
+        {
+            if (delHours[recid] < m_watchListBlackOut * 4)
+            {
+                LOG(VB_GUI, LOG_DEBUG,
+                    QString("Watchlist: Recently deleted daily:  %1")
+                    .arg(p->GetTitle()));
+
+                continue;
+            }
+            else
+            {
+                LOG(VB_GUI, LOG_DEBUG, QString("Watchlist: Daily interval:  %1")
+                    .arg(p->GetTitle()));
+
+                if (maxEpisodes[recid] > 0)
+                    score += (baseValue / 2) + (hrs / 24);
+                else
+                    score += (baseValue / 5) + hrs;
+            }
+        }
+        // Weekly
+        else if (nextHours[recid] ||
+                 recType[recid] == kWeeklyRecord)
+
+        {
+            if (delHours[recid] < (m_watchListBlackOut * 24) - 4)
+            {
+                LOG(VB_GUI, LOG_DEBUG,
+                    QString("Watchlist: Recently deleted weekly:  %1")
+                    .arg(p->GetTitle()));
+
+                continue;
+            }
+            else
+            {
+                LOG(VB_GUI, LOG_DEBUG, QString("Watchlist: Weekly interval: %1")
+                    .arg(p->GetTitle()));
+
+                if (maxEpisodes[recid] > 0)
+                    score += (baseValue / 2) + (hrs / 24);
+                else
+                    score += (baseValue / 3) + (baseValue * hrs / 24 / 4);
+            }
+        }
+        // Not recurring
+        else
+        {
+            if (delHours[recid] < (m_watchListBlackOut * 48) - 4)
+            {
+                continue;
+            }
+            else
+            {
+                // add points for a new Single or final episode
+                if (hrs < 36)
+                    score += baseValue * (36 - hrs) / 36;
+
+                if (avgd != 100)
+                {
+                    if (maxEpisodes[recid] > 0)
+                        score += (baseValue / 2) + (hrs / 24);
+                    else
+                        score += (baseValue / 3) + (baseValue * hrs / 24 / 4);
+                }
+                else if ((hrs / 24) < m_watchListMaxAge)
+                    score += hrs / 24;
+                else
+                    score += m_watchListMaxAge;
+            }
+        }
+
+        // Factor based on the average time shift delay.
+        // Scale the avgd range of 0 thru 200 hours to 133% thru 67%
+        int delaypct = avgd / 3 + 67;
+
+        if (avgd < 100)
+            score = score * (200 - delaypct) / 100;
+        else if (avgd > 100)
+            score = score * 100 / delaypct;
+
+        // use score as primary key in top 32 bits,
+        // use age in secs as a secondary key in low 32 bits to ensure equal
+        // scores are ordered oldest first. Copes with progs up to 136 yrs old
+        score_type longScore = (static_cast<score_type>(score) << 32)
+                | p->GetScheduledStartTime().secsTo(now);
+
+        ordered.insert(longScore, p);
+
+        LOG(VB_GUI, LOG_DEBUG, QString("Watchlist:%1 %2 %3 %4")
+            .arg(score, 5)
+            .arg(longScore, 12)
+            .arg(p->GetTitle())
+            .arg(MythDate::toString(p->GetScheduledStartTime(),
+                                    MythDate::kDateShort)));
+    }
+    return ordered;
+}
+
+/// Sort programs oldest first, with new at top and relegating oldest
+WatchList::ProgramOrder WatchList::OrderByOldestStrategy()
+{
+    QDateTime now = MythDate::current();
+
+    QMap<int, int> avgDelay;
+    QMap<int, QDateTime> lastDelete;
+
+    MSqlQuery query(MSqlQuery::InitCon());
+    query.prepare("SELECT recordid, avg_delay, last_delete FROM record;");
+
+    if (query.exec())
+    {
+        while (query.next())
+        {
+            int recid = query.value(0).toInt();
+            avgDelay[recid] = query.value(1).toInt();
+            lastDelete[recid] = query.value(2).toDateTime();
+        }
+    }
+
+    ProgramOrder ordered;
+    foreach (const WatchGroup &group, m_list)
+    {
+        ProgramInfo* p = group.GetFirst();
+
+        int recid = p->GetRecordingRuleID();
+        bool knownRule = avgDelay.contains(recid);
+
+        // use priority as primary key in top 32 bits:
+        // 0 = bottom, 1 = middle, 2 = top
+        // use age in secs as a secondary key in low 32 bits to ensure equal
+        // scores are ordered oldest first. Copes with progs up to 136 yrs old
+        score_type score = p->GetScheduledStartTime().secsTo(now);
+
+        // put new shows or those from rules that are watched quickly, at the top
+        int ageInHours = p->GetScheduledEndTime().secsTo(now) / 3600;
+        if (ageInHours <= m_watchListRecentLimit
+                || (knownRule && avgDelay[recid] <= m_watchListRecentLimit))
+        {
+            score |= 0x0200000000;
+
+            LOG(VB_GUI, LOG_DEBUG,
+                QString("Watchlist: Top   :%1 - '%2' was recorded %3 hrs "
+                        "ago & being watched after %4 hrs")
+                .arg(score, 11)
+                .arg(p->GetTitle())
+                .arg(ageInHours)
+                .arg(avgDelay[recid]));
+        }
+        // put part-watched shows at top
+        else if (p->GetProgressPercent() > 0)
+        {
+            score |= 0x0200000000;
+
+            LOG(VB_GUI, LOG_DEBUG,
+                QString("Watchlist: Top   :%1 - '%2' is %3% watched")
+                .arg(score, 11)
+                .arg(p->GetTitle())
+                .arg(p->GetProgressPercent()));
+        }
+        // shows go to middle if not yet old enough
+        else if (ageInHours / 24 <= m_watchListOldLimit)
+        {
+            score |= 0x0100000000;
+
+            LOG(VB_GUI, LOG_DEBUG,
+                QString("Watchlist: Middle:%1 - '%2' was recorded %3 hrs ago")
+                .arg(score, 11)
+                .arg(p->GetTitle())
+                .arg(ageInHours));
+        }
+        // or a previous episode for the rule was deleted recently
+        else if (knownRule)
+        {
+            QDateTime deleted = MythDate::as_utc(lastDelete[recid]);
+            if (deleted.isValid()
+                    && deleted.secsTo(now) / 3600 / 24 <= m_watchListOldLimit)
+            {
+                score |= 0x0100000000;
+
+                LOG(VB_GUI, LOG_DEBUG,
+                    QString("Watchlist: Middle:%1 - '%2' was watched %3 days ago")
+                    .arg(score, 11)
+                    .arg(p->GetTitle())
+                    .arg(deleted.secsTo(now) / 3600 / 24));
+            }
+        }
+        else
+            LOG(VB_GUI, LOG_DEBUG,
+                QString("Watchlist: Bottom:%1 - '%2' is %3 hrs old")
+                .arg(score, 11)
+                .arg(p->GetTitle())
+                .arg(ageInHours));
+
+        ordered.insert(score, p);
+    }
+    return ordered;
+}
+
 /* vim: set expandtab tabstop=4 shiftwidth=4: */
diff --git a/mythtv/programs/mythfrontend/playbackbox.h b/mythtv/programs/mythfrontend/playbackbox.h
index 280a516..b01d13a 100644
--- a/mythtv/programs/mythfrontend/playbackbox.h
+++ b/mythtv/programs/mythfrontend/playbackbox.h
@@ -57,6 +57,69 @@ enum {
     kArtworkCoverTimeout  = 50,
 };
 
+class WatchGroup
+{
+public:
+    WatchGroup() : m_count(0), m_season(NULL), m_episode(NULL), m_date(NULL) {}
+
+    ProgramInfo* GetFirst() const;
+    uint    GetCount() const { return m_count; }
+    QString GetTotal() const { return m_count > 1 ? QString::number(m_count) : ""; }
+
+    void AddSeason(ProgramInfo *pginfo)  { Add(m_season,  pginfo); }
+    void AddEpisode(ProgramInfo *pginfo) { Add(m_episode, pginfo); }
+    void AddDate(ProgramInfo *pginfo)    { Add(m_date,    pginfo); }
+
+private:
+    void Add(ProgramInfo *&current, ProgramInfo *pginfo);
+
+    /// Number of episodes with this title
+    uint m_count;
+    /// Oldest episode with a season defined
+    ProgramInfo *m_season;
+    /// Oldest episode with only an episode defined
+    ProgramInfo *m_episode;
+    /// Oldest episode with no season or season defined
+    ProgramInfo *m_date;
+};
+
+class WatchList
+{
+public:
+    static QString GroupOf(const ProgramInfo &pginfo);
+
+    WatchList();
+
+    void Clear()       { m_list.clear(); }
+    bool Empty() const { return m_list.empty(); }
+    QString GetTotal(const ProgramInfo &pginfo) const
+    { return m_list[GroupOf(pginfo)].GetTotal(); }
+    void Add(ProgramInfo *p);
+
+    typedef unsigned long long score_type; // 64 bit
+    // shows keyed by score
+    typedef QMultiMap<score_type, ProgramInfo*> ProgramOrder;
+    ProgramOrder Order();
+
+private:
+    QMap<QString, WatchGroup> m_list;
+    /// exclude recording not marked for auto-expire from the Watch List
+    bool    m_watchListAutoExpire;
+    /// add 1 to the Watch List score up to this many days
+    int     m_watchListMaxAge;
+    /// adjust exclusion of a title from the Watch List after a delete
+    int     m_watchListBlackOut;
+    /// recordings younger than this (hrs) go to the top
+    int     m_watchListRecentLimit;
+    /// recordings older than this got to the bottom
+    int     m_watchListOldLimit;
+    /// strategy for ordering the watchlist
+    QString m_watchListStrategy;
+
+    ProgramOrder OrderByClassicStrategy();
+    ProgramOrder OrderByOldestStrategy();
+};
+
 class PlaybackBox : public ScheduleCommon
 {
     Q_OBJECT
@@ -364,12 +427,6 @@ class PlaybackBox : public ScheduleCommon
     bool                m_useRecGroups;
     /// use the Watch List as the initial view
     bool                m_watchListStart;
-    /// exclude recording not marked for auto-expire from the Watch List
-    bool                m_watchListAutoExpire;
-    /// add 1 to the Watch List scord up to this many days
-    int                 m_watchListMaxAge;
-    /// adjust exclusion of a title from the Watch List after a delete
-    int                 m_watchListBlackOut;
     /// allOrder controls the ordering of the "All Programs" list
     int                 m_allOrder;
     /// listOrder controls the ordering of the recordings in the list
@@ -384,6 +441,9 @@ class PlaybackBox : public ScheduleCommon
     QString             m_watchGroupLabel;
     ViewMask            m_viewMask;
 
+    // Watchlist support
+    WatchList            m_watchlist;
+
     // Popup support //////////////////////////////////////////////////////////
     // General popup support
     MythDialogBox      *m_menuDialog;
@@ -412,7 +472,7 @@ class PlaybackBox : public ScheduleCommon
     /// Recording[s] currently selected for deletion
     QStringList m_delList;
     /// Group currently selected
-    QString m_currentGroup;
+    QString m_currentGroup; // in lower case
 
     // Play List support
     QList<uint>         m_playList;   ///< list of selected items "play list"
diff --git a/mythtv/programs/mythfrontend/progdetails.cpp b/mythtv/programs/mythfrontend/progdetails.cpp
index 6540cd3..31a5be9 100644
--- a/mythtv/programs/mythfrontend/progdetails.cpp
+++ b/mythtv/programs/mythfrontend/progdetails.cpp
@@ -722,8 +722,6 @@ void ProgDetails::loadPage(void)
     QString lastRecorded;
     QString nextRecording;
     QString averageTimeShift;
-    QString watchListScore;
-    QString watchListStatus;
     QString searchPhrase;
 
     if (m_progInfo.GetRecordingRuleID())
@@ -752,31 +750,6 @@ void ProgDetails::loadPage(void)
                 averageTimeShift = tr("%n hour(s)", "",
                                                 query.value(2).toInt());
         }
-        if (recorded)
-        {
-            if (m_progInfo.GetRecordingPriority2() > 0)
-                watchListScore =
-                    QString::number(m_progInfo.GetRecordingPriority2());
-
-            if (m_progInfo.GetRecordingPriority2() < 0)
-            {
-                switch (m_progInfo.GetRecordingPriority2())
-                {
-                    case wlExpireOff:
-                        watchListStatus = tr("Auto-expire off");
-                        break;
-                    case wlWatched:
-                        watchListStatus = tr("Marked as 'watched'");
-                        break;
-                    case wlEarlier:
-                        watchListStatus = tr("Not the earliest episode");
-                        break;
-                    case wlDeleted:
-                        watchListStatus = tr("Recently deleted episode");
-                        break;
-                }
-            }
-        }
         if (record->m_searchType != kManualSearch &&
             record->m_description != m_progInfo.GetDescription())
             searchPhrase = record->m_description;
@@ -798,8 +771,9 @@ void ProgDetails::loadPage(void)
     addItem(tr("Last Recorded"), lastRecorded, ProgInfoList::kLevel2);
     addItem(tr("Next Recording"), nextRecording, ProgInfoList::kLevel2);
     addItem(tr("Average Time Shift"), averageTimeShift, ProgInfoList::kLevel2);
-    addItem(tr("Watch List Score"), watchListScore, ProgInfoList::kLevel2);
-    addItem(tr("Watch List Status"), watchListStatus, ProgInfoList::kLevel2);
+    // Blank removed labels until all themes have removed it
+    //addItem(tr("Watch List Score"), watchListScore, ProgInfoList::kLevel2);
+    //addItem(tr("Watch List Status"), watchListStatus, ProgInfoList::kLevel2);
 
     QString recordingHost;
     QString recordingInput;
diff --git a/mythtv/programs/mythfrontend/programinfocache.cpp b/mythtv/programs/mythfrontend/programinfocache.cpp
index 5a8c59f..f217f09 100644
--- a/mythtv/programs/mythfrontend/programinfocache.cpp
+++ b/mythtv/programs/mythfrontend/programinfocache.cpp
@@ -248,6 +248,14 @@ uint32_t ProgramInfoCache::Update(const ProgramInfo& pginfo)
     if (pginfo.GetRecordingGroup() != pg.GetRecordingGroup())
         flags |= PIC_RECGROUP_CHANGED;
 
+    if (pginfo.GetSeason() != pg.GetSeason()
+            || pginfo.GetEpisode() != pg.GetEpisode()
+            || pginfo.GetTitle() != pg.GetTitle())
+        flags |= PIC_WATCHLIST_CHANGED;
+
+    if (pg.GetProgressPercent() > 0)
+        flags |= PIC_PART_WATCHED;
+
     pg.clone(pginfo, true);
     pg.SetAllowLastPlayPos(true);
 
@@ -295,6 +303,10 @@ void ProgramInfoCache::UpdateFileSize(uint recordingId, uint64_t filesize,
         QString byWhom;
         if (pg.QueryIsInUse(byWhom) && byWhom.contains(QObject::tr("Playing")))
             flags &= ~PIC_MARK_CHANGED;
+
+        // Changing to or from part-watched may affect watchlist
+        if ((pg.GetProgressPercent() == 0) != !(flags & PIC_PART_WATCHED))
+            flags |= PIC_WATCHLIST_CHANGED;
     }
 
     QString mesg = QString("UPDATE_UI_ITEM %1 %2").arg(recordingId).arg(flags);
diff --git a/mythtv/programs/mythfrontend/programinfocache.h b/mythtv/programs/mythfrontend/programinfocache.h
index 4c8d5a4..4dbde6c 100644
--- a/mythtv/programs/mythfrontend/programinfocache.h
+++ b/mythtv/programs/mythfrontend/programinfocache.h
@@ -24,6 +24,8 @@ typedef enum {
     PIC_NONE              = 0x00,
     PIC_MARK_CHANGED      = 0x01,
     PIC_RECGROUP_CHANGED  = 0x02,
+    PIC_PART_WATCHED      = 0X04,
+    PIC_WATCHLIST_CHANGED = 0x08,
     PIC_NO_ACTION         = 0x80,
 } UpdateState;
 
diff --git a/mythtv/themes/MythCenter-wide/htmls/progdetails_page2.html b/mythtv/themes/MythCenter-wide/htmls/progdetails_page2.html
index e35b5fc..98567da 100644
--- a/mythtv/themes/MythCenter-wide/htmls/progdetails_page2.html
+++ b/mythtv/themes/MythCenter-wide/htmls/progdetails_page2.html
@@ -32,8 +32,6 @@
     <h1>%LAST_RECORDED_LABEL%</h1> <p>%LAST_RECORDED%</p>
     <h1>%NEXT_RECORDING_LABEL%</h1> <p>%NEXT_RECORDING%</p>
     <h1>%AVERAGE_TIME_SHIFT_LABEL%</h1> <p>%AVERAGE_TIME_SHIFT%</p>
-    <h1>%WATCH_LIST_SCORE_LABEL%</h1> <p>%WATCH_LIST_SCORE%</p>
-    <h1>%WATCH_LIST_STATUS_LABEL%</h1> <p>%WATCH_LIST_STATUS%</p>
     <h1>%SEARCH_PHRASE_LABEL%</h1> <p>%SEARCH_PHRASE%</p>
     <h1>%FINDID_LABEL%</h1> <p>%FINDID%</p>
     <h1>%RECORDING_HOST_LABEL%</h1> <p>%RECORDING_HOST%</p>
diff --git a/mythtv/themes/MythCenter-wide/recordings-ui.xml b/mythtv/themes/MythCenter-wide/recordings-ui.xml
index 569e204..0abbb29 100644
--- a/mythtv/themes/MythCenter-wide/recordings-ui.xml
+++ b/mythtv/themes/MythCenter-wide/recordings-ui.xml
@@ -222,7 +222,7 @@
                     <textarea name="titlesubtitle" from="buttontext">
                         <area>32,2,656,28</area>
                         <align>vcenter</align>
-                        <template>%titlesubtitle%% (|progresspercent|%)%</template>
+                        <template>%title%% (|watchtotal|)%% - "|subtitle|"%</template>
                     </textarea>
                     <textarea name="shortstartdate" from="buttontext">
                         <area>634,2,120,28</area>
@@ -271,7 +271,7 @@
                     </textarea>
                     <textarea name="titlesubtitle" from="fonts">
                         <area>32,2,656,28</area>
-                        <template>%titlesubtitle%% (|progresspercent|%)%</template>
+                        <template>%title%% (|watchtotal|)%% - "|subtitle|"%</template>
                     </textarea>
                     <textarea name="shortstartdate" from="fonts">
                         <area>634,2,120,28</area>
diff --git a/mythtv/themes/MythCenter/htmls/progdetails_page2.html b/mythtv/themes/MythCenter/htmls/progdetails_page2.html
index 2fa3ea3..af6199d 100644
--- a/mythtv/themes/MythCenter/htmls/progdetails_page2.html
+++ b/mythtv/themes/MythCenter/htmls/progdetails_page2.html
@@ -34,8 +34,6 @@
     <h1>%LAST_RECORDED_LABEL%</h1> <p>%LAST_RECORDED%</p>
     <h1>%NEXT_RECORDING_LABEL%</h1> <p>%NEXT_RECORDING%</p>
     <h1>%AVERAGE_TIME_SHIFT_LABEL%</h1> <p>%AVERAGE_TIME_SHIFT%</p>
-    <h1>%WATCH_LIST_SCORE_LABEL%</h1> <p>%WATCH_LIST_SCORE%</p>
-    <h1>%WATCH_LIST_STATUS_LABEL%</h1> <p>%WATCH_LIST_STATUS%</p>
     <h1>%SEARCH_PHRASE_LABEL%</h1> <p>%SEARCH_PHRASE%</p>
     <h1>%FINDID_LABEL%</h1> <p>%FINDID%</p>
     <h1>%RECORDING_HOST_LABEL%</h1> <p>%RECORDING_HOST%</p>
diff --git a/mythtv/themes/MythCenter/recordings-ui.xml b/mythtv/themes/MythCenter/recordings-ui.xml
index 5500fd7..3c6e418 100644
--- a/mythtv/themes/MythCenter/recordings-ui.xml
+++ b/mythtv/themes/MythCenter/recordings-ui.xml
@@ -212,8 +212,9 @@
                     <textarea name="titlesubtitle" from="buttontext">
                         <area>32,0,336,30</area>
                         <align>vcenter</align>
+                        <template>%title%% (|watchtotal|)%% - "|subtitle|"%</template>
                     </textarea>
-                    <textarea name="shortstartdate" from="titlesubtitle">
+                    <textarea name="shortstartdate" from="buttontext">
                         <area>295,0,130,30</area>
                         <align>right,vcenter</align>
                     </textarea>
@@ -249,21 +250,24 @@
                     <shape name="selectbar">
                         <area>0,0,100%,30</area>
                     </shape>
-                    <textarea name="titlesubtitle" from="buttontext">
-                        <area>32,0,336,30</area>
+                    <textarea name="fonts" from="buttontext">
                         <font>basesmall_normal_selected</font>
                         <font state="disabled">basesmall_disabled_selected</font>
                         <font state="error">basesmall_error_selected</font>
                         <font state="warning">basesmall_warning_selected</font>
                         <font state="normal">basesmall_normal_selected</font>
                         <font state="running">basesmall_running_selected</font>
+                    </textarea>
+                    <textarea name="titlesubtitle" from="fonts">
+                        <area>32,0,336,30</area>
                         <align>vcenter</align>
+                        <template>%title%% (|watchtotal|)%% - "|subtitle|"%</template>
                     </textarea>
-                    <textarea name="shortstartdate" from="titlesubtitle">
+                    <textarea name="shortstartdate" from="fonts">
                         <area>295,0,130,30</area>
                         <align>right,vcenter</align>
                     </textarea>
-                    <textarea name="starttime" from="shortstartdate">
+                    <textarea name="starttime" from="fonts">
                         <area>415,0,114,30</area>
                         <align>right,vcenter</align>
                     </textarea>
diff --git a/mythtv/themes/Terra/htmls/progdetails_page2.html b/mythtv/themes/Terra/htmls/progdetails_page2.html
index a1426d6..02963cd 100644
--- a/mythtv/themes/Terra/htmls/progdetails_page2.html
+++ b/mythtv/themes/Terra/htmls/progdetails_page2.html
@@ -36,8 +36,6 @@
     <h1>%LAST_RECORDED_LABEL%</h1> <p>%LAST_RECORDED%</p>
     <h1>%NEXT_RECORDING_LABEL%</h1> <p>%NEXT_RECORDING%</p>
     <h1>%AVERAGE_TIME_SHIFT_LABEL%</h1> <p>%AVERAGE_TIME_SHIFT%</p>
-    <h1>%WATCH_LIST_SCORE_LABEL%</h1> <p>%WATCH_LIST_SCORE%</p>
-    <h1>%WATCH_LIST_STATUS_LABEL%</h1> <p>%WATCH_LIST_STATUS%</p>
     <h1>%SEARCH_PHRASE_LABEL%</h1> <p>%SEARCH_PHRASE%</p>
     <h1>%FINDID_LABEL%</h1> <p>%FINDID%</p>
     <h1>%RECORDING_HOST_LABEL%</h1> <p>%RECORDING_HOST%</p>
diff --git a/mythtv/themes/Terra/recordings-ui.xml b/mythtv/themes/Terra/recordings-ui.xml
index 195ae08..9f160d8 100644
--- a/mythtv/themes/Terra/recordings-ui.xml
+++ b/mythtv/themes/Terra/recordings-ui.xml
@@ -134,6 +134,10 @@
                             </imagetype>
                         </state>
                     </statetype>
+                    <textarea name="watchtotal" from="basetextarea">
+                        <area>130,121,120,25</area>
+                        <align>right</align>
+                    </textarea>
                     <textarea name="title" from="basetextarea">
                         <area>8,148,240,60</area>
                         <font>basemedium</font>
@@ -166,6 +170,9 @@
                     <statetype name="status">
                         <position>236,124</position>
                     </statetype>
+                    <textarea name="watchtotal">
+                        <area>158,144,120,25</area>
+                    </textarea>
                     <textarea name="title">
                         <area>8,169,272,73</area>
                         <font>baselarge</font>
diff --git a/mythtv/themes/default/htmls/progdetails_page2.html b/mythtv/themes/default/htmls/progdetails_page2.html
index 40fb94b..4a17980 100644
--- a/mythtv/themes/default/htmls/progdetails_page2.html
+++ b/mythtv/themes/default/htmls/progdetails_page2.html
@@ -33,8 +33,6 @@
     <h1>%LAST_RECORDED_LABEL%</h1> <p>%LAST_RECORDED%</p>
     <h1>%NEXT_RECORDING_LABEL%</h1> <p>%NEXT_RECORDING%</p>
     <h1>%AVERAGE_TIME_SHIFT_LABEL%</h1> <p>%AVERAGE_TIME_SHIFT%</p>
-    <h1>%WATCH_LIST_SCORE_LABEL%</h1> <p>%WATCH_LIST_SCORE%</p>
-    <h1>%WATCH_LIST_STATUS_LABEL%</h1> <p>%WATCH_LIST_STATUS%</p>
     <h1>%SEARCH_PHRASE_LABEL%</h1> <p>%SEARCH_PHRASE%</p>
     <h1>%FINDID_LABEL%</h1> <p>%FINDID%</p>
     <h1>%RECORDING_HOST_LABEL%</h1> <p>%RECORDING_HOST%</p>
-- 
2.7.1

