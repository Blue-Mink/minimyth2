From abc9725b8e670ec72c464a10a7080cce4ae49ade Mon Sep 17 00:00:00 2001
From: David Hampton <mythtv@love2code.net>
Date: Fri, 24 Dec 2021 16:09:39 -0500
Subject: [PATCH] Seperate the concepts of last play position and bookmarks.

The last play position is now always recorded on program exit (if
playback has been going for at least 30 sec).  The bookmark is now
solely set and cleared by the user. By default, playback now starts from:

  1) last played position, if present
  2) bookmark, if present
  3) program start mark, if present (recordings only)
  4) beginning of file

This is based on Roger Siddons work from 2015. See
https://code.mythtv.org/trac/ticket/12809 for the full details.
---
 mythtv/bindings/perl/MythTV.pm                |   2 +-
 mythtv/bindings/python/MythTV/static.py       |   2 +-
 mythtv/libs/libmyth/programinfo.cpp           | 110 +++++++++++++++---
 mythtv/libs/libmyth/programinfo.h             |   5 +
 mythtv/libs/libmyth/programtypeflags.h        |   1 +
 mythtv/libs/libmythbase/mythversion.h         |   2 +-
 mythtv/libs/libmythtv/dbcheck.cpp             |  11 ++
 mythtv/libs/libmythtv/mythplayer.cpp          |  10 +-
 mythtv/libs/libmythtv/mythplayer.h            |   1 -
 mythtv/libs/libmythtv/mythplayerui.cpp        |  13 ++-
 mythtv/libs/libmythtv/mythplayerui.h          |   1 +
 mythtv/libs/libmythtv/tv_play.cpp             |  89 ++++----------
 mythtv/libs/libmythtv/tv_play.h               |   4 +-
 mythtv/libs/libmythtv/tvplaybackstate.h       |   1 +
 .../programs/mythfrontend/globalsettings.cpp  |  24 +---
 mythtv/programs/mythfrontend/main.cpp         |  95 +++++++++------
 mythtv/programs/mythfrontend/playbackbox.cpp  |  48 ++++----
 mythtv/programs/mythfrontend/playbackbox.h    |   5 +-
 18 files changed, 237 insertions(+), 187 deletions(-)

diff --git a/mythtv/bindings/perl/MythTV.pm b/mythtv/bindings/perl/MythTV.pm
index 2e62ee5eb9d..051159578a8 100644
--- a/mythtv/bindings/perl/MythTV.pm
+++ b/mythtv/bindings/perl/MythTV.pm
@@ -116,7 +116,7 @@ package MythTV;
 # schema version supported in the main code.  We need to check that the schema
 # version in the database is as expected by the bindings, which are expected
 # to be kept in sync with the main code.
-    our $SCHEMA_VERSION = "1372";
+    our $SCHEMA_VERSION = "1373";
 
 # NUMPROGRAMLINES is defined in mythtv/libs/libmythtv/programinfo.h and is
 # the number of items in a ProgramInfo QStringList group used by
diff --git a/mythtv/bindings/python/MythTV/static.py b/mythtv/bindings/python/MythTV/static.py
index 815ab20e768..208f1fb008b 100644
--- a/mythtv/bindings/python/MythTV/static.py
+++ b/mythtv/bindings/python/MythTV/static.py
@@ -5,7 +5,7 @@
 """
 
 OWN_VERSION = (32,0,-1,0)
-SCHEMA_VERSION = 1372
+SCHEMA_VERSION = 1373
 NVSCHEMA_VERSION = 1007
 MUSICSCHEMA_VERSION = 1025
 PROTO_VERSION = '91'
diff --git a/mythtv/libs/libmyth/programinfo.cpp b/mythtv/libs/libmyth/programinfo.cpp
index 4446da35901..abef88cf110 100644
--- a/mythtv/libs/libmyth/programinfo.cpp
+++ b/mythtv/libs/libmyth/programinfo.cpp
@@ -70,7 +70,7 @@ const QString ProgramInfo::kFromRecordedQuery =
     "       p.syndicatedepisodenumber, p.partnumber, p.parttotal,  "//48-50
     "       p.season,           p.episode,      p.totalepisodes,   "//51-53
     "       p.category_type,    r.recordedid,   r.inputname,       "//54-56
-    "       r.bookmarkupdate                                       "//57-57
+    "       r.bookmarkupdate,   r.lastplay                         "//57-58
     "FROM recorded AS r "
     "LEFT JOIN channel AS c "
     "ON (r.chanid    = c.chanid) "
@@ -2138,6 +2138,7 @@ bool ProgramInfo::LoadProgramFromRecorded(
     set_flag(m_programFlags, FL_REALLYEDITING, query.value(39).toBool());
     set_flag(m_programFlags, FL_BOOKMARK,      query.value(40).toBool());
     set_flag(m_programFlags, FL_WATCHED,       query.value(41).toBool());
+    set_flag(m_programFlags, FL_LASTPLAYPOS,   query.value(58).toBool());
     set_flag(m_programFlags, FL_EDITING,
              ((m_programFlags & FL_REALLYEDITING) != 0U) ||
              ((m_programFlags & FL_COMMPROCESSING) != 0U));
@@ -2684,6 +2685,12 @@ void ProgramInfo::SaveBookmark(uint64_t frame)
 
     set_flag(m_programFlags, FL_BOOKMARK, is_valid);
 
+    UpdateMarkTimeStamp(is_valid);
+    SendUpdateEvent();
+}
+
+void ProgramInfo::UpdateMarkTimeStamp(bool bookmarked) const
+{
     if (IsRecording())
     {
         MSqlQuery query(MSqlQuery::InitCon());
@@ -2691,17 +2698,54 @@ void ProgramInfo::SaveBookmark(uint64_t frame)
             "UPDATE recorded "
             "SET bookmarkupdate = CURRENT_TIMESTAMP, "
             "    bookmark       = :BOOKMARKFLAG "
-            "WHERE chanid    = :CHANID AND "
-            "      starttime = :STARTTIME");
+            "WHERE recordedid = :RECORDEDID");
 
-        query.bindValue(":BOOKMARKFLAG", is_valid);
-        query.bindValue(":CHANID",       m_chanId);
-        query.bindValue(":STARTTIME",    m_recStartTs);
+        query.bindValue(":BOOKMARKFLAG", bookmarked);
+        query.bindValue(":RECORDEDID",   m_recordedId);
 
         if (!query.exec())
             MythDB::DBError("bookmark flag update", query);
+    }
+}
 
-        SendUpdateEvent();
+void ProgramInfo::SaveLastPlayPos(uint64_t frame)
+{
+    ClearMarkupMap(MARK_UTIL_LASTPLAYPOS);
+
+    bool isValid = frame > 0;
+    if (isValid)
+    {
+        frm_dir_map_t lastPlayPosMap;
+        lastPlayPosMap[frame] = MARK_UTIL_LASTPLAYPOS;
+        SaveMarkupMap(lastPlayPosMap, MARK_UTIL_LASTPLAYPOS);
+    }
+
+    set_flag(m_programFlags, FL_LASTPLAYPOS, isValid);
+
+    UpdateLastPlayTimeStamp(isValid);
+    SendUpdateEvent();
+}
+
+// This function overloads the 'bookmarkupdate' field to force the UI
+// to update when the last play timestamp is updated. The alternative
+// is adding another field to the database and to the programinfo
+// serialization.
+void ProgramInfo::UpdateLastPlayTimeStamp(bool hasLastPlay) const
+{
+    if (IsRecording())
+    {
+        MSqlQuery query(MSqlQuery::InitCon());
+        query.prepare(
+            "UPDATE recorded "
+            "SET bookmarkupdate = CURRENT_TIMESTAMP, "
+            "    lastplay       = :LASTPLAYFLAG "
+            "WHERE recordedid = :RECORDEDID");
+
+        query.bindValue(":LASTPLAYFLAG", hasLastPlay);
+        query.bindValue(":RECORDEDID",   m_recordedId);
+
+        if (!query.exec())
+            MythDB::DBError("lastplay flag update", query);
     }
 }
 
@@ -2771,40 +2815,67 @@ uint64_t ProgramInfo::QueryBookmark(uint chanid, const QDateTime &recstartts)
     return (bookmarkmap.isEmpty()) ? 0 : bookmarkmap.begin().key();
 }
 
-/** \brief Gets any progstart position in database,
- *         unless the ignore progstart flag is set.
+/** \brief Gets any lastplaypos position in database,
+ *         unless the ignore lastplaypos flag is set.
  *
- *  \return Progstart position in frames if the query is executed
+ *  \return LastPlayPos position in frames if the query is executed
  *          and succeeds, zero otherwise.
  */
-uint64_t ProgramInfo::QueryProgStart(void) const
+uint64_t ProgramInfo::QueryLastPlayPos() const
 {
-    if (m_programFlags & FL_IGNOREPROGSTART)
+    if (m_programFlags & FL_IGNORELASTPLAYPOS)
         return 0;
 
     frm_dir_map_t bookmarkmap;
-    QueryMarkupMap(bookmarkmap, MARK_UTIL_PROGSTART);
+    QueryMarkupMap(bookmarkmap, MARK_UTIL_LASTPLAYPOS);
 
     return (bookmarkmap.isEmpty()) ? 0 : bookmarkmap.begin().key();
 }
 
-/** \brief Gets any lastplaypos position in database,
- *         unless the ignore lastplaypos flag is set.
+/** \brief Gets any progstart position in database,
+ *         unless the ignore progstart flag is set.
  *
- *  \return LastPlayPos position in frames if the query is executed
+ *  \return Progstart position in frames if the query is executed
  *          and succeeds, zero otherwise.
  */
-uint64_t ProgramInfo::QueryLastPlayPos(void) const
+uint64_t ProgramInfo::QueryProgStart(void) const
 {
-    if (m_programFlags & FL_IGNORELASTPLAYPOS)
+    if (m_programFlags & FL_IGNOREPROGSTART)
         return 0;
 
     frm_dir_map_t bookmarkmap;
-    QueryMarkupMap(bookmarkmap, MARK_UTIL_LASTPLAYPOS);
+    QueryMarkupMap(bookmarkmap, MARK_UTIL_PROGSTART);
 
     return (bookmarkmap.isEmpty()) ? 0 : bookmarkmap.begin().key();
 }
 
+uint64_t ProgramInfo::QueryStartMark(void) const
+{
+    uint64_t start = 0;
+    if ((start = QueryLastPlayPos()) > 0)
+    {
+        LOG(VB_PLAYBACK, LOG_INFO, QString("Using last position @ %1").arg(start));
+    }
+    else if ((start = QueryBookmark()) > 0)
+    {
+        LOG(VB_PLAYBACK, LOG_INFO, QString("Using bookmark @ %1").arg(start));
+    }
+    else if (HasCutlist())
+    {
+        // Disable progstart if the program has a cutlist.
+        LOG(VB_PLAYBACK, LOG_INFO, "Ignoring progstart as cutlist exists");
+    }
+    else if ((start = QueryProgStart()) > 0)
+    {
+        LOG(VB_PLAYBACK, LOG_INFO, QString("Using progstart @ %1").arg(start));
+    }
+    else
+    {
+        LOG(VB_PLAYBACK, LOG_INFO, "Using file start");
+    }
+    return start;
+}
+
 /** \brief Queries "dvdbookmark" table for bookmarking DVD serial
  *         number. Deletes old dvd bookmarks if "delbookmark" is set.
  *
@@ -6071,6 +6142,7 @@ bool LoadFromRecorded(
         set_flag(flags, FL_REALLYEDITING, query.value(39).toBool());
         set_flag(flags, FL_BOOKMARK,      query.value(40).toBool());
         set_flag(flags, FL_WATCHED,       query.value(41).toBool());
+        set_flag(flags, FL_LASTPLAYPOS,   query.value(58).toBool());
 
         if (inUseMap.contains(key))
             flags |= inUseMap[key];
diff --git a/mythtv/libs/libmyth/programinfo.h b/mythtv/libs/libmyth/programinfo.h
index dfc963972dd..8feb445d548 100644
--- a/mythtv/libs/libmyth/programinfo.h
+++ b/mythtv/libs/libmyth/programinfo.h
@@ -480,6 +480,7 @@ class MPUBLIC ProgramInfo
     bool IsCommercialFlagged(void) const { return (m_programFlags & FL_COMMFLAG) != 0U;}
     bool HasCutlist(void)       const { return (m_programFlags & FL_CUTLIST) != 0U;     }
     bool IsBookmarkSet(void)    const { return (m_programFlags & FL_BOOKMARK) != 0U;    }
+    bool IsLastPlaySet(void)    const { return (m_programFlags & FL_LASTPLAYPOS) != 0U; }
     bool IsWatched(void)        const { return (m_programFlags & FL_WATCHED) != 0U;     }
     bool IsAutoExpirable(void)  const { return (m_programFlags & FL_AUTOEXP) != 0U;     }
     bool IsPreserved(void)      const { return (m_programFlags & FL_PRESERVED) != 0U;   }
@@ -591,6 +592,7 @@ class MPUBLIC ProgramInfo
     uint64_t    QueryBookmark(void) const;
     uint64_t    QueryProgStart(void) const;
     uint64_t    QueryLastPlayPos(void) const;
+    uint64_t    QueryStartMark(void) const;
     CategoryType QueryCategoryType(void) const;
     QStringList QueryDVDBookmark(const QString &serialid) const;
     QStringList QueryBDBookmark(const QString &serialid) const;
@@ -617,6 +619,7 @@ class MPUBLIC ProgramInfo
 
     // Slow DB sets
     virtual void SaveFilesize(uint64_t fsize); /// TODO Move to RecordingInfo
+    void SaveLastPlayPos(uint64_t frame);
     void SaveBookmark(uint64_t frame);
     static void SaveDVDBookmark(const QStringList &fields) ;
     static void SaveBDBookmark(const QStringList &fields) ;
@@ -723,6 +726,8 @@ class MPUBLIC ProgramInfo
     static QStringList LoadFromScheduler(const QString &tmptable, int recordid);
 
     // Flagging map support methods
+    void UpdateMarkTimeStamp(bool bookmarked) const;
+    void UpdateLastPlayTimeStamp(bool lastplay) const;
     void QueryMarkupMap(frm_dir_map_t&marks, MarkTypes type,
                         bool merge = false) const;
     void SaveMarkupMap(const frm_dir_map_t &marks, MarkTypes type = MARK_ALL,
diff --git a/mythtv/libs/libmyth/programtypeflags.h b/mythtv/libs/libmyth/programtypeflags.h
index d7e2d93a177..1503e959143 100644
--- a/mythtv/libs/libmyth/programtypeflags.h
+++ b/mythtv/libs/libmyth/programtypeflags.h
@@ -54,6 +54,7 @@ FLAGS_DATA(FL, REACTIVATE,       0x00004000)
 FLAGS_DATA(FL, IGNOREBOOKMARK,   0x00008000)
 FLAGS_DATA(FL, IGNOREPROGSTART,  0x00010000)
 FLAGS_DATA(FL, IGNORELASTPLAYPOS,0x00020000)
+FLAGS_DATA(FL, LASTPLAYPOS,      0x00040000)
 // if you move the type mask please edit {Set,Get}ProgramInfoType()
 FLAGS_DATA(FL, TYPEMASK,         0x00F00000)
 FLAGS_DATA(FL, INUSERECORDING,   0x01000000)
diff --git a/mythtv/libs/libmythbase/mythversion.h b/mythtv/libs/libmythbase/mythversion.h
index b836d72b0d7..3d3e397b190 100644
--- a/mythtv/libs/libmythbase/mythversion.h
+++ b/mythtv/libs/libmythbase/mythversion.h
@@ -74,7 +74,7 @@
  *      mythtv/bindings/php/MythBackend.php
  */
 
-#define MYTH_DATABASE_VERSION "1372"
+#define MYTH_DATABASE_VERSION "1373"
 
 MBASE_PUBLIC  const char *GetMythSourceVersion();
 MBASE_PUBLIC  const char *GetMythSourcePath();
diff --git a/mythtv/libs/libmythtv/dbcheck.cpp b/mythtv/libs/libmythtv/dbcheck.cpp
index 4e06d09bf67..7b69efdb658 100644
--- a/mythtv/libs/libmythtv/dbcheck.cpp
+++ b/mythtv/libs/libmythtv/dbcheck.cpp
@@ -3870,6 +3870,17 @@ static bool doUpgradeTVDatabaseSchema(void)
             return false;
     }
 
+    if (dbver == "1372")
+    {
+        DBUpdates updates {
+            "ALTER TABLE recorded ADD COLUMN lastplay "
+            "    TINYINT UNSIGNED DEFAULT 0 AFTER bookmark;",
+        };
+        if (!performActualUpdate("MythTV", "DBSchemaVer",
+                                 updates, "1373", dbver))
+            return false;
+    }
+
     return true;
 }
 
diff --git a/mythtv/libs/libmythtv/mythplayer.cpp b/mythtv/libs/libmythtv/mythplayer.cpp
index 35cd152489f..7e0db328b30 100644
--- a/mythtv/libs/libmythtv/mythplayer.cpp
+++ b/mythtv/libs/libmythtv/mythplayer.cpp
@@ -95,7 +95,6 @@ MythPlayer::MythPlayer(PlayerContext* Context, PlayerFlags Flags)
 
     m_vbiMode = VBIMode::Parse(gCoreContext->GetSetting("VbiFormat"));
     m_captionsEnabledbyDefault = gCoreContext->GetBoolSetting("DefaultCCMode");
-    m_clearSavedPosition = gCoreContext->GetNumSetting("ClearSavedPosition", 1);
     m_endExitPrompt      = gCoreContext->GetNumSetting("EndOfRecordingExitPrompt");
 
     // Get VBI page number
@@ -1315,14 +1314,7 @@ uint64_t MythPlayer::GetBookmark(void)
     {
         m_playerCtx->LockPlayingInfo(__FILE__, __LINE__);
         if (const ProgramInfo *pi = m_playerCtx->m_playingInfo)
-        {
-            bookmark = pi->QueryBookmark();
-            // Disable progstart if the program has a cutlist.
-            if (bookmark == 0 && !pi->HasCutlist())
-                bookmark = pi->QueryProgStart();
-            if (bookmark == 0)
-                bookmark = pi->QueryLastPlayPos();
-        }
+            bookmark = pi->QueryStartMark();
         m_playerCtx->UnlockPlayingInfo(__FILE__, __LINE__);
     }
 
diff --git a/mythtv/libs/libmythtv/mythplayer.h b/mythtv/libs/libmythtv/mythplayer.h
index 80388e779b0..178329e5d73 100644
--- a/mythtv/libs/libmythtv/mythplayer.h
+++ b/mythtv/libs/libmythtv/mythplayer.h
@@ -418,7 +418,6 @@ class MTV_PUBLIC MythPlayer : public QObject
 
     // Bookmark stuff
     uint64_t m_bookmarkSeek               {0};
-    int      m_clearSavedPosition         {1};
     int      m_endExitPrompt;
 
     // Seek
diff --git a/mythtv/libs/libmythtv/mythplayerui.cpp b/mythtv/libs/libmythtv/mythplayerui.cpp
index 6f7bdcff513..1e6e51322e9 100644
--- a/mythtv/libs/libmythtv/mythplayerui.cpp
+++ b/mythtv/libs/libmythtv/mythplayerui.cpp
@@ -46,6 +46,7 @@ MythPlayerUI::MythPlayerUI(MythMainWindow* MainWindow, TV* Tv,
 
     // Other connections
     connect(m_tv, &TV::UpdateBookmark, this, &MythPlayerUI::SetBookmark);
+    connect(m_tv, &TV::UpdateLastPlayPosition, this, &MythPlayerUI::SetLastPlayPosition);
     connect(m_tv, &TV::InitialisePlayerState, this, &MythPlayerUI::InitialiseState);
 }
 
@@ -95,11 +96,7 @@ void MythPlayerUI::InitialSeek()
 {
     // TODO handle initial commskip and/or cutlist skip as well
     if (m_bookmarkSeek > 30)
-    {
         DoJumpToFrame(m_bookmarkSeek, kInaccuracyNone);
-        if (m_clearSavedPosition)
-            SetBookmark(true);
-    }
 }
 
 void MythPlayerUI::EventLoop()
@@ -766,6 +763,14 @@ void MythPlayerUI::SetBookmark(bool Clear)
     m_playerCtx->UnlockPlayingInfo(__FILE__, __LINE__);
 }
 
+void MythPlayerUI::SetLastPlayPosition(uint64_t frame)
+{
+    m_playerCtx->LockPlayingInfo(__FILE__, __LINE__);
+    if (m_playerCtx->m_playingInfo)
+        m_playerCtx->m_playingInfo->SaveLastPlayPos(frame);
+    m_playerCtx->UnlockPlayingInfo(__FILE__, __LINE__);
+}
+
 bool MythPlayerUI::CanSupportDoubleRate()
 {
     std::chrono::microseconds refreshinterval = 1us;
diff --git a/mythtv/libs/libmythtv/mythplayerui.h b/mythtv/libs/libmythtv/mythplayerui.h
index a2b22fba5ff..20f84039b59 100644
--- a/mythtv/libs/libmythtv/mythplayerui.h
+++ b/mythtv/libs/libmythtv/mythplayerui.h
@@ -19,6 +19,7 @@ class MTV_PUBLIC MythPlayerUI : public MythPlayerEditorUI, public MythVideoScanT
     void ChangeOSDDebug();
     void UpdateOSDDebug();
     virtual void SetBookmark(bool Clear = false);
+    virtual void SetLastPlayPosition(uint64_t frame = 0);
 
   public:
     MythPlayerUI(MythMainWindow* MainWindow, TV* Tv, PlayerContext* Context, PlayerFlags Flags);
diff --git a/mythtv/libs/libmythtv/tv_play.cpp b/mythtv/libs/libmythtv/tv_play.cpp
index 1878ca19856..9f02a703b0f 100644
--- a/mythtv/libs/libmythtv/tv_play.cpp
+++ b/mythtv/libs/libmythtv/tv_play.cpp
@@ -1011,7 +1011,6 @@ void TV::InitFromDB()
     kv["JumpToProgramOSD"]         = "1";
     kv["GuiSizeForTV"]             = "0";
     kv["UseVideoModes"]            = "0";
-    kv["ClearSavedPosition"]       = "1";
     kv["JobsRunOnRecordHost"]      = "0";
     kv["ContinueEmbeddedTVPlay"]   = "0";
     kv["UseFixedWindowSize"]       = "1";
@@ -1061,7 +1060,6 @@ void TV::InitFromDB()
     m_dbJumpPreferOsd      = (kv["JumpToProgramOSD"].toInt() != 0);
     m_dbUseGuiSizeForTv    = (kv["GuiSizeForTV"].toInt() != 0);
     m_dbUseVideoModes      = (kv["UseVideoModes"].toInt() != 0);
-    m_dbClearSavedPosition = (kv["ClearSavedPosition"].toInt() != 0);
     m_dbRunJobsOnRemote    = (kv["JobsRunOnRecordHost"].toInt() != 0);
     m_dbContinueEmbedded   = (kv["ContinueEmbeddedTVPlay"].toInt() != 0);
     m_dbBrowseAlways       = (kv["PersistentBrowseMode"].toInt() != 0);
@@ -2715,51 +2713,22 @@ void TV::PrepToSwitchToRecordedProgram(const ProgramInfo &ProgInfo)
     SetExitPlayer(true, true);
 }
 
-void TV::PrepareToExitPlayer(int Line, BookmarkAction Bookmark)
+void TV::PrepareToExitPlayer(int Line)
 {
-    bool bm_allowed = IsBookmarkAllowed();
     m_playerContext.LockDeletePlayer(__FILE__, Line);
-    if (m_player)
-    {
-        if (bm_allowed)
-        {
-            // If we're exiting in the middle of the recording, we
-            // automatically save a bookmark when "Action on playback
-            // exit" is set to "Save position and exit".
-            bool allow_set_before_end =
-                (Bookmark == kBookmarkAlways ||
-                 (Bookmark == kBookmarkAuto &&
-                  m_dbPlaybackExitPrompt == 2));
-            // If we're exiting at the end of the recording, we
-            // automatically clear the bookmark when "Action on
-            // playback exit" is set to "Save position and exit" and
-            // "Clear bookmark on playback" is set to true.
-            bool allow_clear_at_end =
-                (Bookmark == kBookmarkAlways ||
-                 (Bookmark == kBookmarkAuto &&
-                  m_dbPlaybackExitPrompt == 2 &&
-                  m_dbClearSavedPosition));
-            // Whether to set/clear a bookmark depends on whether we're
-            // exiting at the end of a recording.
-            bool at_end = (m_player->IsNearEnd() || GetEndOfRecording());
-            // Don't consider ourselves at the end if the recording is
-            // in-progress.
-            at_end &= !StateIsRecording(GetState());
-            bool clear_lastplaypos = false;
-            if (at_end && allow_clear_at_end)
-            {
-                SetBookmark(true);
-                // Tidy up the lastplaypos mark only when we clear the
-                // bookmark due to exiting at the end.
-                clear_lastplaypos = true;
-            }
-            else if (!at_end && allow_set_before_end)
-            {
-                SetBookmark(false);
-            }
-            if (clear_lastplaypos && m_playerContext.m_playingInfo)
-                m_playerContext.m_playingInfo->ClearMarkupMap(MARK_UTIL_LASTPLAYPOS);
-        }
+    if (m_savePosOnExit && m_player && m_playerContext.m_playingInfo)
+    {
+        // Clear last play position when we're at the end of a recording.
+        // unless the recording is in-progress.
+        bool at_end = !StateIsRecording(m_playerContext.GetState()) &&
+                (GetEndOfRecording() || m_playerContext.m_player->IsNearEnd());
+
+        // Clear/Save play position without notification
+        // The change must be broadcast when file is no longer in use
+        // to update previews, ie. with the MarkNotInUse notification
+        uint64_t frame = at_end ? 0 : m_playerContext.m_player->GetFramesPlayed();
+        m_playerContext.m_playingInfo->SaveLastPlayPos(frame);
+        emit UpdateLastPlayPosition(frame);
         if (m_dbAutoSetWatched)
             m_player->SetWatched();
     }
@@ -4178,7 +4147,7 @@ bool TV::ActivePostQHandleAction(const QStringList &Actions)
     {
         NormalSpeed();
         StopFFRew();
-        SetBookmark();
+        PrepareToExitPlayer(__LINE__);
         ShowOSDPromptDeleteRecording(tr("Are you sure you want to delete:"));
     }
     else if (IsActionable(ACTION_JUMPTODVDROOTMENU, Actions) && isdisc)
@@ -4368,11 +4337,7 @@ void TV::ProcessNetworkControlCommand(const QString &Command)
     }
     else if (tokens.size() == 2 && tokens[1] == "STOP")
     {
-        SetBookmark();
-        m_playerContext.LockDeletePlayer(__FILE__, __LINE__);
-        if (m_player && m_dbAutoSetWatched)
-            m_player->SetWatched();
-        m_playerContext.UnlockDeletePlayer(__FILE__, __LINE__);
+        PrepareToExitPlayer(__LINE__);
         SetExitPlayer(true, true);
     }
     else if (tokens.size() >= 3 && tokens[1] == "SEEK" && m_playerContext.HasPlayer())
@@ -7233,7 +7198,7 @@ void TV::customEvent(QEvent *Event)
         if (device && filename.endsWith(device->getDevicePath()) && (device->getStatus() == MEDIASTAT_OPEN))
         {
             LOG(VB_GENERAL, LOG_NOTICE, "DVD has been ejected, exiting playback");
-            PrepareToExitPlayer(__LINE__, kBookmarkAuto);
+            PrepareToExitPlayer(__LINE__);
             SetExitPlayer(true, true);
         }
         ReturnPlayerLock();
@@ -9843,15 +9808,7 @@ void TV::ShowOSDStopWatchingRecording()
 
     MythOSDDialogData dialog { OSD_DLG_VIDEOEXIT, tr("You are exiting %1").arg(videotype) };
 
-    if (IsBookmarkAllowed())
-    {
-        dialog.m_buttons.push_back({tr("Save this position and go to the menu"), "DIALOG_VIDEOEXIT_SAVEPOSITIONANDEXIT_0"});
-        dialog.m_buttons.push_back({tr("Do not save, just exit to the menu"), ACTION_STOP});
-    }
-    else
-    {
-        dialog.m_buttons.push_back({tr("Exit %1").arg(videotype), ACTION_STOP});
-    }
+    dialog.m_buttons.push_back({tr("Exit %1").arg(videotype), ACTION_STOP});
 
     if (IsDeleteAllowed())
         dialog.m_buttons.push_back({tr("Delete this recording"), "DIALOG_VIDEOEXIT_CONFIRMDELETE_0"});
@@ -9973,7 +9930,6 @@ bool TV::HandleOSDVideoExit(const QString& Action)
 
     bool hide        = true;
     bool delete_ok   = IsDeleteAllowed();
-    bool bookmark_ok = IsBookmarkAllowed();
 
     m_playerContext.LockDeletePlayer(__FILE__, __LINE__);
     bool near_end = m_player && m_player->IsNearEnd();
@@ -9983,11 +9939,13 @@ bool TV::HandleOSDVideoExit(const QString& Action)
     {
         m_allowRerecord = true;
         m_requestDelete = true;
+        PrepareToExitPlayer(__LINE__);
         SetExitPlayer(true, true);
     }
     else if (Action == "JUSTDELETE" && delete_ok)
     {
         m_requestDelete = true;
+        PrepareToExitPlayer(__LINE__);
         SetExitPlayer(true, true);
     }
     else if (Action == "CONFIRMDELETE")
@@ -9995,11 +9953,6 @@ bool TV::HandleOSDVideoExit(const QString& Action)
         hide = false;
         ShowOSDPromptDeleteRecording(tr("Are you sure you want to delete:"), true);
     }
-    else if (Action == "SAVEPOSITIONANDEXIT" && bookmark_ok)
-    {
-        PrepareToExitPlayer(__LINE__, kBookmarkAlways);
-        SetExitPlayer(true, true);
-    }
     else if (Action == "KEEPWATCHING" && !near_end)
     {
         DoTogglePause(true);
@@ -10049,6 +10002,8 @@ void TV::HandleSaveLastPlayPosEvent()
 
     KillTimer(m_saveLastPlayPosTimerId);
     m_saveLastPlayPosTimerId = StartTimer(kSaveLastPlayPosTimeout, __LINE__);
+
+    m_savePosOnExit = true;
 }
 
 void TV::SetLastProgram(const ProgramInfo* ProgInfo)
diff --git a/mythtv/libs/libmythtv/tv_play.h b/mythtv/libs/libmythtv/tv_play.h
index d16adfea463..66bc408d7a5 100644
--- a/mythtv/libs/libmythtv/tv_play.h
+++ b/mythtv/libs/libmythtv/tv_play.h
@@ -290,7 +290,7 @@ class MTV_PUBLIC TV : public TVPlaybackState, public MythTVMenuItemDisplayer, pu
         kBookmarkNever,
         kBookmarkAuto // set iff db_playback_exit_prompt==2
     };
-    void PrepareToExitPlayer(int Line, BookmarkAction Bookmark = kBookmarkAuto);
+    void PrepareToExitPlayer(int Line);
     void SetExitPlayer(bool SetIt, bool WantsTo);
 
     bool RequestNextRecorder(bool ShowDialogs, const ChannelInfoList &Selection = ChannelInfoList());
@@ -512,7 +512,6 @@ class MTV_PUBLIC TV : public TVPlaybackState, public MythTVMenuItemDisplayer, pu
     bool              m_dbJumpPreferOsd {true};
     bool              m_dbUseGuiSizeForTv {false};
     bool              m_dbUseVideoModes {false};
-    bool              m_dbClearSavedPosition {false};
     bool              m_dbRunJobsOnRemote {false};
     bool              m_dbContinueEmbedded {false};
     bool              m_dbBrowseAlways {false};
@@ -543,6 +542,7 @@ class MTV_PUBLIC TV : public TVPlaybackState, public MythTVMenuItemDisplayer, pu
     bool              m_allowRerecord {false};  ///< User wants to rerecord the last video if deleted
     bool              m_doSmartForward {false};
     bool              m_queuedTranscode {false};
+    bool              m_savePosOnExit {false};  ///< False until first timer event
     /// Picture attribute type to modify.
     PictureAdjustType m_adjustingPicture {kAdjustingPicture_None};
     /// Picture attribute to modify (on arrow left or right)
diff --git a/mythtv/libs/libmythtv/tvplaybackstate.h b/mythtv/libs/libmythtv/tvplaybackstate.h
index 9088303ce09..a9e5a1bc77d 100644
--- a/mythtv/libs/libmythtv/tvplaybackstate.h
+++ b/mythtv/libs/libmythtv/tvplaybackstate.h
@@ -20,6 +20,7 @@ class MTV_PUBLIC TVPlaybackState : public QObject
     // General
     void InitialisePlayerState();
     void UpdateBookmark(bool Clear = false);
+    void UpdateLastPlayPosition(uint64_t frame);
 
     // Overlays
     void IsOSDVisible(bool& Visible);
diff --git a/mythtv/programs/mythfrontend/globalsettings.cpp b/mythtv/programs/mythfrontend/globalsettings.cpp
index 6a2f962f5e8..e2fcc817adb 100644
--- a/mythtv/programs/mythfrontend/globalsettings.cpp
+++ b/mythtv/programs/mythfrontend/globalsettings.cpp
@@ -1739,23 +1739,6 @@ static HostCheckBoxSetting *BrowseAllTuners()
     return gc;
 }
 
-static HostCheckBoxSetting *ClearSavedPosition()
-{
-    auto *gc = new HostCheckBoxSetting("ClearSavedPosition");
-
-    gc->setLabel(PlaybackSettings::tr("Clear bookmark on playback"));
-
-    gc->setValue(true);
-
-    gc->setHelpText(PlaybackSettings::tr("If enabled, automatically clear the "
-                                         "bookmark on a recording when the "
-                                         "recording is played back. If "
-                                         "disabled, you can mark the "
-                                         "beginning with rewind then save "
-                                         "position."));
-    return gc;
-}
-
 static HostCheckBoxSetting *UseProgStartMark()
 {
     auto *gc = new HostCheckBoxSetting("UseProgStartMark");
@@ -1780,7 +1763,6 @@ static HostComboBoxSetting *PlaybackExitPrompt()
     gc->setLabel(PlaybackSettings::tr("Action on playback exit"));
 
     gc->addSelection(PlaybackSettings::tr("Just exit"), "0");
-    gc->addSelection(PlaybackSettings::tr("Save position and exit"), "2");
     gc->addSelection(PlaybackSettings::tr("Always prompt (excluding Live TV)"),
                      "1");
     gc->addSelection(PlaybackSettings::tr("Always prompt (including Live TV)"),
@@ -1790,9 +1772,8 @@ static HostComboBoxSetting *PlaybackExitPrompt()
     gc->setHelpText(PlaybackSettings::tr("If set to prompt, a menu will be "
                                          "displayed when you exit playback "
                                          "mode. The options available will "
-                                         "allow you to save your position, "
-                                         "delete the recording, or continue "
-                                         "watching."));
+                                         "allow you delete the recording, "
+                                         "continue watching, or exit."));
     return gc;
 }
 
@@ -4361,7 +4342,6 @@ void PlaybackSettings::Load(void)
     auto *general = new GroupSetting();
     general->setLabel(tr("General Playback"));
     general->addChild(JumpToProgramOSD());
-    general->addChild(ClearSavedPosition());
     general->addChild(UseProgStartMark());
     general->addChild(AutomaticSetWatched());
     general->addChild(ContinueEmbeddedTVPlay());
diff --git a/mythtv/programs/mythfrontend/main.cpp b/mythtv/programs/mythfrontend/main.cpp
index ebeaa79633b..a99d5aa8c09 100644
--- a/mythtv/programs/mythfrontend/main.cpp
+++ b/mythtv/programs/mythfrontend/main.cpp
@@ -212,22 +212,30 @@ namespace
         ParentalLevelChangeChecker m_plcc;
     };
 
+    /// This dialog is used when playing something from the "Watch
+    /// Videos" page. Playing from the "Watch Recordings" page uses
+    /// the code in PlaybackBox::createPlayFromMenu.
     class BookmarkDialog : MythScreenType
     {
         Q_DECLARE_TR_FUNCTIONS(BookmarkDialog)
 
       public:
-        BookmarkDialog(ProgramInfo *pginfo, MythScreenStack *parent) :
+        BookmarkDialog(ProgramInfo *pginfo, MythScreenStack *parent,
+                       bool bookmarkPresent, bool lastPlayPresent) :
                 MythScreenType(parent, "bookmarkdialog"),
-                m_pgi(pginfo)
-        {
+                m_pgi(pginfo),
+                m_bookmarked(bookmarkPresent),
+                m_lastPlayed(lastPlayPresent),
+                m_btnPlayBookmark(tr("Play from bookmark")),
+                m_btnClearBookmark(tr("Clear bookmark")),
+                m_btnPlayBegin(tr("Play from beginning")),
+                m_btnPlayLast(tr("Play from last played position")),
+                m_btnClearLast(tr("Clear last played position"))       {
         }
 
         bool Create() override // MythScreenType
         {
             QString msg = tr("DVD/Video contains a bookmark");
-            QString btn0msg = tr("Play from bookmark");
-            QString btn1msg = tr("Play from beginning");
 
             auto *popup = new MythDialogBox(msg, GetScreenStack(), "bookmarkdialog");
             if (!popup->Create())
@@ -239,40 +247,51 @@ namespace
             GetScreenStack()->AddScreen(popup);
 
             popup->SetReturnEvent(this, "bookmarkdialog");
-            popup->AddButton(btn0msg);
-            popup->AddButton(btn1msg);
+            if (m_lastPlayed)
+                popup->AddButton(m_btnPlayLast);
+            if (m_bookmarked)
+                popup->AddButton(m_btnPlayBookmark);
+            popup->AddButton(m_btnPlayBegin);
+            if (m_lastPlayed)
+                popup->AddButton(m_btnClearLast);
+            if (m_bookmarked)
+                popup->AddButton(m_btnClearBookmark);
             return true;
         }
 
         void customEvent(QEvent *event) override // MythUIType
         {
-            if (event->type() == DialogCompletionEvent::kEventType)
-            {
-                auto *dce = (DialogCompletionEvent*)(event);
-                int buttonnum = dce->GetResult();
-
-                if (dce->GetId() == "bookmarkdialog")
-                {
-                    uint flags = kStartTVNoFlags;
-                    if (buttonnum == 1)
-                    {
-                        flags |= kStartTVIgnoreBookmark;
-                    }
-                    else if (buttonnum != 0)
-                    {
-                        delete m_pgi;
-                        return;
-                    }
-
-                    TV::StartTV(m_pgi, flags);
-
-                    delete m_pgi;
-                }
-            }
+            if (event->type() != DialogCompletionEvent::kEventType)
+                return;
+
+            auto *dce = (DialogCompletionEvent*)(event);
+            QString buttonText = dce->GetResultText();
+
+            if (dce->GetId() != "bookmarkdialog")
+                return;
+
+            if (buttonText == m_btnPlayLast)
+                TV::StartTV(m_pgi, kStartTVNoFlags);
+            else if (buttonText == m_btnPlayBookmark)
+                TV::StartTV(m_pgi, kStartTVIgnoreLastPlayPos );
+            else if (buttonText == m_btnPlayBegin)
+                TV::StartTV(m_pgi, kStartTVIgnoreLastPlayPos | kStartTVIgnoreBookmark);
+            else if (buttonText == m_btnClearBookmark)
+                m_pgi->SaveBookmark(0);
+            else if (buttonText == m_btnClearLast)
+                m_pgi->SaveLastPlayPos(0);
+            delete m_pgi;
         }
 
       private:
-        ProgramInfo* m_pgi {nullptr};
+        ProgramInfo* m_pgi              {nullptr};
+        bool         m_bookmarked       {false};
+        bool         m_lastPlayed       {false};
+        QString      m_btnPlayBookmark;
+        QString      m_btnClearBookmark;
+        QString      m_btnPlayBegin;
+        QString      m_btnPlayLast;
+        QString      m_btnClearLast;
     };
 
     void cleanup()
@@ -1297,6 +1316,7 @@ static int internal_play_media(const QString &mrl, const QString &plot,
     pginfo->SetProgramInfoType(pginfo->DiscoverProgramInfoType());
 
     bool bookmarkPresent = false;
+    bool lastPlayPresent = false;
 
     if (pginfo->IsVideoDVD())
     {
@@ -1346,13 +1366,20 @@ static int internal_play_media(const QString &mrl, const QString &plot,
             return res;
         }
     }
-    else if (pginfo->IsVideo())
-        bookmarkPresent = (pginfo->QueryBookmark() > 0);
+    else if (useBookmark && pginfo->IsVideo())
+    {
+        pginfo->SetIgnoreLastPlayPos(false);
+        pginfo->SetIgnoreBookmark(false);
+        bookmarkPresent = pginfo->QueryBookmark() > 0;
+        lastPlayPresent = pginfo->QueryLastPlayPos() > 0;
+    }
 
     if (useBookmark && bookmarkPresent)
     {
         MythScreenStack *mainStack = GetMythMainWindow()->GetMainStack();
-        auto *bookmarkdialog = new BookmarkDialog(pginfo, mainStack);
+        auto *bookmarkdialog = new BookmarkDialog(pginfo, mainStack,
+                                                  bookmarkPresent,
+                                                  lastPlayPresent);
         if (!bookmarkdialog->Create())
         {
             delete bookmarkdialog;
diff --git a/mythtv/programs/mythfrontend/playbackbox.cpp b/mythtv/programs/mythfrontend/playbackbox.cpp
index 1b43678d853..b85ed26d4ce 100644
--- a/mythtv/programs/mythfrontend/playbackbox.cpp
+++ b/mythtv/programs/mythfrontend/playbackbox.cpp
@@ -531,7 +531,7 @@ bool PlaybackBox::Create()
     connect(m_recordingList, &MythUIButtonList::itemSelected,
             this, &PlaybackBox::ItemSelected);
     connect(m_recordingList, &MythUIButtonList::itemClicked,
-            this, qOverload<>(&PlaybackBox::PlayFromBookmarkOrProgStart));
+            this, qOverload<>(&PlaybackBox::PlayFromAnyMark));
     connect(m_recordingList, &MythUIButtonList::itemVisible,
             this, &PlaybackBox::ItemVisible);
     connect(m_recordingList, &MythUIButtonList::itemLoaded,
@@ -2271,7 +2271,7 @@ void PlaybackBox::playSelectedPlaylist(bool Random)
         this, new MythEvent("PLAY_PLAYLIST"));
 }
 
-void PlaybackBox::PlayFromBookmarkOrProgStart(MythUIButtonListItem *item)
+void PlaybackBox::PlayFromAnyMark(MythUIButtonListItem *item)
 {
     if (!item)
         item = m_recordingList->GetItemCurrent();
@@ -2283,7 +2283,7 @@ void PlaybackBox::PlayFromBookmarkOrProgStart(MythUIButtonListItem *item)
 
     const bool ignoreBookmark = false;
     const bool ignoreProgStart = false;
-    const bool ignoreLastPlayPos = true;
+    const bool ignoreLastPlayPos = false;
     const bool underNetworkControl = false;
     if (pginfo)
         PlayX(*pginfo, ignoreBookmark, ignoreProgStart, ignoreLastPlayPos,
@@ -2376,6 +2376,13 @@ void PlaybackBox::ClearBookmark()
         pginfo->SaveBookmark(0);
 }
 
+void PlaybackBox::ClearLastPlayPos()
+{
+    ProgramInfo *pginfo = GetCurrentProgram();
+    if (pginfo)
+        pginfo->SaveLastPlayPos(0);
+}
+
 void PlaybackBox::StopSelected(void)
 {
     ProgramInfo *pginfo = GetCurrentProgram();
@@ -2454,7 +2461,7 @@ void PlaybackBox::selected(MythUIButtonListItem *item)
     if (!item)
         return;
 
-    PlayFromBookmarkOrProgStart(item);
+    PlayFromAnyMark(item);
 }
 
 void PlaybackBox::popupClosed(const QString& which, int result)
@@ -2592,14 +2599,6 @@ bool PlaybackBox::Play(
         QCoreApplication::postEvent(
             this, new MythEvent("PLAY_PLAYLIST"));
     }
-    else
-    {
-        // User may have saved or deleted a bookmark
-        // requiring update of bookmark icon..
-        ProgramInfo *pginfo = m_programInfoCache.GetRecordingInfo(tvrec.GetRecordingID());
-        if (pginfo)
-            UpdateUIListItem(pginfo, true);
-    }
 
     if (m_needUpdate)
         ScheduleUpdateUIList();
@@ -3059,19 +3058,20 @@ MythMenu* PlaybackBox::createPlayFromMenu()
     QString title = tr("Play Options") + CreateProgramInfoString(*pginfo);
 
     auto *menu = new MythMenu(title, this, "slotmenu");
-
-    if (pginfo->IsBookmarkSet())
-        menu->AddItem(tr("Play from bookmark"),
-                      qOverload<>(&PlaybackBox::PlayFromBookmark));
-
-    if (pginfo->QueryLastPlayPos())
+    bool hasLastPlay = pginfo->IsLastPlaySet();
+    bool hasBookMark = pginfo->IsBookmarkSet();
+    if (hasLastPlay)
         menu->AddItem(tr("Play from last played position"),
                       qOverload<>(&PlaybackBox::PlayFromLastPlayPos));
-
+    if (hasBookMark)
+        menu->AddItem(tr("Play from bookmark"),
+                      qOverload<>(&PlaybackBox::PlayFromBookmark));
     menu->AddItem(tr("Play from beginning"),
                   qOverload<>(&PlaybackBox::PlayFromBeginning));
-
-    if (pginfo->IsBookmarkSet())
+    if (hasLastPlay)
+        menu->AddItem(tr("Clear last played position"),
+                      &PlaybackBox::ClearLastPlayPos);
+    if (hasBookMark)
         menu->AddItem(tr("Clear bookmark"), &PlaybackBox::ClearBookmark);
 
     return menu;
@@ -3317,11 +3317,11 @@ void PlaybackBox::ShowActionPopup(const ProgramInfo &pginfo)
 
     if (!sameProgram)
     {
-        if (pginfo.IsBookmarkSet() || pginfo.QueryLastPlayPos())
+        if (pginfo.IsBookmarkSet() || pginfo.IsLastPlaySet())
             m_popupMenu->AddItem(tr("Play from..."), nullptr, createPlayFromMenu());
         else
             m_popupMenu->AddItem(tr("Play"),
-                                 qOverload<>(&PlaybackBox::PlayFromBookmarkOrProgStart));
+                                 qOverload<>(&PlaybackBox::PlayFromAnyMark));
     }
 
     if (!m_player)
@@ -4029,7 +4029,7 @@ bool PlaybackBox::keyPressEvent(QKeyEvent *event)
             if (action == "DELETE")
                 deleteSelected(m_recordingList->GetItemCurrent());
             else if (action == ACTION_PLAYBACK)
-                PlayFromBookmarkOrProgStart();
+                PlayFromAnyMark();
             else if (action == "DETAILS" || action == "INFO")
                 ShowDetails();
             else if (action == "CUSTOMEDIT")
diff --git a/mythtv/programs/mythfrontend/playbackbox.h b/mythtv/programs/mythfrontend/playbackbox.h
index 85e70d75d46..e5093c4e887 100644
--- a/mythtv/programs/mythfrontend/playbackbox.h
+++ b/mythtv/programs/mythfrontend/playbackbox.h
@@ -147,8 +147,8 @@ class PlaybackBox : public ScheduleCommon
     void ItemLoaded(MythUIButtonListItem *item);
     void selected(MythUIButtonListItem *item);
     void updateRecGroup(MythUIButtonListItem *sel_item);
-    void PlayFromBookmarkOrProgStart(MythUIButtonListItem *item);
-    void PlayFromBookmarkOrProgStart() { PlayFromBookmarkOrProgStart(nullptr); }
+    void PlayFromAnyMark(MythUIButtonListItem *item);
+    void PlayFromAnyMark() { PlayFromAnyMark(nullptr); }
     void PlayFromBookmark(MythUIButtonListItem *item);
     void PlayFromBookmark() { PlayFromBookmark(nullptr); }
     void PlayFromBeginning(MythUIButtonListItem *item);
@@ -157,6 +157,7 @@ class PlaybackBox : public ScheduleCommon
     void PlayFromLastPlayPos() { PlayFromLastPlayPos(nullptr); }
     void deleteSelected(MythUIButtonListItem *item);
     void ClearBookmark();
+    void ClearLastPlayPos();
     void SwitchList(void);
 
     void ShowGroupPopup(void);
